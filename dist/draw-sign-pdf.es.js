import { ref, onMounted, onBeforeUnmount, createElementBlock, openBlock, createElementVNode, normalizeStyle, defineComponent, nextTick, computed, Fragment, toDisplayString, createCommentVNode, reactive, markRaw, resolveComponent, createVNode, normalizeClass, renderList, createBlock } from "vue";
import download from "downloadjs";
import { PDFDocument, LineCapStyle, rgb } from "pdf-lib";
const _sfc_main$4 = {
  props: {
    page: Object,
    zoomScale: Number,
    finishedRendering: Function
  },
  setup(L, { emit: c }) {
    const i = ref(null), t = ref(0), Z = ref(0), W = () => {
      i.value && i.value.clientWidth && t.value && c("measure", {
        scale: i.value.clientWidth / t.value
      });
    };
    return onMounted(async () => {
      const y = await L.page, h = i.value.getContext("2d"), p = y.getViewport({ scale: L.zoomScale || 1, rotation: 0 });
      t.value = p.width, Z.value = p.height, await y.render({
        canvasContext: h,
        viewport: p
      }).promise.then(function() {
        c("finishedRendering"), W();
      }), window.addEventListener("resize", W);
    }), onBeforeUnmount(() => {
      window.removeEventListener("resize", W);
    }), {
      canvas: i,
      width: t,
      height: Z
    };
  }
}, _export_sfc = (L, c) => {
  const i = L.__vccOpts || L;
  for (const [t, Z] of c)
    i[t] = Z;
  return i;
}, _hoisted_1$4 = ["width", "height"];
function _sfc_render$4(L, c, i, t, Z, W) {
  return openBlock(), createElementBlock("div", null, [
    createElementVNode("canvas", {
      ref: "canvas",
      id: "canvas",
      class: "max-w-full",
      style: normalizeStyle({ width: `${t.width}px` }),
      width: t.width,
      height: t.height
    }, null, 12, _hoisted_1$4)
  ]);
}
const PDFPage = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4], ["__scopeId", "data-v-fc4cca72"]]), _sfc_main$3 = defineComponent({
  props: {
    originWidth: { type: Number, required: !0 },
    originHeight: { type: Number, required: !0 },
    width: { type: Number, required: !0 },
    height: { type: Number, required: !0 },
    x: { type: Number, required: !0 },
    y: { type: Number, required: !0 },
    pageScale: { type: Number, default: 1 },
    path: { type: String, required: !0 },
    zoomScale: { type: Number, required: !0 }
  },
  emits: ["update"],
  setup(L, {}) {
    const c = ref(0), i = ref(0), t = ref(0), Z = ref(""), W = ref(""), y = ref(0), h = ref(0), p = ref(null), X = L.originWidth / L.originHeight;
    return onMounted(async () => {
      await nextTick(), p.value && p.value.setAttribute(
        "viewBox",
        `0 0 ${L.originWidth} ${L.originHeight}`
      );
    }), {
      dx: c,
      dy: i,
      dw: t,
      direction: Z,
      operation: W,
      startX: y,
      startY: h,
      svg: p,
      ratio: X
      // handlePanStart,
      // handlePanMove,
      // handlePanEnd,
    };
  }
}), _hoisted_1$3 = {
  ref: "svg",
  width: "100%",
  height: "100%"
}, _hoisted_2$3 = ["d"];
function _sfc_render$3(L, c, i, t, Z, W) {
  return openBlock(), createElementBlock("div", {
    style: normalizeStyle({
      width: `${(L.width + L.dw) * L.zoomScale}px`,
      height: `${(L.height + L.dw) * L.zoomScale}px`,
      transform: `translate(${(L.x + L.dx) * L.zoomScale}px, ${(L.y + L.dy) * L.zoomScale}px)`
    }),
    class: "absolute left-0 top-0 select-none"
  }, [
    c[0] || (c[0] = createElementVNode("div", { class: "absolute h-full w-full border border-dashed border-gray-400" }, [
      createElementVNode("div", {
        "data-direction": "left-top",
        class: "absolute left-0 top-0 h-4 w-4 -translate-x-1/2 -translate-y-1/2 transform cursor-nwse-resize rounded-full bg-green-400 md:scale-25"
      }),
      createElementVNode("div", {
        "data-direction": "right-bottom",
        class: "absolute bottom-0 right-0 h-4 w-4 translate-x-1/2 translate-y-1/2 transform cursor-nwse-resize rounded-full bg-green-400 md:scale-25"
      })
    ], -1)),
    (openBlock(), createElementBlock("svg", _hoisted_1$3, [
      createElementVNode("path", {
        "stroke-width": "5",
        "stroke-linejoin": "round",
        "stroke-linecap": "round",
        stroke: "black",
        fill: "none",
        d: L.path
      }, null, 8, _hoisted_2$3)
    ], 512))
  ], 4);
}
const DrawingSignature = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3], ["__scopeId", "data-v-a8d09abc"]]), _sfc_main$2 = defineComponent({
  name: "DialogBox",
  props: {
    translations: {
      type: Object,
      default: () => ({})
    },
    type: {
      type: String,
      default: "warning"
    }
  },
  emits: ["finish", "cancel"],
  setup(L, { emit: c }) {
    return {
      getTranslation: computed(() => {
        const W = L.translations;
        return L.type === "warning" ? {
          title: W.warningTitle,
          desc: W.warningDesc,
          close: W.warningClose
        } : {
          title: W.confirmBoxTitle,
          desc: W.confirmBoxDesc,
          close: W.confirmBoxClose,
          saveChanges: W.confirmBoxSaveChanges
        };
      }),
      closeModal: () => c("cancel"),
      finish: () => c("finish")
    };
  }
}), _hoisted_1$2 = { class: "confirm-modal relative top-40 mx-auto shadow-xl rounded-md bg-white max-w-md mt-40" }, _hoisted_2$2 = { class: "flex flex-col bg-white border shadow-sm rounded-xl pointer-events-auto" }, _hoisted_3$2 = { class: "flex justify-between items-center py-3 px-4 border-b" }, _hoisted_4$2 = { class: "font-bold text-gray-800" }, _hoisted_5$2 = { class: "sr-only" }, _hoisted_6$2 = { class: "p-4 overflow-y-auto" }, _hoisted_7$2 = { class: "mt-1 text-gray-800" }, _hoisted_8$2 = { class: "flex justify-end items-center gap-x-2 py-3 px-4 border-t" };
function _sfc_render$2(L, c, i, t, Z, W) {
  return openBlock(), createElementBlock(Fragment, null, [
    c[4] || (c[4] = createElementVNode("div", {
      id: "headlessui-dialog-overlay-16",
      "aria-hidden": "true",
      "data-headlessui-state": "open",
      class: "fixed inset-0 bg-gray-500 opacity-30"
    }, null, -1)),
    createElementVNode("div", _hoisted_1$2, [
      createElementVNode("div", _hoisted_2$2, [
        createElementVNode("div", _hoisted_3$2, [
          createElementVNode("h3", _hoisted_4$2, toDisplayString(L.getTranslation.title), 1),
          createElementVNode("button", {
            onClick: c[0] || (c[0] = (...y) => L.closeModal && L.closeModal(...y)),
            type: "button",
            class: "flex justify-center items-center size-7 text-sm font-semibold rounded-full border border-transparent text-gray-800 hover:bg-gray-100 disabled:opacity-50 disabled:pointer-events-none"
          }, [
            createElementVNode("span", _hoisted_5$2, toDisplayString(L.getTranslation.close), 1),
            c[3] || (c[3] = createElementVNode("svg", {
              class: "flex-shrink-0 size-4",
              xmlns: "http://www.w3.org/2000/svg",
              width: "24",
              height: "24",
              viewBox: "0 0 24 24",
              fill: "none",
              stroke: "currentColor",
              "stroke-width": "2",
              "stroke-linecap": "round",
              "stroke-linejoin": "round"
            }, [
              createElementVNode("path", { d: "M18 6 6 18" }),
              createElementVNode("path", { d: "m6 6 12 12" })
            ], -1))
          ])
        ]),
        createElementVNode("div", _hoisted_6$2, [
          createElementVNode("p", _hoisted_7$2, toDisplayString(L.getTranslation.desc), 1)
        ]),
        createElementVNode("div", _hoisted_8$2, [
          createElementVNode("button", {
            onClick: c[1] || (c[1] = (...y) => L.closeModal && L.closeModal(...y)),
            type: "button",
            "data-cy": "close-confirm",
            class: "py-2 px-3 inline-flex items-center gap-x-2 text-sm font-medium rounded-lg border border-gray-200 bg-white text-gray-800 shadow-sm hover:bg-gray-50 disabled:opacity-50 disabled:pointer-events-none btn-negative"
          }, toDisplayString(L.getTranslation.close), 1),
          L.type === "confirm" ? (openBlock(), createElementBlock("button", {
            key: 0,
            onClick: c[2] || (c[2] = (...y) => L.finish && L.finish(...y)),
            type: "button",
            "data-cy": "confirm-save",
            class: "py-2 px-3 inline-flex items-center gap-x-2 text-sm font-semibold rounded-lg border border-transparent bg-blue-600 text-white hover:bg-blue-700 disabled:opacity-50 disabled:pointer-events-none ml-2 btn-positive"
          }, toDisplayString(L.getTranslation.saveChanges), 1)) : createCommentVNode("", !0)
        ])
      ])
    ])
  ], 64);
}
const DialogBox = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-a1ca1473"]]), _sfc_main$1 = defineComponent({
  name: "DrawingCanvas",
  props: {
    translations: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["finish", "cancel"],
  setup(L, { emit: c }) {
    const i = {
      drawLabel: "Draw the signature here",
      drawDone: "Done",
      drawCancel: "Cancel",
      additionalTextField: ""
    }, t = computed(() => ({
      ...i,
      ...L.translations
    })), Z = ref(null), W = ref([]), y = ref(""), h = reactive({
      drawing: !1,
      x: 0,
      y: 0,
      minX: 1 / 0,
      minY: 1 / 0,
      maxX: 0,
      maxY: 0
    }), p = (e) => {
      if (e.target !== e.currentTarget) {
        h.drawing = !1;
        return;
      }
      h.drawing = !0, h.x = e.x, h.y = e.y, h.minX = Math.min(h.minX, h.x), h.maxX = Math.max(h.maxX, h.x), h.minY = Math.min(h.minY, h.y), h.maxY = Math.max(h.maxY, h.y), W.value.push(["M", h.x, h.y]), y.value += `M${h.x},${h.y}`;
    }, X = (e) => {
      h.drawing && (h.x = e.x, h.y = e.y, h.minX = Math.min(h.minX, h.x), h.maxX = Math.max(h.maxX, h.x), h.minY = Math.min(h.minY, h.y), h.maxY = Math.max(h.maxY, h.y), y.value += `L${h.x},${h.y}`, W.value.push(["L", h.x, h.y]));
    }, M = () => {
      h.drawing = !1;
    }, x = () => {
      var r;
      if (!W.value.length) return;
      const e = -(h.minX - 10), m = -(h.minY - 10), d = h.maxX - h.minX + 20, b = h.maxY - h.minY + 20, N = W.value.reduce((j, D) => j + D[0] + (D[1] + e) + "," + (D[2] + m), ""), G = document.getElementById("signature-path-data");
      if (G) {
        G.style.display = "none", G.removeAttribute("viewBox"), (r = G.querySelector("path")) == null || r.setAttribute("d", N);
        const j = new XMLSerializer().serializeToString(G), D = btoa(j), f = new Image();
        f.src = "data:image/svg+xml;base64," + D, f.onload = () => {
          const P = document.createElement("canvas");
          P.style.display = "none", P.width = d, P.height = b;
          const B = P.getContext("2d");
          B == null || B.drawImage(f, 0, 0);
          let A = P.toDataURL("image/png").replace("data:image/png;base64,", "");
          P.remove(), G.innerHTML = "", W.value = [], c("finish", {
            originWidth: d,
            originHeight: b,
            path: N,
            signatureImageData: {
              data: A,
              type: "image/png"
            }
          });
        };
      }
    }, n = () => {
      W.value = [], c("cancel");
    }, V = (e) => {
      var m, d;
      h.x = e.clientX, h.y = e.clientY, p({
        x: h.x,
        y: h.y,
        target: e.target,
        currentTarget: Z.value
      }), (m = Z.value) == null || m.addEventListener("mousemove", S), (d = Z.value) == null || d.addEventListener("mouseup", o);
    }, S = (e) => {
      e.clientX - h.x, e.clientY - h.y, h.x = e.clientX, h.y = e.clientY, X({ x: h.x, y: h.y });
    }, o = (e) => {
      var m, d;
      h.x = e.clientX, h.y = e.clientY, M(), (m = Z.value) == null || m.removeEventListener("mousemove", S), (d = Z.value) == null || d.removeEventListener("mouseup", o);
    }, R = (e) => {
      var d, b;
      if (e.touches.length > 1) return;
      const m = e.touches[0];
      h.x = m.clientX, h.y = m.clientY, p({
        x: h.x,
        y: h.y,
        target: m.target,
        currentTarget: Z.value
      }), (d = Z.value) == null || d.addEventListener("touchmove", J), (b = Z.value) == null || b.addEventListener("touchend", u);
    }, J = (e) => {
      if (e.preventDefault(), e.touches.length > 1) return;
      const m = e.touches[0];
      m.clientX - h.x, m.clientY - h.y, h.x = m.clientX, h.y = m.clientY, X({ x: h.x, y: h.y });
    }, u = (e) => {
      var m, d;
      h.x = e.changedTouches[0].clientX, h.y = e.changedTouches[0].clientY, M(), (m = Z.value) == null || m.removeEventListener("touchmove", J), (d = Z.value) == null || d.removeEventListener("touchend", u);
    };
    return onMounted(() => {
      var e, m;
      (e = Z.value) == null || e.addEventListener("mousedown", V), (m = Z.value) == null || m.addEventListener("touchstart", R);
    }), onBeforeUnmount(() => {
      var e, m;
      (e = Z.value) == null || e.removeEventListener("mousedown", V), (m = Z.value) == null || m.removeEventListener(
        "touchstart",
        R
      );
    }), {
      getTranslation: t,
      signatureCanvas: Z,
      path: y,
      finish: x,
      cancel: n,
      handlePanStart: p,
      handlePanMove: X,
      handlePanEnd: M
    };
  }
}), _hoisted_1$1 = {
  style: { height: "210px" },
  class: "left-0 right-0 top-0 z-0 border-b border-gray-300 bg-white shadow-lg",
  "data-cy": "sign-area"
}, _hoisted_2$1 = { class: "absolute flex w-full flex-grow items-center justify-center" }, _hoisted_3$1 = { class: "text-black-600" }, _hoisted_4$1 = { class: "absolute bottom-0 right-0 mb-4 mx-4 flex" }, _hoisted_5$1 = { class: "flex w-full flex-grow items-center justify-center" }, _hoisted_6$1 = { class: "text-black-600" }, _hoisted_7$1 = {
  class: "pointer-events-none h-full w-full",
  id: "signature-path-data"
}, _hoisted_8$1 = ["d"];
function _sfc_render$1(L, c, i, t, Z, W) {
  return openBlock(), createElementBlock("div", _hoisted_1$1, [
    createElementVNode("div", {
      ref: "signatureCanvas",
      onPanstart: c[2] || (c[2] = (...y) => L.handlePanStart && L.handlePanStart(...y)),
      onPanmove: c[3] || (c[3] = (...y) => L.handlePanMove && L.handlePanMove(...y)),
      onPanend: c[4] || (c[4] = (...y) => L.handlePanEnd && L.handlePanEnd(...y)),
      class: "relative h-full w-full select-none"
    }, [
      createElementVNode("div", _hoisted_2$1, [
        createElementVNode("p", _hoisted_3$1, toDisplayString(L.getTranslation.drawLabel), 1)
      ]),
      createElementVNode("div", _hoisted_4$1, [
        createElementVNode("div", _hoisted_5$1, [
          createElementVNode("p", _hoisted_6$1, toDisplayString(L.getTranslation.additionalTextField), 1)
        ]),
        createElementVNode("button", {
          onClick: c[0] || (c[0] = (...y) => L.finish && L.finish(...y)),
          class: "mx-4 w-24 rounded bg-blue-600 px-4 py-1 font-bold text-white hover:bg-blue-700 btn-positive",
          "data-cy": "sign-done"
        }, toDisplayString(L.getTranslation.drawDone), 1),
        createElementVNode("button", {
          onClick: c[1] || (c[1] = (...y) => L.cancel && L.cancel(...y)),
          class: "w-24 rounded bg-red-500 px-4 py-1 font-bold text-white hover:bg-red-700 btn-negative",
          "data-cy": "sign-cancel"
        }, toDisplayString(L.getTranslation.drawCancel), 1)
      ]),
      (openBlock(), createElementBlock("svg", _hoisted_7$1, [
        createElementVNode("path", {
          "stroke-width": "5",
          "stroke-linejoin": "round",
          "stroke-linecap": "round",
          d: L.path,
          stroke: "black",
          fill: "none"
        }, null, 8, _hoisted_8$1)
      ]))
    ], 544)
  ]);
}
const DrawingCanvas = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
function render$1(L, c) {
  return openBlock(), createElementBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon"
  }, [
    createElementVNode("path", { d: "M8.75 6.25h-3.5a.75.75 0 0 0 0 1.5h3.5a.75.75 0 0 0 0-1.5Z" }),
    createElementVNode("path", {
      "fill-rule": "evenodd",
      d: "M7 12c1.11 0 2.136-.362 2.965-.974l2.755 2.754a.75.75 0 1 0 1.06-1.06l-2.754-2.755A5 5 0 1 0 7 12Zm0-1.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7Z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render(L, c) {
  return openBlock(), createElementBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon"
  }, [
    createElementVNode("path", { d: "M6.25 8.75v-1h-1a.75.75 0 0 1 0-1.5h1v-1a.75.75 0 0 1 1.5 0v1h1a.75.75 0 0 1 0 1.5h-1v1a.75.75 0 0 1-1.5 0Z" }),
    createElementVNode("path", {
      "fill-rule": "evenodd",
      d: "M7 12c1.11 0 2.136-.362 2.965-.974l2.755 2.754a.75.75 0 1 0 1.06-1.06l-2.754-2.755A5 5 0 1 0 7 12Zm0-1.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7Z",
      "clip-rule": "evenodd"
    })
  ]);
}
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getAugmentedNamespace(L) {
  if (L.__esModule) return L;
  var c = L.default;
  if (typeof c == "function") {
    var i = function t() {
      return this instanceof t ? Reflect.construct(c, arguments, this.constructor) : c.apply(this, arguments);
    };
    i.prototype = c.prototype;
  } else i = {};
  return Object.defineProperty(i, "__esModule", { value: !0 }), Object.keys(L).forEach(function(t) {
    var Z = Object.getOwnPropertyDescriptor(L, t);
    Object.defineProperty(i, t, Z.get ? Z : {
      enumerable: !0,
      get: function() {
        return L[t];
      }
    });
  }), i;
}
function commonjsRequire(L) {
  throw new Error('Could not dynamically require "' + L + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var pdf = { exports: {} }, dommatrix = { exports: {} };
/*!
* DOMMatrix v1.0.3 (https://thednp.github.io/dommatrix/)
* Copyright 2022 © thednp
* Licensed under MIT (https://github.com/thednp/DOMMatrix/blob/master/LICENSE)
*/
var hasRequiredDommatrix;
function requireDommatrix() {
  return hasRequiredDommatrix || (hasRequiredDommatrix = 1, function(L, c) {
    (function(i, t) {
      L.exports = t();
    })(commonjsGlobal, function() {
      function i(u) {
        var e = new S(), m = Array.from(u);
        if (!m.every(function(g) {
          return !Number.isNaN(g);
        }))
          throw TypeError('CSSMatrix: "' + u + '" must only have numbers.');
        if (m.length === 16) {
          var d = m[0], b = m[1], N = m[2], G = m[3], r = m[4], j = m[5], D = m[6], f = m[7], P = m[8], B = m[9], A = m[10], H = m[11], O = m[12], U = m[13], k = m[14], q = m[15];
          e.m11 = d, e.a = d, e.m21 = r, e.c = r, e.m31 = P, e.m41 = O, e.e = O, e.m12 = b, e.b = b, e.m22 = j, e.d = j, e.m32 = B, e.m42 = U, e.f = U, e.m13 = N, e.m23 = D, e.m33 = A, e.m43 = k, e.m14 = G, e.m24 = f, e.m34 = H, e.m44 = q;
        } else if (m.length === 6) {
          var al = m[0], Ml = m[1], wl = m[2], Q = m[3], T = m[4], w = m[5];
          e.m11 = al, e.a = al, e.m12 = Ml, e.b = Ml, e.m21 = wl, e.c = wl, e.m22 = Q, e.d = Q, e.m41 = T, e.e = T, e.m42 = w, e.f = w;
        } else
          throw new TypeError("CSSMatrix: expecting an Array of 6/16 values.");
        return e;
      }
      function t(u) {
        var e = Object.keys(new S());
        if (typeof u == "object" && e.every(function(m) {
          return m in u;
        }))
          return i(
            [
              u.m11,
              u.m12,
              u.m13,
              u.m14,
              u.m21,
              u.m22,
              u.m23,
              u.m24,
              u.m31,
              u.m32,
              u.m33,
              u.m34,
              u.m41,
              u.m42,
              u.m43,
              u.m44
            ]
          );
        throw TypeError('CSSMatrix: "' + JSON.stringify(u) + '" is not a DOMMatrix / CSSMatrix / JSON compatible object.');
      }
      function Z(u) {
        if (typeof u != "string")
          throw TypeError('CSSMatrix: "' + u + '" is not a string.');
        var e = String(u).replace(/\s/g, ""), m = new S(), d = 'CSSMatrix: invalid transform string "' + u + '"';
        return e.split(")").filter(function(b) {
          return b;
        }).forEach(function(b) {
          var N = b.split("("), G = N[0], r = N[1];
          if (!r)
            throw TypeError(d);
          var j = r.split(",").map(function(T) {
            return T.includes("rad") ? parseFloat(T) * (180 / Math.PI) : parseFloat(T);
          }), D = j[0], f = j[1], P = j[2], B = j[3], A = [D, f, P], H = [D, f, P, B];
          if (G === "perspective" && D && [f, P].every(function(T) {
            return T === void 0;
          }))
            m.m34 = -1 / D;
          else if (G.includes("matrix") && [6, 16].includes(j.length) && j.every(function(T) {
            return !Number.isNaN(+T);
          })) {
            var O = j.map(function(T) {
              return Math.abs(T) < 1e-6 ? 0 : T;
            });
            m = m.multiply(i(O));
          } else if (G === "translate3d" && A.every(function(T) {
            return !Number.isNaN(+T);
          }))
            m = m.translate(D, f, P);
          else if (G === "translate" && D && P === void 0)
            m = m.translate(D, f || 0, 0);
          else if (G === "rotate3d" && H.every(function(T) {
            return !Number.isNaN(+T);
          }) && B)
            m = m.rotateAxisAngle(D, f, P, B);
          else if (G === "rotate" && D && [f, P].every(function(T) {
            return T === void 0;
          }))
            m = m.rotate(0, 0, D);
          else if (G === "scale3d" && A.every(function(T) {
            return !Number.isNaN(+T);
          }) && A.some(function(T) {
            return T !== 1;
          }))
            m = m.scale(D, f, P);
          else if (G === "scale" && !Number.isNaN(D) && D !== 1 && P === void 0) {
            var U = Number.isNaN(+f), k = U ? D : f;
            m = m.scale(D, k, 1);
          } else if (G === "skew" && (D || !Number.isNaN(D) && f) && P === void 0)
            m = m.skew(D, f || 0);
          else if (/[XYZ]/.test(G) && D && [f, P].every(function(T) {
            return T === void 0;
          }) && ["translate", "rotate", "scale", "skew"].some(function(T) {
            return G.includes(T);
          }))
            if (["skewX", "skewY"].includes(G))
              m = m[G](D);
            else {
              var q = G.replace(/[XYZ]/, ""), al = G.replace(q, ""), Ml = ["X", "Y", "Z"].indexOf(al), wl = q === "scale" ? 1 : 0, Q = [
                Ml === 0 ? D : wl,
                Ml === 1 ? D : wl,
                Ml === 2 ? D : wl
              ];
              m = m[q].apply(m, Q);
            }
          else
            throw TypeError(d);
        }), m;
      }
      function W(u, e) {
        return e ? [u.a, u.b, u.c, u.d, u.e, u.f] : [
          u.m11,
          u.m12,
          u.m13,
          u.m14,
          u.m21,
          u.m22,
          u.m23,
          u.m24,
          u.m31,
          u.m32,
          u.m33,
          u.m34,
          u.m41,
          u.m42,
          u.m43,
          u.m44
        ];
      }
      function y(u, e, m) {
        var d = new S();
        return d.m41 = u, d.e = u, d.m42 = e, d.f = e, d.m43 = m, d;
      }
      function h(u, e, m) {
        var d = new S(), b = Math.PI / 180, N = u * b, G = e * b, r = m * b, j = Math.cos(N), D = -Math.sin(N), f = Math.cos(G), P = -Math.sin(G), B = Math.cos(r), A = -Math.sin(r), H = f * B, O = -f * A;
        d.m11 = H, d.a = H, d.m12 = O, d.b = O, d.m13 = P;
        var U = D * P * B + j * A;
        d.m21 = U, d.c = U;
        var k = j * B - D * P * A;
        return d.m22 = k, d.d = k, d.m23 = -D * f, d.m31 = D * A - j * P * B, d.m32 = D * B + j * P * A, d.m33 = j * f, d;
      }
      function p(u, e, m, d) {
        var b = new S(), N = Math.sqrt(u * u + e * e + m * m);
        if (N === 0)
          return b;
        var G = u / N, r = e / N, j = m / N, D = d * (Math.PI / 360), f = Math.sin(D), P = Math.cos(D), B = f * f, A = G * G, H = r * r, O = j * j, U = 1 - 2 * (H + O) * B;
        b.m11 = U, b.a = U;
        var k = 2 * (G * r * B + j * f * P);
        b.m12 = k, b.b = k, b.m13 = 2 * (G * j * B - r * f * P);
        var q = 2 * (r * G * B - j * f * P);
        b.m21 = q, b.c = q;
        var al = 1 - 2 * (O + A) * B;
        return b.m22 = al, b.d = al, b.m23 = 2 * (r * j * B + G * f * P), b.m31 = 2 * (j * G * B + r * f * P), b.m32 = 2 * (j * r * B - G * f * P), b.m33 = 1 - 2 * (A + H) * B, b;
      }
      function X(u, e, m) {
        var d = new S();
        return d.m11 = u, d.a = u, d.m22 = e, d.d = e, d.m33 = m, d;
      }
      function M(u, e) {
        var m = new S();
        if (u) {
          var d = u * Math.PI / 180, b = Math.tan(d);
          m.m21 = b, m.c = b;
        }
        if (e) {
          var N = e * Math.PI / 180, G = Math.tan(N);
          m.m12 = G, m.b = G;
        }
        return m;
      }
      function x(u) {
        return M(u, 0);
      }
      function n(u) {
        return M(0, u);
      }
      function V(u, e) {
        var m = e.m11 * u.m11 + e.m12 * u.m21 + e.m13 * u.m31 + e.m14 * u.m41, d = e.m11 * u.m12 + e.m12 * u.m22 + e.m13 * u.m32 + e.m14 * u.m42, b = e.m11 * u.m13 + e.m12 * u.m23 + e.m13 * u.m33 + e.m14 * u.m43, N = e.m11 * u.m14 + e.m12 * u.m24 + e.m13 * u.m34 + e.m14 * u.m44, G = e.m21 * u.m11 + e.m22 * u.m21 + e.m23 * u.m31 + e.m24 * u.m41, r = e.m21 * u.m12 + e.m22 * u.m22 + e.m23 * u.m32 + e.m24 * u.m42, j = e.m21 * u.m13 + e.m22 * u.m23 + e.m23 * u.m33 + e.m24 * u.m43, D = e.m21 * u.m14 + e.m22 * u.m24 + e.m23 * u.m34 + e.m24 * u.m44, f = e.m31 * u.m11 + e.m32 * u.m21 + e.m33 * u.m31 + e.m34 * u.m41, P = e.m31 * u.m12 + e.m32 * u.m22 + e.m33 * u.m32 + e.m34 * u.m42, B = e.m31 * u.m13 + e.m32 * u.m23 + e.m33 * u.m33 + e.m34 * u.m43, A = e.m31 * u.m14 + e.m32 * u.m24 + e.m33 * u.m34 + e.m34 * u.m44, H = e.m41 * u.m11 + e.m42 * u.m21 + e.m43 * u.m31 + e.m44 * u.m41, O = e.m41 * u.m12 + e.m42 * u.m22 + e.m43 * u.m32 + e.m44 * u.m42, U = e.m41 * u.m13 + e.m42 * u.m23 + e.m43 * u.m33 + e.m44 * u.m43, k = e.m41 * u.m14 + e.m42 * u.m24 + e.m43 * u.m34 + e.m44 * u.m44;
        return i(
          [
            m,
            d,
            b,
            N,
            G,
            r,
            j,
            D,
            f,
            P,
            B,
            A,
            H,
            O,
            U,
            k
          ]
        );
      }
      var S = function() {
        for (var e = [], m = arguments.length; m--; ) e[m] = arguments[m];
        var d = this;
        if (d.a = 1, d.b = 0, d.c = 0, d.d = 1, d.e = 0, d.f = 0, d.m11 = 1, d.m12 = 0, d.m13 = 0, d.m14 = 0, d.m21 = 0, d.m22 = 1, d.m23 = 0, d.m24 = 0, d.m31 = 0, d.m32 = 0, d.m33 = 1, d.m34 = 0, d.m41 = 0, d.m42 = 0, d.m43 = 0, d.m44 = 1, e.length) {
          var b = [16, 6].some(function(N) {
            return N === e.length;
          }) ? e : e[0];
          return d.setMatrixValue(b);
        }
        return d;
      }, o = { isIdentity: { configurable: !0 }, is2D: { configurable: !0 } };
      o.isIdentity.get = function() {
        var u = this;
        return u.m11 === 1 && u.m12 === 0 && u.m13 === 0 && u.m14 === 0 && u.m21 === 0 && u.m22 === 1 && u.m23 === 0 && u.m24 === 0 && u.m31 === 0 && u.m32 === 0 && u.m33 === 1 && u.m34 === 0 && u.m41 === 0 && u.m42 === 0 && u.m43 === 0 && u.m44 === 1;
      }, o.is2D.get = function() {
        var u = this;
        return u.m31 === 0 && u.m32 === 0 && u.m33 === 1 && u.m34 === 0 && u.m43 === 0 && u.m44 === 1;
      }, S.prototype.setMatrixValue = function(e) {
        var m = this;
        return typeof e == "string" && e.length && e !== "none" ? Z(e) : [Array, Float64Array, Float32Array].some(function(d) {
          return e instanceof d;
        }) ? i(e) : [S, DOMMatrix, Object].some(function(d) {
          return e instanceof d;
        }) ? t(e) : m;
      }, S.prototype.toFloat32Array = function(e) {
        return Float32Array.from(W(this, e));
      }, S.prototype.toFloat64Array = function(e) {
        return Float64Array.from(W(this, e));
      }, S.prototype.toString = function() {
        var e = this, m = e.is2D, d = e.toFloat64Array(m).join(", "), b = m ? "matrix" : "matrix3d";
        return b + "(" + d + ")";
      }, S.prototype.toJSON = function() {
        var e = this, m = e.is2D, d = e.isIdentity;
        return Object.assign({}, e, { is2D: m, isIdentity: d });
      }, S.prototype.multiply = function(e) {
        return V(this, e);
      }, S.prototype.translate = function(e, m, d) {
        var b = e, N = m, G = d;
        return N === void 0 && (N = 0), G === void 0 && (G = 0), V(this, y(b, N, G));
      }, S.prototype.scale = function(e, m, d) {
        var b = e, N = m, G = d;
        return N === void 0 && (N = e), G === void 0 && (G = 1), V(this, X(b, N, G));
      }, S.prototype.rotate = function(e, m, d) {
        var b = e, N = m || 0, G = d || 0;
        return typeof e == "number" && m === void 0 && d === void 0 && (G = b, b = 0, N = 0), V(this, h(b, N, G));
      }, S.prototype.rotateAxisAngle = function(e, m, d, b) {
        if ([e, m, d, b].some(function(N) {
          return Number.isNaN(+N);
        }))
          throw new TypeError("CSSMatrix: expecting 4 values");
        return V(this, p(e, m, d, b));
      }, S.prototype.skewX = function(e) {
        return V(this, x(e));
      }, S.prototype.skewY = function(e) {
        return V(this, n(e));
      }, S.prototype.skew = function(e, m) {
        return V(this, M(e, m));
      }, S.prototype.transformPoint = function(e) {
        var m = this, d = m.m11 * e.x + m.m21 * e.y + m.m31 * e.z + m.m41 * e.w, b = m.m12 * e.x + m.m22 * e.y + m.m32 * e.z + m.m42 * e.w, N = m.m13 * e.x + m.m23 * e.y + m.m33 * e.z + m.m43 * e.w, G = m.m14 * e.x + m.m24 * e.y + m.m34 * e.z + m.m44 * e.w;
        return e instanceof DOMPoint ? new DOMPoint(d, b, N, G) : {
          x: d,
          y: b,
          z: N,
          w: G
        };
      }, Object.defineProperties(S.prototype, o), Object.assign(S, {
        Translate: y,
        Rotate: h,
        RotateAxisAngle: p,
        Scale: X,
        SkewX: x,
        SkewY: n,
        Skew: M,
        Multiply: V,
        fromArray: i,
        fromMatrix: t,
        fromString: Z,
        toArray: W
      });
      var R = "1.0.3", J = R;
      return Object.assign(S, { Version: J }), S;
    });
  }(dommatrix)), dommatrix.exports;
}
var ponyfill = { exports: {} };
/**
 * @license
 * web-streams-polyfill v3.3.3
 * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
 * This code is released under the MIT license.
 * SPDX-License-Identifier: MIT
 */
var hasRequiredPonyfill;
function requirePonyfill() {
  return hasRequiredPonyfill || (hasRequiredPonyfill = 1, function(L, c) {
    (function(i, t) {
      t(c);
    })(commonjsGlobal, function(i) {
      var t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol : function(l) {
        return "Symbol(".concat(l, ")");
      };
      function Z(l, s) {
        var I = { label: 0, sent: function() {
          if (tl[0] & 1) throw tl[1];
          return tl[1];
        }, trys: [], ops: [] }, E, _, tl, Wl;
        return Wl = { next: Tl(0), throw: Tl(1), return: Tl(2) }, typeof Symbol == "function" && (Wl[Symbol.iterator] = function() {
          return this;
        }), Wl;
        function Tl(pl) {
          return function(Ul) {
            return Rl([pl, Ul]);
          };
        }
        function Rl(pl) {
          if (E) throw new TypeError("Generator is already executing.");
          for (; Wl && (Wl = 0, pl[0] && (I = 0)), I; ) try {
            if (E = 1, _ && (tl = pl[0] & 2 ? _.return : pl[0] ? _.throw || ((tl = _.return) && tl.call(_), 0) : _.next) && !(tl = tl.call(_, pl[1])).done) return tl;
            switch (_ = 0, tl && (pl = [pl[0] & 2, tl.value]), pl[0]) {
              case 0:
              case 1:
                tl = pl;
                break;
              case 4:
                return I.label++, { value: pl[1], done: !1 };
              case 5:
                I.label++, _ = pl[1], pl = [0];
                continue;
              case 7:
                pl = I.ops.pop(), I.trys.pop();
                continue;
              default:
                if (tl = I.trys, !(tl = tl.length > 0 && tl[tl.length - 1]) && (pl[0] === 6 || pl[0] === 2)) {
                  I = 0;
                  continue;
                }
                if (pl[0] === 3 && (!tl || pl[1] > tl[0] && pl[1] < tl[3])) {
                  I.label = pl[1];
                  break;
                }
                if (pl[0] === 6 && I.label < tl[1]) {
                  I.label = tl[1], tl = pl;
                  break;
                }
                if (tl && I.label < tl[2]) {
                  I.label = tl[2], I.ops.push(pl);
                  break;
                }
                tl[2] && I.ops.pop(), I.trys.pop();
                continue;
            }
            pl = s.call(l, I);
          } catch (Ul) {
            pl = [6, Ul], _ = 0;
          } finally {
            E = tl = 0;
          }
          if (pl[0] & 5) throw pl[1];
          return { value: pl[0] ? pl[1] : void 0, done: !0 };
        }
      }
      function W(l) {
        var s = typeof Symbol == "function" && Symbol.iterator, I = s && l[s], E = 0;
        if (I) return I.call(l);
        if (l && typeof l.length == "number") return {
          next: function() {
            return l && E >= l.length && (l = void 0), { value: l && l[E++], done: !l };
          }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }
      function y(l) {
        return this instanceof y ? (this.v = l, this) : new y(l);
      }
      function h(l, s, I) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var E = I.apply(l, s || []), _, tl = [];
        return _ = {}, Wl("next"), Wl("throw"), Wl("return"), _[Symbol.asyncIterator] = function() {
          return this;
        }, _;
        function Wl(Ql) {
          E[Ql] && (_[Ql] = function(di) {
            return new Promise(function(ni, hi) {
              tl.push([Ql, di, ni, hi]) > 1 || Tl(Ql, di);
            });
          });
        }
        function Tl(Ql, di) {
          try {
            Rl(E[Ql](di));
          } catch (ni) {
            vl(tl[0][3], ni);
          }
        }
        function Rl(Ql) {
          Ql.value instanceof y ? Promise.resolve(Ql.value.v).then(pl, Ul) : vl(tl[0][2], Ql);
        }
        function pl(Ql) {
          Tl("next", Ql);
        }
        function Ul(Ql) {
          Tl("throw", Ql);
        }
        function vl(Ql, di) {
          Ql(di), tl.shift(), tl.length && Tl(tl[0][0], tl[0][1]);
        }
      }
      function p(l) {
        var s, I;
        return s = {}, E("next"), E("throw", function(_) {
          throw _;
        }), E("return"), s[Symbol.iterator] = function() {
          return this;
        }, s;
        function E(_, tl) {
          s[_] = l[_] ? function(Wl) {
            return (I = !I) ? { value: y(l[_](Wl)), done: !1 } : tl ? tl(Wl) : Wl;
          } : tl;
        }
      }
      function X(l) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var s = l[Symbol.asyncIterator], I;
        return s ? s.call(l) : (l = typeof W == "function" ? W(l) : l[Symbol.iterator](), I = {}, E("next"), E("throw"), E("return"), I[Symbol.asyncIterator] = function() {
          return this;
        }, I);
        function E(tl) {
          I[tl] = l[tl] && function(Wl) {
            return new Promise(function(Tl, Rl) {
              Wl = l[tl](Wl), _(Tl, Rl, Wl.done, Wl.value);
            });
          };
        }
        function _(tl, Wl, Tl, Rl) {
          Promise.resolve(Rl).then(function(pl) {
            tl({ value: pl, done: Tl });
          }, Wl);
        }
      }
      typeof SuppressedError == "function" && SuppressedError;
      function M() {
      }
      function x(l) {
        return typeof l == "object" && l !== null || typeof l == "function";
      }
      var n = M;
      function V(l, s) {
        try {
          Object.defineProperty(l, "name", {
            value: s,
            configurable: !0
          });
        } catch {
        }
      }
      var S = Promise, o = Promise.prototype.then, R = Promise.reject.bind(S);
      function J(l) {
        return new S(l);
      }
      function u(l) {
        return J(function(s) {
          return s(l);
        });
      }
      function e(l) {
        return R(l);
      }
      function m(l, s, I) {
        return o.call(l, s, I);
      }
      function d(l, s, I) {
        m(m(l, s, I), void 0, n);
      }
      function b(l, s) {
        d(l, s);
      }
      function N(l, s) {
        d(l, void 0, s);
      }
      function G(l, s, I) {
        return m(l, s, I);
      }
      function r(l) {
        m(l, void 0, n);
      }
      var j = function(l) {
        if (typeof queueMicrotask == "function")
          j = queueMicrotask;
        else {
          var s = u(void 0);
          j = function(I) {
            return m(s, I);
          };
        }
        return j(l);
      };
      function D(l, s, I) {
        if (typeof l != "function")
          throw new TypeError("Argument is not a function");
        return Function.prototype.apply.call(l, s, I);
      }
      function f(l, s, I) {
        try {
          return u(D(l, s, I));
        } catch (E) {
          return e(E);
        }
      }
      var P = 16384, B = (
        /** @class */
        function() {
          function l() {
            this._cursor = 0, this._size = 0, this._front = {
              _elements: [],
              _next: void 0
            }, this._back = this._front, this._cursor = 0, this._size = 0;
          }
          return Object.defineProperty(l.prototype, "length", {
            get: function() {
              return this._size;
            },
            enumerable: !1,
            configurable: !0
          }), l.prototype.push = function(s) {
            var I = this._back, E = I;
            I._elements.length === P - 1 && (E = {
              _elements: [],
              _next: void 0
            }), I._elements.push(s), E !== I && (this._back = E, I._next = E), ++this._size;
          }, l.prototype.shift = function() {
            var s = this._front, I = s, E = this._cursor, _ = E + 1, tl = s._elements, Wl = tl[E];
            return _ === P && (I = s._next, _ = 0), --this._size, this._cursor = _, s !== I && (this._front = I), tl[E] = void 0, Wl;
          }, l.prototype.forEach = function(s) {
            for (var I = this._cursor, E = this._front, _ = E._elements; (I !== _.length || E._next !== void 0) && !(I === _.length && (E = E._next, _ = E._elements, I = 0, _.length === 0)); )
              s(_[I]), ++I;
          }, l.prototype.peek = function() {
            var s = this._front, I = this._cursor;
            return s._elements[I];
          }, l;
        }()
      ), A = t("[[AbortSteps]]"), H = t("[[ErrorSteps]]"), O = t("[[CancelSteps]]"), U = t("[[PullSteps]]"), k = t("[[ReleaseSteps]]");
      function q(l, s) {
        l._ownerReadableStream = s, s._reader = l, s._state === "readable" ? Q(l) : s._state === "closed" ? w(l) : T(l, s._storedError);
      }
      function al(l, s) {
        var I = l._ownerReadableStream;
        return Mi(I, s);
      }
      function Ml(l) {
        var s = l._ownerReadableStream;
        s._state === "readable" ? g(l, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : K(l, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), s._readableStreamController[k](), s._reader = void 0, l._ownerReadableStream = void 0;
      }
      function wl(l) {
        return new TypeError("Cannot " + l + " a stream using a released reader");
      }
      function Q(l) {
        l._closedPromise = J(function(s, I) {
          l._closedPromise_resolve = s, l._closedPromise_reject = I;
        });
      }
      function T(l, s) {
        Q(l), g(l, s);
      }
      function w(l) {
        Q(l), a(l);
      }
      function g(l, s) {
        l._closedPromise_reject !== void 0 && (r(l._closedPromise), l._closedPromise_reject(s), l._closedPromise_resolve = void 0, l._closedPromise_reject = void 0);
      }
      function K(l, s) {
        T(l, s);
      }
      function a(l) {
        l._closedPromise_resolve !== void 0 && (l._closedPromise_resolve(void 0), l._closedPromise_resolve = void 0, l._closedPromise_reject = void 0);
      }
      var Y = Number.isFinite || function(l) {
        return typeof l == "number" && isFinite(l);
      }, z = Math.trunc || function(l) {
        return l < 0 ? Math.ceil(l) : Math.floor(l);
      };
      function C(l) {
        return typeof l == "object" || typeof l == "function";
      }
      function F(l, s) {
        if (l !== void 0 && !C(l))
          throw new TypeError("".concat(s, " is not an object."));
      }
      function v(l, s) {
        if (typeof l != "function")
          throw new TypeError("".concat(s, " is not a function."));
      }
      function $(l) {
        return typeof l == "object" && l !== null || typeof l == "function";
      }
      function il(l, s) {
        if (!$(l))
          throw new TypeError("".concat(s, " is not an object."));
      }
      function dl(l, s, I) {
        if (l === void 0)
          throw new TypeError("Parameter ".concat(s, " is required in '").concat(I, "'."));
      }
      function el(l, s, I) {
        if (l === void 0)
          throw new TypeError("".concat(s, " is required in '").concat(I, "'."));
      }
      function bl(l) {
        return Number(l);
      }
      function ml(l) {
        return l === 0 ? 0 : l;
      }
      function Gl(l) {
        return ml(z(l));
      }
      function Yl(l, s) {
        var I = 0, E = Number.MAX_SAFE_INTEGER, _ = Number(l);
        if (_ = ml(_), !Y(_))
          throw new TypeError("".concat(s, " is not a finite number"));
        if (_ = Gl(_), _ < I || _ > E)
          throw new TypeError("".concat(s, " is outside the accepted range of ").concat(I, " to ").concat(E, ", inclusive"));
        return !Y(_) || _ === 0 ? 0 : _;
      }
      function yl(l, s) {
        if (!ri(l))
          throw new TypeError("".concat(s, " is not a ReadableStream."));
      }
      function Vl(l) {
        return new Sl(l);
      }
      function Dl(l, s) {
        l._reader._readRequests.push(s);
      }
      function Xl(l, s, I) {
        var E = l._reader, _ = E._readRequests.shift();
        I ? _._closeSteps() : _._chunkSteps(s);
      }
      function Hl(l) {
        return l._reader._readRequests.length;
      }
      function Al(l) {
        var s = l._reader;
        return !(s === void 0 || !ol(s));
      }
      var Sl = (
        /** @class */
        function() {
          function l(s) {
            if (dl(s, 1, "ReadableStreamDefaultReader"), yl(s, "First parameter"), Ri(s))
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            q(this, s), this._readRequests = new B();
          }
          return Object.defineProperty(l.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed,
             * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
             */
            get: function() {
              return ol(this) ? this._closedPromise : e(fl("closed"));
            },
            enumerable: !1,
            configurable: !0
          }), l.prototype.cancel = function(s) {
            return s === void 0 && (s = void 0), ol(this) ? this._ownerReadableStream === void 0 ? e(wl("cancel")) : al(this, s) : e(fl("cancel"));
          }, l.prototype.read = function() {
            if (!ol(this))
              return e(fl("read"));
            if (this._ownerReadableStream === void 0)
              return e(wl("read from"));
            var s, I, E = J(function(tl, Wl) {
              s = tl, I = Wl;
            }), _ = {
              _chunkSteps: function(tl) {
                return s({ value: tl, done: !1 });
              },
              _closeSteps: function() {
                return s({ value: void 0, done: !0 });
              },
              _errorSteps: function(tl) {
                return I(tl);
              }
            };
            return cl(this, _), E;
          }, l.prototype.releaseLock = function() {
            if (!ol(this))
              throw fl("releaseLock");
            this._ownerReadableStream !== void 0 && Il(this);
          }, l;
        }()
      );
      Object.defineProperties(Sl.prototype, {
        cancel: { enumerable: !0 },
        read: { enumerable: !0 },
        releaseLock: { enumerable: !0 },
        closed: { enumerable: !0 }
      }), V(Sl.prototype.cancel, "cancel"), V(Sl.prototype.read, "read"), V(Sl.prototype.releaseLock, "releaseLock"), typeof t.toStringTag == "symbol" && Object.defineProperty(Sl.prototype, t.toStringTag, {
        value: "ReadableStreamDefaultReader",
        configurable: !0
      });
      function ol(l) {
        return !x(l) || !Object.prototype.hasOwnProperty.call(l, "_readRequests") ? !1 : l instanceof Sl;
      }
      function cl(l, s) {
        var I = l._ownerReadableStream;
        I._disturbed = !0, I._state === "closed" ? s._closeSteps() : I._state === "errored" ? s._errorSteps(I._storedError) : I._readableStreamController[U](s);
      }
      function Il(l) {
        Ml(l);
        var s = new TypeError("Reader was released");
        Jl(l, s);
      }
      function Jl(l, s) {
        var I = l._readRequests;
        l._readRequests = new B(), I.forEach(function(E) {
          E._errorSteps(s);
        });
      }
      function fl(l) {
        return new TypeError("ReadableStreamDefaultReader.prototype.".concat(l, " can only be used on a ReadableStreamDefaultReader"));
      }
      var Nl, zl, kl;
      function nl(l) {
        return l.slice();
      }
      function ll(l, s, I, E, _) {
        new Uint8Array(l).set(new Uint8Array(I, E, _), s);
      }
      var sl = function(l) {
        return typeof l.transfer == "function" ? sl = function(s) {
          return s.transfer();
        } : typeof structuredClone == "function" ? sl = function(s) {
          return structuredClone(s, { transfer: [s] });
        } : sl = function(s) {
          return s;
        }, sl(l);
      }, hl = function(l) {
        return typeof l.detached == "boolean" ? hl = function(s) {
          return s.detached;
        } : hl = function(s) {
          return s.byteLength === 0;
        }, hl(l);
      };
      function Cl(l, s, I) {
        if (l.slice)
          return l.slice(s, I);
        var E = I - s, _ = new ArrayBuffer(E);
        return ll(_, 0, l, s, E), _;
      }
      function jl(l, s) {
        var I = l[s];
        if (I != null) {
          if (typeof I != "function")
            throw new TypeError("".concat(String(s), " is not a function"));
          return I;
        }
      }
      function ul(l) {
        var s, I = (s = {}, s[t.iterator] = function() {
          return l.iterator;
        }, s), E = function() {
          return h(this, arguments, function() {
            return Z(this, function(tl) {
              switch (tl.label) {
                case 0:
                  return [5, W(p(X(I)))];
                case 1:
                  return [4, y.apply(void 0, [tl.sent()])];
                case 2:
                  return [4, y.apply(void 0, [tl.sent()])];
                case 3:
                  return [2, tl.sent()];
              }
            });
          });
        }(), _ = E.next;
        return { iterator: E, nextMethod: _, done: !1 };
      }
      var Zl = (kl = (Nl = t.asyncIterator) !== null && Nl !== void 0 ? Nl : (zl = t.for) === null || zl === void 0 ? void 0 : zl.call(t, "Symbol.asyncIterator")) !== null && kl !== void 0 ? kl : "@@asyncIterator";
      function Ll(l, s, I) {
        if (s === void 0 && (s = "sync"), I === void 0)
          if (s === "async") {
            if (I = jl(l, Zl), I === void 0) {
              var E = jl(l, t.iterator), _ = Ll(l, "sync", E);
              return ul(_);
            }
          } else
            I = jl(l, t.iterator);
        if (I === void 0)
          throw new TypeError("The object is not iterable");
        var tl = D(I, l, []);
        if (!x(tl))
          throw new TypeError("The iterator method must return an object");
        var Wl = tl.next;
        return { iterator: tl, nextMethod: Wl, done: !1 };
      }
      function rl(l) {
        var s = D(l.nextMethod, l.iterator, []);
        if (!x(s))
          throw new TypeError("The iterator.next() method must return an object");
        return s;
      }
      function Fl(l) {
        return !!l.done;
      }
      function Kl(l) {
        return l.value;
      }
      var Ol, El = (Ol = {}, // 25.1.3.1 %AsyncIteratorPrototype% [ @@asyncIterator ] ( )
      // https://tc39.github.io/ecma262/#sec-asynciteratorprototype-asynciterator
      Ol[Zl] = function() {
        return this;
      }, Ol);
      Object.defineProperty(El, Zl, { enumerable: !1 });
      var xl = (
        /** @class */
        function() {
          function l(s, I) {
            this._ongoingPromise = void 0, this._isFinished = !1, this._reader = s, this._preventCancel = I;
          }
          return l.prototype.next = function() {
            var s = this, I = function() {
              return s._nextSteps();
            };
            return this._ongoingPromise = this._ongoingPromise ? G(this._ongoingPromise, I, I) : I(), this._ongoingPromise;
          }, l.prototype.return = function(s) {
            var I = this, E = function() {
              return I._returnSteps(s);
            };
            return this._ongoingPromise ? G(this._ongoingPromise, E, E) : E();
          }, l.prototype._nextSteps = function() {
            var s = this;
            if (this._isFinished)
              return Promise.resolve({ value: void 0, done: !0 });
            var I = this._reader, E, _, tl = J(function(Tl, Rl) {
              E = Tl, _ = Rl;
            }), Wl = {
              _chunkSteps: function(Tl) {
                s._ongoingPromise = void 0, j(function() {
                  return E({ value: Tl, done: !1 });
                });
              },
              _closeSteps: function() {
                s._ongoingPromise = void 0, s._isFinished = !0, Ml(I), E({ value: void 0, done: !0 });
              },
              _errorSteps: function(Tl) {
                s._ongoingPromise = void 0, s._isFinished = !0, Ml(I), _(Tl);
              }
            };
            return cl(I, Wl), tl;
          }, l.prototype._returnSteps = function(s) {
            if (this._isFinished)
              return Promise.resolve({ value: s, done: !0 });
            this._isFinished = !0;
            var I = this._reader;
            if (!this._preventCancel) {
              var E = al(I, s);
              return Ml(I), G(E, function() {
                return { value: s, done: !0 };
              });
            }
            return Ml(I), u({ value: s, done: !0 });
          }, l;
        }()
      ), Bl = {
        next: function() {
          return Pl(this) ? this._asyncIteratorImpl.next() : e(ql("next"));
        },
        return: function(l) {
          return Pl(this) ? this._asyncIteratorImpl.return(l) : e(ql("return"));
        }
      };
      Object.setPrototypeOf(Bl, El);
      function si(l, s) {
        var I = Vl(l), E = new xl(I, s), _ = Object.create(Bl);
        return _._asyncIteratorImpl = E, _;
      }
      function Pl(l) {
        if (!x(l) || !Object.prototype.hasOwnProperty.call(l, "_asyncIteratorImpl"))
          return !1;
        try {
          return l._asyncIteratorImpl instanceof xl;
        } catch {
          return !1;
        }
      }
      function ql(l) {
        return new TypeError("ReadableStreamAsyncIterator.".concat(l, " can only be used on a ReadableSteamAsyncIterator"));
      }
      var ci = Number.isNaN || function(l) {
        return l !== l;
      };
      function $l(l) {
        return !(typeof l != "number" || ci(l) || l < 0);
      }
      function Zi(l) {
        var s = Cl(l.buffer, l.byteOffset, l.byteOffset + l.byteLength);
        return new Uint8Array(s);
      }
      function li(l) {
        var s = l._queue.shift();
        return l._queueTotalSize -= s.size, l._queueTotalSize < 0 && (l._queueTotalSize = 0), s.value;
      }
      function Gi(l, s, I) {
        if (!$l(I) || I === 1 / 0)
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        l._queue.push({ value: s, size: I }), l._queueTotalSize += I;
      }
      function Ti(l) {
        var s = l._queue.peek();
        return s.value;
      }
      function ei(l) {
        l._queue = new B(), l._queueTotalSize = 0;
      }
      function Di(l) {
        return l === DataView;
      }
      function Ki(l) {
        return Di(l.constructor);
      }
      function xi(l) {
        return Di(l) ? 1 : l.BYTES_PER_ELEMENT;
      }
      var mi = (
        /** @class */
        function() {
          function l() {
            throw new TypeError("Illegal constructor");
          }
          return Object.defineProperty(l.prototype, "view", {
            /**
             * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
             */
            get: function() {
              if (!St(this))
                throw kt("view");
              return this._view;
            },
            enumerable: !1,
            configurable: !0
          }), l.prototype.respond = function(s) {
            if (!St(this))
              throw kt("respond");
            if (dl(s, 1, "respond"), s = Yl(s, "First parameter"), this._associatedReadableByteStreamController === void 0)
              throw new TypeError("This BYOB request has been invalidated");
            if (hl(this._view.buffer))
              throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");
            et(this._associatedReadableByteStreamController, s);
          }, l.prototype.respondWithNewView = function(s) {
            if (!St(this))
              throw kt("respondWithNewView");
            if (dl(s, 1, "respondWithNewView"), !ArrayBuffer.isView(s))
              throw new TypeError("You can only respond with array buffer views");
            if (this._associatedReadableByteStreamController === void 0)
              throw new TypeError("This BYOB request has been invalidated");
            if (hl(s.buffer))
              throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");
            mt(this._associatedReadableByteStreamController, s);
          }, l;
        }()
      );
      Object.defineProperties(mi.prototype, {
        respond: { enumerable: !0 },
        respondWithNewView: { enumerable: !0 },
        view: { enumerable: !0 }
      }), V(mi.prototype.respond, "respond"), V(mi.prototype.respondWithNewView, "respondWithNewView"), typeof t.toStringTag == "symbol" && Object.defineProperty(mi.prototype, t.toStringTag, {
        value: "ReadableStreamBYOBRequest",
        configurable: !0
      });
      var yi = (
        /** @class */
        function() {
          function l() {
            throw new TypeError("Illegal constructor");
          }
          return Object.defineProperty(l.prototype, "byobRequest", {
            /**
             * Returns the current BYOB pull request, or `null` if there isn't one.
             */
            get: function() {
              if (!Ji(this))
                throw qi("byobRequest");
              return Jt(this);
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(l.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
             * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
             */
            get: function() {
              if (!Ji(this))
                throw qi("desiredSize");
              return ms(this);
            },
            enumerable: !1,
            configurable: !0
          }), l.prototype.close = function() {
            if (!Ji(this))
              throw qi("close");
            if (this._closeRequested)
              throw new TypeError("The stream has already been closed; do not close it again!");
            var s = this._controlledReadableByteStream._state;
            if (s !== "readable")
              throw new TypeError("The stream (in ".concat(s, " state) is not in the readable state and cannot be closed"));
            _i(this);
          }, l.prototype.enqueue = function(s) {
            if (!Ji(this))
              throw qi("enqueue");
            if (dl(s, 1, "enqueue"), !ArrayBuffer.isView(s))
              throw new TypeError("chunk must be an array buffer view");
            if (s.byteLength === 0)
              throw new TypeError("chunk must have non-zero byteLength");
            if (s.buffer.byteLength === 0)
              throw new TypeError("chunk's buffer must have non-zero byteLength");
            if (this._closeRequested)
              throw new TypeError("stream is closed or draining");
            var I = this._controlledReadableByteStream._state;
            if (I !== "readable")
              throw new TypeError("The stream (in ".concat(I, " state) is not in the readable state and cannot be enqueued to"));
            at(this, s);
          }, l.prototype.error = function(s) {
            if (s === void 0 && (s = void 0), !Ji(this))
              throw qi("error");
            Wi(this, s);
          }, l.prototype[O] = function(s) {
            is(this), ei(this);
            var I = this._cancelAlgorithm(s);
            return bt(this), I;
          }, l.prototype[U] = function(s) {
            var I = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              es(this, s);
              return;
            }
            var E = this._autoAllocateChunkSize;
            if (E !== void 0) {
              var _ = void 0;
              try {
                _ = new ArrayBuffer(E);
              } catch (Wl) {
                s._errorSteps(Wl);
                return;
              }
              var tl = {
                buffer: _,
                bufferByteLength: E,
                byteOffset: 0,
                byteLength: E,
                bytesFilled: 0,
                minimumFill: 1,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(tl);
            }
            Dl(I, s), ki(this);
          }, l.prototype[k] = function() {
            if (this._pendingPullIntos.length > 0) {
              var s = this._pendingPullIntos.peek();
              s.readerType = "none", this._pendingPullIntos = new B(), this._pendingPullIntos.push(s);
            }
          }, l;
        }()
      );
      Object.defineProperties(yi.prototype, {
        close: { enumerable: !0 },
        enqueue: { enumerable: !0 },
        error: { enumerable: !0 },
        byobRequest: { enumerable: !0 },
        desiredSize: { enumerable: !0 }
      }), V(yi.prototype.close, "close"), V(yi.prototype.enqueue, "enqueue"), V(yi.prototype.error, "error"), typeof t.toStringTag == "symbol" && Object.defineProperty(yi.prototype, t.toStringTag, {
        value: "ReadableByteStreamController",
        configurable: !0
      });
      function Ji(l) {
        return !x(l) || !Object.prototype.hasOwnProperty.call(l, "_controlledReadableByteStream") ? !1 : l instanceof yi;
      }
      function St(l) {
        return !x(l) || !Object.prototype.hasOwnProperty.call(l, "_associatedReadableByteStreamController") ? !1 : l instanceof mi;
      }
      function ki(l) {
        var s = tc(l);
        if (s) {
          if (l._pulling) {
            l._pullAgain = !0;
            return;
          }
          l._pulling = !0;
          var I = l._pullAlgorithm();
          d(I, function() {
            return l._pulling = !1, l._pullAgain && (l._pullAgain = !1, ki(l)), null;
          }, function(E) {
            return Wi(l, E), null;
          });
        }
      }
      function is(l) {
        Dt(l), l._pendingPullIntos = new B();
      }
      function Ct(l, s) {
        var I = !1;
        l._state === "closed" && (I = !0);
        var E = ts(s);
        s.readerType === "default" ? Xl(l, E, I) : ac(l, E, I);
      }
      function ts(l) {
        var s = l.bytesFilled, I = l.elementSize;
        return new l.viewConstructor(l.buffer, l.byteOffset, s / I);
      }
      function Zt(l, s, I, E) {
        l._queue.push({ buffer: s, byteOffset: I, byteLength: E }), l._queueTotalSize += E;
      }
      function ss(l, s, I, E) {
        var _;
        try {
          _ = Cl(s, I, I + E);
        } catch (tl) {
          throw Wi(l, tl), tl;
        }
        Zt(l, _, 0, E);
      }
      function cs(l, s) {
        s.bytesFilled > 0 && ss(l, s.buffer, s.byteOffset, s.bytesFilled), Ei(l);
      }
      function ds(l, s) {
        var I = Math.min(l._queueTotalSize, s.byteLength - s.bytesFilled), E = s.bytesFilled + I, _ = I, tl = !1, Wl = E % s.elementSize, Tl = E - Wl;
        Tl >= s.minimumFill && (_ = Tl - s.bytesFilled, tl = !0);
        for (var Rl = l._queue; _ > 0; ) {
          var pl = Rl.peek(), Ul = Math.min(_, pl.byteLength), vl = s.byteOffset + s.bytesFilled;
          ll(s.buffer, vl, pl.buffer, pl.byteOffset, Ul), pl.byteLength === Ul ? Rl.shift() : (pl.byteOffset += Ul, pl.byteLength -= Ul), l._queueTotalSize -= Ul, Zs(l, Ul, s), _ -= Ul;
        }
        return tl;
      }
      function Zs(l, s, I) {
        I.bytesFilled += s;
      }
      function bs(l) {
        l._queueTotalSize === 0 && l._closeRequested ? (bt(l), ct(l._controlledReadableByteStream)) : ki(l);
      }
      function Dt(l) {
        l._byobRequest !== null && (l._byobRequest._associatedReadableByteStreamController = void 0, l._byobRequest._view = null, l._byobRequest = null);
      }
      function xt(l) {
        for (; l._pendingPullIntos.length > 0; ) {
          if (l._queueTotalSize === 0)
            return;
          var s = l._pendingPullIntos.peek();
          ds(l, s) && (Ei(l), Ct(l._controlledReadableByteStream, s));
        }
      }
      function qs(l) {
        for (var s = l._controlledReadableByteStream._reader; s._readRequests.length > 0; ) {
          if (l._queueTotalSize === 0)
            return;
          var I = s._readRequests.shift();
          es(l, I);
        }
      }
      function $s(l, s, I, E) {
        var _ = l._controlledReadableByteStream, tl = s.constructor, Wl = xi(tl), Tl = s.byteOffset, Rl = s.byteLength, pl = I * Wl, Ul;
        try {
          Ul = sl(s.buffer);
        } catch (hi) {
          E._errorSteps(hi);
          return;
        }
        var vl = {
          buffer: Ul,
          bufferByteLength: Ul.byteLength,
          byteOffset: Tl,
          byteLength: Rl,
          bytesFilled: 0,
          minimumFill: pl,
          elementSize: Wl,
          viewConstructor: tl,
          readerType: "byob"
        };
        if (l._pendingPullIntos.length > 0) {
          l._pendingPullIntos.push(vl), Ws(_, E);
          return;
        }
        if (_._state === "closed") {
          var Ql = new tl(vl.buffer, vl.byteOffset, 0);
          E._closeSteps(Ql);
          return;
        }
        if (l._queueTotalSize > 0) {
          if (ds(l, vl)) {
            var di = ts(vl);
            bs(l), E._chunkSteps(di);
            return;
          }
          if (l._closeRequested) {
            var ni = new TypeError("Insufficient bytes to fill elements in the given buffer");
            Wi(l, ni), E._errorSteps(ni);
            return;
          }
        }
        l._pendingPullIntos.push(vl), Ws(_, E), ki(l);
      }
      function lc(l, s) {
        s.readerType === "none" && Ei(l);
        var I = l._controlledReadableByteStream;
        if (jt(I))
          for (; hs(I) > 0; ) {
            var E = Ei(l);
            Ct(I, E);
          }
      }
      function ic(l, s, I) {
        if (Zs(l, s, I), I.readerType === "none") {
          cs(l, I), xt(l);
          return;
        }
        if (!(I.bytesFilled < I.minimumFill)) {
          Ei(l);
          var E = I.bytesFilled % I.elementSize;
          if (E > 0) {
            var _ = I.byteOffset + I.bytesFilled;
            ss(l, I.buffer, _ - E, E);
          }
          I.bytesFilled -= E, Ct(l._controlledReadableByteStream, I), xt(l);
        }
      }
      function as(l, s) {
        var I = l._pendingPullIntos.peek();
        Dt(l);
        var E = l._controlledReadableByteStream._state;
        E === "closed" ? lc(l, I) : ic(l, s, I), ki(l);
      }
      function Ei(l) {
        var s = l._pendingPullIntos.shift();
        return s;
      }
      function tc(l) {
        var s = l._controlledReadableByteStream;
        if (s._state !== "readable" || l._closeRequested || !l._started)
          return !1;
        if (Al(s) && Hl(s) > 0 || jt(s) && hs(s) > 0)
          return !0;
        var I = ms(l);
        return I > 0;
      }
      function bt(l) {
        l._pullAlgorithm = void 0, l._cancelAlgorithm = void 0;
      }
      function _i(l) {
        var s = l._controlledReadableByteStream;
        if (!(l._closeRequested || s._state !== "readable")) {
          if (l._queueTotalSize > 0) {
            l._closeRequested = !0;
            return;
          }
          if (l._pendingPullIntos.length > 0) {
            var I = l._pendingPullIntos.peek();
            if (I.bytesFilled % I.elementSize !== 0) {
              var E = new TypeError("Insufficient bytes to fill elements in the given buffer");
              throw Wi(l, E), E;
            }
          }
          bt(l), ct(s);
        }
      }
      function at(l, s) {
        var I = l._controlledReadableByteStream;
        if (!(l._closeRequested || I._state !== "readable")) {
          var E = s.buffer, _ = s.byteOffset, tl = s.byteLength;
          if (hl(E))
            throw new TypeError("chunk's buffer is detached and so cannot be enqueued");
          var Wl = sl(E);
          if (l._pendingPullIntos.length > 0) {
            var Tl = l._pendingPullIntos.peek();
            if (hl(Tl.buffer))
              throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");
            Dt(l), Tl.buffer = sl(Tl.buffer), Tl.readerType === "none" && cs(l, Tl);
          }
          if (Al(I))
            if (qs(l), Hl(I) === 0)
              Zt(l, Wl, _, tl);
            else {
              l._pendingPullIntos.length > 0 && Ei(l);
              var Rl = new Uint8Array(Wl, _, tl);
              Xl(I, Rl, !1);
            }
          else jt(I) ? (Zt(l, Wl, _, tl), xt(l)) : Zt(l, Wl, _, tl);
          ki(l);
        }
      }
      function Wi(l, s) {
        var I = l._controlledReadableByteStream;
        I._state === "readable" && (is(l), ei(l), bt(l), Fs(I, s));
      }
      function es(l, s) {
        var I = l._queue.shift();
        l._queueTotalSize -= I.byteLength, bs(l);
        var E = new Uint8Array(I.buffer, I.byteOffset, I.byteLength);
        s._chunkSteps(E);
      }
      function Jt(l) {
        if (l._byobRequest === null && l._pendingPullIntos.length > 0) {
          var s = l._pendingPullIntos.peek(), I = new Uint8Array(s.buffer, s.byteOffset + s.bytesFilled, s.byteLength - s.bytesFilled), E = Object.create(mi.prototype);
          cc(E, l, I), l._byobRequest = E;
        }
        return l._byobRequest;
      }
      function ms(l) {
        var s = l._controlledReadableByteStream._state;
        return s === "errored" ? null : s === "closed" ? 0 : l._strategyHWM - l._queueTotalSize;
      }
      function et(l, s) {
        var I = l._pendingPullIntos.peek(), E = l._controlledReadableByteStream._state;
        if (E === "closed") {
          if (s !== 0)
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
        } else {
          if (s === 0)
            throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          if (I.bytesFilled + s > I.byteLength)
            throw new RangeError("bytesWritten out of range");
        }
        I.buffer = sl(I.buffer), as(l, s);
      }
      function mt(l, s) {
        var I = l._pendingPullIntos.peek(), E = l._controlledReadableByteStream._state;
        if (E === "closed") {
          if (s.byteLength !== 0)
            throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
        } else if (s.byteLength === 0)
          throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
        if (I.byteOffset + I.bytesFilled !== s.byteOffset)
          throw new RangeError("The region specified by view does not match byobRequest");
        if (I.bufferByteLength !== s.buffer.byteLength)
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        if (I.bytesFilled + s.byteLength > I.byteLength)
          throw new RangeError("The region specified by view is larger than byobRequest");
        var _ = s.byteLength;
        I.buffer = sl(s.buffer), as(l, _);
      }
      function ns(l, s, I, E, _, tl, Wl) {
        s._controlledReadableByteStream = l, s._pullAgain = !1, s._pulling = !1, s._byobRequest = null, s._queue = s._queueTotalSize = void 0, ei(s), s._closeRequested = !1, s._started = !1, s._strategyHWM = tl, s._pullAlgorithm = E, s._cancelAlgorithm = _, s._autoAllocateChunkSize = Wl, s._pendingPullIntos = new B(), l._readableStreamController = s;
        var Tl = I();
        d(u(Tl), function() {
          return s._started = !0, ki(s), null;
        }, function(Rl) {
          return Wi(s, Rl), null;
        });
      }
      function sc(l, s, I) {
        var E = Object.create(yi.prototype), _, tl, Wl;
        s.start !== void 0 ? _ = function() {
          return s.start(E);
        } : _ = function() {
        }, s.pull !== void 0 ? tl = function() {
          return s.pull(E);
        } : tl = function() {
          return u(void 0);
        }, s.cancel !== void 0 ? Wl = function(Rl) {
          return s.cancel(Rl);
        } : Wl = function() {
          return u(void 0);
        };
        var Tl = s.autoAllocateChunkSize;
        if (Tl === 0)
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        ns(l, E, _, tl, Wl, I, Tl);
      }
      function cc(l, s, I) {
        l._associatedReadableByteStreamController = s, l._view = I;
      }
      function kt(l) {
        return new TypeError("ReadableStreamBYOBRequest.prototype.".concat(l, " can only be used on a ReadableStreamBYOBRequest"));
      }
      function qi(l) {
        return new TypeError("ReadableByteStreamController.prototype.".concat(l, " can only be used on a ReadableByteStreamController"));
      }
      function dc(l, s) {
        F(l, s);
        var I = l == null ? void 0 : l.mode;
        return {
          mode: I === void 0 ? void 0 : Zc(I, "".concat(s, " has member 'mode' that"))
        };
      }
      function Zc(l, s) {
        if (l = "".concat(l), l !== "byob")
          throw new TypeError("".concat(s, " '").concat(l, "' is not a valid enumeration value for ReadableStreamReaderMode"));
        return l;
      }
      function bc(l, s) {
        var I;
        F(l, s);
        var E = (I = l == null ? void 0 : l.min) !== null && I !== void 0 ? I : 1;
        return {
          min: Yl(E, "".concat(s, " has member 'min' that"))
        };
      }
      function us(l) {
        return new wi(l);
      }
      function Ws(l, s) {
        l._reader._readIntoRequests.push(s);
      }
      function ac(l, s, I) {
        var E = l._reader, _ = E._readIntoRequests.shift();
        I ? _._closeSteps(s) : _._chunkSteps(s);
      }
      function hs(l) {
        return l._reader._readIntoRequests.length;
      }
      function jt(l) {
        var s = l._reader;
        return !(s === void 0 || !ji(s));
      }
      var wi = (
        /** @class */
        function() {
          function l(s) {
            if (dl(s, 1, "ReadableStreamBYOBReader"), yl(s, "First parameter"), Ri(s))
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            if (!Ji(s._readableStreamController))
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            q(this, s), this._readIntoRequests = new B();
          }
          return Object.defineProperty(l.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
             * the reader's lock is released before the stream finishes closing.
             */
            get: function() {
              return ji(this) ? this._closedPromise : e(nt("closed"));
            },
            enumerable: !1,
            configurable: !0
          }), l.prototype.cancel = function(s) {
            return s === void 0 && (s = void 0), ji(this) ? this._ownerReadableStream === void 0 ? e(wl("cancel")) : al(this, s) : e(nt("cancel"));
          }, l.prototype.read = function(s, I) {
            if (I === void 0 && (I = {}), !ji(this))
              return e(nt("read"));
            if (!ArrayBuffer.isView(s))
              return e(new TypeError("view must be an array buffer view"));
            if (s.byteLength === 0)
              return e(new TypeError("view must have non-zero byteLength"));
            if (s.buffer.byteLength === 0)
              return e(new TypeError("view's buffer must have non-zero byteLength"));
            if (hl(s.buffer))
              return e(new TypeError("view's buffer has been detached"));
            var E;
            try {
              E = bc(I, "options");
            } catch (pl) {
              return e(pl);
            }
            var _ = E.min;
            if (_ === 0)
              return e(new TypeError("options.min must be greater than 0"));
            if (Ki(s)) {
              if (_ > s.byteLength)
                return e(new RangeError("options.min must be less than or equal to view's byteLength"));
            } else if (_ > s.length)
              return e(new RangeError("options.min must be less than or equal to view's length"));
            if (this._ownerReadableStream === void 0)
              return e(wl("read from"));
            var tl, Wl, Tl = J(function(pl, Ul) {
              tl = pl, Wl = Ul;
            }), Rl = {
              _chunkSteps: function(pl) {
                return tl({ value: pl, done: !1 });
              },
              _closeSteps: function(pl) {
                return tl({ value: pl, done: !0 });
              },
              _errorSteps: function(pl) {
                return Wl(pl);
              }
            };
            return Gs(this, s, _, Rl), Tl;
          }, l.prototype.releaseLock = function() {
            if (!ji(this))
              throw nt("releaseLock");
            this._ownerReadableStream !== void 0 && ec(this);
          }, l;
        }()
      );
      Object.defineProperties(wi.prototype, {
        cancel: { enumerable: !0 },
        read: { enumerable: !0 },
        releaseLock: { enumerable: !0 },
        closed: { enumerable: !0 }
      }), V(wi.prototype.cancel, "cancel"), V(wi.prototype.read, "read"), V(wi.prototype.releaseLock, "releaseLock"), typeof t.toStringTag == "symbol" && Object.defineProperty(wi.prototype, t.toStringTag, {
        value: "ReadableStreamBYOBReader",
        configurable: !0
      });
      function ji(l) {
        return !x(l) || !Object.prototype.hasOwnProperty.call(l, "_readIntoRequests") ? !1 : l instanceof wi;
      }
      function Gs(l, s, I, E) {
        var _ = l._ownerReadableStream;
        _._disturbed = !0, _._state === "errored" ? E._errorSteps(_._storedError) : $s(_._readableStreamController, s, I, E);
      }
      function ec(l) {
        Ml(l);
        var s = new TypeError("Reader was released");
        Ns(l, s);
      }
      function Ns(l, s) {
        var I = l._readIntoRequests;
        l._readIntoRequests = new B(), I.forEach(function(E) {
          E._errorSteps(s);
        });
      }
      function nt(l) {
        return new TypeError("ReadableStreamBYOBReader.prototype.".concat(l, " can only be used on a ReadableStreamBYOBReader"));
      }
      function $i(l, s) {
        var I = l.highWaterMark;
        if (I === void 0)
          return s;
        if (ci(I) || I < 0)
          throw new RangeError("Invalid highWaterMark");
        return I;
      }
      function ut(l) {
        var s = l.size;
        return s || function() {
          return 1;
        };
      }
      function Wt(l, s) {
        F(l, s);
        var I = l == null ? void 0 : l.highWaterMark, E = l == null ? void 0 : l.size;
        return {
          highWaterMark: I === void 0 ? void 0 : bl(I),
          size: E === void 0 ? void 0 : mc(E, "".concat(s, " has member 'size' that"))
        };
      }
      function mc(l, s) {
        return v(l, s), function(I) {
          return bl(l(I));
        };
      }
      function nc(l, s) {
        F(l, s);
        var I = l == null ? void 0 : l.abort, E = l == null ? void 0 : l.close, _ = l == null ? void 0 : l.start, tl = l == null ? void 0 : l.type, Wl = l == null ? void 0 : l.write;
        return {
          abort: I === void 0 ? void 0 : uc(I, l, "".concat(s, " has member 'abort' that")),
          close: E === void 0 ? void 0 : Wc(E, l, "".concat(s, " has member 'close' that")),
          start: _ === void 0 ? void 0 : hc(_, l, "".concat(s, " has member 'start' that")),
          write: Wl === void 0 ? void 0 : Gc(Wl, l, "".concat(s, " has member 'write' that")),
          type: tl
        };
      }
      function uc(l, s, I) {
        return v(l, I), function(E) {
          return f(l, s, [E]);
        };
      }
      function Wc(l, s, I) {
        return v(l, I), function() {
          return f(l, s, []);
        };
      }
      function hc(l, s, I) {
        return v(l, I), function(E) {
          return D(l, s, [E]);
        };
      }
      function Gc(l, s, I) {
        return v(l, I), function(E, _) {
          return f(l, s, [E, _]);
        };
      }
      function Ms(l, s) {
        if (!vi(l))
          throw new TypeError("".concat(s, " is not a WritableStream."));
      }
      function Nc(l) {
        if (typeof l != "object" || l === null)
          return !1;
        try {
          return typeof l.aborted == "boolean";
        } catch {
          return !1;
        }
      }
      var Mc = typeof AbortController == "function";
      function Ic() {
        if (Mc)
          return new AbortController();
      }
      var zi = (
        /** @class */
        function() {
          function l(s, I) {
            s === void 0 && (s = {}), I === void 0 && (I = {}), s === void 0 ? s = null : il(s, "First parameter");
            var E = Wt(I, "Second parameter"), _ = nc(s, "First parameter");
            Ys(this);
            var tl = _.type;
            if (tl !== void 0)
              throw new RangeError("Invalid type is specified");
            var Wl = ut(E), Tl = $i(E, 1);
            Cc(this, _, Tl, Wl);
          }
          return Object.defineProperty(l.prototype, "locked", {
            /**
             * Returns whether or not the writable stream is locked to a writer.
             */
            get: function() {
              if (!vi(this))
                throw It("locked");
              return Qi(this);
            },
            enumerable: !1,
            configurable: !0
          }), l.prototype.abort = function(s) {
            return s === void 0 && (s = void 0), vi(this) ? Qi(this) ? e(new TypeError("Cannot abort a stream that already has a writer")) : ht(this, s) : e(It("abort"));
          }, l.prototype.close = function() {
            return vi(this) ? Qi(this) ? e(new TypeError("Cannot close a stream that already has a writer")) : Ii(this) ? e(new TypeError("Cannot close an already-closing stream")) : Ls(this) : e(It("close"));
          }, l.prototype.getWriter = function() {
            if (!vi(this))
              throw It("getWriter");
            return Is(this);
          }, l;
        }()
      );
      Object.defineProperties(zi.prototype, {
        abort: { enumerable: !0 },
        close: { enumerable: !0 },
        getWriter: { enumerable: !0 },
        locked: { enumerable: !0 }
      }), V(zi.prototype.abort, "abort"), V(zi.prototype.close, "close"), V(zi.prototype.getWriter, "getWriter"), typeof t.toStringTag == "symbol" && Object.defineProperty(zi.prototype, t.toStringTag, {
        value: "WritableStream",
        configurable: !0
      });
      function Is(l) {
        return new oi(l);
      }
      function Yc(l, s, I, E, _, tl) {
        _ === void 0 && (_ = 1), tl === void 0 && (tl = function() {
          return 1;
        });
        var Wl = Object.create(zi.prototype);
        Ys(Wl);
        var Tl = Object.create(Hi.prototype);
        return Ts(Wl, Tl, l, s, I, E, _, tl), Wl;
      }
      function Ys(l) {
        l._state = "writable", l._storedError = void 0, l._writer = void 0, l._writableStreamController = void 0, l._writeRequests = new B(), l._inFlightWriteRequest = void 0, l._closeRequest = void 0, l._inFlightCloseRequest = void 0, l._pendingAbortRequest = void 0, l._backpressure = !1;
      }
      function vi(l) {
        return !x(l) || !Object.prototype.hasOwnProperty.call(l, "_writableStreamController") ? !1 : l instanceof zi;
      }
      function Qi(l) {
        return l._writer !== void 0;
      }
      function ht(l, s) {
        var I;
        if (l._state === "closed" || l._state === "errored")
          return u(void 0);
        l._writableStreamController._abortReason = s, (I = l._writableStreamController._abortController) === null || I === void 0 || I.abort(s);
        var E = l._state;
        if (E === "closed" || E === "errored")
          return u(void 0);
        if (l._pendingAbortRequest !== void 0)
          return l._pendingAbortRequest._promise;
        var _ = !1;
        E === "erroring" && (_ = !0, s = void 0);
        var tl = J(function(Wl, Tl) {
          l._pendingAbortRequest = {
            _promise: void 0,
            _resolve: Wl,
            _reject: Tl,
            _reason: s,
            _wasAlreadyErroring: _
          };
        });
        return l._pendingAbortRequest._promise = tl, _ || Ut(l, s), tl;
      }
      function Ls(l) {
        var s = l._state;
        if (s === "closed" || s === "errored")
          return e(new TypeError("The stream (in ".concat(s, " state) is not in the writable state and cannot be closed")));
        var I = J(function(_, tl) {
          var Wl = {
            _resolve: _,
            _reject: tl
          };
          l._closeRequest = Wl;
        }), E = l._writer;
        return E !== void 0 && l._backpressure && s === "writable" && Pt(E), Dc(l._writableStreamController), I;
      }
      function Lc(l) {
        var s = J(function(I, E) {
          var _ = {
            _resolve: I,
            _reject: E
          };
          l._writeRequests.push(_);
        });
        return s;
      }
      function Ft(l, s) {
        var I = l._state;
        if (I === "writable") {
          Ut(l, s);
          return;
        }
        Ot(l);
      }
      function Ut(l, s) {
        var I = l._writableStreamController;
        l._state = "erroring", l._storedError = s;
        var E = l._writer;
        E !== void 0 && ys(E, s), !pc(l) && I._started && Ot(l);
      }
      function Ot(l) {
        l._state = "errored", l._writableStreamController[H]();
        var s = l._storedError;
        if (l._writeRequests.forEach(function(_) {
          _._reject(s);
        }), l._writeRequests = new B(), l._pendingAbortRequest === void 0) {
          Gt(l);
          return;
        }
        var I = l._pendingAbortRequest;
        if (l._pendingAbortRequest = void 0, I._wasAlreadyErroring) {
          I._reject(s), Gt(l);
          return;
        }
        var E = l._writableStreamController[A](I._reason);
        d(E, function() {
          return I._resolve(), Gt(l), null;
        }, function(_) {
          return I._reject(_), Gt(l), null;
        });
      }
      function Xc(l) {
        l._inFlightWriteRequest._resolve(void 0), l._inFlightWriteRequest = void 0;
      }
      function yc(l, s) {
        l._inFlightWriteRequest._reject(s), l._inFlightWriteRequest = void 0, Ft(l, s);
      }
      function oc(l) {
        l._inFlightCloseRequest._resolve(void 0), l._inFlightCloseRequest = void 0;
        var s = l._state;
        s === "erroring" && (l._storedError = void 0, l._pendingAbortRequest !== void 0 && (l._pendingAbortRequest._resolve(), l._pendingAbortRequest = void 0)), l._state = "closed";
        var I = l._writer;
        I !== void 0 && Rs(I);
      }
      function Vc(l, s) {
        l._inFlightCloseRequest._reject(s), l._inFlightCloseRequest = void 0, l._pendingAbortRequest !== void 0 && (l._pendingAbortRequest._reject(s), l._pendingAbortRequest = void 0), Ft(l, s);
      }
      function Ii(l) {
        return !(l._closeRequest === void 0 && l._inFlightCloseRequest === void 0);
      }
      function pc(l) {
        return !(l._inFlightWriteRequest === void 0 && l._inFlightCloseRequest === void 0);
      }
      function Tc(l) {
        l._inFlightCloseRequest = l._closeRequest, l._closeRequest = void 0;
      }
      function wc(l) {
        l._inFlightWriteRequest = l._writeRequests.shift();
      }
      function Gt(l) {
        l._closeRequest !== void 0 && (l._closeRequest._reject(l._storedError), l._closeRequest = void 0);
        var s = l._writer;
        s !== void 0 && Qt(s, l._storedError);
      }
      function gt(l, s) {
        var I = l._writer;
        I !== void 0 && s !== l._backpressure && (s ? Oc(I) : Pt(I)), l._backpressure = s;
      }
      var oi = (
        /** @class */
        function() {
          function l(s) {
            if (dl(s, 1, "WritableStreamDefaultWriter"), Ms(s, "First parameter"), Qi(s))
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            this._ownerWritableStream = s, s._writer = this;
            var I = s._state;
            if (I === "writable")
              !Ii(s) && s._backpressure ? Lt(this) : Ss(this), Yt(this);
            else if (I === "erroring")
              Ht(this, s._storedError), Yt(this);
            else if (I === "closed")
              Ss(this), Fc(this);
            else {
              var E = s._storedError;
              Ht(this, E), rs(this, E);
            }
          }
          return Object.defineProperty(l.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
             * the writer’s lock is released before the stream finishes closing.
             */
            get: function() {
              return Fi(this) ? this._closedPromise : e(Ui("closed"));
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(l.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.
             * A producer can use this information to determine the right amount of data to write.
             *
             * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
             * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
             * the writer’s lock is released.
             */
            get: function() {
              if (!Fi(this))
                throw Ui("desiredSize");
              if (this._ownerWritableStream === void 0)
                throw it("desiredSize");
              return Sc(this);
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(l.prototype, "ready", {
            /**
             * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions
             * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
             * back to zero or below, the getter will return a new promise that stays pending until the next transition.
             *
             * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become
             * rejected.
             */
            get: function() {
              return Fi(this) ? this._readyPromise : e(Ui("ready"));
            },
            enumerable: !1,
            configurable: !0
          }), l.prototype.abort = function(s) {
            return s === void 0 && (s = void 0), Fi(this) ? this._ownerWritableStream === void 0 ? e(it("abort")) : zc(this, s) : e(Ui("abort"));
          }, l.prototype.close = function() {
            if (!Fi(this))
              return e(Ui("close"));
            var s = this._ownerWritableStream;
            return s === void 0 ? e(it("close")) : Ii(s) ? e(new TypeError("Cannot close an already-closing stream")) : Xs(this);
          }, l.prototype.releaseLock = function() {
            if (!Fi(this))
              throw Ui("releaseLock");
            var s = this._ownerWritableStream;
            s !== void 0 && os(this);
          }, l.prototype.write = function(s) {
            return s === void 0 && (s = void 0), Fi(this) ? this._ownerWritableStream === void 0 ? e(it("write to")) : Vs(this, s) : e(Ui("write"));
          }, l;
        }()
      );
      Object.defineProperties(oi.prototype, {
        abort: { enumerable: !0 },
        close: { enumerable: !0 },
        releaseLock: { enumerable: !0 },
        write: { enumerable: !0 },
        closed: { enumerable: !0 },
        desiredSize: { enumerable: !0 },
        ready: { enumerable: !0 }
      }), V(oi.prototype.abort, "abort"), V(oi.prototype.close, "close"), V(oi.prototype.releaseLock, "releaseLock"), V(oi.prototype.write, "write"), typeof t.toStringTag == "symbol" && Object.defineProperty(oi.prototype, t.toStringTag, {
        value: "WritableStreamDefaultWriter",
        configurable: !0
      });
      function Fi(l) {
        return !x(l) || !Object.prototype.hasOwnProperty.call(l, "_ownerWritableStream") ? !1 : l instanceof oi;
      }
      function zc(l, s) {
        var I = l._ownerWritableStream;
        return ht(I, s);
      }
      function Xs(l) {
        var s = l._ownerWritableStream;
        return Ls(s);
      }
      function rc(l) {
        var s = l._ownerWritableStream, I = s._state;
        return Ii(s) || I === "closed" ? u(void 0) : I === "errored" ? e(s._storedError) : Xs(l);
      }
      function Rc(l, s) {
        l._closedPromiseState === "pending" ? Qt(l, s) : Uc(l, s);
      }
      function ys(l, s) {
        l._readyPromiseState === "pending" ? Cs(l, s) : gc(l, s);
      }
      function Sc(l) {
        var s = l._ownerWritableStream, I = s._state;
        return I === "errored" || I === "erroring" ? null : I === "closed" ? 0 : ws(s._writableStreamController);
      }
      function os(l) {
        var s = l._ownerWritableStream, I = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
        ys(l, I), Rc(l, I), s._writer = void 0, l._ownerWritableStream = void 0;
      }
      function Vs(l, s) {
        var I = l._ownerWritableStream, E = I._writableStreamController, _ = xc(E, s);
        if (I !== l._ownerWritableStream)
          return e(it("write to"));
        var tl = I._state;
        if (tl === "errored")
          return e(I._storedError);
        if (Ii(I) || tl === "closed")
          return e(new TypeError("The stream is closing or closed and cannot be written to"));
        if (tl === "erroring")
          return e(I._storedError);
        var Wl = Lc(I);
        return Jc(E, s, _), Wl;
      }
      var ps = {}, Hi = (
        /** @class */
        function() {
          function l() {
            throw new TypeError("Illegal constructor");
          }
          return Object.defineProperty(l.prototype, "abortReason", {
            /**
             * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
             *
             * @deprecated
             *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
             *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
             */
            get: function() {
              if (!Kt(this))
                throw vt("abortReason");
              return this._abortReason;
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(l.prototype, "signal", {
            /**
             * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
             */
            get: function() {
              if (!Kt(this))
                throw vt("signal");
              if (this._abortController === void 0)
                throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
              return this._abortController.signal;
            },
            enumerable: !1,
            configurable: !0
          }), l.prototype.error = function(s) {
            if (s === void 0 && (s = void 0), !Kt(this))
              throw vt("error");
            var I = this._controlledWritableStream._state;
            I === "writable" && zs(this, s);
          }, l.prototype[A] = function(s) {
            var I = this._abortAlgorithm(s);
            return Nt(this), I;
          }, l.prototype[H] = function() {
            ei(this);
          }, l;
        }()
      );
      Object.defineProperties(Hi.prototype, {
        abortReason: { enumerable: !0 },
        signal: { enumerable: !0 },
        error: { enumerable: !0 }
      }), typeof t.toStringTag == "symbol" && Object.defineProperty(Hi.prototype, t.toStringTag, {
        value: "WritableStreamDefaultController",
        configurable: !0
      });
      function Kt(l) {
        return !x(l) || !Object.prototype.hasOwnProperty.call(l, "_controlledWritableStream") ? !1 : l instanceof Hi;
      }
      function Ts(l, s, I, E, _, tl, Wl, Tl) {
        s._controlledWritableStream = l, l._writableStreamController = s, s._queue = void 0, s._queueTotalSize = void 0, ei(s), s._abortReason = void 0, s._abortController = Ic(), s._started = !1, s._strategySizeAlgorithm = Tl, s._strategyHWM = Wl, s._writeAlgorithm = E, s._closeAlgorithm = _, s._abortAlgorithm = tl;
        var Rl = Et(s);
        gt(l, Rl);
        var pl = I(), Ul = u(pl);
        d(Ul, function() {
          return s._started = !0, Mt(s), null;
        }, function(vl) {
          return s._started = !0, Ft(l, vl), null;
        });
      }
      function Cc(l, s, I, E) {
        var _ = Object.create(Hi.prototype), tl, Wl, Tl, Rl;
        s.start !== void 0 ? tl = function() {
          return s.start(_);
        } : tl = function() {
        }, s.write !== void 0 ? Wl = function(pl) {
          return s.write(pl, _);
        } : Wl = function() {
          return u(void 0);
        }, s.close !== void 0 ? Tl = function() {
          return s.close();
        } : Tl = function() {
          return u(void 0);
        }, s.abort !== void 0 ? Rl = function(pl) {
          return s.abort(pl);
        } : Rl = function() {
          return u(void 0);
        }, Ts(l, _, tl, Wl, Tl, Rl, I, E);
      }
      function Nt(l) {
        l._writeAlgorithm = void 0, l._closeAlgorithm = void 0, l._abortAlgorithm = void 0, l._strategySizeAlgorithm = void 0;
      }
      function Dc(l) {
        Gi(l, ps, 0), Mt(l);
      }
      function xc(l, s) {
        try {
          return l._strategySizeAlgorithm(s);
        } catch (I) {
          return lt(l, I), 1;
        }
      }
      function ws(l) {
        return l._strategyHWM - l._queueTotalSize;
      }
      function Jc(l, s, I) {
        try {
          Gi(l, s, I);
        } catch (tl) {
          lt(l, tl);
          return;
        }
        var E = l._controlledWritableStream;
        if (!Ii(E) && E._state === "writable") {
          var _ = Et(l);
          gt(E, _);
        }
        Mt(l);
      }
      function Mt(l) {
        var s = l._controlledWritableStream;
        if (l._started && s._inFlightWriteRequest === void 0) {
          var I = s._state;
          if (I === "erroring") {
            Ot(s);
            return;
          }
          if (l._queue.length !== 0) {
            var E = Ti(l);
            E === ps ? kc(l) : jc(l, E);
          }
        }
      }
      function lt(l, s) {
        l._controlledWritableStream._state === "writable" && zs(l, s);
      }
      function kc(l) {
        var s = l._controlledWritableStream;
        Tc(s), li(l);
        var I = l._closeAlgorithm();
        Nt(l), d(I, function() {
          return oc(s), null;
        }, function(E) {
          return Vc(s, E), null;
        });
      }
      function jc(l, s) {
        var I = l._controlledWritableStream;
        wc(I);
        var E = l._writeAlgorithm(s);
        d(E, function() {
          Xc(I);
          var _ = I._state;
          if (li(l), !Ii(I) && _ === "writable") {
            var tl = Et(l);
            gt(I, tl);
          }
          return Mt(l), null;
        }, function(_) {
          return I._state === "writable" && Nt(l), yc(I, _), null;
        });
      }
      function Et(l) {
        var s = ws(l);
        return s <= 0;
      }
      function zs(l, s) {
        var I = l._controlledWritableStream;
        Nt(l), Ut(I, s);
      }
      function It(l) {
        return new TypeError("WritableStream.prototype.".concat(l, " can only be used on a WritableStream"));
      }
      function vt(l) {
        return new TypeError("WritableStreamDefaultController.prototype.".concat(l, " can only be used on a WritableStreamDefaultController"));
      }
      function Ui(l) {
        return new TypeError("WritableStreamDefaultWriter.prototype.".concat(l, " can only be used on a WritableStreamDefaultWriter"));
      }
      function it(l) {
        return new TypeError("Cannot " + l + " a stream using a released writer");
      }
      function Yt(l) {
        l._closedPromise = J(function(s, I) {
          l._closedPromise_resolve = s, l._closedPromise_reject = I, l._closedPromiseState = "pending";
        });
      }
      function rs(l, s) {
        Yt(l), Qt(l, s);
      }
      function Fc(l) {
        Yt(l), Rs(l);
      }
      function Qt(l, s) {
        l._closedPromise_reject !== void 0 && (r(l._closedPromise), l._closedPromise_reject(s), l._closedPromise_resolve = void 0, l._closedPromise_reject = void 0, l._closedPromiseState = "rejected");
      }
      function Uc(l, s) {
        rs(l, s);
      }
      function Rs(l) {
        l._closedPromise_resolve !== void 0 && (l._closedPromise_resolve(void 0), l._closedPromise_resolve = void 0, l._closedPromise_reject = void 0, l._closedPromiseState = "resolved");
      }
      function Lt(l) {
        l._readyPromise = J(function(s, I) {
          l._readyPromise_resolve = s, l._readyPromise_reject = I;
        }), l._readyPromiseState = "pending";
      }
      function Ht(l, s) {
        Lt(l), Cs(l, s);
      }
      function Ss(l) {
        Lt(l), Pt(l);
      }
      function Cs(l, s) {
        l._readyPromise_reject !== void 0 && (r(l._readyPromise), l._readyPromise_reject(s), l._readyPromise_resolve = void 0, l._readyPromise_reject = void 0, l._readyPromiseState = "rejected");
      }
      function Oc(l) {
        Lt(l);
      }
      function gc(l, s) {
        Ht(l, s);
      }
      function Pt(l) {
        l._readyPromise_resolve !== void 0 && (l._readyPromise_resolve(void 0), l._readyPromise_resolve = void 0, l._readyPromise_reject = void 0, l._readyPromiseState = "fulfilled");
      }
      function Kc() {
        if (typeof globalThis < "u")
          return globalThis;
        if (typeof self < "u")
          return self;
        if (typeof commonjsGlobal < "u")
          return commonjsGlobal;
      }
      var Bt = Kc();
      function Ec(l) {
        if (!(typeof l == "function" || typeof l == "object") || l.name !== "DOMException")
          return !1;
        try {
          return new l(), !0;
        } catch {
          return !1;
        }
      }
      function vc() {
        var l = Bt == null ? void 0 : Bt.DOMException;
        return Ec(l) ? l : void 0;
      }
      function Qc() {
        var l = function(I, E) {
          this.message = I || "", this.name = E || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
        };
        return V(l, "DOMException"), l.prototype = Object.create(Error.prototype), Object.defineProperty(l.prototype, "constructor", { value: l, writable: !0, configurable: !0 }), l;
      }
      var Hc = vc() || Qc();
      function Ds(l, s, I, E, _, tl) {
        var Wl = Vl(l), Tl = Is(s);
        l._disturbed = !0;
        var Rl = !1, pl = u(void 0);
        return J(function(Ul, vl) {
          var Ql;
          if (tl !== void 0) {
            if (Ql = function() {
              var gl = tl.reason !== void 0 ? tl.reason : new Hc("Aborted", "AbortError"), _l = [];
              E || _l.push(function() {
                return s._state === "writable" ? ht(s, gl) : u(void 0);
              }), _ || _l.push(function() {
                return l._state === "readable" ? Mi(l, gl) : u(void 0);
              }), ui(function() {
                return Promise.all(_l.map(function(ti) {
                  return ti();
                }));
              }, !0, gl);
            }, tl.aborted) {
              Ql();
              return;
            }
            tl.addEventListener("abort", Ql);
          }
          function di() {
            return J(function(gl, _l) {
              function ti(Xi) {
                Xi ? gl() : m(ni(), ti, _l);
              }
              ti(!1);
            });
          }
          function ni() {
            return Rl ? u(!0) : m(Tl._readyPromise, function() {
              return J(function(gl, _l) {
                cl(Wl, {
                  _chunkSteps: function(ti) {
                    pl = m(Vs(Tl, ti), void 0, M), gl(!1);
                  },
                  _closeSteps: function() {
                    return gl(!0);
                  },
                  _errorSteps: _l
                });
              });
            });
          }
          if (bi(l, Wl._closedPromise, function(gl) {
            return E ? pi(!0, gl) : ui(function() {
              return ht(s, gl);
            }, !0, gl), null;
          }), bi(s, Tl._closedPromise, function(gl) {
            return _ ? pi(!0, gl) : ui(function() {
              return Mi(l, gl);
            }, !0, gl), null;
          }), Li(l, Wl._closedPromise, function() {
            return I ? pi() : ui(function() {
              return rc(Tl);
            }), null;
          }), Ii(s) || s._state === "closed") {
            var hi = new TypeError("the destination writable stream closed before all data could be piped to it");
            _ ? pi(!0, hi) : ui(function() {
              return Mi(l, hi);
            }, !0, hi);
          }
          r(di());
          function Yi() {
            var gl = pl;
            return m(pl, function() {
              return gl !== pl ? Yi() : void 0;
            });
          }
          function bi(gl, _l, ti) {
            gl._state === "errored" ? ti(gl._storedError) : N(_l, ti);
          }
          function Li(gl, _l, ti) {
            gl._state === "closed" ? ti() : b(_l, ti);
          }
          function ui(gl, _l, ti) {
            if (Rl)
              return;
            Rl = !0, s._state === "writable" && !Ii(s) ? b(Yi(), Xi) : Xi();
            function Xi() {
              return d(gl(), function() {
                return ii(_l, ti);
              }, function(Ci) {
                return ii(!0, Ci);
              }), null;
            }
          }
          function pi(gl, _l) {
            Rl || (Rl = !0, s._state === "writable" && !Ii(s) ? b(Yi(), function() {
              return ii(gl, _l);
            }) : ii(gl, _l));
          }
          function ii(gl, _l) {
            return os(Tl), Ml(Wl), tl !== void 0 && tl.removeEventListener("abort", Ql), gl ? vl(_l) : Ul(void 0), null;
          }
        });
      }
      var Vi = (
        /** @class */
        function() {
          function l() {
            throw new TypeError("Illegal constructor");
          }
          return Object.defineProperty(l.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
             * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
             */
            get: function() {
              if (!Xt(this))
                throw ot("desiredSize");
              return ft(this);
            },
            enumerable: !1,
            configurable: !0
          }), l.prototype.close = function() {
            if (!Xt(this))
              throw ot("close");
            if (!Bi(this))
              throw new TypeError("The stream is not in a state that permits close");
            Oi(this);
          }, l.prototype.enqueue = function(s) {
            if (s === void 0 && (s = void 0), !Xt(this))
              throw ot("enqueue");
            if (!Bi(this))
              throw new TypeError("The stream is not in a state that permits enqueue");
            return Pi(this, s);
          }, l.prototype.error = function(s) {
            if (s === void 0 && (s = void 0), !Xt(this))
              throw ot("error");
            Ni(this, s);
          }, l.prototype[O] = function(s) {
            ei(this);
            var I = this._cancelAlgorithm(s);
            return yt(this), I;
          }, l.prototype[U] = function(s) {
            var I = this._controlledReadableStream;
            if (this._queue.length > 0) {
              var E = li(this);
              this._closeRequested && this._queue.length === 0 ? (yt(this), ct(I)) : tt(this), s._chunkSteps(E);
            } else
              Dl(I, s), tt(this);
          }, l.prototype[k] = function() {
          }, l;
        }()
      );
      Object.defineProperties(Vi.prototype, {
        close: { enumerable: !0 },
        enqueue: { enumerable: !0 },
        error: { enumerable: !0 },
        desiredSize: { enumerable: !0 }
      }), V(Vi.prototype.close, "close"), V(Vi.prototype.enqueue, "enqueue"), V(Vi.prototype.error, "error"), typeof t.toStringTag == "symbol" && Object.defineProperty(Vi.prototype, t.toStringTag, {
        value: "ReadableStreamDefaultController",
        configurable: !0
      });
      function Xt(l) {
        return !x(l) || !Object.prototype.hasOwnProperty.call(l, "_controlledReadableStream") ? !1 : l instanceof Vi;
      }
      function tt(l) {
        var s = xs(l);
        if (s) {
          if (l._pulling) {
            l._pullAgain = !0;
            return;
          }
          l._pulling = !0;
          var I = l._pullAlgorithm();
          d(I, function() {
            return l._pulling = !1, l._pullAgain && (l._pullAgain = !1, tt(l)), null;
          }, function(E) {
            return Ni(l, E), null;
          });
        }
      }
      function xs(l) {
        var s = l._controlledReadableStream;
        if (!Bi(l) || !l._started)
          return !1;
        if (Ri(s) && Hl(s) > 0)
          return !0;
        var I = ft(l);
        return I > 0;
      }
      function yt(l) {
        l._pullAlgorithm = void 0, l._cancelAlgorithm = void 0, l._strategySizeAlgorithm = void 0;
      }
      function Oi(l) {
        if (Bi(l)) {
          var s = l._controlledReadableStream;
          l._closeRequested = !0, l._queue.length === 0 && (yt(l), ct(s));
        }
      }
      function Pi(l, s) {
        if (Bi(l)) {
          var I = l._controlledReadableStream;
          if (Ri(I) && Hl(I) > 0)
            Xl(I, s, !1);
          else {
            var E = void 0;
            try {
              E = l._strategySizeAlgorithm(s);
            } catch (_) {
              throw Ni(l, _), _;
            }
            try {
              Gi(l, s, E);
            } catch (_) {
              throw Ni(l, _), _;
            }
          }
          tt(l);
        }
      }
      function Ni(l, s) {
        var I = l._controlledReadableStream;
        I._state === "readable" && (ei(l), yt(l), Fs(I, s));
      }
      function ft(l) {
        var s = l._controlledReadableStream._state;
        return s === "errored" ? null : s === "closed" ? 0 : l._strategyHWM - l._queueTotalSize;
      }
      function Pc(l) {
        return !xs(l);
      }
      function Bi(l) {
        var s = l._controlledReadableStream._state;
        return !l._closeRequested && s === "readable";
      }
      function Js(l, s, I, E, _, tl, Wl) {
        s._controlledReadableStream = l, s._queue = void 0, s._queueTotalSize = void 0, ei(s), s._started = !1, s._closeRequested = !1, s._pullAgain = !1, s._pulling = !1, s._strategySizeAlgorithm = Wl, s._strategyHWM = tl, s._pullAlgorithm = E, s._cancelAlgorithm = _, l._readableStreamController = s;
        var Tl = I();
        d(u(Tl), function() {
          return s._started = !0, tt(s), null;
        }, function(Rl) {
          return Ni(s, Rl), null;
        });
      }
      function Bc(l, s, I, E) {
        var _ = Object.create(Vi.prototype), tl, Wl, Tl;
        s.start !== void 0 ? tl = function() {
          return s.start(_);
        } : tl = function() {
        }, s.pull !== void 0 ? Wl = function() {
          return s.pull(_);
        } : Wl = function() {
          return u(void 0);
        }, s.cancel !== void 0 ? Tl = function(Rl) {
          return s.cancel(Rl);
        } : Tl = function() {
          return u(void 0);
        }, Js(l, _, tl, Wl, Tl, I, E);
      }
      function ot(l) {
        return new TypeError("ReadableStreamDefaultController.prototype.".concat(l, " can only be used on a ReadableStreamDefaultController"));
      }
      function fc(l, s) {
        return Ji(l._readableStreamController) ? _c(l) : Ac(l);
      }
      function Ac(l, s) {
        var I = Vl(l), E = !1, _ = !1, tl = !1, Wl = !1, Tl, Rl, pl, Ul, vl, Ql = J(function(bi) {
          vl = bi;
        });
        function di() {
          if (E)
            return _ = !0, u(void 0);
          E = !0;
          var bi = {
            _chunkSteps: function(Li) {
              j(function() {
                _ = !1;
                var ui = Li, pi = Li;
                tl || Pi(pl._readableStreamController, ui), Wl || Pi(Ul._readableStreamController, pi), E = !1, _ && di();
              });
            },
            _closeSteps: function() {
              E = !1, tl || Oi(pl._readableStreamController), Wl || Oi(Ul._readableStreamController), (!tl || !Wl) && vl(void 0);
            },
            _errorSteps: function() {
              E = !1;
            }
          };
          return cl(I, bi), u(void 0);
        }
        function ni(bi) {
          if (tl = !0, Tl = bi, Wl) {
            var Li = nl([Tl, Rl]), ui = Mi(l, Li);
            vl(ui);
          }
          return Ql;
        }
        function hi(bi) {
          if (Wl = !0, Rl = bi, tl) {
            var Li = nl([Tl, Rl]), ui = Mi(l, Li);
            vl(ui);
          }
          return Ql;
        }
        function Yi() {
        }
        return pl = st(Yi, di, ni), Ul = st(Yi, di, hi), N(I._closedPromise, function(bi) {
          return Ni(pl._readableStreamController, bi), Ni(Ul._readableStreamController, bi), (!tl || !Wl) && vl(void 0), null;
        }), [pl, Ul];
      }
      function _c(l) {
        var s = Vl(l), I = !1, E = !1, _ = !1, tl = !1, Wl = !1, Tl, Rl, pl, Ul, vl, Ql = J(function(ii) {
          vl = ii;
        });
        function di(ii) {
          N(ii._closedPromise, function(gl) {
            return ii !== s || (Wi(pl._readableStreamController, gl), Wi(Ul._readableStreamController, gl), (!tl || !Wl) && vl(void 0)), null;
          });
        }
        function ni() {
          ji(s) && (Ml(s), s = Vl(l), di(s));
          var ii = {
            _chunkSteps: function(gl) {
              j(function() {
                E = !1, _ = !1;
                var _l = gl, ti = gl;
                if (!tl && !Wl)
                  try {
                    ti = Zi(gl);
                  } catch (Xi) {
                    Wi(pl._readableStreamController, Xi), Wi(Ul._readableStreamController, Xi), vl(Mi(l, Xi));
                    return;
                  }
                tl || at(pl._readableStreamController, _l), Wl || at(Ul._readableStreamController, ti), I = !1, E ? Yi() : _ && bi();
              });
            },
            _closeSteps: function() {
              I = !1, tl || _i(pl._readableStreamController), Wl || _i(Ul._readableStreamController), pl._readableStreamController._pendingPullIntos.length > 0 && et(pl._readableStreamController, 0), Ul._readableStreamController._pendingPullIntos.length > 0 && et(Ul._readableStreamController, 0), (!tl || !Wl) && vl(void 0);
            },
            _errorSteps: function() {
              I = !1;
            }
          };
          cl(s, ii);
        }
        function hi(ii, gl) {
          ol(s) && (Ml(s), s = us(l), di(s));
          var _l = gl ? Ul : pl, ti = gl ? pl : Ul, Xi = {
            _chunkSteps: function(Ci) {
              j(function() {
                E = !1, _ = !1;
                var Ai = gl ? Wl : tl, dt = gl ? tl : Wl;
                if (dt)
                  Ai || mt(_l._readableStreamController, Ci);
                else {
                  var _s = void 0;
                  try {
                    _s = Zi(Ci);
                  } catch (ls) {
                    Wi(_l._readableStreamController, ls), Wi(ti._readableStreamController, ls), vl(Mi(l, ls));
                    return;
                  }
                  Ai || mt(_l._readableStreamController, Ci), at(ti._readableStreamController, _s);
                }
                I = !1, E ? Yi() : _ && bi();
              });
            },
            _closeSteps: function(Ci) {
              I = !1;
              var Ai = gl ? Wl : tl, dt = gl ? tl : Wl;
              Ai || _i(_l._readableStreamController), dt || _i(ti._readableStreamController), Ci !== void 0 && (Ai || mt(_l._readableStreamController, Ci), !dt && ti._readableStreamController._pendingPullIntos.length > 0 && et(ti._readableStreamController, 0)), (!Ai || !dt) && vl(void 0);
            },
            _errorSteps: function() {
              I = !1;
            }
          };
          Gs(s, ii, 1, Xi);
        }
        function Yi() {
          if (I)
            return E = !0, u(void 0);
          I = !0;
          var ii = Jt(pl._readableStreamController);
          return ii === null ? ni() : hi(ii._view, !1), u(void 0);
        }
        function bi() {
          if (I)
            return _ = !0, u(void 0);
          I = !0;
          var ii = Jt(Ul._readableStreamController);
          return ii === null ? ni() : hi(ii._view, !0), u(void 0);
        }
        function Li(ii) {
          if (tl = !0, Tl = ii, Wl) {
            var gl = nl([Tl, Rl]), _l = Mi(l, gl);
            vl(_l);
          }
          return Ql;
        }
        function ui(ii) {
          if (Wl = !0, Rl = ii, tl) {
            var gl = nl([Tl, Rl]), _l = Mi(l, gl);
            vl(_l);
          }
          return Ql;
        }
        function pi() {
        }
        return pl = js(pi, Yi, Li), Ul = js(pi, bi, ui), di(s), [pl, Ul];
      }
      function qc(l) {
        return x(l) && typeof l.getReader < "u";
      }
      function $c(l) {
        return qc(l) ? id(l.getReader()) : ld(l);
      }
      function ld(l) {
        var s, I = Ll(l, "async"), E = M;
        function _() {
          var Wl;
          try {
            Wl = rl(I);
          } catch (Rl) {
            return e(Rl);
          }
          var Tl = u(Wl);
          return G(Tl, function(Rl) {
            if (!x(Rl))
              throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");
            var pl = Fl(Rl);
            if (pl)
              Oi(s._readableStreamController);
            else {
              var Ul = Kl(Rl);
              Pi(s._readableStreamController, Ul);
            }
          });
        }
        function tl(Wl) {
          var Tl = I.iterator, Rl;
          try {
            Rl = jl(Tl, "return");
          } catch (vl) {
            return e(vl);
          }
          if (Rl === void 0)
            return u(void 0);
          var pl;
          try {
            pl = D(Rl, Tl, [Wl]);
          } catch (vl) {
            return e(vl);
          }
          var Ul = u(pl);
          return G(Ul, function(vl) {
            if (!x(vl))
              throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");
          });
        }
        return s = st(E, _, tl, 0), s;
      }
      function id(l) {
        var s, I = M;
        function E() {
          var tl;
          try {
            tl = l.read();
          } catch (Wl) {
            return e(Wl);
          }
          return G(tl, function(Wl) {
            if (!x(Wl))
              throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");
            if (Wl.done)
              Oi(s._readableStreamController);
            else {
              var Tl = Wl.value;
              Pi(s._readableStreamController, Tl);
            }
          });
        }
        function _(tl) {
          try {
            return u(l.cancel(tl));
          } catch (Wl) {
            return e(Wl);
          }
        }
        return s = st(I, E, _, 0), s;
      }
      function td(l, s) {
        F(l, s);
        var I = l, E = I == null ? void 0 : I.autoAllocateChunkSize, _ = I == null ? void 0 : I.cancel, tl = I == null ? void 0 : I.pull, Wl = I == null ? void 0 : I.start, Tl = I == null ? void 0 : I.type;
        return {
          autoAllocateChunkSize: E === void 0 ? void 0 : Yl(E, "".concat(s, " has member 'autoAllocateChunkSize' that")),
          cancel: _ === void 0 ? void 0 : sd(_, I, "".concat(s, " has member 'cancel' that")),
          pull: tl === void 0 ? void 0 : cd(tl, I, "".concat(s, " has member 'pull' that")),
          start: Wl === void 0 ? void 0 : dd(Wl, I, "".concat(s, " has member 'start' that")),
          type: Tl === void 0 ? void 0 : Zd(Tl, "".concat(s, " has member 'type' that"))
        };
      }
      function sd(l, s, I) {
        return v(l, I), function(E) {
          return f(l, s, [E]);
        };
      }
      function cd(l, s, I) {
        return v(l, I), function(E) {
          return f(l, s, [E]);
        };
      }
      function dd(l, s, I) {
        return v(l, I), function(E) {
          return D(l, s, [E]);
        };
      }
      function Zd(l, s) {
        if (l = "".concat(l), l !== "bytes")
          throw new TypeError("".concat(s, " '").concat(l, "' is not a valid enumeration value for ReadableStreamType"));
        return l;
      }
      function bd(l, s) {
        F(l, s);
        var I = l == null ? void 0 : l.preventCancel;
        return { preventCancel: !!I };
      }
      function ks(l, s) {
        F(l, s);
        var I = l == null ? void 0 : l.preventAbort, E = l == null ? void 0 : l.preventCancel, _ = l == null ? void 0 : l.preventClose, tl = l == null ? void 0 : l.signal;
        return tl !== void 0 && ad(tl, "".concat(s, " has member 'signal' that")), {
          preventAbort: !!I,
          preventCancel: !!E,
          preventClose: !!_,
          signal: tl
        };
      }
      function ad(l, s) {
        if (!Nc(l))
          throw new TypeError("".concat(s, " is not an AbortSignal."));
      }
      function ed(l, s) {
        F(l, s);
        var I = l == null ? void 0 : l.readable;
        el(I, "readable", "ReadableWritablePair"), yl(I, "".concat(s, " has member 'readable' that"));
        var E = l == null ? void 0 : l.writable;
        return el(E, "writable", "ReadableWritablePair"), Ms(E, "".concat(s, " has member 'writable' that")), { readable: I, writable: E };
      }
      var ai = (
        /** @class */
        function() {
          function l(s, I) {
            s === void 0 && (s = {}), I === void 0 && (I = {}), s === void 0 ? s = null : il(s, "First parameter");
            var E = Wt(I, "Second parameter"), _ = td(s, "First parameter");
            if (At(this), _.type === "bytes") {
              if (E.size !== void 0)
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              var tl = $i(E, 0);
              sc(this, _, tl);
            } else {
              var Wl = ut(E), tl = $i(E, 1);
              Bc(this, _, tl, Wl);
            }
          }
          return Object.defineProperty(l.prototype, "locked", {
            /**
             * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
             */
            get: function() {
              if (!ri(this))
                throw gi("locked");
              return Ri(this);
            },
            enumerable: !1,
            configurable: !0
          }), l.prototype.cancel = function(s) {
            return s === void 0 && (s = void 0), ri(this) ? Ri(this) ? e(new TypeError("Cannot cancel a stream that already has a reader")) : Mi(this, s) : e(gi("cancel"));
          }, l.prototype.getReader = function(s) {
            if (s === void 0 && (s = void 0), !ri(this))
              throw gi("getReader");
            var I = dc(s, "First parameter");
            return I.mode === void 0 ? Vl(this) : us(this);
          }, l.prototype.pipeThrough = function(s, I) {
            if (I === void 0 && (I = {}), !ri(this))
              throw gi("pipeThrough");
            dl(s, 1, "pipeThrough");
            var E = ed(s, "First parameter"), _ = ks(I, "Second parameter");
            if (Ri(this))
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            if (Qi(E.writable))
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            var tl = Ds(this, E.writable, _.preventClose, _.preventAbort, _.preventCancel, _.signal);
            return r(tl), E.readable;
          }, l.prototype.pipeTo = function(s, I) {
            if (I === void 0 && (I = {}), !ri(this))
              return e(gi("pipeTo"));
            if (s === void 0)
              return e("Parameter 1 is required in 'pipeTo'.");
            if (!vi(s))
              return e(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
            var E;
            try {
              E = ks(I, "Second parameter");
            } catch (_) {
              return e(_);
            }
            return Ri(this) ? e(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : Qi(s) ? e(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : Ds(this, s, E.preventClose, E.preventAbort, E.preventCancel, E.signal);
          }, l.prototype.tee = function() {
            if (!ri(this))
              throw gi("tee");
            var s = fc(this);
            return nl(s);
          }, l.prototype.values = function(s) {
            if (s === void 0 && (s = void 0), !ri(this))
              throw gi("values");
            var I = bd(s, "First parameter");
            return si(this, I.preventCancel);
          }, l.prototype[Zl] = function(s) {
            return this.values(s);
          }, l.from = function(s) {
            return $c(s);
          }, l;
        }()
      );
      Object.defineProperties(ai, {
        from: { enumerable: !0 }
      }), Object.defineProperties(ai.prototype, {
        cancel: { enumerable: !0 },
        getReader: { enumerable: !0 },
        pipeThrough: { enumerable: !0 },
        pipeTo: { enumerable: !0 },
        tee: { enumerable: !0 },
        values: { enumerable: !0 },
        locked: { enumerable: !0 }
      }), V(ai.from, "from"), V(ai.prototype.cancel, "cancel"), V(ai.prototype.getReader, "getReader"), V(ai.prototype.pipeThrough, "pipeThrough"), V(ai.prototype.pipeTo, "pipeTo"), V(ai.prototype.tee, "tee"), V(ai.prototype.values, "values"), typeof t.toStringTag == "symbol" && Object.defineProperty(ai.prototype, t.toStringTag, {
        value: "ReadableStream",
        configurable: !0
      }), Object.defineProperty(ai.prototype, Zl, {
        value: ai.prototype.values,
        writable: !0,
        configurable: !0
      });
      function st(l, s, I, E, _) {
        E === void 0 && (E = 1), _ === void 0 && (_ = function() {
          return 1;
        });
        var tl = Object.create(ai.prototype);
        At(tl);
        var Wl = Object.create(Vi.prototype);
        return Js(tl, Wl, l, s, I, E, _), tl;
      }
      function js(l, s, I) {
        var E = Object.create(ai.prototype);
        At(E);
        var _ = Object.create(yi.prototype);
        return ns(E, _, l, s, I, 0, void 0), E;
      }
      function At(l) {
        l._state = "readable", l._reader = void 0, l._storedError = void 0, l._disturbed = !1;
      }
      function ri(l) {
        return !x(l) || !Object.prototype.hasOwnProperty.call(l, "_readableStreamController") ? !1 : l instanceof ai;
      }
      function Ri(l) {
        return l._reader !== void 0;
      }
      function Mi(l, s) {
        if (l._disturbed = !0, l._state === "closed")
          return u(void 0);
        if (l._state === "errored")
          return e(l._storedError);
        ct(l);
        var I = l._reader;
        if (I !== void 0 && ji(I)) {
          var E = I._readIntoRequests;
          I._readIntoRequests = new B(), E.forEach(function(tl) {
            tl._closeSteps(void 0);
          });
        }
        var _ = l._readableStreamController[O](s);
        return G(_, M);
      }
      function ct(l) {
        l._state = "closed";
        var s = l._reader;
        if (s !== void 0 && (a(s), ol(s))) {
          var I = s._readRequests;
          s._readRequests = new B(), I.forEach(function(E) {
            E._closeSteps();
          });
        }
      }
      function Fs(l, s) {
        l._state = "errored", l._storedError = s;
        var I = l._reader;
        I !== void 0 && (g(I, s), ol(I) ? Jl(I, s) : Ns(I, s));
      }
      function gi(l) {
        return new TypeError("ReadableStream.prototype.".concat(l, " can only be used on a ReadableStream"));
      }
      function Us(l, s) {
        F(l, s);
        var I = l == null ? void 0 : l.highWaterMark;
        return el(I, "highWaterMark", "QueuingStrategyInit"), {
          highWaterMark: bl(I)
        };
      }
      var Os = function(l) {
        return l.byteLength;
      };
      V(Os, "size");
      var Vt = (
        /** @class */
        function() {
          function l(s) {
            dl(s, 1, "ByteLengthQueuingStrategy"), s = Us(s, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = s.highWaterMark;
          }
          return Object.defineProperty(l.prototype, "highWaterMark", {
            /**
             * Returns the high water mark provided to the constructor.
             */
            get: function() {
              if (!Ks(this))
                throw gs("highWaterMark");
              return this._byteLengthQueuingStrategyHighWaterMark;
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(l.prototype, "size", {
            /**
             * Measures the size of `chunk` by returning the value of its `byteLength` property.
             */
            get: function() {
              if (!Ks(this))
                throw gs("size");
              return Os;
            },
            enumerable: !1,
            configurable: !0
          }), l;
        }()
      );
      Object.defineProperties(Vt.prototype, {
        highWaterMark: { enumerable: !0 },
        size: { enumerable: !0 }
      }), typeof t.toStringTag == "symbol" && Object.defineProperty(Vt.prototype, t.toStringTag, {
        value: "ByteLengthQueuingStrategy",
        configurable: !0
      });
      function gs(l) {
        return new TypeError("ByteLengthQueuingStrategy.prototype.".concat(l, " can only be used on a ByteLengthQueuingStrategy"));
      }
      function Ks(l) {
        return !x(l) || !Object.prototype.hasOwnProperty.call(l, "_byteLengthQueuingStrategyHighWaterMark") ? !1 : l instanceof Vt;
      }
      var Es = function() {
        return 1;
      };
      V(Es, "size");
      var pt = (
        /** @class */
        function() {
          function l(s) {
            dl(s, 1, "CountQueuingStrategy"), s = Us(s, "First parameter"), this._countQueuingStrategyHighWaterMark = s.highWaterMark;
          }
          return Object.defineProperty(l.prototype, "highWaterMark", {
            /**
             * Returns the high water mark provided to the constructor.
             */
            get: function() {
              if (!Qs(this))
                throw vs("highWaterMark");
              return this._countQueuingStrategyHighWaterMark;
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(l.prototype, "size", {
            /**
             * Measures the size of `chunk` by always returning 1.
             * This ensures that the total queue size is a count of the number of chunks in the queue.
             */
            get: function() {
              if (!Qs(this))
                throw vs("size");
              return Es;
            },
            enumerable: !1,
            configurable: !0
          }), l;
        }()
      );
      Object.defineProperties(pt.prototype, {
        highWaterMark: { enumerable: !0 },
        size: { enumerable: !0 }
      }), typeof t.toStringTag == "symbol" && Object.defineProperty(pt.prototype, t.toStringTag, {
        value: "CountQueuingStrategy",
        configurable: !0
      });
      function vs(l) {
        return new TypeError("CountQueuingStrategy.prototype.".concat(l, " can only be used on a CountQueuingStrategy"));
      }
      function Qs(l) {
        return !x(l) || !Object.prototype.hasOwnProperty.call(l, "_countQueuingStrategyHighWaterMark") ? !1 : l instanceof pt;
      }
      function md(l, s) {
        F(l, s);
        var I = l == null ? void 0 : l.cancel, E = l == null ? void 0 : l.flush, _ = l == null ? void 0 : l.readableType, tl = l == null ? void 0 : l.start, Wl = l == null ? void 0 : l.transform, Tl = l == null ? void 0 : l.writableType;
        return {
          cancel: I === void 0 ? void 0 : hd(I, l, "".concat(s, " has member 'cancel' that")),
          flush: E === void 0 ? void 0 : nd(E, l, "".concat(s, " has member 'flush' that")),
          readableType: _,
          start: tl === void 0 ? void 0 : ud(tl, l, "".concat(s, " has member 'start' that")),
          transform: Wl === void 0 ? void 0 : Wd(Wl, l, "".concat(s, " has member 'transform' that")),
          writableType: Tl
        };
      }
      function nd(l, s, I) {
        return v(l, I), function(E) {
          return f(l, s, [E]);
        };
      }
      function ud(l, s, I) {
        return v(l, I), function(E) {
          return D(l, s, [E]);
        };
      }
      function Wd(l, s, I) {
        return v(l, I), function(E, _) {
          return f(l, s, [E, _]);
        };
      }
      function hd(l, s, I) {
        return v(l, I), function(E) {
          return f(l, s, [E]);
        };
      }
      var Tt = (
        /** @class */
        function() {
          function l(s, I, E) {
            s === void 0 && (s = {}), I === void 0 && (I = {}), E === void 0 && (E = {}), s === void 0 && (s = null);
            var _ = Wt(I, "Second parameter"), tl = Wt(E, "Third parameter"), Wl = md(s, "First parameter");
            if (Wl.readableType !== void 0)
              throw new RangeError("Invalid readableType specified");
            if (Wl.writableType !== void 0)
              throw new RangeError("Invalid writableType specified");
            var Tl = $i(tl, 0), Rl = ut(tl), pl = $i(_, 1), Ul = ut(_), vl, Ql = J(function(di) {
              vl = di;
            });
            Gd(this, Ql, pl, Ul, Tl, Rl), Md(this, Wl), Wl.start !== void 0 ? vl(Wl.start(this._transformStreamController)) : vl(void 0);
          }
          return Object.defineProperty(l.prototype, "readable", {
            /**
             * The readable side of the transform stream.
             */
            get: function() {
              if (!Hs(this))
                throw As("readable");
              return this._readable;
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(l.prototype, "writable", {
            /**
             * The writable side of the transform stream.
             */
            get: function() {
              if (!Hs(this))
                throw As("writable");
              return this._writable;
            },
            enumerable: !1,
            configurable: !0
          }), l;
        }()
      );
      Object.defineProperties(Tt.prototype, {
        readable: { enumerable: !0 },
        writable: { enumerable: !0 }
      }), typeof t.toStringTag == "symbol" && Object.defineProperty(Tt.prototype, t.toStringTag, {
        value: "TransformStream",
        configurable: !0
      });
      function Gd(l, s, I, E, _, tl) {
        function Wl() {
          return s;
        }
        function Tl(Ql) {
          return Ld(l, Ql);
        }
        function Rl(Ql) {
          return Xd(l, Ql);
        }
        function pl() {
          return yd(l);
        }
        l._writable = Yc(Wl, Tl, pl, Rl, I, E);
        function Ul() {
          return od(l);
        }
        function vl(Ql) {
          return Vd(l, Ql);
        }
        l._readable = st(Wl, Ul, vl, _, tl), l._backpressure = void 0, l._backpressureChangePromise = void 0, l._backpressureChangePromise_resolve = void 0, wt(l, !0), l._transformStreamController = void 0;
      }
      function Hs(l) {
        return !x(l) || !Object.prototype.hasOwnProperty.call(l, "_transformStreamController") ? !1 : l instanceof Tt;
      }
      function Ps(l, s) {
        Ni(l._readable._readableStreamController, s), _t(l, s);
      }
      function _t(l, s) {
        rt(l._transformStreamController), lt(l._writable._writableStreamController, s), qt(l);
      }
      function qt(l) {
        l._backpressure && wt(l, !1);
      }
      function wt(l, s) {
        l._backpressureChangePromise !== void 0 && l._backpressureChangePromise_resolve(), l._backpressureChangePromise = J(function(I) {
          l._backpressureChangePromise_resolve = I;
        }), l._backpressure = s;
      }
      var Si = (
        /** @class */
        function() {
          function l() {
            throw new TypeError("Illegal constructor");
          }
          return Object.defineProperty(l.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.
             */
            get: function() {
              if (!zt(this))
                throw Rt("desiredSize");
              var s = this._controlledTransformStream._readable._readableStreamController;
              return ft(s);
            },
            enumerable: !1,
            configurable: !0
          }), l.prototype.enqueue = function(s) {
            if (s === void 0 && (s = void 0), !zt(this))
              throw Rt("enqueue");
            Bs(this, s);
          }, l.prototype.error = function(s) {
            if (s === void 0 && (s = void 0), !zt(this))
              throw Rt("error");
            Id(this, s);
          }, l.prototype.terminate = function() {
            if (!zt(this))
              throw Rt("terminate");
            Yd(this);
          }, l;
        }()
      );
      Object.defineProperties(Si.prototype, {
        enqueue: { enumerable: !0 },
        error: { enumerable: !0 },
        terminate: { enumerable: !0 },
        desiredSize: { enumerable: !0 }
      }), V(Si.prototype.enqueue, "enqueue"), V(Si.prototype.error, "error"), V(Si.prototype.terminate, "terminate"), typeof t.toStringTag == "symbol" && Object.defineProperty(Si.prototype, t.toStringTag, {
        value: "TransformStreamDefaultController",
        configurable: !0
      });
      function zt(l) {
        return !x(l) || !Object.prototype.hasOwnProperty.call(l, "_controlledTransformStream") ? !1 : l instanceof Si;
      }
      function Nd(l, s, I, E, _) {
        s._controlledTransformStream = l, l._transformStreamController = s, s._transformAlgorithm = I, s._flushAlgorithm = E, s._cancelAlgorithm = _, s._finishPromise = void 0, s._finishPromise_resolve = void 0, s._finishPromise_reject = void 0;
      }
      function Md(l, s) {
        var I = Object.create(Si.prototype), E, _, tl;
        s.transform !== void 0 ? E = function(Wl) {
          return s.transform(Wl, I);
        } : E = function(Wl) {
          try {
            return Bs(I, Wl), u(void 0);
          } catch (Tl) {
            return e(Tl);
          }
        }, s.flush !== void 0 ? _ = function() {
          return s.flush(I);
        } : _ = function() {
          return u(void 0);
        }, s.cancel !== void 0 ? tl = function(Wl) {
          return s.cancel(Wl);
        } : tl = function() {
          return u(void 0);
        }, Nd(l, I, E, _, tl);
      }
      function rt(l) {
        l._transformAlgorithm = void 0, l._flushAlgorithm = void 0, l._cancelAlgorithm = void 0;
      }
      function Bs(l, s) {
        var I = l._controlledTransformStream, E = I._readable._readableStreamController;
        if (!Bi(E))
          throw new TypeError("Readable side is not in a state that permits enqueue");
        try {
          Pi(E, s);
        } catch (tl) {
          throw _t(I, tl), I._readable._storedError;
        }
        var _ = Pc(E);
        _ !== I._backpressure && wt(I, !0);
      }
      function Id(l, s) {
        Ps(l._controlledTransformStream, s);
      }
      function fs(l, s) {
        var I = l._transformAlgorithm(s);
        return G(I, void 0, function(E) {
          throw Ps(l._controlledTransformStream, E), E;
        });
      }
      function Yd(l) {
        var s = l._controlledTransformStream, I = s._readable._readableStreamController;
        Oi(I);
        var E = new TypeError("TransformStream terminated");
        _t(s, E);
      }
      function Ld(l, s) {
        var I = l._transformStreamController;
        if (l._backpressure) {
          var E = l._backpressureChangePromise;
          return G(E, function() {
            var _ = l._writable, tl = _._state;
            if (tl === "erroring")
              throw _._storedError;
            return fs(I, s);
          });
        }
        return fs(I, s);
      }
      function Xd(l, s) {
        var I = l._transformStreamController;
        if (I._finishPromise !== void 0)
          return I._finishPromise;
        var E = l._readable;
        I._finishPromise = J(function(tl, Wl) {
          I._finishPromise_resolve = tl, I._finishPromise_reject = Wl;
        });
        var _ = I._cancelAlgorithm(s);
        return rt(I), d(_, function() {
          return E._state === "errored" ? fi(I, E._storedError) : (Ni(E._readableStreamController, s), $t(I)), null;
        }, function(tl) {
          return Ni(E._readableStreamController, tl), fi(I, tl), null;
        }), I._finishPromise;
      }
      function yd(l) {
        var s = l._transformStreamController;
        if (s._finishPromise !== void 0)
          return s._finishPromise;
        var I = l._readable;
        s._finishPromise = J(function(_, tl) {
          s._finishPromise_resolve = _, s._finishPromise_reject = tl;
        });
        var E = s._flushAlgorithm();
        return rt(s), d(E, function() {
          return I._state === "errored" ? fi(s, I._storedError) : (Oi(I._readableStreamController), $t(s)), null;
        }, function(_) {
          return Ni(I._readableStreamController, _), fi(s, _), null;
        }), s._finishPromise;
      }
      function od(l) {
        return wt(l, !1), l._backpressureChangePromise;
      }
      function Vd(l, s) {
        var I = l._transformStreamController;
        if (I._finishPromise !== void 0)
          return I._finishPromise;
        var E = l._writable;
        I._finishPromise = J(function(tl, Wl) {
          I._finishPromise_resolve = tl, I._finishPromise_reject = Wl;
        });
        var _ = I._cancelAlgorithm(s);
        return rt(I), d(_, function() {
          return E._state === "errored" ? fi(I, E._storedError) : (lt(E._writableStreamController, s), qt(l), $t(I)), null;
        }, function(tl) {
          return lt(E._writableStreamController, tl), qt(l), fi(I, tl), null;
        }), I._finishPromise;
      }
      function Rt(l) {
        return new TypeError("TransformStreamDefaultController.prototype.".concat(l, " can only be used on a TransformStreamDefaultController"));
      }
      function $t(l) {
        l._finishPromise_resolve !== void 0 && (l._finishPromise_resolve(), l._finishPromise_resolve = void 0, l._finishPromise_reject = void 0);
      }
      function fi(l, s) {
        l._finishPromise_reject !== void 0 && (r(l._finishPromise), l._finishPromise_reject(s), l._finishPromise_resolve = void 0, l._finishPromise_reject = void 0);
      }
      function As(l) {
        return new TypeError("TransformStream.prototype.".concat(l, " can only be used on a TransformStream"));
      }
      i.ByteLengthQueuingStrategy = Vt, i.CountQueuingStrategy = pt, i.ReadableByteStreamController = yi, i.ReadableStream = ai, i.ReadableStreamBYOBReader = wi, i.ReadableStreamBYOBRequest = mi, i.ReadableStreamDefaultController = Vi, i.ReadableStreamDefaultReader = Sl, i.TransformStream = Tt, i.TransformStreamDefaultController = Si, i.WritableStream = zi, i.WritableStreamDefaultController = Hi, i.WritableStreamDefaultWriter = oi;
    });
  }(ponyfill, ponyfill.exports)), ponyfill.exports;
}
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$7 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module, exports) {
  (function(c, i) {
    module.exports = i();
  })(globalThis, () => (
    /******/
    (() => {
      var __webpack_modules__ = [
        ,
        /* 1 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.VerbosityLevel = c.Util = c.UnknownErrorException = c.UnexpectedResponseException = c.UNSUPPORTED_FEATURES = c.TextRenderingMode = c.StreamType = c.RenderingIntentFlag = c.PermissionFlag = c.PasswordResponses = c.PasswordException = c.PageActionEventType = c.OPS = c.MissingPDFException = c.LINE_FACTOR = c.LINE_DESCENT_FACTOR = c.InvalidPDFException = c.ImageKind = c.IDENTITY_MATRIX = c.FormatError = c.FontType = c.FeatureTest = c.FONT_IDENTITY_MATRIX = c.DocumentActionEventType = c.CMapCompressionType = c.BaseException = c.AnnotationType = c.AnnotationStateModelType = c.AnnotationReviewState = c.AnnotationReplyType = c.AnnotationMode = c.AnnotationMarkedState = c.AnnotationFlag = c.AnnotationFieldFlag = c.AnnotationEditorType = c.AnnotationEditorPrefix = c.AnnotationEditorParamsType = c.AnnotationBorderStyleType = c.AnnotationActionEventType = c.AbortException = void 0, c.arrayByteLength = dl, c.arraysToBytes = el, c.assert = wl, c.bytesToString = $, c.createPromiseCapability = kl, c.createValidAbsoluteUrl = T, c.escapeString = Sl, c.getModificationDate = zl, c.getVerbosityLevel = k, c.info = q, c.isArrayBuffer = fl, c.isArrayEqual = Nl, c.isAscii = ol, c.objectFromMap = Gl, c.objectSize = ml, c.setVerbosityLevel = U, c.shadow = w, c.string32 = bl, c.stringToBytes = il, c.stringToPDFString = Al, c.stringToUTF16BEString = cl, c.stringToUTF8String = Il, c.unreachable = Ml, c.utf8StringToString = Jl, c.warn = al, i(2);
          const t = [1, 0, 0, 1, 0, 0];
          c.IDENTITY_MATRIX = t;
          const Z = [1e-3, 0, 0, 1e-3, 0, 0];
          c.FONT_IDENTITY_MATRIX = Z;
          const W = 1.35;
          c.LINE_FACTOR = W;
          const y = 0.35;
          c.LINE_DESCENT_FACTOR = y;
          const h = {
            ANY: 1,
            DISPLAY: 2,
            PRINT: 4,
            ANNOTATIONS_FORMS: 16,
            ANNOTATIONS_STORAGE: 32,
            ANNOTATIONS_DISABLE: 64,
            OPLIST: 256
          };
          c.RenderingIntentFlag = h;
          const p = {
            DISABLE: 0,
            ENABLE: 1,
            ENABLE_FORMS: 2,
            ENABLE_STORAGE: 3
          };
          c.AnnotationMode = p;
          const X = "pdfjs_internal_editor_";
          c.AnnotationEditorPrefix = X;
          const M = {
            DISABLE: -1,
            NONE: 0,
            FREETEXT: 3,
            INK: 15
          };
          c.AnnotationEditorType = M;
          const x = {
            FREETEXT_SIZE: 1,
            FREETEXT_COLOR: 2,
            FREETEXT_OPACITY: 3,
            INK_COLOR: 11,
            INK_THICKNESS: 12,
            INK_OPACITY: 13
          };
          c.AnnotationEditorParamsType = x;
          const n = {
            PRINT: 4,
            MODIFY_CONTENTS: 8,
            COPY: 16,
            MODIFY_ANNOTATIONS: 32,
            FILL_INTERACTIVE_FORMS: 256,
            COPY_FOR_ACCESSIBILITY: 512,
            ASSEMBLE: 1024,
            PRINT_HIGH_QUALITY: 2048
          };
          c.PermissionFlag = n;
          const V = {
            FILL: 0,
            STROKE: 1,
            FILL_STROKE: 2,
            INVISIBLE: 3,
            FILL_ADD_TO_PATH: 4,
            STROKE_ADD_TO_PATH: 5,
            FILL_STROKE_ADD_TO_PATH: 6,
            ADD_TO_PATH: 7,
            FILL_STROKE_MASK: 3,
            ADD_TO_PATH_FLAG: 4
          };
          c.TextRenderingMode = V;
          const S = {
            GRAYSCALE_1BPP: 1,
            RGB_24BPP: 2,
            RGBA_32BPP: 3
          };
          c.ImageKind = S;
          const o = {
            TEXT: 1,
            LINK: 2,
            FREETEXT: 3,
            LINE: 4,
            SQUARE: 5,
            CIRCLE: 6,
            POLYGON: 7,
            POLYLINE: 8,
            HIGHLIGHT: 9,
            UNDERLINE: 10,
            SQUIGGLY: 11,
            STRIKEOUT: 12,
            STAMP: 13,
            CARET: 14,
            INK: 15,
            POPUP: 16,
            FILEATTACHMENT: 17,
            SOUND: 18,
            MOVIE: 19,
            WIDGET: 20,
            SCREEN: 21,
            PRINTERMARK: 22,
            TRAPNET: 23,
            WATERMARK: 24,
            THREED: 25,
            REDACT: 26
          };
          c.AnnotationType = o;
          const R = {
            MARKED: "Marked",
            REVIEW: "Review"
          };
          c.AnnotationStateModelType = R;
          const J = {
            MARKED: "Marked",
            UNMARKED: "Unmarked"
          };
          c.AnnotationMarkedState = J;
          const u = {
            ACCEPTED: "Accepted",
            REJECTED: "Rejected",
            CANCELLED: "Cancelled",
            COMPLETED: "Completed",
            NONE: "None"
          };
          c.AnnotationReviewState = u;
          const e = {
            GROUP: "Group",
            REPLY: "R"
          };
          c.AnnotationReplyType = e;
          const m = {
            INVISIBLE: 1,
            HIDDEN: 2,
            PRINT: 4,
            NOZOOM: 8,
            NOROTATE: 16,
            NOVIEW: 32,
            READONLY: 64,
            LOCKED: 128,
            TOGGLENOVIEW: 256,
            LOCKEDCONTENTS: 512
          };
          c.AnnotationFlag = m;
          const d = {
            READONLY: 1,
            REQUIRED: 2,
            NOEXPORT: 4,
            MULTILINE: 4096,
            PASSWORD: 8192,
            NOTOGGLETOOFF: 16384,
            RADIO: 32768,
            PUSHBUTTON: 65536,
            COMBO: 131072,
            EDIT: 262144,
            SORT: 524288,
            FILESELECT: 1048576,
            MULTISELECT: 2097152,
            DONOTSPELLCHECK: 4194304,
            DONOTSCROLL: 8388608,
            COMB: 16777216,
            RICHTEXT: 33554432,
            RADIOSINUNISON: 33554432,
            COMMITONSELCHANGE: 67108864
          };
          c.AnnotationFieldFlag = d;
          const b = {
            SOLID: 1,
            DASHED: 2,
            BEVELED: 3,
            INSET: 4,
            UNDERLINE: 5
          };
          c.AnnotationBorderStyleType = b;
          const N = {
            E: "Mouse Enter",
            X: "Mouse Exit",
            D: "Mouse Down",
            U: "Mouse Up",
            Fo: "Focus",
            Bl: "Blur",
            PO: "PageOpen",
            PC: "PageClose",
            PV: "PageVisible",
            PI: "PageInvisible",
            K: "Keystroke",
            F: "Format",
            V: "Validate",
            C: "Calculate"
          };
          c.AnnotationActionEventType = N;
          const G = {
            WC: "WillClose",
            WS: "WillSave",
            DS: "DidSave",
            WP: "WillPrint",
            DP: "DidPrint"
          };
          c.DocumentActionEventType = G;
          const r = {
            O: "PageOpen",
            C: "PageClose"
          };
          c.PageActionEventType = r;
          const j = {
            UNKNOWN: "UNKNOWN",
            FLATE: "FLATE",
            LZW: "LZW",
            DCT: "DCT",
            JPX: "JPX",
            JBIG: "JBIG",
            A85: "A85",
            AHX: "AHX",
            CCF: "CCF",
            RLX: "RLX"
          };
          c.StreamType = j;
          const D = {
            UNKNOWN: "UNKNOWN",
            TYPE1: "TYPE1",
            TYPE1STANDARD: "TYPE1STANDARD",
            TYPE1C: "TYPE1C",
            CIDFONTTYPE0: "CIDFONTTYPE0",
            CIDFONTTYPE0C: "CIDFONTTYPE0C",
            TRUETYPE: "TRUETYPE",
            CIDFONTTYPE2: "CIDFONTTYPE2",
            TYPE3: "TYPE3",
            OPENTYPE: "OPENTYPE",
            TYPE0: "TYPE0",
            MMTYPE1: "MMTYPE1"
          };
          c.FontType = D;
          const f = {
            ERRORS: 0,
            WARNINGS: 1,
            INFOS: 5
          };
          c.VerbosityLevel = f;
          const P = {
            NONE: 0,
            BINARY: 1,
            STREAM: 2
          };
          c.CMapCompressionType = P;
          const B = {
            dependency: 1,
            setLineWidth: 2,
            setLineCap: 3,
            setLineJoin: 4,
            setMiterLimit: 5,
            setDash: 6,
            setRenderingIntent: 7,
            setFlatness: 8,
            setGState: 9,
            save: 10,
            restore: 11,
            transform: 12,
            moveTo: 13,
            lineTo: 14,
            curveTo: 15,
            curveTo2: 16,
            curveTo3: 17,
            closePath: 18,
            rectangle: 19,
            stroke: 20,
            closeStroke: 21,
            fill: 22,
            eoFill: 23,
            fillStroke: 24,
            eoFillStroke: 25,
            closeFillStroke: 26,
            closeEOFillStroke: 27,
            endPath: 28,
            clip: 29,
            eoClip: 30,
            beginText: 31,
            endText: 32,
            setCharSpacing: 33,
            setWordSpacing: 34,
            setHScale: 35,
            setLeading: 36,
            setFont: 37,
            setTextRenderingMode: 38,
            setTextRise: 39,
            moveText: 40,
            setLeadingMoveText: 41,
            setTextMatrix: 42,
            nextLine: 43,
            showText: 44,
            showSpacedText: 45,
            nextLineShowText: 46,
            nextLineSetSpacingShowText: 47,
            setCharWidth: 48,
            setCharWidthAndBounds: 49,
            setStrokeColorSpace: 50,
            setFillColorSpace: 51,
            setStrokeColor: 52,
            setStrokeColorN: 53,
            setFillColor: 54,
            setFillColorN: 55,
            setStrokeGray: 56,
            setFillGray: 57,
            setStrokeRGBColor: 58,
            setFillRGBColor: 59,
            setStrokeCMYKColor: 60,
            setFillCMYKColor: 61,
            shadingFill: 62,
            beginInlineImage: 63,
            beginImageData: 64,
            endInlineImage: 65,
            paintXObject: 66,
            markPoint: 67,
            markPointProps: 68,
            beginMarkedContent: 69,
            beginMarkedContentProps: 70,
            endMarkedContent: 71,
            beginCompat: 72,
            endCompat: 73,
            paintFormXObjectBegin: 74,
            paintFormXObjectEnd: 75,
            beginGroup: 76,
            endGroup: 77,
            beginAnnotations: 78,
            endAnnotations: 79,
            beginAnnotation: 80,
            endAnnotation: 81,
            paintJpegXObject: 82,
            paintImageMaskXObject: 83,
            paintImageMaskXObjectGroup: 84,
            paintImageXObject: 85,
            paintInlineImageXObject: 86,
            paintInlineImageXObjectGroup: 87,
            paintImageXObjectRepeat: 88,
            paintImageMaskXObjectRepeat: 89,
            paintSolidColorImageMask: 90,
            constructPath: 91
          };
          c.OPS = B;
          const A = {
            unknown: "unknown",
            forms: "forms",
            javaScript: "javaScript",
            signatures: "signatures",
            smask: "smask",
            shadingPattern: "shadingPattern",
            font: "font",
            errorTilingPattern: "errorTilingPattern",
            errorExtGState: "errorExtGState",
            errorXObject: "errorXObject",
            errorFontLoadType3: "errorFontLoadType3",
            errorFontState: "errorFontState",
            errorFontMissing: "errorFontMissing",
            errorFontTranslate: "errorFontTranslate",
            errorColorSpace: "errorColorSpace",
            errorOperatorList: "errorOperatorList",
            errorFontToUnicode: "errorFontToUnicode",
            errorFontLoadNative: "errorFontLoadNative",
            errorFontBuildPath: "errorFontBuildPath",
            errorFontGetPath: "errorFontGetPath",
            errorMarkedContent: "errorMarkedContent",
            errorContentSubStream: "errorContentSubStream"
          };
          c.UNSUPPORTED_FEATURES = A;
          const H = {
            NEED_PASSWORD: 1,
            INCORRECT_PASSWORD: 2
          };
          c.PasswordResponses = H;
          let O = f.WARNINGS;
          function U(nl) {
            Number.isInteger(nl) && (O = nl);
          }
          function k() {
            return O;
          }
          function q(nl) {
            O >= f.INFOS && console.log(`Info: ${nl}`);
          }
          function al(nl) {
            O >= f.WARNINGS && console.log(`Warning: ${nl}`);
          }
          function Ml(nl) {
            throw new Error(nl);
          }
          function wl(nl, ll) {
            nl || Ml(ll);
          }
          function Q(nl) {
            if (!nl)
              return !1;
            switch (nl.protocol) {
              case "http:":
              case "https:":
              case "ftp:":
              case "mailto:":
              case "tel:":
                return !0;
              default:
                return !1;
            }
          }
          function T(nl) {
            let ll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, sl = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            if (!nl)
              return null;
            try {
              if (sl && typeof nl == "string") {
                if (sl.addDefaultProtocol && nl.startsWith("www.")) {
                  const Cl = nl.match(/\./g);
                  Cl && Cl.length >= 2 && (nl = `http://${nl}`);
                }
                if (sl.tryConvertEncoding)
                  try {
                    nl = Il(nl);
                  } catch {
                  }
              }
              const hl = ll ? new URL(nl, ll) : new URL(nl);
              if (Q(hl))
                return hl;
            } catch {
            }
            return null;
          }
          function w(nl, ll, sl) {
            return Object.defineProperty(nl, ll, {
              value: sl,
              enumerable: !0,
              configurable: !0,
              writable: !1
            }), sl;
          }
          const g = function() {
            function ll(sl, hl) {
              this.constructor === ll && Ml("Cannot initialize BaseException."), this.message = sl, this.name = hl;
            }
            return ll.prototype = new Error(), ll.constructor = ll, ll;
          }();
          c.BaseException = g;
          class K extends g {
            constructor(ll, sl) {
              super(ll, "PasswordException"), this.code = sl;
            }
          }
          c.PasswordException = K;
          class a extends g {
            constructor(ll, sl) {
              super(ll, "UnknownErrorException"), this.details = sl;
            }
          }
          c.UnknownErrorException = a;
          class Y extends g {
            constructor(ll) {
              super(ll, "InvalidPDFException");
            }
          }
          c.InvalidPDFException = Y;
          class z extends g {
            constructor(ll) {
              super(ll, "MissingPDFException");
            }
          }
          c.MissingPDFException = z;
          class C extends g {
            constructor(ll, sl) {
              super(ll, "UnexpectedResponseException"), this.status = sl;
            }
          }
          c.UnexpectedResponseException = C;
          class F extends g {
            constructor(ll) {
              super(ll, "FormatError");
            }
          }
          c.FormatError = F;
          class v extends g {
            constructor(ll) {
              super(ll, "AbortException");
            }
          }
          c.AbortException = v;
          function $(nl) {
            (typeof nl != "object" || nl === null || nl.length === void 0) && Ml("Invalid argument for bytesToString");
            const ll = nl.length, sl = 8192;
            if (ll < sl)
              return String.fromCharCode.apply(null, nl);
            const hl = [];
            for (let Cl = 0; Cl < ll; Cl += sl) {
              const jl = Math.min(Cl + sl, ll), ul = nl.subarray(Cl, jl);
              hl.push(String.fromCharCode.apply(null, ul));
            }
            return hl.join("");
          }
          function il(nl) {
            typeof nl != "string" && Ml("Invalid argument for stringToBytes");
            const ll = nl.length, sl = new Uint8Array(ll);
            for (let hl = 0; hl < ll; ++hl)
              sl[hl] = nl.charCodeAt(hl) & 255;
            return sl;
          }
          function dl(nl) {
            if (nl.length !== void 0)
              return nl.length;
            if (nl.byteLength !== void 0)
              return nl.byteLength;
            Ml("Invalid argument for arrayByteLength");
          }
          function el(nl) {
            const ll = nl.length;
            if (ll === 1 && nl[0] instanceof Uint8Array)
              return nl[0];
            let sl = 0;
            for (let jl = 0; jl < ll; jl++)
              sl += dl(nl[jl]);
            let hl = 0;
            const Cl = new Uint8Array(sl);
            for (let jl = 0; jl < ll; jl++) {
              let ul = nl[jl];
              ul instanceof Uint8Array || (typeof ul == "string" ? ul = il(ul) : ul = new Uint8Array(ul));
              const Zl = ul.byteLength;
              Cl.set(ul, hl), hl += Zl;
            }
            return Cl;
          }
          function bl(nl) {
            return String.fromCharCode(nl >> 24 & 255, nl >> 16 & 255, nl >> 8 & 255, nl & 255);
          }
          function ml(nl) {
            return Object.keys(nl).length;
          }
          function Gl(nl) {
            const ll = /* @__PURE__ */ Object.create(null);
            for (const [sl, hl] of nl)
              ll[sl] = hl;
            return ll;
          }
          function Yl() {
            const nl = new Uint8Array(4);
            return nl[0] = 1, new Uint32Array(nl.buffer, 0, 1)[0] === 1;
          }
          function yl() {
            try {
              return new Function(""), !0;
            } catch {
              return !1;
            }
          }
          class Vl {
            static get isLittleEndian() {
              return w(this, "isLittleEndian", Yl());
            }
            static get isEvalSupported() {
              return w(this, "isEvalSupported", yl());
            }
            static get isOffscreenCanvasSupported() {
              return w(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
            }
          }
          c.FeatureTest = Vl;
          const Dl = [...Array(256).keys()].map((nl) => nl.toString(16).padStart(2, "0"));
          class Xl {
            static makeHexColor(ll, sl, hl) {
              return `#${Dl[ll]}${Dl[sl]}${Dl[hl]}`;
            }
            static scaleMinMax(ll, sl) {
              let hl;
              ll[0] ? (ll[0] < 0 && (hl = sl[0], sl[0] = sl[1], sl[1] = hl), sl[0] *= ll[0], sl[1] *= ll[0], ll[3] < 0 && (hl = sl[2], sl[2] = sl[3], sl[3] = hl), sl[2] *= ll[3], sl[3] *= ll[3]) : (hl = sl[0], sl[0] = sl[2], sl[2] = hl, hl = sl[1], sl[1] = sl[3], sl[3] = hl, ll[1] < 0 && (hl = sl[2], sl[2] = sl[3], sl[3] = hl), sl[2] *= ll[1], sl[3] *= ll[1], ll[2] < 0 && (hl = sl[0], sl[0] = sl[1], sl[1] = hl), sl[0] *= ll[2], sl[1] *= ll[2]), sl[0] += ll[4], sl[1] += ll[4], sl[2] += ll[5], sl[3] += ll[5];
            }
            static transform(ll, sl) {
              return [ll[0] * sl[0] + ll[2] * sl[1], ll[1] * sl[0] + ll[3] * sl[1], ll[0] * sl[2] + ll[2] * sl[3], ll[1] * sl[2] + ll[3] * sl[3], ll[0] * sl[4] + ll[2] * sl[5] + ll[4], ll[1] * sl[4] + ll[3] * sl[5] + ll[5]];
            }
            static applyTransform(ll, sl) {
              const hl = ll[0] * sl[0] + ll[1] * sl[2] + sl[4], Cl = ll[0] * sl[1] + ll[1] * sl[3] + sl[5];
              return [hl, Cl];
            }
            static applyInverseTransform(ll, sl) {
              const hl = sl[0] * sl[3] - sl[1] * sl[2], Cl = (ll[0] * sl[3] - ll[1] * sl[2] + sl[2] * sl[5] - sl[4] * sl[3]) / hl, jl = (-ll[0] * sl[1] + ll[1] * sl[0] + sl[4] * sl[1] - sl[5] * sl[0]) / hl;
              return [Cl, jl];
            }
            static getAxialAlignedBoundingBox(ll, sl) {
              const hl = Xl.applyTransform(ll, sl), Cl = Xl.applyTransform(ll.slice(2, 4), sl), jl = Xl.applyTransform([ll[0], ll[3]], sl), ul = Xl.applyTransform([ll[2], ll[1]], sl);
              return [Math.min(hl[0], Cl[0], jl[0], ul[0]), Math.min(hl[1], Cl[1], jl[1], ul[1]), Math.max(hl[0], Cl[0], jl[0], ul[0]), Math.max(hl[1], Cl[1], jl[1], ul[1])];
            }
            static inverseTransform(ll) {
              const sl = ll[0] * ll[3] - ll[1] * ll[2];
              return [ll[3] / sl, -ll[1] / sl, -ll[2] / sl, ll[0] / sl, (ll[2] * ll[5] - ll[4] * ll[3]) / sl, (ll[4] * ll[1] - ll[5] * ll[0]) / sl];
            }
            static apply3dTransform(ll, sl) {
              return [ll[0] * sl[0] + ll[1] * sl[1] + ll[2] * sl[2], ll[3] * sl[0] + ll[4] * sl[1] + ll[5] * sl[2], ll[6] * sl[0] + ll[7] * sl[1] + ll[8] * sl[2]];
            }
            static singularValueDecompose2dScale(ll) {
              const sl = [ll[0], ll[2], ll[1], ll[3]], hl = ll[0] * sl[0] + ll[1] * sl[2], Cl = ll[0] * sl[1] + ll[1] * sl[3], jl = ll[2] * sl[0] + ll[3] * sl[2], ul = ll[2] * sl[1] + ll[3] * sl[3], Zl = (hl + ul) / 2, Ll = Math.sqrt((hl + ul) ** 2 - 4 * (hl * ul - jl * Cl)) / 2, rl = Zl + Ll || 1, Fl = Zl - Ll || 1;
              return [Math.sqrt(rl), Math.sqrt(Fl)];
            }
            static normalizeRect(ll) {
              const sl = ll.slice(0);
              return ll[0] > ll[2] && (sl[0] = ll[2], sl[2] = ll[0]), ll[1] > ll[3] && (sl[1] = ll[3], sl[3] = ll[1]), sl;
            }
            static intersect(ll, sl) {
              const hl = Math.max(Math.min(ll[0], ll[2]), Math.min(sl[0], sl[2])), Cl = Math.min(Math.max(ll[0], ll[2]), Math.max(sl[0], sl[2]));
              if (hl > Cl)
                return null;
              const jl = Math.max(Math.min(ll[1], ll[3]), Math.min(sl[1], sl[3])), ul = Math.min(Math.max(ll[1], ll[3]), Math.max(sl[1], sl[3]));
              return jl > ul ? null : [hl, jl, Cl, ul];
            }
            static bezierBoundingBox(ll, sl, hl, Cl, jl, ul, Zl, Ll) {
              const rl = [], Fl = [[], []];
              let Kl, Ol, El, xl, Bl, si, Pl, ql;
              for (let li = 0; li < 2; ++li) {
                if (li === 0 ? (Ol = 6 * ll - 12 * hl + 6 * jl, Kl = -3 * ll + 9 * hl - 9 * jl + 3 * Zl, El = 3 * hl - 3 * ll) : (Ol = 6 * sl - 12 * Cl + 6 * ul, Kl = -3 * sl + 9 * Cl - 9 * ul + 3 * Ll, El = 3 * Cl - 3 * sl), Math.abs(Kl) < 1e-12) {
                  if (Math.abs(Ol) < 1e-12)
                    continue;
                  xl = -El / Ol, 0 < xl && xl < 1 && rl.push(xl);
                  continue;
                }
                Pl = Ol * Ol - 4 * El * Kl, ql = Math.sqrt(Pl), !(Pl < 0) && (Bl = (-Ol + ql) / (2 * Kl), 0 < Bl && Bl < 1 && rl.push(Bl), si = (-Ol - ql) / (2 * Kl), 0 < si && si < 1 && rl.push(si));
              }
              let ci = rl.length, $l;
              const Zi = ci;
              for (; ci--; )
                xl = rl[ci], $l = 1 - xl, Fl[0][ci] = $l * $l * $l * ll + 3 * $l * $l * xl * hl + 3 * $l * xl * xl * jl + xl * xl * xl * Zl, Fl[1][ci] = $l * $l * $l * sl + 3 * $l * $l * xl * Cl + 3 * $l * xl * xl * ul + xl * xl * xl * Ll;
              return Fl[0][Zi] = ll, Fl[1][Zi] = sl, Fl[0][Zi + 1] = Zl, Fl[1][Zi + 1] = Ll, Fl[0].length = Fl[1].length = Zi + 2, [Math.min(...Fl[0]), Math.min(...Fl[1]), Math.max(...Fl[0]), Math.max(...Fl[1])];
            }
          }
          c.Util = Xl;
          const Hl = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
          function Al(nl) {
            if (nl[0] >= "ï") {
              let sl;
              if (nl[0] === "þ" && nl[1] === "ÿ" ? sl = "utf-16be" : nl[0] === "ÿ" && nl[1] === "þ" ? sl = "utf-16le" : nl[0] === "ï" && nl[1] === "»" && nl[2] === "¿" && (sl = "utf-8"), sl)
                try {
                  const hl = new TextDecoder(sl, {
                    fatal: !0
                  }), Cl = il(nl);
                  return hl.decode(Cl);
                } catch (hl) {
                  al(`stringToPDFString: "${hl}".`);
                }
            }
            const ll = [];
            for (let sl = 0, hl = nl.length; sl < hl; sl++) {
              const Cl = Hl[nl.charCodeAt(sl)];
              ll.push(Cl ? String.fromCharCode(Cl) : nl.charAt(sl));
            }
            return ll.join("");
          }
          function Sl(nl) {
            return nl.replace(/([()\\\n\r])/g, (ll) => ll === `
` ? "\\n" : ll === "\r" ? "\\r" : `\\${ll}`);
          }
          function ol(nl) {
            return /^[\x00-\x7F]*$/.test(nl);
          }
          function cl(nl) {
            const ll = ["þÿ"];
            for (let sl = 0, hl = nl.length; sl < hl; sl++) {
              const Cl = nl.charCodeAt(sl);
              ll.push(String.fromCharCode(Cl >> 8 & 255), String.fromCharCode(Cl & 255));
            }
            return ll.join("");
          }
          function Il(nl) {
            return decodeURIComponent(escape(nl));
          }
          function Jl(nl) {
            return unescape(encodeURIComponent(nl));
          }
          function fl(nl) {
            return typeof nl == "object" && nl !== null && nl.byteLength !== void 0;
          }
          function Nl(nl, ll) {
            if (nl.length !== ll.length)
              return !1;
            for (let sl = 0, hl = nl.length; sl < hl; sl++)
              if (nl[sl] !== ll[sl])
                return !1;
            return !0;
          }
          function zl() {
            let nl = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Date();
            return [nl.getUTCFullYear().toString(), (nl.getUTCMonth() + 1).toString().padStart(2, "0"), nl.getUTCDate().toString().padStart(2, "0"), nl.getUTCHours().toString().padStart(2, "0"), nl.getUTCMinutes().toString().padStart(2, "0"), nl.getUTCSeconds().toString().padStart(2, "0")].join("");
          }
          function kl() {
            const nl = /* @__PURE__ */ Object.create(null);
            let ll = !1;
            return Object.defineProperty(nl, "settled", {
              get() {
                return ll;
              }
            }), nl.promise = new Promise(function(sl, hl) {
              nl.resolve = function(Cl) {
                ll = !0, sl(Cl);
              }, nl.reject = function(Cl) {
                ll = !0, hl(Cl);
              };
            }), nl;
          }
        },
        /* 2 */
        /***/
        (L, c, i) => {
          var t = i(3);
          globalThis._pdfjsCompatibilityChecked || (globalThis._pdfjsCompatibilityChecked = !0, function() {
            globalThis.btoa || !t.isNodeJS || (globalThis.btoa = function(W) {
              return Buffer.from(W, "binary").toString("base64");
            });
          }(), function() {
            globalThis.atob || !t.isNodeJS || (globalThis.atob = function(W) {
              return Buffer.from(W, "base64").toString("binary");
            });
          }(), function() {
            globalThis.DOMMatrix || !t.isNodeJS || (globalThis.DOMMatrix = requireDommatrix());
          }(), function() {
            globalThis.ReadableStream || !t.isNodeJS || (globalThis.ReadableStream = requirePonyfill().ReadableStream);
          }(), function() {
            Array.prototype.at || i(4);
          }(), function() {
            Uint8Array.prototype.at || i(76);
          }(), function() {
            globalThis.structuredClone || i(86);
          }());
        },
        /* 3 */
        /***/
        (L, c) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.isNodeJS = void 0;
          const i = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
          c.isNodeJS = i;
        },
        /* 4 */
        /***/
        (L, c, i) => {
          i(5);
          var t = i(75);
          L.exports = t("Array", "at");
        },
        /* 5 */
        /***/
        (L, c, i) => {
          var t = i(6), Z = i(41), W = i(65), y = i(63), h = i(70);
          t({
            target: "Array",
            proto: !0
          }, {
            at: function(X) {
              var M = Z(this), x = W(M), n = y(X), V = n >= 0 ? n : x + n;
              return V < 0 || V >= x ? void 0 : M[V];
            }
          }), h("at");
        },
        /* 6 */
        /***/
        (L, c, i) => {
          var t = i(7), Z = i(8).f, W = i(45), y = i(49), h = i(39), p = i(57), X = i(69);
          L.exports = function(M, x) {
            var n = M.target, V = M.global, S = M.stat, o, R, J, u, e, m;
            if (V ? R = t : S ? R = t[n] || h(n, {}) : R = (t[n] || {}).prototype, R)
              for (J in x) {
                if (e = x[J], M.dontCallGetSet ? (m = Z(R, J), u = m && m.value) : u = R[J], o = X(V ? J : n + (S ? "." : "#") + J, M.forced), !o && u !== void 0) {
                  if (typeof e == typeof u)
                    continue;
                  p(e, u);
                }
                (M.sham || u && u.sham) && W(e, "sham", !0), y(R, J, e, M);
              }
          };
        },
        /* 7 */
        /***/
        (L) => {
          var c = function(i) {
            return i && i.Math == Math && i;
          };
          L.exports = c(typeof globalThis == "object" && globalThis) || c(typeof window == "object" && window) || c(typeof self == "object" && self) || c(typeof commonjsGlobal == "object" && commonjsGlobal) || /* @__PURE__ */ function() {
            return this;
          }() || Function("return this")();
        },
        /* 8 */
        /***/
        (L, c, i) => {
          var t = i(9), Z = i(11), W = i(13), y = i(14), h = i(15), p = i(20), X = i(40), M = i(43), x = Object.getOwnPropertyDescriptor;
          c.f = t ? x : function(V, S) {
            if (V = h(V), S = p(S), M)
              try {
                return x(V, S);
              } catch {
              }
            if (X(V, S))
              return y(!Z(W.f, V, S), V[S]);
          };
        },
        /* 9 */
        /***/
        (L, c, i) => {
          var t = i(10);
          L.exports = !t(function() {
            return Object.defineProperty({}, 1, {
              get: function() {
                return 7;
              }
            })[1] != 7;
          });
        },
        /* 10 */
        /***/
        (L) => {
          L.exports = function(c) {
            try {
              return !!c();
            } catch {
              return !0;
            }
          };
        },
        /* 11 */
        /***/
        (L, c, i) => {
          var t = i(12), Z = Function.prototype.call;
          L.exports = t ? Z.bind(Z) : function() {
            return Z.apply(Z, arguments);
          };
        },
        /* 12 */
        /***/
        (L, c, i) => {
          var t = i(10);
          L.exports = !t(function() {
            var Z = (function() {
            }).bind();
            return typeof Z != "function" || Z.hasOwnProperty("prototype");
          });
        },
        /* 13 */
        /***/
        (L, c) => {
          var i = {}.propertyIsEnumerable, t = Object.getOwnPropertyDescriptor, Z = t && !i.call({ 1: 2 }, 1);
          c.f = Z ? function(y) {
            var h = t(this, y);
            return !!h && h.enumerable;
          } : i;
        },
        /* 14 */
        /***/
        (L) => {
          L.exports = function(c, i) {
            return {
              enumerable: !(c & 1),
              configurable: !(c & 2),
              writable: !(c & 4),
              value: i
            };
          };
        },
        /* 15 */
        /***/
        (L, c, i) => {
          var t = i(16), Z = i(19);
          L.exports = function(W) {
            return t(Z(W));
          };
        },
        /* 16 */
        /***/
        (L, c, i) => {
          var t = i(17), Z = i(10), W = i(18), y = Object, h = t("".split);
          L.exports = Z(function() {
            return !y("z").propertyIsEnumerable(0);
          }) ? function(p) {
            return W(p) == "String" ? h(p, "") : y(p);
          } : y;
        },
        /* 17 */
        /***/
        (L, c, i) => {
          var t = i(12), Z = Function.prototype, W = Z.bind, y = Z.call, h = t && W.bind(y, y);
          L.exports = t ? function(p) {
            return p && h(p);
          } : function(p) {
            return p && function() {
              return y.apply(p, arguments);
            };
          };
        },
        /* 18 */
        /***/
        (L, c, i) => {
          var t = i(17), Z = t({}.toString), W = t("".slice);
          L.exports = function(y) {
            return W(Z(y), 8, -1);
          };
        },
        /* 19 */
        /***/
        (L) => {
          var c = TypeError;
          L.exports = function(i) {
            if (i == null)
              throw c("Can't call method on " + i);
            return i;
          };
        },
        /* 20 */
        /***/
        (L, c, i) => {
          var t = i(21), Z = i(24);
          L.exports = function(W) {
            var y = t(W, "string");
            return Z(y) ? y : y + "";
          };
        },
        /* 21 */
        /***/
        (L, c, i) => {
          var t = i(11), Z = i(22), W = i(24), y = i(31), h = i(34), p = i(35), X = TypeError, M = p("toPrimitive");
          L.exports = function(x, n) {
            if (!Z(x) || W(x))
              return x;
            var V = y(x, M), S;
            if (V) {
              if (n === void 0 && (n = "default"), S = t(V, x, n), !Z(S) || W(S))
                return S;
              throw X("Can't convert object to primitive value");
            }
            return n === void 0 && (n = "number"), h(x, n);
          };
        },
        /* 22 */
        /***/
        (L, c, i) => {
          var t = i(23);
          L.exports = function(Z) {
            return typeof Z == "object" ? Z !== null : t(Z);
          };
        },
        /* 23 */
        /***/
        (L) => {
          L.exports = function(c) {
            return typeof c == "function";
          };
        },
        /* 24 */
        /***/
        (L, c, i) => {
          var t = i(25), Z = i(23), W = i(26), y = i(27), h = Object;
          L.exports = y ? function(p) {
            return typeof p == "symbol";
          } : function(p) {
            var X = t("Symbol");
            return Z(X) && W(X.prototype, h(p));
          };
        },
        /* 25 */
        /***/
        (L, c, i) => {
          var t = i(7), Z = i(23), W = function(y) {
            return Z(y) ? y : void 0;
          };
          L.exports = function(y, h) {
            return arguments.length < 2 ? W(t[y]) : t[y] && t[y][h];
          };
        },
        /* 26 */
        /***/
        (L, c, i) => {
          var t = i(17);
          L.exports = t({}.isPrototypeOf);
        },
        /* 27 */
        /***/
        (L, c, i) => {
          var t = i(28);
          L.exports = t && !Symbol.sham && typeof Symbol.iterator == "symbol";
        },
        /* 28 */
        /***/
        (L, c, i) => {
          var t = i(29), Z = i(10);
          L.exports = !!Object.getOwnPropertySymbols && !Z(function() {
            var W = Symbol();
            return !String(W) || !(Object(W) instanceof Symbol) || !Symbol.sham && t && t < 41;
          });
        },
        /* 29 */
        /***/
        (L, c, i) => {
          var t = i(7), Z = i(30), W = t.process, y = t.Deno, h = W && W.versions || y && y.version, p = h && h.v8, X, M;
          p && (X = p.split("."), M = X[0] > 0 && X[0] < 4 ? 1 : +(X[0] + X[1])), !M && Z && (X = Z.match(/Edge\/(\d+)/), (!X || X[1] >= 74) && (X = Z.match(/Chrome\/(\d+)/), X && (M = +X[1]))), L.exports = M;
        },
        /* 30 */
        /***/
        (L, c, i) => {
          var t = i(25);
          L.exports = t("navigator", "userAgent") || "";
        },
        /* 31 */
        /***/
        (L, c, i) => {
          var t = i(32);
          L.exports = function(Z, W) {
            var y = Z[W];
            return y == null ? void 0 : t(y);
          };
        },
        /* 32 */
        /***/
        (L, c, i) => {
          var t = i(23), Z = i(33), W = TypeError;
          L.exports = function(y) {
            if (t(y))
              return y;
            throw W(Z(y) + " is not a function");
          };
        },
        /* 33 */
        /***/
        (L) => {
          var c = String;
          L.exports = function(i) {
            try {
              return c(i);
            } catch {
              return "Object";
            }
          };
        },
        /* 34 */
        /***/
        (L, c, i) => {
          var t = i(11), Z = i(23), W = i(22), y = TypeError;
          L.exports = function(h, p) {
            var X, M;
            if (p === "string" && Z(X = h.toString) && !W(M = t(X, h)) || Z(X = h.valueOf) && !W(M = t(X, h)) || p !== "string" && Z(X = h.toString) && !W(M = t(X, h)))
              return M;
            throw y("Can't convert object to primitive value");
          };
        },
        /* 35 */
        /***/
        (L, c, i) => {
          var t = i(7), Z = i(36), W = i(40), y = i(42), h = i(28), p = i(27), X = Z("wks"), M = t.Symbol, x = M && M.for, n = p ? M : M && M.withoutSetter || y;
          L.exports = function(V) {
            if (!W(X, V) || !(h || typeof X[V] == "string")) {
              var S = "Symbol." + V;
              h && W(M, V) ? X[V] = M[V] : p && x ? X[V] = x(S) : X[V] = n(S);
            }
            return X[V];
          };
        },
        /* 36 */
        /***/
        (L, c, i) => {
          var t = i(37), Z = i(38);
          (L.exports = function(W, y) {
            return Z[W] || (Z[W] = y !== void 0 ? y : {});
          })("versions", []).push({
            version: "3.24.1",
            mode: t ? "pure" : "global",
            copyright: "© 2014-2022 Denis Pushkarev (zloirock.ru)",
            license: "https://github.com/zloirock/core-js/blob/v3.24.1/LICENSE",
            source: "https://github.com/zloirock/core-js"
          });
        },
        /* 37 */
        /***/
        (L) => {
          L.exports = !1;
        },
        /* 38 */
        /***/
        (L, c, i) => {
          var t = i(7), Z = i(39), W = "__core-js_shared__", y = t[W] || Z(W, {});
          L.exports = y;
        },
        /* 39 */
        /***/
        (L, c, i) => {
          var t = i(7), Z = Object.defineProperty;
          L.exports = function(W, y) {
            try {
              Z(t, W, {
                value: y,
                configurable: !0,
                writable: !0
              });
            } catch {
              t[W] = y;
            }
            return y;
          };
        },
        /* 40 */
        /***/
        (L, c, i) => {
          var t = i(17), Z = i(41), W = t({}.hasOwnProperty);
          L.exports = Object.hasOwn || function(h, p) {
            return W(Z(h), p);
          };
        },
        /* 41 */
        /***/
        (L, c, i) => {
          var t = i(19), Z = Object;
          L.exports = function(W) {
            return Z(t(W));
          };
        },
        /* 42 */
        /***/
        (L, c, i) => {
          var t = i(17), Z = 0, W = Math.random(), y = t(1 .toString);
          L.exports = function(h) {
            return "Symbol(" + (h === void 0 ? "" : h) + ")_" + y(++Z + W, 36);
          };
        },
        /* 43 */
        /***/
        (L, c, i) => {
          var t = i(9), Z = i(10), W = i(44);
          L.exports = !t && !Z(function() {
            return Object.defineProperty(W("div"), "a", {
              get: function() {
                return 7;
              }
            }).a != 7;
          });
        },
        /* 44 */
        /***/
        (L, c, i) => {
          var t = i(7), Z = i(22), W = t.document, y = Z(W) && Z(W.createElement);
          L.exports = function(h) {
            return y ? W.createElement(h) : {};
          };
        },
        /* 45 */
        /***/
        (L, c, i) => {
          var t = i(9), Z = i(46), W = i(14);
          L.exports = t ? function(y, h, p) {
            return Z.f(y, h, W(1, p));
          } : function(y, h, p) {
            return y[h] = p, y;
          };
        },
        /* 46 */
        /***/
        (L, c, i) => {
          var t = i(9), Z = i(43), W = i(47), y = i(48), h = i(20), p = TypeError, X = Object.defineProperty, M = Object.getOwnPropertyDescriptor, x = "enumerable", n = "configurable", V = "writable";
          c.f = t ? W ? function(o, R, J) {
            if (y(o), R = h(R), y(J), typeof o == "function" && R === "prototype" && "value" in J && V in J && !J[V]) {
              var u = M(o, R);
              u && u[V] && (o[R] = J.value, J = {
                configurable: n in J ? J[n] : u[n],
                enumerable: x in J ? J[x] : u[x],
                writable: !1
              });
            }
            return X(o, R, J);
          } : X : function(o, R, J) {
            if (y(o), R = h(R), y(J), Z)
              try {
                return X(o, R, J);
              } catch {
              }
            if ("get" in J || "set" in J)
              throw p("Accessors not supported");
            return "value" in J && (o[R] = J.value), o;
          };
        },
        /* 47 */
        /***/
        (L, c, i) => {
          var t = i(9), Z = i(10);
          L.exports = t && Z(function() {
            return Object.defineProperty(function() {
            }, "prototype", {
              value: 42,
              writable: !1
            }).prototype != 42;
          });
        },
        /* 48 */
        /***/
        (L, c, i) => {
          var t = i(22), Z = String, W = TypeError;
          L.exports = function(y) {
            if (t(y))
              return y;
            throw W(Z(y) + " is not an object");
          };
        },
        /* 49 */
        /***/
        (L, c, i) => {
          var t = i(23), Z = i(46), W = i(50), y = i(39);
          L.exports = function(h, p, X, M) {
            M || (M = {});
            var x = M.enumerable, n = M.name !== void 0 ? M.name : p;
            if (t(X) && W(X, n, M), M.global)
              x ? h[p] = X : y(p, X);
            else {
              try {
                M.unsafe ? h[p] && (x = !0) : delete h[p];
              } catch {
              }
              x ? h[p] = X : Z.f(h, p, {
                value: X,
                enumerable: !1,
                configurable: !M.nonConfigurable,
                writable: !M.nonWritable
              });
            }
            return h;
          };
        },
        /* 50 */
        /***/
        (L, c, i) => {
          var t = i(10), Z = i(23), W = i(40), y = i(9), h = i(51).CONFIGURABLE, p = i(52), X = i(53), M = X.enforce, x = X.get, n = Object.defineProperty, V = y && !t(function() {
            return n(function() {
            }, "length", { value: 8 }).length !== 8;
          }), S = String(String).split("String"), o = L.exports = function(R, J, u) {
            String(J).slice(0, 7) === "Symbol(" && (J = "[" + String(J).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), u && u.getter && (J = "get " + J), u && u.setter && (J = "set " + J), (!W(R, "name") || h && R.name !== J) && (y ? n(R, "name", {
              value: J,
              configurable: !0
            }) : R.name = J), V && u && W(u, "arity") && R.length !== u.arity && n(R, "length", { value: u.arity });
            try {
              u && W(u, "constructor") && u.constructor ? y && n(R, "prototype", { writable: !1 }) : R.prototype && (R.prototype = void 0);
            } catch {
            }
            var e = M(R);
            return W(e, "source") || (e.source = S.join(typeof J == "string" ? J : "")), R;
          };
          Function.prototype.toString = o(function() {
            return Z(this) && x(this).source || p(this);
          }, "toString");
        },
        /* 51 */
        /***/
        (L, c, i) => {
          var t = i(9), Z = i(40), W = Function.prototype, y = t && Object.getOwnPropertyDescriptor, h = Z(W, "name"), p = h && (function() {
          }).name === "something", X = h && (!t || t && y(W, "name").configurable);
          L.exports = {
            EXISTS: h,
            PROPER: p,
            CONFIGURABLE: X
          };
        },
        /* 52 */
        /***/
        (L, c, i) => {
          var t = i(17), Z = i(23), W = i(38), y = t(Function.toString);
          Z(W.inspectSource) || (W.inspectSource = function(h) {
            return y(h);
          }), L.exports = W.inspectSource;
        },
        /* 53 */
        /***/
        (L, c, i) => {
          var t = i(54), Z = i(7), W = i(17), y = i(22), h = i(45), p = i(40), X = i(38), M = i(55), x = i(56), n = "Object already initialized", V = Z.TypeError, S = Z.WeakMap, o, R, J, u = function(r) {
            return J(r) ? R(r) : o(r, {});
          }, e = function(r) {
            return function(j) {
              var D;
              if (!y(j) || (D = R(j)).type !== r)
                throw V("Incompatible receiver, " + r + " required");
              return D;
            };
          };
          if (t || X.state) {
            var m = X.state || (X.state = new S()), d = W(m.get), b = W(m.has), N = W(m.set);
            o = function(r, j) {
              if (b(m, r))
                throw new V(n);
              return j.facade = r, N(m, r, j), j;
            }, R = function(r) {
              return d(m, r) || {};
            }, J = function(r) {
              return b(m, r);
            };
          } else {
            var G = M("state");
            x[G] = !0, o = function(r, j) {
              if (p(r, G))
                throw new V(n);
              return j.facade = r, h(r, G, j), j;
            }, R = function(r) {
              return p(r, G) ? r[G] : {};
            }, J = function(r) {
              return p(r, G);
            };
          }
          L.exports = {
            set: o,
            get: R,
            has: J,
            enforce: u,
            getterFor: e
          };
        },
        /* 54 */
        /***/
        (L, c, i) => {
          var t = i(7), Z = i(23), W = i(52), y = t.WeakMap;
          L.exports = Z(y) && /native code/.test(W(y));
        },
        /* 55 */
        /***/
        (L, c, i) => {
          var t = i(36), Z = i(42), W = t("keys");
          L.exports = function(y) {
            return W[y] || (W[y] = Z(y));
          };
        },
        /* 56 */
        /***/
        (L) => {
          L.exports = {};
        },
        /* 57 */
        /***/
        (L, c, i) => {
          var t = i(40), Z = i(58), W = i(8), y = i(46);
          L.exports = function(h, p, X) {
            for (var M = Z(p), x = y.f, n = W.f, V = 0; V < M.length; V++) {
              var S = M[V];
              !t(h, S) && !(X && t(X, S)) && x(h, S, n(p, S));
            }
          };
        },
        /* 58 */
        /***/
        (L, c, i) => {
          var t = i(25), Z = i(17), W = i(59), y = i(68), h = i(48), p = Z([].concat);
          L.exports = t("Reflect", "ownKeys") || function(M) {
            var x = W.f(h(M)), n = y.f;
            return n ? p(x, n(M)) : x;
          };
        },
        /* 59 */
        /***/
        (L, c, i) => {
          var t = i(60), Z = i(67), W = Z.concat("length", "prototype");
          c.f = Object.getOwnPropertyNames || function(h) {
            return t(h, W);
          };
        },
        /* 60 */
        /***/
        (L, c, i) => {
          var t = i(17), Z = i(40), W = i(15), y = i(61).indexOf, h = i(56), p = t([].push);
          L.exports = function(X, M) {
            var x = W(X), n = 0, V = [], S;
            for (S in x)
              !Z(h, S) && Z(x, S) && p(V, S);
            for (; M.length > n; )
              Z(x, S = M[n++]) && (~y(V, S) || p(V, S));
            return V;
          };
        },
        /* 61 */
        /***/
        (L, c, i) => {
          var t = i(15), Z = i(62), W = i(65), y = function(h) {
            return function(p, X, M) {
              var x = t(p), n = W(x), V = Z(M, n), S;
              if (h && X != X) {
                for (; n > V; )
                  if (S = x[V++], S != S)
                    return !0;
              } else
                for (; n > V; V++)
                  if ((h || V in x) && x[V] === X)
                    return h || V || 0;
              return !h && -1;
            };
          };
          L.exports = {
            includes: y(!0),
            indexOf: y(!1)
          };
        },
        /* 62 */
        /***/
        (L, c, i) => {
          var t = i(63), Z = Math.max, W = Math.min;
          L.exports = function(y, h) {
            var p = t(y);
            return p < 0 ? Z(p + h, 0) : W(p, h);
          };
        },
        /* 63 */
        /***/
        (L, c, i) => {
          var t = i(64);
          L.exports = function(Z) {
            var W = +Z;
            return W !== W || W === 0 ? 0 : t(W);
          };
        },
        /* 64 */
        /***/
        (L) => {
          var c = Math.ceil, i = Math.floor;
          L.exports = Math.trunc || function(Z) {
            var W = +Z;
            return (W > 0 ? i : c)(W);
          };
        },
        /* 65 */
        /***/
        (L, c, i) => {
          var t = i(66);
          L.exports = function(Z) {
            return t(Z.length);
          };
        },
        /* 66 */
        /***/
        (L, c, i) => {
          var t = i(63), Z = Math.min;
          L.exports = function(W) {
            return W > 0 ? Z(t(W), 9007199254740991) : 0;
          };
        },
        /* 67 */
        /***/
        (L) => {
          L.exports = [
            "constructor",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "toLocaleString",
            "toString",
            "valueOf"
          ];
        },
        /* 68 */
        /***/
        (L, c) => {
          c.f = Object.getOwnPropertySymbols;
        },
        /* 69 */
        /***/
        (L, c, i) => {
          var t = i(10), Z = i(23), W = /#|\.prototype\./, y = function(x, n) {
            var V = p[h(x)];
            return V == M ? !0 : V == X ? !1 : Z(n) ? t(n) : !!n;
          }, h = y.normalize = function(x) {
            return String(x).replace(W, ".").toLowerCase();
          }, p = y.data = {}, X = y.NATIVE = "N", M = y.POLYFILL = "P";
          L.exports = y;
        },
        /* 70 */
        /***/
        (L, c, i) => {
          var t = i(35), Z = i(71), W = i(46).f, y = t("unscopables"), h = Array.prototype;
          h[y] == null && W(h, y, {
            configurable: !0,
            value: Z(null)
          }), L.exports = function(p) {
            h[y][p] = !0;
          };
        },
        /* 71 */
        /***/
        (L, c, i) => {
          var t = i(48), Z = i(72), W = i(67), y = i(56), h = i(74), p = i(44), X = i(55), M = ">", x = "<", n = "prototype", V = "script", S = X("IE_PROTO"), o = function() {
          }, R = function(d) {
            return x + V + M + d + x + "/" + V + M;
          }, J = function(d) {
            d.write(R("")), d.close();
            var b = d.parentWindow.Object;
            return d = null, b;
          }, u = function() {
            var d = p("iframe"), b = "java" + V + ":", N;
            return d.style.display = "none", h.appendChild(d), d.src = String(b), N = d.contentWindow.document, N.open(), N.write(R("document.F=Object")), N.close(), N.F;
          }, e, m = function() {
            try {
              e = new ActiveXObject("htmlfile");
            } catch {
            }
            m = typeof document < "u" ? document.domain && e ? J(e) : u() : J(e);
            for (var d = W.length; d--; )
              delete m[n][W[d]];
            return m();
          };
          y[S] = !0, L.exports = Object.create || function(b, N) {
            var G;
            return b !== null ? (o[n] = t(b), G = new o(), o[n] = null, G[S] = b) : G = m(), N === void 0 ? G : Z.f(G, N);
          };
        },
        /* 72 */
        /***/
        (L, c, i) => {
          var t = i(9), Z = i(47), W = i(46), y = i(48), h = i(15), p = i(73);
          c.f = t && !Z ? Object.defineProperties : function(M, x) {
            y(M);
            for (var n = h(x), V = p(x), S = V.length, o = 0, R; S > o; )
              W.f(M, R = V[o++], n[R]);
            return M;
          };
        },
        /* 73 */
        /***/
        (L, c, i) => {
          var t = i(60), Z = i(67);
          L.exports = Object.keys || function(y) {
            return t(y, Z);
          };
        },
        /* 74 */
        /***/
        (L, c, i) => {
          var t = i(25);
          L.exports = t("document", "documentElement");
        },
        /* 75 */
        /***/
        (L, c, i) => {
          var t = i(7), Z = i(17);
          L.exports = function(W, y) {
            return Z(t[W].prototype[y]);
          };
        },
        /* 76 */
        /***/
        (L, c, i) => {
          i(77);
        },
        /* 77 */
        /***/
        (L, c, i) => {
          var t = i(78), Z = i(65), W = i(63), y = t.aTypedArray, h = t.exportTypedArrayMethod;
          h("at", function(X) {
            var M = y(this), x = Z(M), n = W(X), V = n >= 0 ? n : x + n;
            return V < 0 || V >= x ? void 0 : M[V];
          });
        },
        /* 78 */
        /***/
        (L, c, i) => {
          var t = i(79), Z = i(9), W = i(7), y = i(23), h = i(22), p = i(40), X = i(80), M = i(33), x = i(45), n = i(49), V = i(46).f, S = i(26), o = i(82), R = i(84), J = i(35), u = i(42), e = i(53), m = e.enforce, d = e.get, b = W.Int8Array, N = b && b.prototype, G = W.Uint8ClampedArray, r = G && G.prototype, j = b && o(b), D = N && o(N), f = Object.prototype, P = W.TypeError, B = J("toStringTag"), A = u("TYPED_ARRAY_TAG"), H = "TypedArrayConstructor", O = t && !!R && X(W.opera) !== "Opera", U = !1, k, q, al, Ml = {
            Int8Array: 1,
            Uint8Array: 1,
            Uint8ClampedArray: 1,
            Int16Array: 2,
            Uint16Array: 2,
            Int32Array: 4,
            Uint32Array: 4,
            Float32Array: 4,
            Float64Array: 8
          }, wl = {
            BigInt64Array: 8,
            BigUint64Array: 8
          }, Q = function(C) {
            if (!h(C))
              return !1;
            var F = X(C);
            return F === "DataView" || p(Ml, F) || p(wl, F);
          }, T = function(z) {
            var C = o(z);
            if (h(C)) {
              var F = d(C);
              return F && p(F, H) ? F[H] : T(C);
            }
          }, w = function(z) {
            if (!h(z))
              return !1;
            var C = X(z);
            return p(Ml, C) || p(wl, C);
          }, g = function(z) {
            if (w(z))
              return z;
            throw P("Target is not a typed array");
          }, K = function(z) {
            if (y(z) && (!R || S(j, z)))
              return z;
            throw P(M(z) + " is not a typed array constructor");
          }, a = function(z, C, F, v) {
            if (Z) {
              if (F)
                for (var $ in Ml) {
                  var il = W[$];
                  if (il && p(il.prototype, z))
                    try {
                      delete il.prototype[z];
                    } catch {
                      try {
                        il.prototype[z] = C;
                      } catch {
                      }
                    }
                }
              (!D[z] || F) && n(D, z, F ? C : O && N[z] || C, v);
            }
          }, Y = function(z, C, F) {
            var v, $;
            if (Z) {
              if (R) {
                if (F) {
                  for (v in Ml)
                    if ($ = W[v], $ && p($, z))
                      try {
                        delete $[z];
                      } catch {
                      }
                }
                if (!j[z] || F)
                  try {
                    return n(j, z, F ? C : O && j[z] || C);
                  } catch {
                  }
                else
                  return;
              }
              for (v in Ml)
                $ = W[v], $ && (!$[z] || F) && n($, z, C);
            }
          };
          for (k in Ml)
            q = W[k], al = q && q.prototype, al ? m(al)[H] = q : O = !1;
          for (k in wl)
            q = W[k], al = q && q.prototype, al && (m(al)[H] = q);
          if ((!O || !y(j) || j === Function.prototype) && (j = function() {
            throw P("Incorrect invocation");
          }, O))
            for (k in Ml)
              W[k] && R(W[k], j);
          if ((!O || !D || D === f) && (D = j.prototype, O))
            for (k in Ml)
              W[k] && R(W[k].prototype, D);
          if (O && o(r) !== D && R(r, D), Z && !p(D, B)) {
            U = !0, V(D, B, {
              get: function() {
                return h(this) ? this[A] : void 0;
              }
            });
            for (k in Ml)
              W[k] && x(W[k], A, k);
          }
          L.exports = {
            NATIVE_ARRAY_BUFFER_VIEWS: O,
            TYPED_ARRAY_TAG: U && A,
            aTypedArray: g,
            aTypedArrayConstructor: K,
            exportTypedArrayMethod: a,
            exportTypedArrayStaticMethod: Y,
            getTypedArrayConstructor: T,
            isView: Q,
            isTypedArray: w,
            TypedArray: j,
            TypedArrayPrototype: D
          };
        },
        /* 79 */
        /***/
        (L) => {
          L.exports = typeof ArrayBuffer < "u" && typeof DataView < "u";
        },
        /* 80 */
        /***/
        (L, c, i) => {
          var t = i(81), Z = i(23), W = i(18), y = i(35), h = y("toStringTag"), p = Object, X = W(/* @__PURE__ */ function() {
            return arguments;
          }()) == "Arguments", M = function(x, n) {
            try {
              return x[n];
            } catch {
            }
          };
          L.exports = t ? W : function(x) {
            var n, V, S;
            return x === void 0 ? "Undefined" : x === null ? "Null" : typeof (V = M(n = p(x), h)) == "string" ? V : X ? W(n) : (S = W(n)) == "Object" && Z(n.callee) ? "Arguments" : S;
          };
        },
        /* 81 */
        /***/
        (L, c, i) => {
          var t = i(35), Z = t("toStringTag"), W = {};
          W[Z] = "z", L.exports = String(W) === "[object z]";
        },
        /* 82 */
        /***/
        (L, c, i) => {
          var t = i(40), Z = i(23), W = i(41), y = i(55), h = i(83), p = y("IE_PROTO"), X = Object, M = X.prototype;
          L.exports = h ? X.getPrototypeOf : function(x) {
            var n = W(x);
            if (t(n, p))
              return n[p];
            var V = n.constructor;
            return Z(V) && n instanceof V ? V.prototype : n instanceof X ? M : null;
          };
        },
        /* 83 */
        /***/
        (L, c, i) => {
          var t = i(10);
          L.exports = !t(function() {
            function Z() {
            }
            return Z.prototype.constructor = null, Object.getPrototypeOf(new Z()) !== Z.prototype;
          });
        },
        /* 84 */
        /***/
        (L, c, i) => {
          var t = i(17), Z = i(48), W = i(85);
          L.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
            var y = !1, h = {}, p;
            try {
              p = t(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set), p(h, []), y = h instanceof Array;
            } catch {
            }
            return function(M, x) {
              return Z(M), W(x), y ? p(M, x) : M.__proto__ = x, M;
            };
          }() : void 0);
        },
        /* 85 */
        /***/
        (L, c, i) => {
          var t = i(23), Z = String, W = TypeError;
          L.exports = function(y) {
            if (typeof y == "object" || t(y))
              return y;
            throw W("Can't set " + Z(y) + " as a prototype");
          };
        },
        /* 86 */
        /***/
        (L, c, i) => {
          i(87), i(93), i(95), i(117), i(119);
          var t = i(128);
          L.exports = t.structuredClone;
        },
        /* 87 */
        /***/
        (L, c, i) => {
          var t = i(15), Z = i(70), W = i(88), y = i(53), h = i(46).f, p = i(89), X = i(37), M = i(9), x = "Array Iterator", n = y.set, V = y.getterFor(x);
          L.exports = p(Array, "Array", function(o, R) {
            n(this, {
              type: x,
              target: t(o),
              index: 0,
              kind: R
            });
          }, function() {
            var o = V(this), R = o.target, J = o.kind, u = o.index++;
            return !R || u >= R.length ? (o.target = void 0, {
              value: void 0,
              done: !0
            }) : J == "keys" ? {
              value: u,
              done: !1
            } : J == "values" ? {
              value: R[u],
              done: !1
            } : {
              value: [
                u,
                R[u]
              ],
              done: !1
            };
          }, "values");
          var S = W.Arguments = W.Array;
          if (Z("keys"), Z("values"), Z("entries"), !X && M && S.name !== "values")
            try {
              h(S, "name", { value: "values" });
            } catch {
            }
        },
        /* 88 */
        /***/
        (L) => {
          L.exports = {};
        },
        /* 89 */
        /***/
        (L, c, i) => {
          var t = i(6), Z = i(11), W = i(37), y = i(51), h = i(23), p = i(90), X = i(82), M = i(84), x = i(92), n = i(45), V = i(49), S = i(35), o = i(88), R = i(91), J = y.PROPER, u = y.CONFIGURABLE, e = R.IteratorPrototype, m = R.BUGGY_SAFARI_ITERATORS, d = S("iterator"), b = "keys", N = "values", G = "entries", r = function() {
            return this;
          };
          L.exports = function(j, D, f, P, B, A, H) {
            p(f, D, P);
            var O = function(g) {
              if (g === B && Ml)
                return Ml;
              if (!m && g in q)
                return q[g];
              switch (g) {
                case b:
                  return function() {
                    return new f(this, g);
                  };
                case N:
                  return function() {
                    return new f(this, g);
                  };
                case G:
                  return function() {
                    return new f(this, g);
                  };
              }
              return function() {
                return new f(this);
              };
            }, U = D + " Iterator", k = !1, q = j.prototype, al = q[d] || q["@@iterator"] || B && q[B], Ml = !m && al || O(B), wl = D == "Array" && q.entries || al, Q, T, w;
            if (wl && (Q = X(wl.call(new j())), Q !== Object.prototype && Q.next && (!W && X(Q) !== e && (M ? M(Q, e) : h(Q[d]) || V(Q, d, r)), x(Q, U, !0, !0), W && (o[U] = r))), J && B == N && al && al.name !== N && (!W && u ? n(q, "name", N) : (k = !0, Ml = function() {
              return Z(al, this);
            })), B)
              if (T = {
                values: O(N),
                keys: A ? Ml : O(b),
                entries: O(G)
              }, H)
                for (w in T)
                  (m || k || !(w in q)) && V(q, w, T[w]);
              else
                t({
                  target: D,
                  proto: !0,
                  forced: m || k
                }, T);
            return (!W || H) && q[d] !== Ml && V(q, d, Ml, { name: B }), o[D] = Ml, T;
          };
        },
        /* 90 */
        /***/
        (L, c, i) => {
          var t = i(91).IteratorPrototype, Z = i(71), W = i(14), y = i(92), h = i(88), p = function() {
            return this;
          };
          L.exports = function(X, M, x, n) {
            var V = M + " Iterator";
            return X.prototype = Z(t, { next: W(+!n, x) }), y(X, V, !1, !0), h[V] = p, X;
          };
        },
        /* 91 */
        /***/
        (L, c, i) => {
          var t = i(10), Z = i(23), W = i(71), y = i(82), h = i(49), p = i(35), X = i(37), M = p("iterator"), x = !1, n, V, S;
          [].keys && (S = [].keys(), "next" in S ? (V = y(y(S)), V !== Object.prototype && (n = V)) : x = !0);
          var o = n == null || t(function() {
            var R = {};
            return n[M].call(R) !== R;
          });
          o ? n = {} : X && (n = W(n)), Z(n[M]) || h(n, M, function() {
            return this;
          }), L.exports = {
            IteratorPrototype: n,
            BUGGY_SAFARI_ITERATORS: x
          };
        },
        /* 92 */
        /***/
        (L, c, i) => {
          var t = i(46).f, Z = i(40), W = i(35), y = W("toStringTag");
          L.exports = function(h, p, X) {
            h && !X && (h = h.prototype), h && !Z(h, y) && t(h, y, {
              configurable: !0,
              value: p
            });
          };
        },
        /* 93 */
        /***/
        (L, c, i) => {
          var t = i(81), Z = i(49), W = i(94);
          t || Z(Object.prototype, "toString", W, { unsafe: !0 });
        },
        /* 94 */
        /***/
        (L, c, i) => {
          var t = i(81), Z = i(80);
          L.exports = t ? {}.toString : function() {
            return "[object " + Z(this) + "]";
          };
        },
        /* 95 */
        /***/
        (L, c, i) => {
          i(96);
        },
        /* 96 */
        /***/
        (L, c, i) => {
          var t = i(97), Z = i(114);
          t("Map", function(W) {
            return function() {
              return W(this, arguments.length ? arguments[0] : void 0);
            };
          }, Z);
        },
        /* 97 */
        /***/
        (L, c, i) => {
          var t = i(6), Z = i(7), W = i(17), y = i(69), h = i(49), p = i(98), X = i(105), M = i(111), x = i(23), n = i(22), V = i(10), S = i(112), o = i(92), R = i(113);
          L.exports = function(J, u, e) {
            var m = J.indexOf("Map") !== -1, d = J.indexOf("Weak") !== -1, b = m ? "set" : "add", N = Z[J], G = N && N.prototype, r = N, j = {}, D = function(U) {
              var k = W(G[U]);
              h(G, U, U == "add" ? function(al) {
                return k(this, al === 0 ? 0 : al), this;
              } : U == "delete" ? function(q) {
                return d && !n(q) ? !1 : k(this, q === 0 ? 0 : q);
              } : U == "get" ? function(al) {
                return d && !n(al) ? void 0 : k(this, al === 0 ? 0 : al);
              } : U == "has" ? function(al) {
                return d && !n(al) ? !1 : k(this, al === 0 ? 0 : al);
              } : function(al, Ml) {
                return k(this, al === 0 ? 0 : al, Ml), this;
              });
            }, f = y(J, !x(N) || !(d || G.forEach && !V(function() {
              new N().entries().next();
            })));
            if (f)
              r = e.getConstructor(u, J, m, b), p.enable();
            else if (y(J, !0)) {
              var P = new r(), B = P[b](d ? {} : -0, 1) != P, A = V(function() {
                P.has(1);
              }), H = S(function(U) {
                new N(U);
              }), O = !d && V(function() {
                for (var U = new N(), k = 5; k--; )
                  U[b](k, k);
                return !U.has(-0);
              });
              H || (r = u(function(U, k) {
                M(U, G);
                var q = R(new N(), U, r);
                return k != null && X(k, q[b], {
                  that: q,
                  AS_ENTRIES: m
                }), q;
              }), r.prototype = G, G.constructor = r), (A || O) && (D("delete"), D("has"), m && D("get")), (O || B) && D(b), d && G.clear && delete G.clear;
            }
            return j[J] = r, t({
              global: !0,
              constructor: !0,
              forced: r != N
            }, j), o(r, J), d || e.setStrong(r, J, m), r;
          };
        },
        /* 98 */
        /***/
        (L, c, i) => {
          var t = i(6), Z = i(17), W = i(56), y = i(22), h = i(40), p = i(46).f, X = i(59), M = i(99), x = i(102), n = i(42), V = i(104), S = !1, o = n("meta"), R = 0, J = function(N) {
            p(N, o, {
              value: {
                objectID: "O" + R++,
                weakData: {}
              }
            });
          }, u = function(N, G) {
            if (!y(N))
              return typeof N == "symbol" ? N : (typeof N == "string" ? "S" : "P") + N;
            if (!h(N, o)) {
              if (!x(N))
                return "F";
              if (!G)
                return "E";
              J(N);
            }
            return N[o].objectID;
          }, e = function(N, G) {
            if (!h(N, o)) {
              if (!x(N))
                return !0;
              if (!G)
                return !1;
              J(N);
            }
            return N[o].weakData;
          }, m = function(N) {
            return V && S && x(N) && !h(N, o) && J(N), N;
          }, d = function() {
            b.enable = function() {
            }, S = !0;
            var N = X.f, G = Z([].splice), r = {};
            r[o] = 1, N(r).length && (X.f = function(j) {
              for (var D = N(j), f = 0, P = D.length; f < P; f++)
                if (D[f] === o) {
                  G(D, f, 1);
                  break;
                }
              return D;
            }, t({
              target: "Object",
              stat: !0,
              forced: !0
            }, { getOwnPropertyNames: M.f }));
          }, b = L.exports = {
            enable: d,
            fastKey: u,
            getWeakData: e,
            onFreeze: m
          };
          W[o] = !0;
        },
        /* 99 */
        /***/
        (L, c, i) => {
          var t = i(18), Z = i(15), W = i(59).f, y = i(100), h = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], p = function(X) {
            try {
              return W(X);
            } catch {
              return y(h);
            }
          };
          L.exports.f = function(M) {
            return h && t(M) == "Window" ? p(M) : W(Z(M));
          };
        },
        /* 100 */
        /***/
        (L, c, i) => {
          var t = i(62), Z = i(65), W = i(101), y = Array, h = Math.max;
          L.exports = function(p, X, M) {
            for (var x = Z(p), n = t(X, x), V = t(M === void 0 ? x : M, x), S = y(h(V - n, 0)), o = 0; n < V; n++, o++)
              W(S, o, p[n]);
            return S.length = o, S;
          };
        },
        /* 101 */
        /***/
        (L, c, i) => {
          var t = i(20), Z = i(46), W = i(14);
          L.exports = function(y, h, p) {
            var X = t(h);
            X in y ? Z.f(y, X, W(0, p)) : y[X] = p;
          };
        },
        /* 102 */
        /***/
        (L, c, i) => {
          var t = i(10), Z = i(22), W = i(18), y = i(103), h = Object.isExtensible, p = t(function() {
          });
          L.exports = p || y ? function(M) {
            return !Z(M) || y && W(M) == "ArrayBuffer" ? !1 : h ? h(M) : !0;
          } : h;
        },
        /* 103 */
        /***/
        (L, c, i) => {
          var t = i(10);
          L.exports = t(function() {
            if (typeof ArrayBuffer == "function") {
              var Z = new ArrayBuffer(8);
              Object.isExtensible(Z) && Object.defineProperty(Z, "a", { value: 8 });
            }
          });
        },
        /* 104 */
        /***/
        (L, c, i) => {
          var t = i(10);
          L.exports = !t(function() {
            return Object.isExtensible(Object.preventExtensions({}));
          });
        },
        /* 105 */
        /***/
        (L, c, i) => {
          var t = i(106), Z = i(11), W = i(48), y = i(33), h = i(107), p = i(65), X = i(26), M = i(108), x = i(109), n = i(110), V = TypeError, S = function(R, J) {
            this.stopped = R, this.result = J;
          }, o = S.prototype;
          L.exports = function(R, J, u) {
            var e = u && u.that, m = !!(u && u.AS_ENTRIES), d = !!(u && u.IS_RECORD), b = !!(u && u.IS_ITERATOR), N = !!(u && u.INTERRUPTED), G = t(J, e), r, j, D, f, P, B, A, H = function(U) {
              return r && n(r, "normal", U), new S(!0, U);
            }, O = function(U) {
              return m ? (W(U), N ? G(U[0], U[1], H) : G(U[0], U[1])) : N ? G(U, H) : G(U);
            };
            if (d)
              r = R.iterator;
            else if (b)
              r = R;
            else {
              if (j = x(R), !j)
                throw V(y(R) + " is not iterable");
              if (h(j)) {
                for (D = 0, f = p(R); f > D; D++)
                  if (P = O(R[D]), P && X(o, P))
                    return P;
                return new S(!1);
              }
              r = M(R, j);
            }
            for (B = d ? R.next : r.next; !(A = Z(B, r)).done; ) {
              try {
                P = O(A.value);
              } catch (U) {
                n(r, "throw", U);
              }
              if (typeof P == "object" && P && X(o, P))
                return P;
            }
            return new S(!1);
          };
        },
        /* 106 */
        /***/
        (L, c, i) => {
          var t = i(17), Z = i(32), W = i(12), y = t(t.bind);
          L.exports = function(h, p) {
            return Z(h), p === void 0 ? h : W ? y(h, p) : function() {
              return h.apply(p, arguments);
            };
          };
        },
        /* 107 */
        /***/
        (L, c, i) => {
          var t = i(35), Z = i(88), W = t("iterator"), y = Array.prototype;
          L.exports = function(h) {
            return h !== void 0 && (Z.Array === h || y[W] === h);
          };
        },
        /* 108 */
        /***/
        (L, c, i) => {
          var t = i(11), Z = i(32), W = i(48), y = i(33), h = i(109), p = TypeError;
          L.exports = function(X, M) {
            var x = arguments.length < 2 ? h(X) : M;
            if (Z(x))
              return W(t(x, X));
            throw p(y(X) + " is not iterable");
          };
        },
        /* 109 */
        /***/
        (L, c, i) => {
          var t = i(80), Z = i(31), W = i(88), y = i(35), h = y("iterator");
          L.exports = function(p) {
            if (p != null)
              return Z(p, h) || Z(p, "@@iterator") || W[t(p)];
          };
        },
        /* 110 */
        /***/
        (L, c, i) => {
          var t = i(11), Z = i(48), W = i(31);
          L.exports = function(y, h, p) {
            var X, M;
            Z(y);
            try {
              if (X = W(y, "return"), !X) {
                if (h === "throw")
                  throw p;
                return p;
              }
              X = t(X, y);
            } catch (x) {
              M = !0, X = x;
            }
            if (h === "throw")
              throw p;
            if (M)
              throw X;
            return Z(X), p;
          };
        },
        /* 111 */
        /***/
        (L, c, i) => {
          var t = i(26), Z = TypeError;
          L.exports = function(W, y) {
            if (t(y, W))
              return W;
            throw Z("Incorrect invocation");
          };
        },
        /* 112 */
        /***/
        (L, c, i) => {
          var t = i(35), Z = t("iterator"), W = !1;
          try {
            var y = 0, h = {
              next: function() {
                return { done: !!y++ };
              },
              return: function() {
                W = !0;
              }
            };
            h[Z] = function() {
              return this;
            }, Array.from(h, function() {
              throw 2;
            });
          } catch {
          }
          L.exports = function(p, X) {
            if (!X && !W)
              return !1;
            var M = !1;
            try {
              var x = {};
              x[Z] = function() {
                return {
                  next: function() {
                    return { done: M = !0 };
                  }
                };
              }, p(x);
            } catch {
            }
            return M;
          };
        },
        /* 113 */
        /***/
        (L, c, i) => {
          var t = i(23), Z = i(22), W = i(84);
          L.exports = function(y, h, p) {
            var X, M;
            return W && t(X = h.constructor) && X !== p && Z(M = X.prototype) && M !== p.prototype && W(y, M), y;
          };
        },
        /* 114 */
        /***/
        (L, c, i) => {
          var t = i(46).f, Z = i(71), W = i(115), y = i(106), h = i(111), p = i(105), X = i(89), M = i(116), x = i(9), n = i(98).fastKey, V = i(53), S = V.set, o = V.getterFor;
          L.exports = {
            getConstructor: function(R, J, u, e) {
              var m = R(function(r, j) {
                h(r, d), S(r, {
                  type: J,
                  index: Z(null),
                  first: void 0,
                  last: void 0,
                  size: 0
                }), x || (r.size = 0), j != null && p(j, r[e], {
                  that: r,
                  AS_ENTRIES: u
                });
              }), d = m.prototype, b = o(J), N = function(r, j, D) {
                var f = b(r), P = G(r, j), B, A;
                return P ? P.value = D : (f.last = P = {
                  index: A = n(j, !0),
                  key: j,
                  value: D,
                  previous: B = f.last,
                  next: void 0,
                  removed: !1
                }, f.first || (f.first = P), B && (B.next = P), x ? f.size++ : r.size++, A !== "F" && (f.index[A] = P)), r;
              }, G = function(r, j) {
                var D = b(r), f = n(j), P;
                if (f !== "F")
                  return D.index[f];
                for (P = D.first; P; P = P.next)
                  if (P.key == j)
                    return P;
              };
              return W(d, {
                clear: function() {
                  for (var j = this, D = b(j), f = D.index, P = D.first; P; )
                    P.removed = !0, P.previous && (P.previous = P.previous.next = void 0), delete f[P.index], P = P.next;
                  D.first = D.last = void 0, x ? D.size = 0 : j.size = 0;
                },
                delete: function(r) {
                  var j = this, D = b(j), f = G(j, r);
                  if (f) {
                    var P = f.next, B = f.previous;
                    delete D.index[f.index], f.removed = !0, B && (B.next = P), P && (P.previous = B), D.first == f && (D.first = P), D.last == f && (D.last = B), x ? D.size-- : j.size--;
                  }
                  return !!f;
                },
                forEach: function(j) {
                  for (var D = b(this), f = y(j, arguments.length > 1 ? arguments[1] : void 0), P; P = P ? P.next : D.first; )
                    for (f(P.value, P.key, this); P && P.removed; )
                      P = P.previous;
                },
                has: function(j) {
                  return !!G(this, j);
                }
              }), W(d, u ? {
                get: function(j) {
                  var D = G(this, j);
                  return D && D.value;
                },
                set: function(j, D) {
                  return N(this, j === 0 ? 0 : j, D);
                }
              } : {
                add: function(j) {
                  return N(this, j = j === 0 ? 0 : j, j);
                }
              }), x && t(d, "size", {
                get: function() {
                  return b(this).size;
                }
              }), m;
            },
            setStrong: function(R, J, u) {
              var e = J + " Iterator", m = o(J), d = o(e);
              X(R, J, function(b, N) {
                S(this, {
                  type: e,
                  target: b,
                  state: m(b),
                  kind: N,
                  last: void 0
                });
              }, function() {
                for (var b = d(this), N = b.kind, G = b.last; G && G.removed; )
                  G = G.previous;
                return !b.target || !(b.last = G = G ? G.next : b.state.first) ? (b.target = void 0, {
                  value: void 0,
                  done: !0
                }) : N == "keys" ? {
                  value: G.key,
                  done: !1
                } : N == "values" ? {
                  value: G.value,
                  done: !1
                } : {
                  value: [
                    G.key,
                    G.value
                  ],
                  done: !1
                };
              }, u ? "entries" : "values", !u, !0), M(J);
            }
          };
        },
        /* 115 */
        /***/
        (L, c, i) => {
          var t = i(49);
          L.exports = function(Z, W, y) {
            for (var h in W)
              t(Z, h, W[h], y);
            return Z;
          };
        },
        /* 116 */
        /***/
        (L, c, i) => {
          var t = i(25), Z = i(46), W = i(35), y = i(9), h = W("species");
          L.exports = function(p) {
            var X = t(p), M = Z.f;
            y && X && !X[h] && M(X, h, {
              configurable: !0,
              get: function() {
                return this;
              }
            });
          };
        },
        /* 117 */
        /***/
        (L, c, i) => {
          i(118);
        },
        /* 118 */
        /***/
        (L, c, i) => {
          var t = i(97), Z = i(114);
          t("Set", function(W) {
            return function() {
              return W(this, arguments.length ? arguments[0] : void 0);
            };
          }, Z);
        },
        /* 119 */
        /***/
        (L, c, i) => {
          var t = i(37), Z = i(6), W = i(7), y = i(25), h = i(17), p = i(10), X = i(42), M = i(23), x = i(120), n = i(22), V = i(24), S = i(105), o = i(48), R = i(80), J = i(40), u = i(101), e = i(45), m = i(65), d = i(121), b = i(122), N = i(124), G = i(29), r = i(125), j = i(126), D = i(127), f = W.Object, P = W.Date, B = W.Error, A = W.EvalError, H = W.RangeError, O = W.ReferenceError, U = W.SyntaxError, k = W.TypeError, q = W.URIError, al = W.PerformanceMark, Ml = W.WebAssembly, wl = Ml && Ml.CompileError || B, Q = Ml && Ml.LinkError || B, T = Ml && Ml.RuntimeError || B, w = y("DOMException"), g = y("Set"), K = y("Map"), a = K.prototype, Y = h(a.has), z = h(a.get), C = h(a.set), F = h(g.prototype.add), v = y("Object", "keys"), $ = h([].push), il = h((!0).valueOf), dl = h(1 .valueOf), el = h("".valueOf), bl = h(P.prototype.getTime), ml = X("structuredClone"), Gl = "DataCloneError", Yl = "Transferring", yl = function(Nl) {
            return !p(function() {
              var zl = new W.Set([7]), kl = Nl(zl), nl = Nl(f(7));
              return kl == zl || !kl.has(7) || typeof nl != "object" || nl != 7;
            }) && Nl;
          }, Vl = function(Nl, zl) {
            return !p(function() {
              var kl = new zl(), nl = Nl({
                a: kl,
                b: kl
              });
              return !(nl && nl.a === nl.b && nl.a instanceof zl && nl.a.stack === kl.stack);
            });
          }, Dl = function(Nl) {
            return !p(function() {
              var zl = Nl(new W.AggregateError([1], ml, { cause: 3 }));
              return zl.name != "AggregateError" || zl.errors[0] != 1 || zl.message != ml || zl.cause != 3;
            });
          }, Xl = W.structuredClone, Hl = t || !Vl(Xl, B) || !Vl(Xl, w) || !Dl(Xl), Al = !Xl && yl(function(Nl) {
            return new al(ml, { detail: Nl }).detail;
          }), Sl = yl(Xl) || Al, ol = function(Nl) {
            throw new w("Uncloneable type: " + Nl, Gl);
          }, cl = function(Nl, zl) {
            throw new w((zl || "Cloning") + " of " + Nl + " cannot be properly polyfilled in this engine", Gl);
          }, Il = function(Nl, zl) {
            if (V(Nl) && ol("Symbol"), !n(Nl))
              return Nl;
            if (zl) {
              if (Y(zl, Nl))
                return z(zl, Nl);
            } else
              zl = new K();
            var kl = R(Nl), nl = !1, ll, sl, hl, Cl, jl, ul, Zl, Ll, rl, Fl;
            switch (kl) {
              case "Array":
                hl = [], nl = !0;
                break;
              case "Object":
                hl = {}, nl = !0;
                break;
              case "Map":
                hl = new K(), nl = !0;
                break;
              case "Set":
                hl = new g(), nl = !0;
                break;
              case "RegExp":
                hl = new RegExp(Nl.source, b(Nl));
                break;
              case "Error":
                switch (sl = Nl.name, sl) {
                  case "AggregateError":
                    hl = y("AggregateError")([]);
                    break;
                  case "EvalError":
                    hl = A();
                    break;
                  case "RangeError":
                    hl = H();
                    break;
                  case "ReferenceError":
                    hl = O();
                    break;
                  case "SyntaxError":
                    hl = U();
                    break;
                  case "TypeError":
                    hl = k();
                    break;
                  case "URIError":
                    hl = q();
                    break;
                  case "CompileError":
                    hl = wl();
                    break;
                  case "LinkError":
                    hl = Q();
                    break;
                  case "RuntimeError":
                    hl = T();
                    break;
                  default:
                    hl = B();
                }
                nl = !0;
                break;
              case "DOMException":
                hl = new w(Nl.message, Nl.name), nl = !0;
                break;
              case "DataView":
              case "Int8Array":
              case "Uint8Array":
              case "Uint8ClampedArray":
              case "Int16Array":
              case "Uint16Array":
              case "Int32Array":
              case "Uint32Array":
              case "Float32Array":
              case "Float64Array":
              case "BigInt64Array":
              case "BigUint64Array":
                ll = W[kl], n(ll) || cl(kl), hl = new ll(Il(Nl.buffer, zl), Nl.byteOffset, kl === "DataView" ? Nl.byteLength : Nl.length);
                break;
              case "DOMQuad":
                try {
                  hl = new DOMQuad(Il(Nl.p1, zl), Il(Nl.p2, zl), Il(Nl.p3, zl), Il(Nl.p4, zl));
                } catch {
                  Sl ? hl = Sl(Nl) : cl(kl);
                }
                break;
              case "FileList":
                if (ll = W.DataTransfer, x(ll)) {
                  for (Cl = new ll(), jl = 0, ul = m(Nl); jl < ul; jl++)
                    Cl.items.add(Il(Nl[jl], zl));
                  hl = Cl.files;
                } else Sl ? hl = Sl(Nl) : cl(kl);
                break;
              case "ImageData":
                try {
                  hl = new ImageData(Il(Nl.data, zl), Nl.width, Nl.height, { colorSpace: Nl.colorSpace });
                } catch {
                  Sl ? hl = Sl(Nl) : cl(kl);
                }
                break;
              default:
                if (Sl)
                  hl = Sl(Nl);
                else
                  switch (kl) {
                    case "BigInt":
                      hl = f(Nl.valueOf());
                      break;
                    case "Boolean":
                      hl = f(il(Nl));
                      break;
                    case "Number":
                      hl = f(dl(Nl));
                      break;
                    case "String":
                      hl = f(el(Nl));
                      break;
                    case "Date":
                      hl = new P(bl(Nl));
                      break;
                    case "ArrayBuffer":
                      ll = W.DataView, !ll && typeof Nl.slice != "function" && cl(kl);
                      try {
                        if (typeof Nl.slice == "function")
                          hl = Nl.slice(0);
                        else
                          for (ul = Nl.byteLength, hl = new ArrayBuffer(ul), rl = new ll(Nl), Fl = new ll(hl), jl = 0; jl < ul; jl++)
                            Fl.setUint8(jl, rl.getUint8(jl));
                      } catch {
                        throw new w("ArrayBuffer is detached", Gl);
                      }
                      break;
                    case "SharedArrayBuffer":
                      hl = Nl;
                      break;
                    case "Blob":
                      try {
                        hl = Nl.slice(0, Nl.size, Nl.type);
                      } catch {
                        cl(kl);
                      }
                      break;
                    case "DOMPoint":
                    case "DOMPointReadOnly":
                      ll = W[kl];
                      try {
                        hl = ll.fromPoint ? ll.fromPoint(Nl) : new ll(Nl.x, Nl.y, Nl.z, Nl.w);
                      } catch {
                        cl(kl);
                      }
                      break;
                    case "DOMRect":
                    case "DOMRectReadOnly":
                      ll = W[kl];
                      try {
                        hl = ll.fromRect ? ll.fromRect(Nl) : new ll(Nl.x, Nl.y, Nl.width, Nl.height);
                      } catch {
                        cl(kl);
                      }
                      break;
                    case "DOMMatrix":
                    case "DOMMatrixReadOnly":
                      ll = W[kl];
                      try {
                        hl = ll.fromMatrix ? ll.fromMatrix(Nl) : new ll(Nl);
                      } catch {
                        cl(kl);
                      }
                      break;
                    case "AudioData":
                    case "VideoFrame":
                      M(Nl.clone) || cl(kl);
                      try {
                        hl = Nl.clone();
                      } catch {
                        ol(kl);
                      }
                      break;
                    case "File":
                      try {
                        hl = new File([Nl], Nl.name, Nl);
                      } catch {
                        cl(kl);
                      }
                      break;
                    case "CryptoKey":
                    case "GPUCompilationMessage":
                    case "GPUCompilationInfo":
                    case "ImageBitmap":
                    case "RTCCertificate":
                    case "WebAssembly.Module":
                      cl(kl);
                    default:
                      ol(kl);
                  }
            }
            if (C(zl, Nl, hl), nl)
              switch (kl) {
                case "Array":
                case "Object":
                  for (Zl = v(Nl), jl = 0, ul = m(Zl); jl < ul; jl++)
                    Ll = Zl[jl], u(hl, Ll, Il(Nl[Ll], zl));
                  break;
                case "Map":
                  Nl.forEach(function(Kl, Ol) {
                    C(hl, Il(Ol, zl), Il(Kl, zl));
                  });
                  break;
                case "Set":
                  Nl.forEach(function(Kl) {
                    F(hl, Il(Kl, zl));
                  });
                  break;
                case "Error":
                  e(hl, "message", Il(Nl.message, zl)), J(Nl, "cause") && e(hl, "cause", Il(Nl.cause, zl)), sl == "AggregateError" && (hl.errors = Il(Nl.errors, zl));
                case "DOMException":
                  N && e(hl, "stack", Il(Nl.stack, zl));
              }
            return hl;
          }, Jl = Xl && !p(function() {
            if (j && G > 92 || D && G > 94 || r && G > 97)
              return !1;
            var Nl = new ArrayBuffer(8), zl = Xl(Nl, { transfer: [Nl] });
            return Nl.byteLength != 0 || zl.byteLength != 8;
          }), fl = function(Nl, zl) {
            if (!n(Nl))
              throw k("Transfer option cannot be converted to a sequence");
            var kl = [];
            S(Nl, function(rl) {
              $(kl, o(rl));
            });
            var nl = 0, ll = m(kl), sl, hl, Cl, jl, ul, Zl, Ll;
            if (Jl)
              for (jl = Xl(kl, { transfer: kl }); nl < ll; )
                C(zl, kl[nl], jl[nl++]);
            else
              for (; nl < ll; ) {
                if (sl = kl[nl++], Y(zl, sl))
                  throw new w("Duplicate transferable", Gl);
                switch (hl = R(sl), hl) {
                  case "ImageBitmap":
                    Cl = W.OffscreenCanvas, x(Cl) || cl(hl, Yl);
                    try {
                      Zl = new Cl(sl.width, sl.height), Ll = Zl.getContext("bitmaprenderer"), Ll.transferFromImageBitmap(sl), ul = Zl.transferToImageBitmap();
                    } catch {
                    }
                    break;
                  case "AudioData":
                  case "VideoFrame":
                    (!M(sl.clone) || !M(sl.close)) && cl(hl, Yl);
                    try {
                      ul = sl.clone(), sl.close();
                    } catch {
                    }
                    break;
                  case "ArrayBuffer":
                  case "MessagePort":
                  case "OffscreenCanvas":
                  case "ReadableStream":
                  case "TransformStream":
                  case "WritableStream":
                    cl(hl, Yl);
                }
                if (ul === void 0)
                  throw new w("This object cannot be transferred: " + hl, Gl);
                C(zl, sl, ul);
              }
          };
          Z({
            global: !0,
            enumerable: !0,
            sham: !Jl,
            forced: Hl
          }, {
            structuredClone: function(zl) {
              var kl = d(arguments.length, 1) > 1 && arguments[1] != null ? o(arguments[1]) : void 0, nl = kl ? kl.transfer : void 0, ll;
              return nl !== void 0 && (ll = new K(), fl(nl, ll)), Il(zl, ll);
            }
          });
        },
        /* 120 */
        /***/
        (L, c, i) => {
          var t = i(17), Z = i(10), W = i(23), y = i(80), h = i(25), p = i(52), X = function() {
          }, M = [], x = h("Reflect", "construct"), n = /^\s*(?:class|function)\b/, V = t(n.exec), S = !n.exec(X), o = function(u) {
            if (!W(u))
              return !1;
            try {
              return x(X, M, u), !0;
            } catch {
              return !1;
            }
          }, R = function(u) {
            if (!W(u))
              return !1;
            switch (y(u)) {
              case "AsyncFunction":
              case "GeneratorFunction":
              case "AsyncGeneratorFunction":
                return !1;
            }
            try {
              return S || !!V(n, p(u));
            } catch {
              return !0;
            }
          };
          R.sham = !0, L.exports = !x || Z(function() {
            var J;
            return o(o.call) || !o(Object) || !o(function() {
              J = !0;
            }) || J;
          }) ? R : o;
        },
        /* 121 */
        /***/
        (L) => {
          var c = TypeError;
          L.exports = function(i, t) {
            if (i < t)
              throw c("Not enough arguments");
            return i;
          };
        },
        /* 122 */
        /***/
        (L, c, i) => {
          var t = i(11), Z = i(40), W = i(26), y = i(123), h = RegExp.prototype;
          L.exports = function(p) {
            var X = p.flags;
            return X === void 0 && !("flags" in h) && !Z(p, "flags") && W(h, p) ? t(y, p) : X;
          };
        },
        /* 123 */
        /***/
        (L, c, i) => {
          var t = i(48);
          L.exports = function() {
            var Z = t(this), W = "";
            return Z.hasIndices && (W += "d"), Z.global && (W += "g"), Z.ignoreCase && (W += "i"), Z.multiline && (W += "m"), Z.dotAll && (W += "s"), Z.unicode && (W += "u"), Z.unicodeSets && (W += "v"), Z.sticky && (W += "y"), W;
          };
        },
        /* 124 */
        /***/
        (L, c, i) => {
          var t = i(10), Z = i(14);
          L.exports = !t(function() {
            var W = Error("a");
            return "stack" in W ? (Object.defineProperty(W, "stack", Z(1, 7)), W.stack !== 7) : !0;
          });
        },
        /* 125 */
        /***/
        (L, c, i) => {
          var t = i(126), Z = i(127);
          L.exports = !t && !Z && typeof window == "object" && typeof document == "object";
        },
        /* 126 */
        /***/
        (L) => {
          L.exports = typeof Deno == "object" && Deno && typeof Deno.version == "object";
        },
        /* 127 */
        /***/
        (L, c, i) => {
          var t = i(18), Z = i(7);
          L.exports = t(Z.process) == "process";
        },
        /* 128 */
        /***/
        (L, c, i) => {
          var t = i(7);
          L.exports = t;
        },
        /* 129 */
        /***/
        (__unused_webpack_module, exports, __w_pdfjs_require__) => {
          Object.defineProperty(exports, "__esModule", {
            value: !0
          }), exports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0, exports.getDocument = getDocument, exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory, exports.version = void 0;
          var _util = __w_pdfjs_require__(1), _annotation_storage = __w_pdfjs_require__(130), _display_utils = __w_pdfjs_require__(133), _font_loader = __w_pdfjs_require__(136), _canvas = __w_pdfjs_require__(137), _worker_options = __w_pdfjs_require__(140), _is_node = __w_pdfjs_require__(3), _message_handler = __w_pdfjs_require__(141), _metadata = __w_pdfjs_require__(142), _optional_content_config = __w_pdfjs_require__(143), _transport_stream = __w_pdfjs_require__(144), _xfa_text = __w_pdfjs_require__(145);
          function _classPrivateMethodInitSpec(L, c) {
            _checkPrivateRedeclaration(L, c), c.add(L);
          }
          function _classPrivateMethodGet(L, c, i) {
            if (!c.has(L))
              throw new TypeError("attempted to get private field on non-instance");
            return i;
          }
          function _classPrivateFieldInitSpec(L, c, i) {
            _checkPrivateRedeclaration(L, c), c.set(L, i);
          }
          function _checkPrivateRedeclaration(L, c) {
            if (c.has(L))
              throw new TypeError("Cannot initialize the same private elements twice on an object");
          }
          function _classPrivateFieldSet(L, c, i) {
            var t = _classExtractFieldDescriptor(L, c, "set");
            return _classApplyDescriptorSet(L, t, i), i;
          }
          function _classPrivateFieldGet(L, c) {
            var i = _classExtractFieldDescriptor(L, c, "get");
            return _classApplyDescriptorGet(L, i);
          }
          function _classExtractFieldDescriptor(L, c, i) {
            if (!c.has(L))
              throw new TypeError("attempted to " + i + " private field on non-instance");
            return c.get(L);
          }
          function _classStaticPrivateFieldSpecSet(L, c, i, t) {
            return _classCheckPrivateStaticAccess(L, c), _classCheckPrivateStaticFieldDescriptor(i, "set"), _classApplyDescriptorSet(L, i, t), t;
          }
          function _classApplyDescriptorSet(L, c, i) {
            if (c.set)
              c.set.call(L, i);
            else {
              if (!c.writable)
                throw new TypeError("attempted to set read only private field");
              c.value = i;
            }
          }
          function _classStaticPrivateFieldSpecGet(L, c, i) {
            return _classCheckPrivateStaticAccess(L, c), _classCheckPrivateStaticFieldDescriptor(i, "get"), _classApplyDescriptorGet(L, i);
          }
          function _classCheckPrivateStaticFieldDescriptor(L, c) {
            if (L === void 0)
              throw new TypeError("attempted to " + c + " private static field before its declaration");
          }
          function _classCheckPrivateStaticAccess(L, c) {
            if (L !== c)
              throw new TypeError("Private static access of wrong provenance");
          }
          function _classApplyDescriptorGet(L, c) {
            return c.get ? c.get.call(L) : c.value;
          }
          const DEFAULT_RANGE_CHUNK_SIZE = 65536, RENDERING_CANCELLED_TIMEOUT = 100;
          let DefaultCanvasFactory = _display_utils.DOMCanvasFactory;
          exports.DefaultCanvasFactory = DefaultCanvasFactory;
          let DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory;
          exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
          let DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory;
          if (exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory, _is_node.isNodeJS) {
            const {
              NodeCanvasFactory: L,
              NodeCMapReaderFactory: c,
              NodeStandardFontDataFactory: i
            } = __w_pdfjs_require__(146);
            exports.DefaultCanvasFactory = DefaultCanvasFactory = L, exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = c, exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = i;
          }
          let createPDFNetworkStream;
          function setPDFNetworkStreamFactory(L) {
            createPDFNetworkStream = L;
          }
          function getDocument(L) {
            const c = new PDFDocumentLoadingTask();
            let i;
            if (typeof L == "string" || L instanceof URL)
              i = {
                url: L
              };
            else if ((0, _util.isArrayBuffer)(L))
              i = {
                data: L
              };
            else if (L instanceof PDFDataRangeTransport)
              i = {
                range: L
              };
            else {
              if (typeof L != "object")
                throw new Error("Invalid parameter in getDocument, need either string, URL, TypedArray, or parameter object.");
              if (!L.url && !L.data && !L.range)
                throw new Error("Invalid parameter object: need either .data, .range or .url");
              i = L;
            }
            const t = /* @__PURE__ */ Object.create(null);
            let Z = null, W = null;
            for (const h in i) {
              const p = i[h];
              switch (h) {
                case "url":
                  if (typeof window < "u")
                    try {
                      t[h] = new URL(p, window.location).href;
                      continue;
                    } catch (X) {
                      (0, _util.warn)(`Cannot create valid URL: "${X}".`);
                    }
                  else if (typeof p == "string" || p instanceof URL) {
                    t[h] = p.toString();
                    continue;
                  }
                  throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
                case "range":
                  Z = p;
                  continue;
                case "worker":
                  W = p;
                  continue;
                case "data":
                  if (_is_node.isNodeJS && typeof Buffer < "u" && p instanceof Buffer)
                    t[h] = new Uint8Array(p);
                  else {
                    if (p instanceof Uint8Array)
                      break;
                    if (typeof p == "string")
                      t[h] = (0, _util.stringToBytes)(p);
                    else if (typeof p == "object" && p !== null && !isNaN(p.length))
                      t[h] = new Uint8Array(p);
                    else if ((0, _util.isArrayBuffer)(p))
                      t[h] = new Uint8Array(p);
                    else
                      throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
                  }
                  continue;
              }
              t[h] = p;
            }
            if (t.CMapReaderFactory = t.CMapReaderFactory || DefaultCMapReaderFactory, t.StandardFontDataFactory = t.StandardFontDataFactory || DefaultStandardFontDataFactory, t.ignoreErrors = t.stopAtErrors !== !0, t.fontExtraProperties = t.fontExtraProperties === !0, t.pdfBug = t.pdfBug === !0, t.enableXfa = t.enableXfa === !0, (!Number.isInteger(t.rangeChunkSize) || t.rangeChunkSize < 1) && (t.rangeChunkSize = DEFAULT_RANGE_CHUNK_SIZE), (typeof t.docBaseUrl != "string" || (0, _display_utils.isDataScheme)(t.docBaseUrl)) && (t.docBaseUrl = null), (!Number.isInteger(t.maxImageSize) || t.maxImageSize < -1) && (t.maxImageSize = -1), typeof t.cMapUrl != "string" && (t.cMapUrl = null), typeof t.standardFontDataUrl != "string" && (t.standardFontDataUrl = null), typeof t.useWorkerFetch != "boolean" && (t.useWorkerFetch = t.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && t.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory), typeof t.isEvalSupported != "boolean" && (t.isEvalSupported = !0), typeof t.disableFontFace != "boolean" && (t.disableFontFace = _is_node.isNodeJS), typeof t.useSystemFonts != "boolean" && (t.useSystemFonts = !_is_node.isNodeJS && !t.disableFontFace), (typeof t.ownerDocument != "object" || t.ownerDocument === null) && (t.ownerDocument = globalThis.document), typeof t.disableRange != "boolean" && (t.disableRange = !1), typeof t.disableStream != "boolean" && (t.disableStream = !1), typeof t.disableAutoFetch != "boolean" && (t.disableAutoFetch = !1), (0, _util.setVerbosityLevel)(t.verbosity), !W) {
              const h = {
                verbosity: t.verbosity,
                port: _worker_options.GlobalWorkerOptions.workerPort
              };
              W = h.port ? PDFWorker.fromPort(h) : new PDFWorker(h), c._worker = W;
            }
            const y = c.docId;
            return W.promise.then(function() {
              if (c.destroyed)
                throw new Error("Loading aborted");
              const h = _fetchDocument(W, t, Z, y), p = new Promise(function(X) {
                let M;
                Z ? M = new _transport_stream.PDFDataTransportStream({
                  length: t.length,
                  initialData: t.initialData,
                  progressiveDone: t.progressiveDone,
                  contentDispositionFilename: t.contentDispositionFilename,
                  disableRange: t.disableRange,
                  disableStream: t.disableStream
                }, Z) : t.data || (M = createPDFNetworkStream({
                  url: t.url,
                  length: t.length,
                  httpHeaders: t.httpHeaders,
                  withCredentials: t.withCredentials,
                  rangeChunkSize: t.rangeChunkSize,
                  disableRange: t.disableRange,
                  disableStream: t.disableStream
                })), X(M);
              });
              return Promise.all([h, p]).then(function(X) {
                let [M, x] = X;
                if (c.destroyed)
                  throw new Error("Loading aborted");
                const n = new _message_handler.MessageHandler(y, M, W.port), V = new WorkerTransport(n, c, x, t);
                c._transport = V, n.send("Ready", null);
              });
            }).catch(c._capability.reject), c;
          }
          async function _fetchDocument(L, c, i, t) {
            if (L.destroyed)
              throw new Error("Worker was destroyed");
            i && (c.length = i.length, c.initialData = i.initialData, c.progressiveDone = i.progressiveDone, c.contentDispositionFilename = i.contentDispositionFilename);
            const Z = await L.messageHandler.sendWithPromise("GetDocRequest", {
              docId: t,
              apiVersion: "2.16.105",
              source: {
                data: c.data,
                url: c.url,
                password: c.password,
                disableAutoFetch: c.disableAutoFetch,
                rangeChunkSize: c.rangeChunkSize,
                length: c.length
              },
              maxImageSize: c.maxImageSize,
              disableFontFace: c.disableFontFace,
              docBaseUrl: c.docBaseUrl,
              ignoreErrors: c.ignoreErrors,
              isEvalSupported: c.isEvalSupported,
              fontExtraProperties: c.fontExtraProperties,
              enableXfa: c.enableXfa,
              useSystemFonts: c.useSystemFonts,
              cMapUrl: c.useWorkerFetch ? c.cMapUrl : null,
              standardFontDataUrl: c.useWorkerFetch ? c.standardFontDataUrl : null
            });
            if (c.data && (c.data = null), L.destroyed)
              throw new Error("Worker was destroyed");
            return Z;
          }
          class PDFDocumentLoadingTask {
            constructor() {
              var c, i;
              this._capability = (0, _util.createPromiseCapability)(), this._transport = null, this._worker = null, this.docId = `d${_classStaticPrivateFieldSpecSet(PDFDocumentLoadingTask, PDFDocumentLoadingTask, _docId, (c = _classStaticPrivateFieldSpecGet(PDFDocumentLoadingTask, PDFDocumentLoadingTask, _docId), i = c++, c)), i}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null, this.onUnsupportedFeature = null;
            }
            get promise() {
              return this._capability.promise;
            }
            async destroy() {
              var c;
              this.destroyed = !0, await ((c = this._transport) === null || c === void 0 ? void 0 : c.destroy()), this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
            }
          }
          exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
          var _docId = {
            writable: !0,
            value: 0
          };
          class PDFDataRangeTransport {
            constructor(c, i) {
              let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, Z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
              this.length = c, this.initialData = i, this.progressiveDone = t, this.contentDispositionFilename = Z, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = (0, _util.createPromiseCapability)();
            }
            addRangeListener(c) {
              this._rangeListeners.push(c);
            }
            addProgressListener(c) {
              this._progressListeners.push(c);
            }
            addProgressiveReadListener(c) {
              this._progressiveReadListeners.push(c);
            }
            addProgressiveDoneListener(c) {
              this._progressiveDoneListeners.push(c);
            }
            onDataRange(c, i) {
              for (const t of this._rangeListeners)
                t(c, i);
            }
            onDataProgress(c, i) {
              this._readyCapability.promise.then(() => {
                for (const t of this._progressListeners)
                  t(c, i);
              });
            }
            onDataProgressiveRead(c) {
              this._readyCapability.promise.then(() => {
                for (const i of this._progressiveReadListeners)
                  i(c);
              });
            }
            onDataProgressiveDone() {
              this._readyCapability.promise.then(() => {
                for (const c of this._progressiveDoneListeners)
                  c();
              });
            }
            transportReady() {
              this._readyCapability.resolve();
            }
            requestDataRange(c, i) {
              (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
            }
            abort() {
            }
          }
          exports.PDFDataRangeTransport = PDFDataRangeTransport;
          class PDFDocumentProxy {
            constructor(c, i) {
              this._pdfInfo = c, this._transport = i, Object.defineProperty(this, "fingerprint", {
                get() {
                  return (0, _display_utils.deprecated)("`PDFDocumentProxy.fingerprint`, please use `PDFDocumentProxy.fingerprints` instead."), this.fingerprints[0];
                }
              }), Object.defineProperty(this, "getStats", {
                value: async () => ((0, _display_utils.deprecated)("`PDFDocumentProxy.getStats`, please use the `PDFDocumentProxy.stats`-getter instead."), this.stats || {
                  streamTypes: {},
                  fontTypes: {}
                })
              });
            }
            get annotationStorage() {
              return this._transport.annotationStorage;
            }
            get numPages() {
              return this._pdfInfo.numPages;
            }
            get fingerprints() {
              return this._pdfInfo.fingerprints;
            }
            get stats() {
              return this._transport.stats;
            }
            get isPureXfa() {
              return !!this._transport._htmlForXfa;
            }
            get allXfaHtml() {
              return this._transport._htmlForXfa;
            }
            getPage(c) {
              return this._transport.getPage(c);
            }
            getPageIndex(c) {
              return this._transport.getPageIndex(c);
            }
            getDestinations() {
              return this._transport.getDestinations();
            }
            getDestination(c) {
              return this._transport.getDestination(c);
            }
            getPageLabels() {
              return this._transport.getPageLabels();
            }
            getPageLayout() {
              return this._transport.getPageLayout();
            }
            getPageMode() {
              return this._transport.getPageMode();
            }
            getViewerPreferences() {
              return this._transport.getViewerPreferences();
            }
            getOpenAction() {
              return this._transport.getOpenAction();
            }
            getAttachments() {
              return this._transport.getAttachments();
            }
            getJavaScript() {
              return this._transport.getJavaScript();
            }
            getJSActions() {
              return this._transport.getDocJSActions();
            }
            getOutline() {
              return this._transport.getOutline();
            }
            getOptionalContentConfig() {
              return this._transport.getOptionalContentConfig();
            }
            getPermissions() {
              return this._transport.getPermissions();
            }
            getMetadata() {
              return this._transport.getMetadata();
            }
            getMarkInfo() {
              return this._transport.getMarkInfo();
            }
            getData() {
              return this._transport.getData();
            }
            getDownloadInfo() {
              return this._transport.downloadInfoCapability.promise;
            }
            cleanup() {
              let c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
              return this._transport.startCleanup(c || this.isPureXfa);
            }
            destroy() {
              return this.loadingTask.destroy();
            }
            get loadingParams() {
              return this._transport.loadingParams;
            }
            get loadingTask() {
              return this._transport.loadingTask;
            }
            saveDocument() {
              return this._transport.annotationStorage.size <= 0 && (0, _display_utils.deprecated)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead."), this._transport.saveDocument();
            }
            getFieldObjects() {
              return this._transport.getFieldObjects();
            }
            hasJSActions() {
              return this._transport.hasJSActions();
            }
            getCalculationOrderIds() {
              return this._transport.getCalculationOrderIds();
            }
          }
          exports.PDFDocumentProxy = PDFDocumentProxy;
          class PDFPageProxy {
            constructor(c, i, t, Z) {
              let W = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
              this._pageIndex = c, this._pageInfo = i, this._ownerDocument = Z, this._transport = t, this._stats = W ? new _display_utils.StatTimer() : null, this._pdfBug = W, this.commonObjs = t.commonObjs, this.objs = new PDFObjects(), this._bitmaps = /* @__PURE__ */ new Set(), this.cleanupAfterRender = !1, this.pendingCleanup = !1, this._intentStates = /* @__PURE__ */ new Map(), this._annotationPromises = /* @__PURE__ */ new Map(), this.destroyed = !1;
            }
            get pageNumber() {
              return this._pageIndex + 1;
            }
            get rotate() {
              return this._pageInfo.rotate;
            }
            get ref() {
              return this._pageInfo.ref;
            }
            get userUnit() {
              return this._pageInfo.userUnit;
            }
            get view() {
              return this._pageInfo.view;
            }
            getViewport() {
              let {
                scale: c,
                rotation: i = this.rotate,
                offsetX: t = 0,
                offsetY: Z = 0,
                dontFlip: W = !1
              } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              return new _display_utils.PageViewport({
                viewBox: this.view,
                scale: c,
                rotation: i,
                offsetX: t,
                offsetY: Z,
                dontFlip: W
              });
            }
            getAnnotations() {
              let {
                intent: c = "display"
              } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              const i = this._transport.getRenderingIntent(c);
              let t = this._annotationPromises.get(i.cacheKey);
              return t || (t = this._transport.getAnnotations(this._pageIndex, i.renderingIntent), this._annotationPromises.set(i.cacheKey, t), t = t.then((Z) => {
                for (const W of Z)
                  W.titleObj !== void 0 && Object.defineProperty(W, "title", {
                    get() {
                      return (0, _display_utils.deprecated)("`title`-property on annotation, please use `titleObj` instead."), W.titleObj.str;
                    }
                  }), W.contentsObj !== void 0 && Object.defineProperty(W, "contents", {
                    get() {
                      return (0, _display_utils.deprecated)("`contents`-property on annotation, please use `contentsObj` instead."), W.contentsObj.str;
                    }
                  });
                return Z;
              })), t;
            }
            getJSActions() {
              return this._jsActionsPromise || (this._jsActionsPromise = this._transport.getPageJSActions(this._pageIndex));
            }
            async getXfa() {
              var c;
              return ((c = this._transport._htmlForXfa) === null || c === void 0 ? void 0 : c.children[this._pageIndex]) || null;
            }
            render(c) {
              var i, t, Z;
              let {
                canvasContext: W,
                viewport: y,
                intent: h = "display",
                annotationMode: p = _util.AnnotationMode.ENABLE,
                transform: X = null,
                imageLayer: M = null,
                canvasFactory: x = null,
                background: n = null,
                optionalContentConfigPromise: V = null,
                annotationCanvasMap: S = null,
                pageColors: o = null,
                printAnnotationStorage: R = null
              } = c;
              ((i = arguments[0]) === null || i === void 0 ? void 0 : i.renderInteractiveForms) !== void 0 && ((0, _display_utils.deprecated)("render no longer accepts the `renderInteractiveForms`-option, please use the `annotationMode`-option instead."), arguments[0].renderInteractiveForms === !0 && p === _util.AnnotationMode.ENABLE && (p = _util.AnnotationMode.ENABLE_FORMS)), ((t = arguments[0]) === null || t === void 0 ? void 0 : t.includeAnnotationStorage) !== void 0 && ((0, _display_utils.deprecated)("render no longer accepts the `includeAnnotationStorage`-option, please use the `annotationMode`-option instead."), arguments[0].includeAnnotationStorage === !0 && p === _util.AnnotationMode.ENABLE && (p = _util.AnnotationMode.ENABLE_STORAGE)), this._stats && this._stats.time("Overall");
              const J = this._transport.getRenderingIntent(h, p, R);
              this.pendingCleanup = !1, V || (V = this._transport.getOptionalContentConfig());
              let u = this._intentStates.get(J.cacheKey);
              u || (u = /* @__PURE__ */ Object.create(null), this._intentStates.set(J.cacheKey, u)), u.streamReaderCancelTimeout && (clearTimeout(u.streamReaderCancelTimeout), u.streamReaderCancelTimeout = null);
              const e = x || new DefaultCanvasFactory({
                ownerDocument: this._ownerDocument
              }), m = !!(J.renderingIntent & _util.RenderingIntentFlag.PRINT);
              u.displayReadyCapability || (u.displayReadyCapability = (0, _util.createPromiseCapability)(), u.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: !1,
                separateAnnots: null
              }, this._stats && this._stats.time("Page Request"), this._pumpOperatorList(J));
              const d = (G) => {
                u.renderTasks.delete(b), (this.cleanupAfterRender || m) && (this.pendingCleanup = !0), this._tryCleanup(), G ? (b.capability.reject(G), this._abortOperatorList({
                  intentState: u,
                  reason: G instanceof Error ? G : new Error(G)
                })) : b.capability.resolve(), this._stats && (this._stats.timeEnd("Rendering"), this._stats.timeEnd("Overall"));
              }, b = new InternalRenderTask({
                callback: d,
                params: {
                  canvasContext: W,
                  viewport: y,
                  transform: X,
                  imageLayer: M,
                  background: n
                },
                objs: this.objs,
                commonObjs: this.commonObjs,
                annotationCanvasMap: S,
                operatorList: u.operatorList,
                pageIndex: this._pageIndex,
                canvasFactory: e,
                useRequestAnimationFrame: !m,
                pdfBug: this._pdfBug,
                pageColors: o
              });
              ((Z = u).renderTasks || (Z.renderTasks = /* @__PURE__ */ new Set())).add(b);
              const N = b.task;
              return Promise.all([u.displayReadyCapability.promise, V]).then((G) => {
                let [r, j] = G;
                if (this.pendingCleanup) {
                  d();
                  return;
                }
                this._stats && this._stats.time("Rendering"), b.initializeGraphics({
                  transparency: r,
                  optionalContentConfig: j
                }), b.operatorListChanged();
              }).catch(d), N;
            }
            getOperatorList() {
              let {
                intent: c = "display",
                annotationMode: i = _util.AnnotationMode.ENABLE,
                printAnnotationStorage: t = null
              } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              function Z() {
                y.operatorList.lastChunk && (y.opListReadCapability.resolve(y.operatorList), y.renderTasks.delete(h));
              }
              const W = this._transport.getRenderingIntent(c, i, t, !0);
              let y = this._intentStates.get(W.cacheKey);
              y || (y = /* @__PURE__ */ Object.create(null), this._intentStates.set(W.cacheKey, y));
              let h;
              if (!y.opListReadCapability) {
                var p;
                h = /* @__PURE__ */ Object.create(null), h.operatorListChanged = Z, y.opListReadCapability = (0, _util.createPromiseCapability)(), ((p = y).renderTasks || (p.renderTasks = /* @__PURE__ */ new Set())).add(h), y.operatorList = {
                  fnArray: [],
                  argsArray: [],
                  lastChunk: !1,
                  separateAnnots: null
                }, this._stats && this._stats.time("Page Request"), this._pumpOperatorList(W);
              }
              return y.opListReadCapability.promise;
            }
            streamTextContent() {
              let {
                disableCombineTextItems: c = !1,
                includeMarkedContent: i = !1
              } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              return this._transport.messageHandler.sendWithStream("GetTextContent", {
                pageIndex: this._pageIndex,
                combineTextItems: c !== !0,
                includeMarkedContent: i === !0
              }, {
                highWaterMark: 100,
                size(Z) {
                  return Z.items.length;
                }
              });
            }
            getTextContent() {
              let c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              if (this._transport._htmlForXfa)
                return this.getXfa().then((t) => _xfa_text.XfaText.textContent(t));
              const i = this.streamTextContent(c);
              return new Promise(function(t, Z) {
                function W() {
                  y.read().then(function(p) {
                    let {
                      value: X,
                      done: M
                    } = p;
                    if (M) {
                      t(h);
                      return;
                    }
                    Object.assign(h.styles, X.styles), h.items.push(...X.items), W();
                  }, Z);
                }
                const y = i.getReader(), h = {
                  items: [],
                  styles: /* @__PURE__ */ Object.create(null)
                };
                W();
              });
            }
            getStructTree() {
              return this._structTreePromise || (this._structTreePromise = this._transport.getStructTree(this._pageIndex));
            }
            _destroy() {
              this.destroyed = !0;
              const c = [];
              for (const i of this._intentStates.values())
                if (this._abortOperatorList({
                  intentState: i,
                  reason: new Error("Page was destroyed."),
                  force: !0
                }), !i.opListReadCapability)
                  for (const t of i.renderTasks)
                    c.push(t.completed), t.cancel();
              this.objs.clear();
              for (const i of this._bitmaps)
                i.close();
              return this._bitmaps.clear(), this._annotationPromises.clear(), this._jsActionsPromise = null, this._structTreePromise = null, this.pendingCleanup = !1, Promise.all(c);
            }
            cleanup() {
              let c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
              return this.pendingCleanup = !0, this._tryCleanup(c);
            }
            _tryCleanup() {
              let c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
              if (!this.pendingCleanup)
                return !1;
              for (const {
                renderTasks: i,
                operatorList: t
              } of this._intentStates.values())
                if (i.size > 0 || !t.lastChunk)
                  return !1;
              this._intentStates.clear(), this.objs.clear(), this._annotationPromises.clear(), this._jsActionsPromise = null, this._structTreePromise = null, c && this._stats && (this._stats = new _display_utils.StatTimer());
              for (const i of this._bitmaps)
                i.close();
              return this._bitmaps.clear(), this.pendingCleanup = !1, !0;
            }
            _startRenderPage(c, i) {
              const t = this._intentStates.get(i);
              t && (this._stats && this._stats.timeEnd("Page Request"), t.displayReadyCapability && t.displayReadyCapability.resolve(c));
            }
            _renderPageChunk(c, i) {
              for (let t = 0, Z = c.length; t < Z; t++)
                i.operatorList.fnArray.push(c.fnArray[t]), i.operatorList.argsArray.push(c.argsArray[t]);
              i.operatorList.lastChunk = c.lastChunk, i.operatorList.separateAnnots = c.separateAnnots;
              for (const t of i.renderTasks)
                t.operatorListChanged();
              c.lastChunk && this._tryCleanup();
            }
            _pumpOperatorList(c) {
              let {
                renderingIntent: i,
                cacheKey: t,
                annotationStorageMap: Z
              } = c;
              const y = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                pageIndex: this._pageIndex,
                intent: i,
                cacheKey: t,
                annotationStorage: Z
              }).getReader(), h = this._intentStates.get(t);
              h.streamReader = y;
              const p = () => {
                y.read().then((X) => {
                  let {
                    value: M,
                    done: x
                  } = X;
                  if (x) {
                    h.streamReader = null;
                    return;
                  }
                  this._transport.destroyed || (this._renderPageChunk(M, h), p());
                }, (X) => {
                  if (h.streamReader = null, !this._transport.destroyed) {
                    if (h.operatorList) {
                      h.operatorList.lastChunk = !0;
                      for (const M of h.renderTasks)
                        M.operatorListChanged();
                      this._tryCleanup();
                    }
                    if (h.displayReadyCapability)
                      h.displayReadyCapability.reject(X);
                    else if (h.opListReadCapability)
                      h.opListReadCapability.reject(X);
                    else
                      throw X;
                  }
                });
              };
              p();
            }
            _abortOperatorList(c) {
              let {
                intentState: i,
                reason: t,
                force: Z = !1
              } = c;
              if (i.streamReader) {
                if (!Z) {
                  if (i.renderTasks.size > 0)
                    return;
                  if (t instanceof _display_utils.RenderingCancelledException) {
                    i.streamReaderCancelTimeout = setTimeout(() => {
                      this._abortOperatorList({
                        intentState: i,
                        reason: t,
                        force: !0
                      }), i.streamReaderCancelTimeout = null;
                    }, RENDERING_CANCELLED_TIMEOUT);
                    return;
                  }
                }
                if (i.streamReader.cancel(new _util.AbortException(t.message)).catch(() => {
                }), i.streamReader = null, !this._transport.destroyed) {
                  for (const [W, y] of this._intentStates)
                    if (y === i) {
                      this._intentStates.delete(W);
                      break;
                    }
                  this.cleanup();
                }
              }
            }
            get stats() {
              return this._stats;
            }
          }
          exports.PDFPageProxy = PDFPageProxy;
          class LoopbackPort {
            constructor() {
              this._listeners = [], this._deferred = Promise.resolve();
            }
            postMessage(c, i) {
              const t = {
                data: structuredClone(c, i)
              };
              this._deferred.then(() => {
                for (const Z of this._listeners)
                  Z.call(this, t);
              });
            }
            addEventListener(c, i) {
              this._listeners.push(i);
            }
            removeEventListener(c, i) {
              const t = this._listeners.indexOf(i);
              this._listeners.splice(t, 1);
            }
            terminate() {
              this._listeners.length = 0;
            }
          }
          exports.LoopbackPort = LoopbackPort;
          const PDFWorkerUtil = {
            isWorkerDisabled: !1,
            fallbackWorkerSrc: null,
            fakeWorkerId: 0
          };
          exports.PDFWorkerUtil = PDFWorkerUtil;
          {
            if (_is_node.isNodeJS && typeof commonjsRequire == "function")
              PDFWorkerUtil.isWorkerDisabled = !0, PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
            else if (typeof document == "object") {
              var _document, _document$currentScri;
              const L = (_document = document) === null || _document === void 0 || (_document$currentScri = _document.currentScript) === null || _document$currentScri === void 0 ? void 0 : _document$currentScri.src;
              L && (PDFWorkerUtil.fallbackWorkerSrc = L.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2"));
            }
            PDFWorkerUtil.isSameOrigin = function(L, c) {
              let i;
              try {
                if (i = new URL(L), !i.origin || i.origin === "null")
                  return !1;
              } catch {
                return !1;
              }
              const t = new URL(c, i);
              return i.origin === t.origin;
            }, PDFWorkerUtil.createCDNWrapper = function(L) {
              const c = `importScripts("${L}");`;
              return URL.createObjectURL(new Blob([c]));
            };
          }
          class PDFWorker {
            constructor() {
              let {
                name: L = null,
                port: c = null,
                verbosity: i = (0, _util.getVerbosityLevel)()
              } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              if (c && _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts).has(c))
                throw new Error("Cannot use more than one PDFWorker per port.");
              if (this.name = L, this.destroyed = !1, this.verbosity = i, this._readyCapability = (0, _util.createPromiseCapability)(), this._port = null, this._webWorker = null, this._messageHandler = null, c) {
                _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts).set(c, this), this._initializeFromPort(c);
                return;
              }
              this._initialize();
            }
            get promise() {
              return this._readyCapability.promise;
            }
            get port() {
              return this._port;
            }
            get messageHandler() {
              return this._messageHandler;
            }
            _initializeFromPort(L) {
              this._port = L, this._messageHandler = new _message_handler.MessageHandler("main", "worker", L), this._messageHandler.on("ready", function() {
              }), this._readyCapability.resolve();
            }
            _initialize() {
              if (!PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {
                let {
                  workerSrc: L
                } = PDFWorker;
                try {
                  PDFWorkerUtil.isSameOrigin(window.location.href, L) || (L = PDFWorkerUtil.createCDNWrapper(new URL(L, window.location).href));
                  const c = new Worker(L), i = new _message_handler.MessageHandler("main", "worker", c), t = () => {
                    c.removeEventListener("error", Z), i.destroy(), c.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
                  }, Z = () => {
                    this._webWorker || t();
                  };
                  c.addEventListener("error", Z), i.on("test", (y) => {
                    if (c.removeEventListener("error", Z), this.destroyed) {
                      t();
                      return;
                    }
                    y ? (this._messageHandler = i, this._port = c, this._webWorker = c, this._readyCapability.resolve(), i.send("configure", {
                      verbosity: this.verbosity
                    })) : (this._setupFakeWorker(), i.destroy(), c.terminate());
                  }), i.on("ready", (y) => {
                    if (c.removeEventListener("error", Z), this.destroyed) {
                      t();
                      return;
                    }
                    try {
                      W();
                    } catch {
                      this._setupFakeWorker();
                    }
                  });
                  const W = () => {
                    const y = new Uint8Array();
                    i.send("test", y, [y.buffer]);
                  };
                  W();
                  return;
                } catch {
                  (0, _util.info)("The worker has been disabled.");
                }
              }
              this._setupFakeWorker();
            }
            _setupFakeWorker() {
              PDFWorkerUtil.isWorkerDisabled || ((0, _util.warn)("Setting up fake worker."), PDFWorkerUtil.isWorkerDisabled = !0), PDFWorker._setupFakeWorkerGlobal.then((L) => {
                if (this.destroyed) {
                  this._readyCapability.reject(new Error("Worker was destroyed"));
                  return;
                }
                const c = new LoopbackPort();
                this._port = c;
                const i = `fake${PDFWorkerUtil.fakeWorkerId++}`, t = new _message_handler.MessageHandler(i + "_worker", i, c);
                L.setup(t, c);
                const Z = new _message_handler.MessageHandler(i, i + "_worker", c);
                this._messageHandler = Z, this._readyCapability.resolve(), Z.send("configure", {
                  verbosity: this.verbosity
                });
              }).catch((L) => {
                this._readyCapability.reject(new Error(`Setting up fake worker failed: "${L.message}".`));
              });
            }
            destroy() {
              this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts).delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
            }
            static fromPort(L) {
              if (!(L != null && L.port))
                throw new Error("PDFWorker.fromPort - invalid method signature.");
              return _classStaticPrivateFieldSpecGet(this, PDFWorker, _workerPorts).has(L.port) ? _classStaticPrivateFieldSpecGet(this, PDFWorker, _workerPorts).get(L.port) : new PDFWorker(L);
            }
            static get workerSrc() {
              if (_worker_options.GlobalWorkerOptions.workerSrc)
                return _worker_options.GlobalWorkerOptions.workerSrc;
              if (PDFWorkerUtil.fallbackWorkerSrc !== null)
                return _is_node.isNodeJS || (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.'), PDFWorkerUtil.fallbackWorkerSrc;
              throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
            }
            static get _mainThreadWorkerMessageHandler() {
              try {
                var L;
                return ((L = globalThis.pdfjsWorker) === null || L === void 0 ? void 0 : L.WorkerMessageHandler) || null;
              } catch {
                return null;
              }
            }
            static get _setupFakeWorkerGlobal() {
              const loader = async () => {
                const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;
                if (mainWorkerMessageHandler)
                  return mainWorkerMessageHandler;
                if (_is_node.isNodeJS && typeof commonjsRequire == "function") {
                  const worker = eval("require")(this.workerSrc);
                  return worker.WorkerMessageHandler;
                }
                return await (0, _display_utils.loadScript)(this.workerSrc), window.pdfjsWorker.WorkerMessageHandler;
              };
              return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
            }
          }
          exports.PDFWorker = PDFWorker;
          var _workerPorts = {
            value: /* @__PURE__ */ new WeakMap()
          };
          PDFWorker.getWorkerSrc = function() {
            return (0, _display_utils.deprecated)("`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead."), this.workerSrc;
          };
          var _docStats = /* @__PURE__ */ new WeakMap(), _pageCache = /* @__PURE__ */ new WeakMap(), _pagePromises = /* @__PURE__ */ new WeakMap(), _metadataPromise = /* @__PURE__ */ new WeakMap();
          class WorkerTransport {
            constructor(c, i, t, Z) {
              _classPrivateFieldInitSpec(this, _docStats, {
                writable: !0,
                value: null
              }), _classPrivateFieldInitSpec(this, _pageCache, {
                writable: !0,
                value: /* @__PURE__ */ new Map()
              }), _classPrivateFieldInitSpec(this, _pagePromises, {
                writable: !0,
                value: /* @__PURE__ */ new Map()
              }), _classPrivateFieldInitSpec(this, _metadataPromise, {
                writable: !0,
                value: null
              }), this.messageHandler = c, this.loadingTask = i, this.commonObjs = new PDFObjects(), this.fontLoader = new _font_loader.FontLoader({
                docId: i.docId,
                onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                ownerDocument: Z.ownerDocument,
                styleElement: Z.styleElement
              }), this._params = Z, Z.useWorkerFetch || (this.CMapReaderFactory = new Z.CMapReaderFactory({
                baseUrl: Z.cMapUrl,
                isCompressed: Z.cMapPacked
              }), this.StandardFontDataFactory = new Z.StandardFontDataFactory({
                baseUrl: Z.standardFontDataUrl
              })), this.destroyed = !1, this.destroyCapability = null, this._passwordCapability = null, this._networkStream = t, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = (0, _util.createPromiseCapability)(), this.setupMessageHandler();
            }
            get annotationStorage() {
              return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
            }
            get stats() {
              return _classPrivateFieldGet(this, _docStats);
            }
            getRenderingIntent(c) {
              let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _util.AnnotationMode.ENABLE, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, Z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, W = _util.RenderingIntentFlag.DISPLAY, y = null;
              switch (c) {
                case "any":
                  W = _util.RenderingIntentFlag.ANY;
                  break;
                case "display":
                  break;
                case "print":
                  W = _util.RenderingIntentFlag.PRINT;
                  break;
                default:
                  (0, _util.warn)(`getRenderingIntent - invalid intent: ${c}`);
              }
              switch (i) {
                case _util.AnnotationMode.DISABLE:
                  W += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                  break;
                case _util.AnnotationMode.ENABLE:
                  break;
                case _util.AnnotationMode.ENABLE_FORMS:
                  W += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                  break;
                case _util.AnnotationMode.ENABLE_STORAGE:
                  W += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE, y = (W & _util.RenderingIntentFlag.PRINT && t instanceof _annotation_storage.PrintAnnotationStorage ? t : this.annotationStorage).serializable;
                  break;
                default:
                  (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${i}`);
              }
              return Z && (W += _util.RenderingIntentFlag.OPLIST), {
                renderingIntent: W,
                cacheKey: `${W}_${_annotation_storage.AnnotationStorage.getHash(y)}`,
                annotationStorageMap: y
              };
            }
            destroy() {
              if (this.destroyCapability)
                return this.destroyCapability.promise;
              this.destroyed = !0, this.destroyCapability = (0, _util.createPromiseCapability)(), this._passwordCapability && this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
              const c = [];
              for (const t of _classPrivateFieldGet(this, _pageCache).values())
                c.push(t._destroy());
              _classPrivateFieldGet(this, _pageCache).clear(), _classPrivateFieldGet(this, _pagePromises).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
              const i = this.messageHandler.sendWithPromise("Terminate", null);
              return c.push(i), Promise.all(c).then(() => {
                this.commonObjs.clear(), this.fontLoader.clear(), _classPrivateFieldSet(this, _metadataPromise, null), this._getFieldObjectsPromise = null, this._hasJSActionsPromise = null, this._networkStream && this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
              }, this.destroyCapability.reject), this.destroyCapability.promise;
            }
            setupMessageHandler() {
              const {
                messageHandler: c,
                loadingTask: i
              } = this;
              c.on("GetReader", (t, Z) => {
                (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (W) => {
                  this._lastProgress = {
                    loaded: W.loaded,
                    total: W.total
                  };
                }, Z.onPull = () => {
                  this._fullReader.read().then(function(W) {
                    let {
                      value: y,
                      done: h
                    } = W;
                    if (h) {
                      Z.close();
                      return;
                    }
                    (0, _util.assert)((0, _util.isArrayBuffer)(y), "GetReader - expected an ArrayBuffer."), Z.enqueue(new Uint8Array(y), 1, [y]);
                  }).catch((W) => {
                    Z.error(W);
                  });
                }, Z.onCancel = (W) => {
                  this._fullReader.cancel(W), Z.ready.catch((y) => {
                    if (!this.destroyed)
                      throw y;
                  });
                };
              }), c.on("ReaderHeadersReady", (t) => {
                const Z = (0, _util.createPromiseCapability)(), W = this._fullReader;
                return W.headersReady.then(() => {
                  if (!W.isStreamingSupported || !W.isRangeSupported) {
                    if (this._lastProgress) {
                      var y;
                      (y = i.onProgress) === null || y === void 0 || y.call(i, this._lastProgress);
                    }
                    W.onProgress = (h) => {
                      var p;
                      (p = i.onProgress) === null || p === void 0 || p.call(i, {
                        loaded: h.loaded,
                        total: h.total
                      });
                    };
                  }
                  Z.resolve({
                    isStreamingSupported: W.isStreamingSupported,
                    isRangeSupported: W.isRangeSupported,
                    contentLength: W.contentLength
                  });
                }, Z.reject), Z.promise;
              }), c.on("GetRangeReader", (t, Z) => {
                (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                const W = this._networkStream.getRangeReader(t.begin, t.end);
                if (!W) {
                  Z.close();
                  return;
                }
                Z.onPull = () => {
                  W.read().then(function(y) {
                    let {
                      value: h,
                      done: p
                    } = y;
                    if (p) {
                      Z.close();
                      return;
                    }
                    (0, _util.assert)((0, _util.isArrayBuffer)(h), "GetRangeReader - expected an ArrayBuffer."), Z.enqueue(new Uint8Array(h), 1, [h]);
                  }).catch((y) => {
                    Z.error(y);
                  });
                }, Z.onCancel = (y) => {
                  W.cancel(y), Z.ready.catch((h) => {
                    if (!this.destroyed)
                      throw h;
                  });
                };
              }), c.on("GetDoc", (t) => {
                let {
                  pdfInfo: Z
                } = t;
                this._numPages = Z.numPages, this._htmlForXfa = Z.htmlForXfa, delete Z.htmlForXfa, i._capability.resolve(new PDFDocumentProxy(Z, this));
              }), c.on("DocException", function(t) {
                let Z;
                switch (t.name) {
                  case "PasswordException":
                    Z = new _util.PasswordException(t.message, t.code);
                    break;
                  case "InvalidPDFException":
                    Z = new _util.InvalidPDFException(t.message);
                    break;
                  case "MissingPDFException":
                    Z = new _util.MissingPDFException(t.message);
                    break;
                  case "UnexpectedResponseException":
                    Z = new _util.UnexpectedResponseException(t.message, t.status);
                    break;
                  case "UnknownErrorException":
                    Z = new _util.UnknownErrorException(t.message, t.details);
                    break;
                  default:
                    (0, _util.unreachable)("DocException - expected a valid Error.");
                }
                i._capability.reject(Z);
              }), c.on("PasswordRequest", (t) => {
                if (this._passwordCapability = (0, _util.createPromiseCapability)(), i.onPassword) {
                  const Z = (W) => {
                    W instanceof Error ? this._passwordCapability.reject(W) : this._passwordCapability.resolve({
                      password: W
                    });
                  };
                  try {
                    i.onPassword(Z, t.code);
                  } catch (W) {
                    this._passwordCapability.reject(W);
                  }
                } else
                  this._passwordCapability.reject(new _util.PasswordException(t.message, t.code));
                return this._passwordCapability.promise;
              }), c.on("DataLoaded", (t) => {
                var Z;
                (Z = i.onProgress) === null || Z === void 0 || Z.call(i, {
                  loaded: t.length,
                  total: t.length
                }), this.downloadInfoCapability.resolve(t);
              }), c.on("StartRenderPage", (t) => {
                if (this.destroyed)
                  return;
                _classPrivateFieldGet(this, _pageCache).get(t.pageIndex)._startRenderPage(t.transparency, t.cacheKey);
              }), c.on("commonobj", (t) => {
                var Z;
                let [W, y, h] = t;
                if (!this.destroyed && !this.commonObjs.has(W))
                  switch (y) {
                    case "Font":
                      const p = this._params;
                      if ("error" in h) {
                        const x = h.error;
                        (0, _util.warn)(`Error during font loading: ${x}`), this.commonObjs.resolve(W, x);
                        break;
                      }
                      let X = null;
                      p.pdfBug && (Z = globalThis.FontInspector) !== null && Z !== void 0 && Z.enabled && (X = {
                        registerFont(x, n) {
                          globalThis.FontInspector.fontAdded(x, n);
                        }
                      });
                      const M = new _font_loader.FontFaceObject(h, {
                        isEvalSupported: p.isEvalSupported,
                        disableFontFace: p.disableFontFace,
                        ignoreErrors: p.ignoreErrors,
                        onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                        fontRegistry: X
                      });
                      this.fontLoader.bind(M).catch((x) => c.sendWithPromise("FontFallback", {
                        id: W
                      })).finally(() => {
                        !p.fontExtraProperties && M.data && (M.data = null), this.commonObjs.resolve(W, M);
                      });
                      break;
                    case "FontPath":
                    case "Image":
                      this.commonObjs.resolve(W, h);
                      break;
                    default:
                      throw new Error(`Got unknown common object type ${y}`);
                  }
              }), c.on("obj", (t) => {
                let [Z, W, y, h] = t;
                if (this.destroyed)
                  return;
                const p = _classPrivateFieldGet(this, _pageCache).get(W);
                if (!p.objs.has(Z))
                  switch (y) {
                    case "Image":
                      p.objs.resolve(Z, h);
                      const M = 8e6;
                      if (h) {
                        let x;
                        if (h.bitmap) {
                          const {
                            bitmap: n,
                            width: V,
                            height: S
                          } = h;
                          x = V * S * 4, p._bitmaps.add(n);
                        } else {
                          var X;
                          x = ((X = h.data) === null || X === void 0 ? void 0 : X.length) || 0;
                        }
                        x > M && (p.cleanupAfterRender = !0);
                      }
                      break;
                    case "Pattern":
                      p.objs.resolve(Z, h);
                      break;
                    default:
                      throw new Error(`Got unknown object type ${y}`);
                  }
              }), c.on("DocProgress", (t) => {
                var Z;
                this.destroyed || (Z = i.onProgress) === null || Z === void 0 || Z.call(i, {
                  loaded: t.loaded,
                  total: t.total
                });
              }), c.on("DocStats", (t) => {
                this.destroyed || _classPrivateFieldSet(this, _docStats, Object.freeze({
                  streamTypes: Object.freeze(t.streamTypes),
                  fontTypes: Object.freeze(t.fontTypes)
                }));
              }), c.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this)), c.on("FetchBuiltInCMap", (t) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.CMapReaderFactory ? this.CMapReaderFactory.fetch(t) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), c.on("FetchStandardFontData", (t) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.StandardFontDataFactory ? this.StandardFontDataFactory.fetch(t) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
            }
            _onUnsupportedFeature(c) {
              var i, t;
              let {
                featureId: Z
              } = c;
              this.destroyed || (i = (t = this.loadingTask).onUnsupportedFeature) === null || i === void 0 || i.call(t, Z);
            }
            getData() {
              return this.messageHandler.sendWithPromise("GetData", null);
            }
            getPage(c) {
              if (!Number.isInteger(c) || c <= 0 || c > this._numPages)
                return Promise.reject(new Error("Invalid page request."));
              const i = c - 1, t = _classPrivateFieldGet(this, _pagePromises).get(i);
              if (t)
                return t;
              const Z = this.messageHandler.sendWithPromise("GetPage", {
                pageIndex: i
              }).then((W) => {
                if (this.destroyed)
                  throw new Error("Transport destroyed");
                const y = new PDFPageProxy(i, W, this, this._params.ownerDocument, this._params.pdfBug);
                return _classPrivateFieldGet(this, _pageCache).set(i, y), y;
              });
              return _classPrivateFieldGet(this, _pagePromises).set(i, Z), Z;
            }
            getPageIndex(c) {
              return typeof c != "object" || c === null || !Number.isInteger(c.num) || c.num < 0 || !Number.isInteger(c.gen) || c.gen < 0 ? Promise.reject(new Error("Invalid pageIndex request.")) : this.messageHandler.sendWithPromise("GetPageIndex", {
                num: c.num,
                gen: c.gen
              });
            }
            getAnnotations(c, i) {
              return this.messageHandler.sendWithPromise("GetAnnotations", {
                pageIndex: c,
                intent: i
              });
            }
            saveDocument() {
              var c, i;
              return this.messageHandler.sendWithPromise("SaveDocument", {
                isPureXfa: !!this._htmlForXfa,
                numPages: this._numPages,
                annotationStorage: this.annotationStorage.serializable,
                filename: (c = (i = this._fullReader) === null || i === void 0 ? void 0 : i.filename) !== null && c !== void 0 ? c : null
              }).finally(() => {
                this.annotationStorage.resetModified();
              });
            }
            getFieldObjects() {
              return this._getFieldObjectsPromise || (this._getFieldObjectsPromise = this.messageHandler.sendWithPromise("GetFieldObjects", null));
            }
            hasJSActions() {
              return this._hasJSActionsPromise || (this._hasJSActionsPromise = this.messageHandler.sendWithPromise("HasJSActions", null));
            }
            getCalculationOrderIds() {
              return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
            }
            getDestinations() {
              return this.messageHandler.sendWithPromise("GetDestinations", null);
            }
            getDestination(c) {
              return typeof c != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
                id: c
              });
            }
            getPageLabels() {
              return this.messageHandler.sendWithPromise("GetPageLabels", null);
            }
            getPageLayout() {
              return this.messageHandler.sendWithPromise("GetPageLayout", null);
            }
            getPageMode() {
              return this.messageHandler.sendWithPromise("GetPageMode", null);
            }
            getViewerPreferences() {
              return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
            }
            getOpenAction() {
              return this.messageHandler.sendWithPromise("GetOpenAction", null);
            }
            getAttachments() {
              return this.messageHandler.sendWithPromise("GetAttachments", null);
            }
            getJavaScript() {
              return this.messageHandler.sendWithPromise("GetJavaScript", null);
            }
            getDocJSActions() {
              return this.messageHandler.sendWithPromise("GetDocJSActions", null);
            }
            getPageJSActions(c) {
              return this.messageHandler.sendWithPromise("GetPageJSActions", {
                pageIndex: c
              });
            }
            getStructTree(c) {
              return this.messageHandler.sendWithPromise("GetStructTree", {
                pageIndex: c
              });
            }
            getOutline() {
              return this.messageHandler.sendWithPromise("GetOutline", null);
            }
            getOptionalContentConfig() {
              return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((c) => new _optional_content_config.OptionalContentConfig(c));
            }
            getPermissions() {
              return this.messageHandler.sendWithPromise("GetPermissions", null);
            }
            getMetadata() {
              return _classPrivateFieldGet(this, _metadataPromise) || _classPrivateFieldSet(this, _metadataPromise, this.messageHandler.sendWithPromise("GetMetadata", null).then((c) => {
                var i, t, Z, W;
                return {
                  info: c[0],
                  metadata: c[1] ? new _metadata.Metadata(c[1]) : null,
                  contentDispositionFilename: (i = (t = this._fullReader) === null || t === void 0 ? void 0 : t.filename) !== null && i !== void 0 ? i : null,
                  contentLength: (Z = (W = this._fullReader) === null || W === void 0 ? void 0 : W.contentLength) !== null && Z !== void 0 ? Z : null
                };
              }));
            }
            getMarkInfo() {
              return this.messageHandler.sendWithPromise("GetMarkInfo", null);
            }
            async startCleanup() {
              let c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
              if (await this.messageHandler.sendWithPromise("Cleanup", null), !this.destroyed) {
                for (const i of _classPrivateFieldGet(this, _pageCache).values())
                  if (!i.cleanup())
                    throw new Error(`startCleanup: Page ${i.pageNumber} is currently rendering.`);
                this.commonObjs.clear(), c || this.fontLoader.clear(), _classPrivateFieldSet(this, _metadataPromise, null), this._getFieldObjectsPromise = null, this._hasJSActionsPromise = null;
              }
            }
            get loadingParams() {
              const c = this._params;
              return (0, _util.shadow)(this, "loadingParams", {
                disableAutoFetch: c.disableAutoFetch,
                enableXfa: c.enableXfa
              });
            }
          }
          var _objs = /* @__PURE__ */ new WeakMap(), _ensureObj = /* @__PURE__ */ new WeakSet();
          class PDFObjects {
            constructor() {
              _classPrivateMethodInitSpec(this, _ensureObj), _classPrivateFieldInitSpec(this, _objs, {
                writable: !0,
                value: /* @__PURE__ */ Object.create(null)
              });
            }
            get(c) {
              let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
              if (i) {
                const Z = _classPrivateMethodGet(this, _ensureObj, _ensureObj2).call(this, c);
                return Z.capability.promise.then(() => i(Z.data)), null;
              }
              const t = _classPrivateFieldGet(this, _objs)[c];
              if (!(t != null && t.capability.settled))
                throw new Error(`Requesting object that isn't resolved yet ${c}.`);
              return t.data;
            }
            has(c) {
              const i = _classPrivateFieldGet(this, _objs)[c];
              return (i == null ? void 0 : i.capability.settled) || !1;
            }
            resolve(c) {
              let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
              const t = _classPrivateMethodGet(this, _ensureObj, _ensureObj2).call(this, c);
              t.data = i, t.capability.resolve();
            }
            clear() {
              _classPrivateFieldSet(this, _objs, /* @__PURE__ */ Object.create(null));
            }
          }
          function _ensureObj2(L) {
            const c = _classPrivateFieldGet(this, _objs)[L];
            return c || (_classPrivateFieldGet(this, _objs)[L] = {
              capability: (0, _util.createPromiseCapability)(),
              data: null
            });
          }
          var _internalRenderTask = /* @__PURE__ */ new WeakMap();
          class RenderTask {
            constructor(c) {
              _classPrivateFieldInitSpec(this, _internalRenderTask, {
                writable: !0,
                value: null
              }), _classPrivateFieldSet(this, _internalRenderTask, c), this.onContinue = null;
            }
            get promise() {
              return _classPrivateFieldGet(this, _internalRenderTask).capability.promise;
            }
            cancel() {
              _classPrivateFieldGet(this, _internalRenderTask).cancel();
            }
            get separateAnnots() {
              const {
                separateAnnots: c
              } = _classPrivateFieldGet(this, _internalRenderTask).operatorList;
              if (!c)
                return !1;
              const {
                annotationCanvasMap: i
              } = _classPrivateFieldGet(this, _internalRenderTask);
              return c.form || c.canvas && (i == null ? void 0 : i.size) > 0;
            }
          }
          exports.RenderTask = RenderTask;
          class InternalRenderTask {
            constructor(c) {
              let {
                callback: i,
                params: t,
                objs: Z,
                commonObjs: W,
                annotationCanvasMap: y,
                operatorList: h,
                pageIndex: p,
                canvasFactory: X,
                useRequestAnimationFrame: M = !1,
                pdfBug: x = !1,
                pageColors: n = null
              } = c;
              this.callback = i, this.params = t, this.objs = Z, this.commonObjs = W, this.annotationCanvasMap = y, this.operatorListIdx = null, this.operatorList = h, this._pageIndex = p, this.canvasFactory = X, this._pdfBug = x, this.pageColors = n, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = M === !0 && typeof window < "u", this.cancelled = !1, this.capability = (0, _util.createPromiseCapability)(), this.task = new RenderTask(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = t.canvasContext.canvas;
            }
            get completed() {
              return this.capability.promise.catch(function() {
              });
            }
            initializeGraphics(c) {
              var i;
              let {
                transparency: t = !1,
                optionalContentConfig: Z
              } = c;
              if (this.cancelled)
                return;
              if (this._canvas) {
                if (_classStaticPrivateFieldSpecGet(InternalRenderTask, InternalRenderTask, _canvasInUse).has(this._canvas))
                  throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                _classStaticPrivateFieldSpecGet(InternalRenderTask, InternalRenderTask, _canvasInUse).add(this._canvas);
              }
              this._pdfBug && (i = globalThis.StepperManager) !== null && i !== void 0 && i.enabled && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
              const {
                canvasContext: W,
                viewport: y,
                transform: h,
                imageLayer: p,
                background: X
              } = this.params;
              this.gfx = new _canvas.CanvasGraphics(W, this.commonObjs, this.objs, this.canvasFactory, p, Z, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({
                transform: h,
                viewport: y,
                transparency: t,
                background: X
              }), this.operatorListIdx = 0, this.graphicsReady = !0, this.graphicsReadyCallback && this.graphicsReadyCallback();
            }
            cancel() {
              let c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
              this.running = !1, this.cancelled = !0, this.gfx && this.gfx.endDrawing(), this._canvas && _classStaticPrivateFieldSpecGet(InternalRenderTask, InternalRenderTask, _canvasInUse).delete(this._canvas), this.callback(c || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas"));
            }
            operatorListChanged() {
              if (!this.graphicsReady) {
                this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
                return;
              }
              this.stepper && this.stepper.updateOperatorList(this.operatorList), !this.running && this._continue();
            }
            _continue() {
              this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
            }
            _scheduleNext() {
              this._useRequestAnimationFrame ? window.requestAnimationFrame(() => {
                this._nextBound().catch(this._cancelBound);
              }) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
            }
            async _next() {
              this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), this._canvas && _classStaticPrivateFieldSpecGet(InternalRenderTask, InternalRenderTask, _canvasInUse).delete(this._canvas), this.callback())));
            }
          }
          var _canvasInUse = {
            value: /* @__PURE__ */ new WeakSet()
          };
          const version = "2.16.105";
          exports.version = version;
          const build = "172ccdbe5";
          exports.build = build;
        },
        /* 130 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.PrintAnnotationStorage = c.AnnotationStorage = void 0;
          var t = i(1), Z = i(131), W = i(135);
          function y(m, d, b) {
            V(m, d), d.set(m, b);
          }
          function h(m, d) {
            var b = M(m, d, "get");
            return p(m, b);
          }
          function p(m, d) {
            return d.get ? d.get.call(m) : d.value;
          }
          function X(m, d, b) {
            var N = M(m, d, "set");
            return x(m, N, b), b;
          }
          function M(m, d, b) {
            if (!d.has(m))
              throw new TypeError("attempted to " + b + " private field on non-instance");
            return d.get(m);
          }
          function x(m, d, b) {
            if (d.set)
              d.set.call(m, b);
            else {
              if (!d.writable)
                throw new TypeError("attempted to set read only private field");
              d.value = b;
            }
          }
          function n(m, d) {
            V(m, d), d.add(m);
          }
          function V(m, d) {
            if (d.has(m))
              throw new TypeError("Cannot initialize the same private elements twice on an object");
          }
          function S(m, d, b) {
            if (!d.has(m))
              throw new TypeError("attempted to get private field on non-instance");
            return b;
          }
          var o = /* @__PURE__ */ new WeakSet();
          class R {
            constructor() {
              n(this, o), this._storage = /* @__PURE__ */ new Map(), this._modified = !1, this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
            }
            getValue(d, b) {
              const N = this._storage.get(d);
              return N === void 0 ? b : Object.assign(b, N);
            }
            getRawValue(d) {
              return this._storage.get(d);
            }
            remove(d) {
              if (this._storage.delete(d), this._storage.size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
                for (const b of this._storage.values())
                  if (b instanceof Z.AnnotationEditor)
                    return;
                this.onAnnotationEditor(null);
              }
            }
            setValue(d, b) {
              const N = this._storage.get(d);
              let G = !1;
              if (N !== void 0)
                for (const [r, j] of Object.entries(b))
                  N[r] !== j && (G = !0, N[r] = j);
              else
                G = !0, this._storage.set(d, b);
              G && S(this, o, J).call(this), b instanceof Z.AnnotationEditor && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(b.constructor._type);
            }
            has(d) {
              return this._storage.has(d);
            }
            getAll() {
              return this._storage.size > 0 ? (0, t.objectFromMap)(this._storage) : null;
            }
            get size() {
              return this._storage.size;
            }
            resetModified() {
              this._modified && (this._modified = !1, typeof this.onResetModified == "function" && this.onResetModified());
            }
            get print() {
              return new e(this);
            }
            get serializable() {
              if (this._storage.size === 0)
                return null;
              const d = /* @__PURE__ */ new Map();
              for (const [b, N] of this._storage) {
                const G = N instanceof Z.AnnotationEditor ? N.serialize() : N;
                G && d.set(b, G);
              }
              return d;
            }
            static getHash(d) {
              if (!d)
                return "";
              const b = new W.MurmurHash3_64();
              for (const [N, G] of d)
                b.update(`${N}:${JSON.stringify(G)}`);
              return b.hexdigest();
            }
          }
          c.AnnotationStorage = R;
          function J() {
            this._modified || (this._modified = !0, typeof this.onSetModified == "function" && this.onSetModified());
          }
          var u = /* @__PURE__ */ new WeakMap();
          class e extends R {
            constructor(d) {
              super(), y(this, u, {
                writable: !0,
                value: null
              }), X(this, u, structuredClone(d.serializable));
            }
            get print() {
              (0, t.unreachable)("Should not call PrintAnnotationStorage.print");
            }
            get serializable() {
              return h(this, u);
            }
          }
          c.PrintAnnotationStorage = e;
        },
        /* 131 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.AnnotationEditor = void 0;
          var t = i(132), Z = i(1);
          function W(m, d, b) {
            return d in m ? Object.defineProperty(m, d, { value: b, enumerable: !0, configurable: !0, writable: !0 }) : m[d] = b, m;
          }
          function y(m, d, b) {
            h(m, d), d.set(m, b);
          }
          function h(m, d) {
            if (d.has(m))
              throw new TypeError("Cannot initialize the same private elements twice on an object");
          }
          function p(m, d, b) {
            var N = x(m, d, "set");
            return X(m, N, b), b;
          }
          function X(m, d, b) {
            if (d.set)
              d.set.call(m, b);
            else {
              if (!d.writable)
                throw new TypeError("attempted to set read only private field");
              d.value = b;
            }
          }
          function M(m, d) {
            var b = x(m, d, "get");
            return n(m, b);
          }
          function x(m, d, b) {
            if (!d.has(m))
              throw new TypeError("attempted to " + b + " private field on non-instance");
            return d.get(m);
          }
          function n(m, d) {
            return d.get ? d.get.call(m) : d.value;
          }
          var V = /* @__PURE__ */ new WeakMap(), S = /* @__PURE__ */ new WeakMap(), o = /* @__PURE__ */ new WeakMap(), R = /* @__PURE__ */ new WeakMap(), J = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap();
          class e {
            constructor(d) {
              y(this, V, {
                writable: !0,
                value: this.focusin.bind(this)
              }), y(this, S, {
                writable: !0,
                value: this.focusout.bind(this)
              }), y(this, o, {
                writable: !0,
                value: !1
              }), y(this, R, {
                writable: !0,
                value: !1
              }), y(this, J, {
                writable: !0,
                value: !1
              }), y(this, u, {
                writable: !0,
                value: e._zIndex++
              }), this.constructor === e && (0, Z.unreachable)("Cannot initialize AnnotationEditor."), this.parent = d.parent, this.id = d.id, this.width = this.height = null, this.pageIndex = d.parent.pageIndex, this.name = d.name, this.div = null;
              const [b, N] = this.parent.viewportBaseDimensions;
              this.x = d.x / b, this.y = d.y / N, this.rotation = this.parent.viewport.rotation, this.isAttachedToDOM = !1;
            }
            static get _defaultLineColor() {
              return (0, Z.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
            }
            setInBackground() {
              this.div.style.zIndex = 0;
            }
            setInForeground() {
              this.div.style.zIndex = M(this, u);
            }
            focusin(d) {
              M(this, o) ? p(this, o, !1) : this.parent.setSelected(this);
            }
            focusout(d) {
              if (!this.isAttachedToDOM)
                return;
              const b = d.relatedTarget;
              b != null && b.closest(`#${this.id}`) || (d.preventDefault(), this.parent.isMultipleSelection || this.commitOrRemove());
            }
            commitOrRemove() {
              this.isEmpty() ? this.remove() : this.commit();
            }
            commit() {
              this.parent.addToAnnotationStorage(this);
            }
            dragstart(d) {
              const b = this.parent.div.getBoundingClientRect();
              this.startX = d.clientX - b.x, this.startY = d.clientY - b.y, d.dataTransfer.setData("text/plain", this.id), d.dataTransfer.effectAllowed = "move";
            }
            setAt(d, b, N, G) {
              const [r, j] = this.parent.viewportBaseDimensions;
              [N, G] = this.screenToPageTranslation(N, G), this.x = (d + N) / r, this.y = (b + G) / j, this.div.style.left = `${100 * this.x}%`, this.div.style.top = `${100 * this.y}%`;
            }
            translate(d, b) {
              const [N, G] = this.parent.viewportBaseDimensions;
              [d, b] = this.screenToPageTranslation(d, b), this.x += d / N, this.y += b / G, this.div.style.left = `${100 * this.x}%`, this.div.style.top = `${100 * this.y}%`;
            }
            screenToPageTranslation(d, b) {
              const {
                rotation: N
              } = this.parent.viewport;
              switch (N) {
                case 90:
                  return [b, -d];
                case 180:
                  return [-d, -b];
                case 270:
                  return [-b, d];
                default:
                  return [d, b];
              }
            }
            setDims(d, b) {
              const [N, G] = this.parent.viewportBaseDimensions;
              this.div.style.width = `${100 * d / N}%`, this.div.style.height = `${100 * b / G}%`;
            }
            getInitialTranslation() {
              return [0, 0];
            }
            render() {
              this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.setAttribute("tabIndex", 0), this.setInForeground(), this.div.addEventListener("focusin", M(this, V)), this.div.addEventListener("focusout", M(this, S));
              const [d, b] = this.getInitialTranslation();
              return this.translate(d, b), (0, t.bindEvents)(this, this.div, ["dragstart", "pointerdown"]), this.div;
            }
            pointerdown(d) {
              const b = t.KeyboardManager.platform.isMac;
              if (d.button !== 0 || d.ctrlKey && b) {
                d.preventDefault();
                return;
              }
              d.ctrlKey && !b || d.shiftKey || d.metaKey && b ? this.parent.toggleSelected(this) : this.parent.setSelected(this), p(this, o, !0);
            }
            getRect(d, b) {
              const [N, G] = this.parent.viewportBaseDimensions, [r, j] = this.parent.pageDimensions, D = r * d / N, f = j * b / G, P = this.x * r, B = this.y * j, A = this.width * r, H = this.height * j;
              switch (this.rotation) {
                case 0:
                  return [P + D, j - B - f - H, P + D + A, j - B - f];
                case 90:
                  return [P + f, j - B + D, P + f + H, j - B + D + A];
                case 180:
                  return [P - D - A, j - B + f, P - D, j - B + f + H];
                case 270:
                  return [P - f - H, j - B - D - A, P - f, j - B - D];
                default:
                  throw new Error("Invalid rotation");
              }
            }
            getRectInCurrentCoords(d, b) {
              const [N, G, r, j] = d, D = r - N, f = j - G;
              switch (this.rotation) {
                case 0:
                  return [N, b - j, D, f];
                case 90:
                  return [N, b - G, f, D];
                case 180:
                  return [r, b - G, D, f];
                case 270:
                  return [r, b - j, f, D];
                default:
                  throw new Error("Invalid rotation");
              }
            }
            onceAdded() {
            }
            isEmpty() {
              return !1;
            }
            enableEditMode() {
              p(this, J, !0);
            }
            disableEditMode() {
              p(this, J, !1);
            }
            isInEditMode() {
              return M(this, J);
            }
            shouldGetKeyboardEvents() {
              return !1;
            }
            needsToBeRebuilt() {
              return this.div && !this.isAttachedToDOM;
            }
            rebuild() {
              var d;
              (d = this.div) === null || d === void 0 || d.addEventListener("focusin", M(this, V));
            }
            serialize() {
              (0, Z.unreachable)("An editor must be serializable");
            }
            static deserialize(d, b) {
              const N = new this.prototype.constructor({
                parent: b,
                id: b.getNextId()
              });
              N.rotation = d.rotation;
              const [G, r] = b.pageDimensions, [j, D, f, P] = N.getRectInCurrentCoords(d.rect, r);
              return N.x = j / G, N.y = D / r, N.width = f / G, N.height = P / r, N;
            }
            remove() {
              this.div.removeEventListener("focusin", M(this, V)), this.div.removeEventListener("focusout", M(this, S)), this.isEmpty() || this.commit(), this.parent.remove(this);
            }
            select() {
              var d;
              (d = this.div) === null || d === void 0 || d.classList.add("selectedEditor");
            }
            unselect() {
              var d;
              (d = this.div) === null || d === void 0 || d.classList.remove("selectedEditor");
            }
            updateParams(d, b) {
            }
            disableEditing() {
            }
            enableEditing() {
            }
            get propertiesToUpdate() {
              return {};
            }
            get contentDiv() {
              return this.div;
            }
            get isEditing() {
              return M(this, R);
            }
            set isEditing(d) {
              p(this, R, d), d ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null);
            }
          }
          c.AnnotationEditor = e, W(e, "_colorManager", new t.ColorManager()), W(e, "_zIndex", 1);
        },
        /* 132 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.KeyboardManager = c.CommandManager = c.ColorManager = c.AnnotationEditorUIManager = void 0, c.bindEvents = o, c.opacityToHex = R;
          var t = i(1), Z = i(133);
          function W(ol, cl, Il) {
            return cl in ol ? Object.defineProperty(ol, cl, { value: Il, enumerable: !0, configurable: !0, writable: !0 }) : ol[cl] = Il, ol;
          }
          function y(ol, cl) {
            X(ol, cl), cl.add(ol);
          }
          function h(ol, cl, Il) {
            if (!cl.has(ol))
              throw new TypeError("attempted to get private field on non-instance");
            return Il;
          }
          function p(ol, cl, Il) {
            X(ol, cl), cl.set(ol, Il);
          }
          function X(ol, cl) {
            if (cl.has(ol))
              throw new TypeError("Cannot initialize the same private elements twice on an object");
          }
          function M(ol, cl, Il) {
            var Jl = V(ol, cl, "set");
            return x(ol, Jl, Il), Il;
          }
          function x(ol, cl, Il) {
            if (cl.set)
              cl.set.call(ol, Il);
            else {
              if (!cl.writable)
                throw new TypeError("attempted to set read only private field");
              cl.value = Il;
            }
          }
          function n(ol, cl) {
            var Il = V(ol, cl, "get");
            return S(ol, Il);
          }
          function V(ol, cl, Il) {
            if (!cl.has(ol))
              throw new TypeError("attempted to " + Il + " private field on non-instance");
            return cl.get(ol);
          }
          function S(ol, cl) {
            return cl.get ? cl.get.call(ol) : cl.value;
          }
          function o(ol, cl, Il) {
            for (const Jl of Il)
              cl.addEventListener(Jl, ol[Jl].bind(ol));
          }
          function R(ol) {
            return Math.round(Math.min(255, Math.max(1, 255 * ol))).toString(16).padStart(2, "0");
          }
          var J = /* @__PURE__ */ new WeakMap();
          class u {
            constructor() {
              p(this, J, {
                writable: !0,
                value: 0
              });
            }
            getId() {
              var cl, Il;
              return `${t.AnnotationEditorPrefix}${M(this, J, (cl = n(this, J), Il = cl++, cl)), Il}`;
            }
          }
          var e = /* @__PURE__ */ new WeakMap(), m = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakMap(), b = /* @__PURE__ */ new WeakMap();
          class N {
            constructor() {
              let cl = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 128;
              p(this, e, {
                writable: !0,
                value: []
              }), p(this, m, {
                writable: !0,
                value: !1
              }), p(this, d, {
                writable: !0,
                value: void 0
              }), p(this, b, {
                writable: !0,
                value: -1
              }), M(this, d, cl);
            }
            add(cl) {
              let {
                cmd: Il,
                undo: Jl,
                mustExec: fl,
                type: Nl = NaN,
                overwriteIfSameType: zl = !1,
                keepUndo: kl = !1
              } = cl;
              if (fl && Il(), n(this, m))
                return;
              const nl = {
                cmd: Il,
                undo: Jl,
                type: Nl
              };
              if (n(this, b) === -1) {
                n(this, e).length > 0 && (n(this, e).length = 0), M(this, b, 0), n(this, e).push(nl);
                return;
              }
              if (zl && n(this, e)[n(this, b)].type === Nl) {
                kl && (nl.undo = n(this, e)[n(this, b)].undo), n(this, e)[n(this, b)] = nl;
                return;
              }
              const ll = n(this, b) + 1;
              ll === n(this, d) ? n(this, e).splice(0, 1) : (M(this, b, ll), ll < n(this, e).length && n(this, e).splice(ll)), n(this, e).push(nl);
            }
            undo() {
              n(this, b) !== -1 && (M(this, m, !0), n(this, e)[n(this, b)].undo(), M(this, m, !1), M(this, b, n(this, b) - 1));
            }
            redo() {
              n(this, b) < n(this, e).length - 1 && (M(this, b, n(this, b) + 1), M(this, m, !0), n(this, e)[n(this, b)].cmd(), M(this, m, !1));
            }
            hasSomethingToUndo() {
              return n(this, b) !== -1;
            }
            hasSomethingToRedo() {
              return n(this, b) < n(this, e).length - 1;
            }
            destroy() {
              M(this, e, null);
            }
          }
          c.CommandManager = N;
          var G = /* @__PURE__ */ new WeakSet();
          class r {
            constructor(cl) {
              y(this, G), this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
              const Il = r.platform.isMac;
              for (const [Jl, fl] of cl)
                for (const Nl of Jl) {
                  const zl = Nl.startsWith("mac+");
                  Il && zl ? (this.callbacks.set(Nl.slice(4), fl), this.allKeys.add(Nl.split("+").at(-1))) : !Il && !zl && (this.callbacks.set(Nl, fl), this.allKeys.add(Nl.split("+").at(-1)));
                }
            }
            static get platform() {
              const cl = typeof navigator < "u" ? navigator.platform : "";
              return (0, t.shadow)(this, "platform", {
                isWin: cl.includes("Win"),
                isMac: cl.includes("Mac")
              });
            }
            exec(cl, Il) {
              if (!this.allKeys.has(Il.key))
                return;
              const Jl = this.callbacks.get(h(this, G, j).call(this, Il));
              Jl && (Jl.bind(cl)(), Il.stopPropagation(), Il.preventDefault());
            }
          }
          c.KeyboardManager = r;
          function j(ol) {
            ol.altKey && this.buffer.push("alt"), ol.ctrlKey && this.buffer.push("ctrl"), ol.metaKey && this.buffer.push("meta"), ol.shiftKey && this.buffer.push("shift"), this.buffer.push(ol.key);
            const cl = this.buffer.join("+");
            return this.buffer.length = 0, cl;
          }
          var D = /* @__PURE__ */ new WeakMap();
          class f {
            constructor() {
              p(this, D, {
                writable: !0,
                value: null
              });
            }
            copy(cl) {
              cl && (Array.isArray(cl) ? M(this, D, cl.map((Il) => Il.serialize())) : M(this, D, [cl.serialize()]), M(this, D, n(this, D).filter((Il) => !!Il)), n(this, D).length === 0 && M(this, D, null));
            }
            paste() {
              return n(this, D);
            }
            isEmpty() {
              return n(this, D) === null;
            }
            destroy() {
              M(this, D, null);
            }
          }
          class P {
            get _colors() {
              const cl = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
              return (0, Z.getColorValues)(cl), (0, t.shadow)(this, "_colors", cl);
            }
            convert(cl) {
              const Il = (0, Z.getRGB)(cl);
              if (!window.matchMedia("(forced-colors: active)").matches)
                return Il;
              for (const [Jl, fl] of this._colors)
                if (fl.every((Nl, zl) => Nl === Il[zl]))
                  return P._colorsMapping.get(Jl);
              return Il;
            }
            getHexCode(cl) {
              const Il = this._colors.get(cl);
              return Il ? t.Util.makeHexColor(...Il) : cl;
            }
          }
          c.ColorManager = P, W(P, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
          var B = /* @__PURE__ */ new WeakMap(), A = /* @__PURE__ */ new WeakMap(), H = /* @__PURE__ */ new WeakMap(), O = /* @__PURE__ */ new WeakMap(), U = /* @__PURE__ */ new WeakMap(), k = /* @__PURE__ */ new WeakMap(), q = /* @__PURE__ */ new WeakMap(), al = /* @__PURE__ */ new WeakMap(), Ml = /* @__PURE__ */ new WeakMap(), wl = /* @__PURE__ */ new WeakMap(), Q = /* @__PURE__ */ new WeakMap(), T = /* @__PURE__ */ new WeakMap(), w = /* @__PURE__ */ new WeakMap(), g = /* @__PURE__ */ new WeakMap(), K = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new WeakMap(), Y = /* @__PURE__ */ new WeakMap(), z = /* @__PURE__ */ new WeakSet(), C = /* @__PURE__ */ new WeakSet(), F = /* @__PURE__ */ new WeakSet(), v = /* @__PURE__ */ new WeakSet(), $ = /* @__PURE__ */ new WeakSet(), il = /* @__PURE__ */ new WeakSet(), dl = /* @__PURE__ */ new WeakSet(), el = /* @__PURE__ */ new WeakSet(), bl = /* @__PURE__ */ new WeakSet();
          class ml {
            constructor(cl, Il) {
              y(this, bl), y(this, el), y(this, dl), y(this, il), y(this, $), y(this, v), y(this, F), y(this, C), y(this, z), p(this, B, {
                writable: !0,
                value: null
              }), p(this, A, {
                writable: !0,
                value: /* @__PURE__ */ new Map()
              }), p(this, H, {
                writable: !0,
                value: /* @__PURE__ */ new Map()
              }), p(this, O, {
                writable: !0,
                value: new f()
              }), p(this, U, {
                writable: !0,
                value: new N()
              }), p(this, k, {
                writable: !0,
                value: 0
              }), p(this, q, {
                writable: !0,
                value: null
              }), p(this, al, {
                writable: !0,
                value: null
              }), p(this, Ml, {
                writable: !0,
                value: new u()
              }), p(this, wl, {
                writable: !0,
                value: !1
              }), p(this, Q, {
                writable: !0,
                value: t.AnnotationEditorType.NONE
              }), p(this, T, {
                writable: !0,
                value: /* @__PURE__ */ new Set()
              }), p(this, w, {
                writable: !0,
                value: this.keydown.bind(this)
              }), p(this, g, {
                writable: !0,
                value: this.onEditingAction.bind(this)
              }), p(this, K, {
                writable: !0,
                value: this.onPageChanging.bind(this)
              }), p(this, a, {
                writable: !0,
                value: {
                  isEditing: !1,
                  isEmpty: !0,
                  hasEmptyClipboard: !0,
                  hasSomethingToUndo: !1,
                  hasSomethingToRedo: !1,
                  hasSelectedEditor: !1
                }
              }), p(this, Y, {
                writable: !0,
                value: null
              }), M(this, Y, cl), M(this, al, Il), n(this, al)._on("editingaction", n(this, g)), n(this, al)._on("pagechanging", n(this, K));
            }
            destroy() {
              h(this, C, Yl).call(this), n(this, al)._off("editingaction", n(this, g)), n(this, al)._off("pagechanging", n(this, K));
              for (const cl of n(this, H).values())
                cl.destroy();
              n(this, H).clear(), n(this, A).clear(), M(this, B, null), n(this, T).clear(), n(this, O).destroy(), n(this, U).destroy();
            }
            onPageChanging(cl) {
              let {
                pageNumber: Il
              } = cl;
              M(this, k, Il - 1);
            }
            focusMainContainer() {
              n(this, Y).focus();
            }
            keydown(cl) {
              var Il;
              (Il = this.getActive()) !== null && Il !== void 0 && Il.shouldGetKeyboardEvents() || ml._keyboardManager.exec(this, cl);
            }
            onEditingAction(cl) {
              ["undo", "redo", "cut", "copy", "paste", "delete", "selectAll"].includes(cl.name) && this[cl.name]();
            }
            setEditingState(cl) {
              cl ? (h(this, z, Gl).call(this), h(this, F, yl).call(this, {
                isEditing: n(this, Q) !== t.AnnotationEditorType.NONE,
                isEmpty: h(this, el, Al).call(this),
                hasSomethingToUndo: n(this, U).hasSomethingToUndo(),
                hasSomethingToRedo: n(this, U).hasSomethingToRedo(),
                hasSelectedEditor: !1,
                hasEmptyClipboard: n(this, O).isEmpty()
              })) : (h(this, C, Yl).call(this), h(this, F, yl).call(this, {
                isEditing: !1
              }));
            }
            registerEditorTypes(cl) {
              M(this, q, cl);
              for (const Il of n(this, q))
                h(this, v, Vl).call(this, Il.defaultPropertiesToUpdate);
            }
            getId() {
              return n(this, Ml).getId();
            }
            addLayer(cl) {
              n(this, H).set(cl.pageIndex, cl), n(this, wl) ? cl.enable() : cl.disable();
            }
            removeLayer(cl) {
              n(this, H).delete(cl.pageIndex);
            }
            updateMode(cl) {
              if (M(this, Q, cl), cl === t.AnnotationEditorType.NONE)
                this.setEditingState(!1), h(this, il, Xl).call(this);
              else {
                this.setEditingState(!0), h(this, $, Dl).call(this);
                for (const Il of n(this, H).values())
                  Il.updateMode(cl);
              }
            }
            updateToolbar(cl) {
              cl !== n(this, Q) && n(this, al).dispatch("switchannotationeditormode", {
                source: this,
                mode: cl
              });
            }
            updateParams(cl, Il) {
              for (const Jl of n(this, T))
                Jl.updateParams(cl, Il);
              for (const Jl of n(this, q))
                Jl.updateDefaultParams(cl, Il);
            }
            getEditors(cl) {
              const Il = [];
              for (const Jl of n(this, A).values())
                Jl.pageIndex === cl && Il.push(Jl);
              return Il;
            }
            getEditor(cl) {
              return n(this, A).get(cl);
            }
            addEditor(cl) {
              n(this, A).set(cl.id, cl);
            }
            removeEditor(cl) {
              n(this, A).delete(cl.id), this.unselect(cl);
            }
            setActiveEditor(cl) {
              n(this, B) !== cl && (M(this, B, cl), cl && h(this, v, Vl).call(this, cl.propertiesToUpdate));
            }
            toggleSelected(cl) {
              if (n(this, T).has(cl)) {
                n(this, T).delete(cl), cl.unselect(), h(this, F, yl).call(this, {
                  hasSelectedEditor: this.hasSelection
                });
                return;
              }
              n(this, T).add(cl), cl.select(), h(this, v, Vl).call(this, cl.propertiesToUpdate), h(this, F, yl).call(this, {
                hasSelectedEditor: !0
              });
            }
            setSelected(cl) {
              for (const Il of n(this, T))
                Il !== cl && Il.unselect();
              n(this, T).clear(), n(this, T).add(cl), cl.select(), h(this, v, Vl).call(this, cl.propertiesToUpdate), h(this, F, yl).call(this, {
                hasSelectedEditor: !0
              });
            }
            isSelected(cl) {
              return n(this, T).has(cl);
            }
            unselect(cl) {
              cl.unselect(), n(this, T).delete(cl), h(this, F, yl).call(this, {
                hasSelectedEditor: this.hasSelection
              });
            }
            get hasSelection() {
              return n(this, T).size !== 0;
            }
            undo() {
              n(this, U).undo(), h(this, F, yl).call(this, {
                hasSomethingToUndo: n(this, U).hasSomethingToUndo(),
                hasSomethingToRedo: !0,
                isEmpty: h(this, el, Al).call(this)
              });
            }
            redo() {
              n(this, U).redo(), h(this, F, yl).call(this, {
                hasSomethingToUndo: !0,
                hasSomethingToRedo: n(this, U).hasSomethingToRedo(),
                isEmpty: h(this, el, Al).call(this)
              });
            }
            addCommands(cl) {
              n(this, U).add(cl), h(this, F, yl).call(this, {
                hasSomethingToUndo: !0,
                hasSomethingToRedo: !1,
                isEmpty: h(this, el, Al).call(this)
              });
            }
            delete() {
              if (n(this, B) && n(this, B).commitOrRemove(), !this.hasSelection)
                return;
              const cl = [...n(this, T)], Il = () => {
                for (const fl of cl)
                  fl.remove();
              }, Jl = () => {
                for (const fl of cl)
                  h(this, dl, Hl).call(this, fl);
              };
              this.addCommands({
                cmd: Il,
                undo: Jl,
                mustExec: !0
              });
            }
            copy() {
              if (n(this, B) && n(this, B).commitOrRemove(), this.hasSelection) {
                const cl = [];
                for (const Il of n(this, T))
                  Il.isEmpty() || cl.push(Il);
                if (cl.length === 0)
                  return;
                n(this, O).copy(cl), h(this, F, yl).call(this, {
                  hasEmptyClipboard: !1
                });
              }
            }
            cut() {
              this.copy(), this.delete();
            }
            paste() {
              if (n(this, O).isEmpty())
                return;
              this.unselectAll();
              const cl = n(this, H).get(n(this, k)), Il = n(this, O).paste().map((Nl) => cl.deserialize(Nl)), Jl = () => {
                for (const Nl of Il)
                  h(this, dl, Hl).call(this, Nl);
                h(this, bl, Sl).call(this, Il);
              }, fl = () => {
                for (const Nl of Il)
                  Nl.remove();
              };
              this.addCommands({
                cmd: Jl,
                undo: fl,
                mustExec: !0
              });
            }
            selectAll() {
              for (const cl of n(this, T))
                cl.commit();
              h(this, bl, Sl).call(this, n(this, A).values());
            }
            unselectAll() {
              if (n(this, B)) {
                n(this, B).commitOrRemove();
                return;
              }
              if (h(this, bl, Sl).size !== 0) {
                for (const cl of n(this, T))
                  cl.unselect();
                n(this, T).clear(), h(this, F, yl).call(this, {
                  hasSelectedEditor: !1
                });
              }
            }
            isActive(cl) {
              return n(this, B) === cl;
            }
            getActive() {
              return n(this, B);
            }
            getMode() {
              return n(this, Q);
            }
          }
          c.AnnotationEditorUIManager = ml;
          function Gl() {
            n(this, Y).addEventListener("keydown", n(this, w));
          }
          function Yl() {
            n(this, Y).removeEventListener("keydown", n(this, w));
          }
          function yl(ol) {
            Object.entries(ol).some((Il) => {
              let [Jl, fl] = Il;
              return n(this, a)[Jl] !== fl;
            }) && n(this, al).dispatch("annotationeditorstateschanged", {
              source: this,
              details: Object.assign(n(this, a), ol)
            });
          }
          function Vl(ol) {
            n(this, al).dispatch("annotationeditorparamschanged", {
              source: this,
              details: ol
            });
          }
          function Dl() {
            if (!n(this, wl)) {
              M(this, wl, !0);
              for (const ol of n(this, H).values())
                ol.enable();
            }
          }
          function Xl() {
            if (this.unselectAll(), n(this, wl)) {
              M(this, wl, !1);
              for (const ol of n(this, H).values())
                ol.disable();
            }
          }
          function Hl(ol) {
            const cl = n(this, H).get(ol.pageIndex);
            cl ? cl.addOrRebuild(ol) : this.addEditor(ol);
          }
          function Al() {
            if (n(this, A).size === 0)
              return !0;
            if (n(this, A).size === 1)
              for (const ol of n(this, A).values())
                return ol.isEmpty();
            return !1;
          }
          function Sl(ol) {
            n(this, T).clear();
            for (const cl of ol)
              cl.isEmpty() || (n(this, T).add(cl), cl.select());
            h(this, F, yl).call(this, {
              hasSelectedEditor: !0
            });
          }
          W(ml, "_keyboardManager", new r([[["ctrl+a", "mac+meta+a"], ml.prototype.selectAll], [["ctrl+c", "mac+meta+c"], ml.prototype.copy], [["ctrl+v", "mac+meta+v"], ml.prototype.paste], [["ctrl+x", "mac+meta+x"], ml.prototype.cut], [["ctrl+z", "mac+meta+z"], ml.prototype.undo], [["ctrl+y", "ctrl+shift+Z", "mac+meta+shift+Z"], ml.prototype.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete"], ml.prototype.delete], [["Escape", "mac+Escape"], ml.prototype.unselectAll]]));
        },
        /* 133 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.StatTimer = c.RenderingCancelledException = c.PixelsPerInch = c.PageViewport = c.PDFDateString = c.DOMStandardFontDataFactory = c.DOMSVGFactory = c.DOMCanvasFactory = c.DOMCMapReaderFactory = c.AnnotationPrefix = void 0, c.deprecated = N, c.getColorValues = f, c.getCurrentTransform = P, c.getCurrentTransformInverse = B, c.getFilenameFromUrl = u, c.getPdfFilenameFromUrl = e, c.getRGB = D, c.getXfaPageViewport = j, c.isDataScheme = R, c.isPdfFile = J, c.isValidFetchUrl = d, c.loadScript = b;
          var t = i(134), Z = i(1);
          function W(A, H, O) {
            return H in A ? Object.defineProperty(A, H, { value: O, enumerable: !0, configurable: !0, writable: !0 }) : A[H] = O, A;
          }
          const y = "http://www.w3.org/2000/svg", h = "pdfjs_internal_id_";
          c.AnnotationPrefix = h;
          class p {
          }
          c.PixelsPerInch = p, W(p, "CSS", 96), W(p, "PDF", 72), W(p, "PDF_TO_CSS_UNITS", p.CSS / p.PDF);
          class X extends t.BaseCanvasFactory {
            constructor() {
              let {
                ownerDocument: H = globalThis.document
              } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              super(), this._document = H;
            }
            _createCanvas(H, O) {
              const U = this._document.createElement("canvas");
              return U.width = H, U.height = O, U;
            }
          }
          c.DOMCanvasFactory = X;
          async function M(A) {
            let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            if (d(A, document.baseURI)) {
              const O = await fetch(A);
              if (!O.ok)
                throw new Error(O.statusText);
              return H ? new Uint8Array(await O.arrayBuffer()) : (0, Z.stringToBytes)(await O.text());
            }
            return new Promise((O, U) => {
              const k = new XMLHttpRequest();
              k.open("GET", A, !0), H && (k.responseType = "arraybuffer"), k.onreadystatechange = () => {
                if (k.readyState === XMLHttpRequest.DONE) {
                  if (k.status === 200 || k.status === 0) {
                    let q;
                    if (H && k.response ? q = new Uint8Array(k.response) : !H && k.responseText && (q = (0, Z.stringToBytes)(k.responseText)), q) {
                      O(q);
                      return;
                    }
                  }
                  U(new Error(k.statusText));
                }
              }, k.send(null);
            });
          }
          class x extends t.BaseCMapReaderFactory {
            _fetchData(H, O) {
              return M(H, this.isCompressed).then((U) => ({
                cMapData: U,
                compressionType: O
              }));
            }
          }
          c.DOMCMapReaderFactory = x;
          class n extends t.BaseStandardFontDataFactory {
            _fetchData(H) {
              return M(H, !0);
            }
          }
          c.DOMStandardFontDataFactory = n;
          class V extends t.BaseSVGFactory {
            _createSVG(H) {
              return document.createElementNS(y, H);
            }
          }
          c.DOMSVGFactory = V;
          class S {
            constructor(H) {
              let {
                viewBox: O,
                scale: U,
                rotation: k,
                offsetX: q = 0,
                offsetY: al = 0,
                dontFlip: Ml = !1
              } = H;
              this.viewBox = O, this.scale = U, this.rotation = k, this.offsetX = q, this.offsetY = al;
              const wl = (O[2] + O[0]) / 2, Q = (O[3] + O[1]) / 2;
              let T, w, g, K;
              switch (k %= 360, k < 0 && (k += 360), k) {
                case 180:
                  T = -1, w = 0, g = 0, K = 1;
                  break;
                case 90:
                  T = 0, w = 1, g = 1, K = 0;
                  break;
                case 270:
                  T = 0, w = -1, g = -1, K = 0;
                  break;
                case 0:
                  T = 1, w = 0, g = 0, K = -1;
                  break;
                default:
                  throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
              }
              Ml && (g = -g, K = -K);
              let a, Y, z, C;
              T === 0 ? (a = Math.abs(Q - O[1]) * U + q, Y = Math.abs(wl - O[0]) * U + al, z = Math.abs(O[3] - O[1]) * U, C = Math.abs(O[2] - O[0]) * U) : (a = Math.abs(wl - O[0]) * U + q, Y = Math.abs(Q - O[1]) * U + al, z = Math.abs(O[2] - O[0]) * U, C = Math.abs(O[3] - O[1]) * U), this.transform = [T * U, w * U, g * U, K * U, a - T * U * wl - g * U * Q, Y - w * U * wl - K * U * Q], this.width = z, this.height = C;
            }
            clone() {
              let {
                scale: H = this.scale,
                rotation: O = this.rotation,
                offsetX: U = this.offsetX,
                offsetY: k = this.offsetY,
                dontFlip: q = !1
              } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              return new S({
                viewBox: this.viewBox.slice(),
                scale: H,
                rotation: O,
                offsetX: U,
                offsetY: k,
                dontFlip: q
              });
            }
            convertToViewportPoint(H, O) {
              return Z.Util.applyTransform([H, O], this.transform);
            }
            convertToViewportRectangle(H) {
              const O = Z.Util.applyTransform([H[0], H[1]], this.transform), U = Z.Util.applyTransform([H[2], H[3]], this.transform);
              return [O[0], O[1], U[0], U[1]];
            }
            convertToPdfPoint(H, O) {
              return Z.Util.applyInverseTransform([H, O], this.transform);
            }
          }
          c.PageViewport = S;
          class o extends Z.BaseException {
            constructor(H, O) {
              super(H, "RenderingCancelledException"), this.type = O;
            }
          }
          c.RenderingCancelledException = o;
          function R(A) {
            const H = A.length;
            let O = 0;
            for (; O < H && A[O].trim() === ""; )
              O++;
            return A.substring(O, O + 5).toLowerCase() === "data:";
          }
          function J(A) {
            return typeof A == "string" && /\.pdf$/i.test(A);
          }
          function u(A) {
            const H = A.indexOf("#"), O = A.indexOf("?"), U = Math.min(H > 0 ? H : A.length, O > 0 ? O : A.length);
            return A.substring(A.lastIndexOf("/", U) + 1, U);
          }
          function e(A) {
            let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "document.pdf";
            if (typeof A != "string")
              return H;
            if (R(A))
              return (0, Z.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), H;
            const O = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/, U = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, k = O.exec(A);
            let q = U.exec(k[1]) || U.exec(k[2]) || U.exec(k[3]);
            if (q && (q = q[0], q.includes("%")))
              try {
                q = U.exec(decodeURIComponent(q))[0];
              } catch {
              }
            return q || H;
          }
          class m {
            constructor() {
              this.started = /* @__PURE__ */ Object.create(null), this.times = [];
            }
            time(H) {
              H in this.started && (0, Z.warn)(`Timer is already running for ${H}`), this.started[H] = Date.now();
            }
            timeEnd(H) {
              H in this.started || (0, Z.warn)(`Timer has not been started for ${H}`), this.times.push({
                name: H,
                start: this.started[H],
                end: Date.now()
              }), delete this.started[H];
            }
            toString() {
              const H = [];
              let O = 0;
              for (const U of this.times) {
                const k = U.name;
                k.length > O && (O = k.length);
              }
              for (const U of this.times) {
                const k = U.end - U.start;
                H.push(`${U.name.padEnd(O)} ${k}ms
`);
              }
              return H.join("");
            }
          }
          c.StatTimer = m;
          function d(A, H) {
            try {
              const {
                protocol: O
              } = H ? new URL(A, H) : new URL(A);
              return O === "http:" || O === "https:";
            } catch {
              return !1;
            }
          }
          function b(A) {
            let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            return new Promise((O, U) => {
              const k = document.createElement("script");
              k.src = A, k.onload = function(q) {
                H && k.remove(), O(q);
              }, k.onerror = function() {
                U(new Error(`Cannot load script at: ${k.src}`));
              }, (document.head || document.documentElement).append(k);
            });
          }
          function N(A) {
            console.log("Deprecated API usage: " + A);
          }
          let G;
          class r {
            static toDateObject(H) {
              if (!H || typeof H != "string")
                return null;
              G || (G = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
              const O = G.exec(H);
              if (!O)
                return null;
              const U = parseInt(O[1], 10);
              let k = parseInt(O[2], 10);
              k = k >= 1 && k <= 12 ? k - 1 : 0;
              let q = parseInt(O[3], 10);
              q = q >= 1 && q <= 31 ? q : 1;
              let al = parseInt(O[4], 10);
              al = al >= 0 && al <= 23 ? al : 0;
              let Ml = parseInt(O[5], 10);
              Ml = Ml >= 0 && Ml <= 59 ? Ml : 0;
              let wl = parseInt(O[6], 10);
              wl = wl >= 0 && wl <= 59 ? wl : 0;
              const Q = O[7] || "Z";
              let T = parseInt(O[8], 10);
              T = T >= 0 && T <= 23 ? T : 0;
              let w = parseInt(O[9], 10) || 0;
              return w = w >= 0 && w <= 59 ? w : 0, Q === "-" ? (al += T, Ml += w) : Q === "+" && (al -= T, Ml -= w), new Date(Date.UTC(U, k, q, al, Ml, wl));
            }
          }
          c.PDFDateString = r;
          function j(A, H) {
            let {
              scale: O = 1,
              rotation: U = 0
            } = H;
            const {
              width: k,
              height: q
            } = A.attributes.style, al = [0, 0, parseInt(k), parseInt(q)];
            return new S({
              viewBox: al,
              scale: O,
              rotation: U
            });
          }
          function D(A) {
            if (A.startsWith("#")) {
              const H = parseInt(A.slice(1), 16);
              return [(H & 16711680) >> 16, (H & 65280) >> 8, H & 255];
            }
            return A.startsWith("rgb(") ? A.slice(4, -1).split(",").map((H) => parseInt(H)) : A.startsWith("rgba(") ? A.slice(5, -1).split(",").map((H) => parseInt(H)).slice(0, 3) : ((0, Z.warn)(`Not a valid color format: "${A}"`), [0, 0, 0]);
          }
          function f(A) {
            const H = document.createElement("span");
            H.style.visibility = "hidden", document.body.append(H);
            for (const O of A.keys()) {
              H.style.color = O;
              const U = window.getComputedStyle(H).color;
              A.set(O, D(U));
            }
            H.remove();
          }
          function P(A) {
            const {
              a: H,
              b: O,
              c: U,
              d: k,
              e: q,
              f: al
            } = A.getTransform();
            return [H, O, U, k, q, al];
          }
          function B(A) {
            const {
              a: H,
              b: O,
              c: U,
              d: k,
              e: q,
              f: al
            } = A.getTransform().invertSelf();
            return [H, O, U, k, q, al];
          }
        },
        /* 134 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.BaseStandardFontDataFactory = c.BaseSVGFactory = c.BaseCanvasFactory = c.BaseCMapReaderFactory = void 0;
          var t = i(1);
          class Z {
            constructor() {
              this.constructor === Z && (0, t.unreachable)("Cannot initialize BaseCanvasFactory.");
            }
            create(X, M) {
              if (X <= 0 || M <= 0)
                throw new Error("Invalid canvas size");
              const x = this._createCanvas(X, M);
              return {
                canvas: x,
                context: x.getContext("2d")
              };
            }
            reset(X, M, x) {
              if (!X.canvas)
                throw new Error("Canvas is not specified");
              if (M <= 0 || x <= 0)
                throw new Error("Invalid canvas size");
              X.canvas.width = M, X.canvas.height = x;
            }
            destroy(X) {
              if (!X.canvas)
                throw new Error("Canvas is not specified");
              X.canvas.width = 0, X.canvas.height = 0, X.canvas = null, X.context = null;
            }
            _createCanvas(X, M) {
              (0, t.unreachable)("Abstract method `_createCanvas` called.");
            }
          }
          c.BaseCanvasFactory = Z;
          class W {
            constructor(X) {
              let {
                baseUrl: M = null,
                isCompressed: x = !1
              } = X;
              this.constructor === W && (0, t.unreachable)("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = M, this.isCompressed = x;
            }
            async fetch(X) {
              let {
                name: M
              } = X;
              if (!this.baseUrl)
                throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
              if (!M)
                throw new Error("CMap name must be specified.");
              const x = this.baseUrl + M + (this.isCompressed ? ".bcmap" : ""), n = this.isCompressed ? t.CMapCompressionType.BINARY : t.CMapCompressionType.NONE;
              return this._fetchData(x, n).catch((V) => {
                throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${x}`);
              });
            }
            _fetchData(X, M) {
              (0, t.unreachable)("Abstract method `_fetchData` called.");
            }
          }
          c.BaseCMapReaderFactory = W;
          class y {
            constructor(X) {
              let {
                baseUrl: M = null
              } = X;
              this.constructor === y && (0, t.unreachable)("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = M;
            }
            async fetch(X) {
              let {
                filename: M
              } = X;
              if (!this.baseUrl)
                throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
              if (!M)
                throw new Error("Font filename must be specified.");
              const x = `${this.baseUrl}${M}`;
              return this._fetchData(x).catch((n) => {
                throw new Error(`Unable to load font data at: ${x}`);
              });
            }
            _fetchData(X) {
              (0, t.unreachable)("Abstract method `_fetchData` called.");
            }
          }
          c.BaseStandardFontDataFactory = y;
          class h {
            constructor() {
              this.constructor === h && (0, t.unreachable)("Cannot initialize BaseSVGFactory.");
            }
            create(X, M) {
              let x = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
              if (X <= 0 || M <= 0)
                throw new Error("Invalid SVG dimensions");
              const n = this._createSVG("svg:svg");
              return n.setAttribute("version", "1.1"), x || (n.setAttribute("width", `${X}px`), n.setAttribute("height", `${M}px`)), n.setAttribute("preserveAspectRatio", "none"), n.setAttribute("viewBox", `0 0 ${X} ${M}`), n;
            }
            createElement(X) {
              if (typeof X != "string")
                throw new Error("Invalid SVG element type");
              return this._createSVG(X);
            }
            _createSVG(X) {
              (0, t.unreachable)("Abstract method `_createSVG` called.");
            }
          }
          c.BaseSVGFactory = h;
        },
        /* 135 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.MurmurHash3_64 = void 0;
          var t = i(1);
          const Z = 3285377520, W = 4294901760, y = 65535;
          class h {
            constructor(X) {
              this.h1 = X ? X & 4294967295 : Z, this.h2 = X ? X & 4294967295 : Z;
            }
            update(X) {
              let M, x;
              if (typeof X == "string") {
                M = new Uint8Array(X.length * 2), x = 0;
                for (let N = 0, G = X.length; N < G; N++) {
                  const r = X.charCodeAt(N);
                  r <= 255 ? M[x++] = r : (M[x++] = r >>> 8, M[x++] = r & 255);
                }
              } else if ((0, t.isArrayBuffer)(X))
                M = X.slice(), x = M.byteLength;
              else
                throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
              const n = x >> 2, V = x - n * 4, S = new Uint32Array(M.buffer, 0, n);
              let o = 0, R = 0, J = this.h1, u = this.h2;
              const e = 3432918353, m = 461845907, d = e & y, b = m & y;
              for (let N = 0; N < n; N++)
                N & 1 ? (o = S[N], o = o * e & W | o * d & y, o = o << 15 | o >>> 17, o = o * m & W | o * b & y, J ^= o, J = J << 13 | J >>> 19, J = J * 5 + 3864292196) : (R = S[N], R = R * e & W | R * d & y, R = R << 15 | R >>> 17, R = R * m & W | R * b & y, u ^= R, u = u << 13 | u >>> 19, u = u * 5 + 3864292196);
              switch (o = 0, V) {
                case 3:
                  o ^= M[n * 4 + 2] << 16;
                case 2:
                  o ^= M[n * 4 + 1] << 8;
                case 1:
                  o ^= M[n * 4], o = o * e & W | o * d & y, o = o << 15 | o >>> 17, o = o * m & W | o * b & y, n & 1 ? J ^= o : u ^= o;
              }
              this.h1 = J, this.h2 = u;
            }
            hexdigest() {
              let X = this.h1, M = this.h2;
              X ^= M >>> 1, X = X * 3981806797 & W | X * 36045 & y, M = M * 4283543511 & W | ((M << 16 | X >>> 16) * 2950163797 & W) >>> 16, X ^= M >>> 1, X = X * 444984403 & W | X * 60499 & y, M = M * 3301882366 & W | ((M << 16 | X >>> 16) * 3120437893 & W) >>> 16, X ^= M >>> 1;
              const x = (X >>> 0).toString(16), n = (M >>> 0).toString(16);
              return x.padStart(8, "0") + n.padStart(8, "0");
            }
          }
          c.MurmurHash3_64 = h;
        },
        /* 136 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.FontLoader = c.FontFaceObject = void 0;
          var t = i(1);
          class Z {
            constructor(p) {
              let {
                docId: X,
                onUnsupportedFeature: M,
                ownerDocument: x = globalThis.document,
                styleElement: n = null
              } = p;
              this.constructor === Z && (0, t.unreachable)("Cannot initialize BaseFontLoader."), this.docId = X, this._onUnsupportedFeature = M, this._document = x, this.nativeFontFaces = [], this.styleElement = null;
            }
            addNativeFontFace(p) {
              this.nativeFontFaces.push(p), this._document.fonts.add(p);
            }
            insertRule(p) {
              let X = this.styleElement;
              X || (X = this.styleElement = this._document.createElement("style"), X.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`, this._document.documentElement.getElementsByTagName("head")[0].append(X));
              const M = X.sheet;
              M.insertRule(p, M.cssRules.length);
            }
            clear() {
              for (const p of this.nativeFontFaces)
                this._document.fonts.delete(p);
              this.nativeFontFaces.length = 0, this.styleElement && (this.styleElement.remove(), this.styleElement = null);
            }
            async bind(p) {
              if (p.attached || p.missingFile)
                return;
              if (p.attached = !0, this.isFontLoadingAPISupported) {
                const M = p.createNativeFontFace();
                if (M) {
                  this.addNativeFontFace(M);
                  try {
                    await M.loaded;
                  } catch (x) {
                    throw this._onUnsupportedFeature({
                      featureId: t.UNSUPPORTED_FEATURES.errorFontLoadNative
                    }), (0, t.warn)(`Failed to load font '${M.family}': '${x}'.`), p.disableFontFace = !0, x;
                  }
                }
                return;
              }
              const X = p.createFontFaceRule();
              if (X) {
                if (this.insertRule(X), this.isSyncFontLoadingSupported)
                  return;
                await new Promise((M) => {
                  const x = this._queueLoadingCallback(M);
                  this._prepareFontLoadEvent([X], [p], x);
                });
              }
            }
            _queueLoadingCallback(p) {
              (0, t.unreachable)("Abstract method `_queueLoadingCallback`.");
            }
            get isFontLoadingAPISupported() {
              var p;
              const X = !!((p = this._document) !== null && p !== void 0 && p.fonts);
              return (0, t.shadow)(this, "isFontLoadingAPISupported", X);
            }
            get isSyncFontLoadingSupported() {
              (0, t.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
            }
            get _loadTestFont() {
              (0, t.unreachable)("Abstract method `_loadTestFont`.");
            }
            _prepareFontLoadEvent(p, X, M) {
              (0, t.unreachable)("Abstract method `_prepareFontLoadEvent`.");
            }
          }
          let W;
          c.FontLoader = W, c.FontLoader = W = class extends Z {
            constructor(p) {
              super(p), this.loadingContext = {
                requests: [],
                nextRequestId: 0
              }, this.loadTestFontId = 0;
            }
            get isSyncFontLoadingSupported() {
              let p = !1;
              if (typeof navigator > "u")
                p = !0;
              else {
                const X = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
                (X == null ? void 0 : X[1]) >= 14 && (p = !0);
              }
              return (0, t.shadow)(this, "isSyncFontLoadingSupported", p);
            }
            _queueLoadingCallback(p) {
              function X() {
                for ((0, t.assert)(!x.done, "completeRequest() cannot be called twice."), x.done = !0; M.requests.length > 0 && M.requests[0].done; ) {
                  const n = M.requests.shift();
                  setTimeout(n.callback, 0);
                }
              }
              const M = this.loadingContext, x = {
                id: `pdfjs-font-loading-${M.nextRequestId++}`,
                done: !1,
                complete: X,
                callback: p
              };
              return M.requests.push(x), x;
            }
            get _loadTestFont() {
              const p = function() {
                return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
              };
              return (0, t.shadow)(this, "_loadTestFont", p());
            }
            _prepareFontLoadEvent(p, X, M) {
              function x(P, B) {
                return P.charCodeAt(B) << 24 | P.charCodeAt(B + 1) << 16 | P.charCodeAt(B + 2) << 8 | P.charCodeAt(B + 3) & 255;
              }
              function n(P, B, A, H) {
                const O = P.substring(0, B), U = P.substring(B + A);
                return O + H + U;
              }
              let V, S;
              const o = this._document.createElement("canvas");
              o.width = 1, o.height = 1;
              const R = o.getContext("2d");
              let J = 0;
              function u(P, B) {
                if (J++, J > 30) {
                  (0, t.warn)("Load test font never loaded."), B();
                  return;
                }
                if (R.font = "30px " + P, R.fillText(".", 0, 20), R.getImageData(0, 0, 1, 1).data[3] > 0) {
                  B();
                  return;
                }
                setTimeout(u.bind(null, P, B));
              }
              const e = `lt${Date.now()}${this.loadTestFontId++}`;
              let m = this._loadTestFont;
              m = n(m, 976, e.length, e);
              const b = 16, N = 1482184792;
              let G = x(m, b);
              for (V = 0, S = e.length - 3; V < S; V += 4)
                G = G - N + x(e, V) | 0;
              V < e.length && (G = G - N + x(e + "XXX", V) | 0), m = n(m, b, 4, (0, t.string32)(G));
              const r = `url(data:font/opentype;base64,${btoa(m)});`, j = `@font-face {font-family:"${e}";src:${r}}`;
              this.insertRule(j);
              const D = [];
              for (const P of X)
                D.push(P.loadedName);
              D.push(e);
              const f = this._document.createElement("div");
              f.style.visibility = "hidden", f.style.width = f.style.height = "10px", f.style.position = "absolute", f.style.top = f.style.left = "0px";
              for (const P of D) {
                const B = this._document.createElement("span");
                B.textContent = "Hi", B.style.fontFamily = P, f.append(B);
              }
              this._document.body.append(f), u(e, () => {
                f.remove(), M.complete();
              });
            }
          };
          class y {
            constructor(p, X) {
              let {
                isEvalSupported: M = !0,
                disableFontFace: x = !1,
                ignoreErrors: n = !1,
                onUnsupportedFeature: V,
                fontRegistry: S = null
              } = X;
              this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
              for (const o in p)
                this[o] = p[o];
              this.isEvalSupported = M !== !1, this.disableFontFace = x === !0, this.ignoreErrors = n === !0, this._onUnsupportedFeature = V, this.fontRegistry = S;
            }
            createNativeFontFace() {
              if (!this.data || this.disableFontFace)
                return null;
              let p;
              if (!this.cssFontInfo)
                p = new FontFace(this.loadedName, this.data, {});
              else {
                const X = {
                  weight: this.cssFontInfo.fontWeight
                };
                this.cssFontInfo.italicAngle && (X.style = `oblique ${this.cssFontInfo.italicAngle}deg`), p = new FontFace(this.cssFontInfo.fontFamily, this.data, X);
              }
              return this.fontRegistry && this.fontRegistry.registerFont(this), p;
            }
            createFontFaceRule() {
              if (!this.data || this.disableFontFace)
                return null;
              const p = (0, t.bytesToString)(this.data), X = `url(data:${this.mimetype};base64,${btoa(p)});`;
              let M;
              if (!this.cssFontInfo)
                M = `@font-face {font-family:"${this.loadedName}";src:${X}}`;
              else {
                let x = `font-weight: ${this.cssFontInfo.fontWeight};`;
                this.cssFontInfo.italicAngle && (x += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), M = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${x}src:${X}}`;
              }
              return this.fontRegistry && this.fontRegistry.registerFont(this, X), M;
            }
            getPathGenerator(p, X) {
              if (this.compiledGlyphs[X] !== void 0)
                return this.compiledGlyphs[X];
              let M;
              try {
                M = p.get(this.loadedName + "_path_" + X);
              } catch (x) {
                if (!this.ignoreErrors)
                  throw x;
                return this._onUnsupportedFeature({
                  featureId: t.UNSUPPORTED_FEATURES.errorFontGetPath
                }), (0, t.warn)(`getPathGenerator - ignoring character: "${x}".`), this.compiledGlyphs[X] = function(n, V) {
                };
              }
              if (this.isEvalSupported && t.FeatureTest.isEvalSupported) {
                const x = [];
                for (const n of M) {
                  const V = n.args !== void 0 ? n.args.join(",") : "";
                  x.push("c.", n.cmd, "(", V, `);
`);
                }
                return this.compiledGlyphs[X] = new Function("c", "size", x.join(""));
              }
              return this.compiledGlyphs[X] = function(x, n) {
                for (const V of M)
                  V.cmd === "scale" && (V.args = [n, -n]), x[V.cmd].apply(x, V.args);
              };
            }
          }
          c.FontFaceObject = y;
        },
        /* 137 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.CanvasGraphics = void 0;
          var t = i(133), Z = i(1), W = i(138), y = i(139), h = i(3);
          function p(Q, T) {
            X(Q, T), T.add(Q);
          }
          function X(Q, T) {
            if (T.has(Q))
              throw new TypeError("Cannot initialize the same private elements twice on an object");
          }
          function M(Q, T, w) {
            if (!T.has(Q))
              throw new TypeError("attempted to get private field on non-instance");
            return w;
          }
          const x = 16, n = 100, V = 4096, S = 15, o = 10, R = h.isNodeJS && typeof Path2D > "u" ? -1 : 1e3, J = 16;
          function u(Q, T) {
            if (Q._removeMirroring)
              throw new Error("Context is already forwarding operations.");
            Q.__originalSave = Q.save, Q.__originalRestore = Q.restore, Q.__originalRotate = Q.rotate, Q.__originalScale = Q.scale, Q.__originalTranslate = Q.translate, Q.__originalTransform = Q.transform, Q.__originalSetTransform = Q.setTransform, Q.__originalResetTransform = Q.resetTransform, Q.__originalClip = Q.clip, Q.__originalMoveTo = Q.moveTo, Q.__originalLineTo = Q.lineTo, Q.__originalBezierCurveTo = Q.bezierCurveTo, Q.__originalRect = Q.rect, Q.__originalClosePath = Q.closePath, Q.__originalBeginPath = Q.beginPath, Q._removeMirroring = () => {
              Q.save = Q.__originalSave, Q.restore = Q.__originalRestore, Q.rotate = Q.__originalRotate, Q.scale = Q.__originalScale, Q.translate = Q.__originalTranslate, Q.transform = Q.__originalTransform, Q.setTransform = Q.__originalSetTransform, Q.resetTransform = Q.__originalResetTransform, Q.clip = Q.__originalClip, Q.moveTo = Q.__originalMoveTo, Q.lineTo = Q.__originalLineTo, Q.bezierCurveTo = Q.__originalBezierCurveTo, Q.rect = Q.__originalRect, Q.closePath = Q.__originalClosePath, Q.beginPath = Q.__originalBeginPath, delete Q._removeMirroring;
            }, Q.save = function() {
              T.save(), this.__originalSave();
            }, Q.restore = function() {
              T.restore(), this.__originalRestore();
            }, Q.translate = function(g, K) {
              T.translate(g, K), this.__originalTranslate(g, K);
            }, Q.scale = function(g, K) {
              T.scale(g, K), this.__originalScale(g, K);
            }, Q.transform = function(g, K, a, Y, z, C) {
              T.transform(g, K, a, Y, z, C), this.__originalTransform(g, K, a, Y, z, C);
            }, Q.setTransform = function(g, K, a, Y, z, C) {
              T.setTransform(g, K, a, Y, z, C), this.__originalSetTransform(g, K, a, Y, z, C);
            }, Q.resetTransform = function() {
              T.resetTransform(), this.__originalResetTransform();
            }, Q.rotate = function(g) {
              T.rotate(g), this.__originalRotate(g);
            }, Q.clip = function(g) {
              T.clip(g), this.__originalClip(g);
            }, Q.moveTo = function(w, g) {
              T.moveTo(w, g), this.__originalMoveTo(w, g);
            }, Q.lineTo = function(w, g) {
              T.lineTo(w, g), this.__originalLineTo(w, g);
            }, Q.bezierCurveTo = function(w, g, K, a, Y, z) {
              T.bezierCurveTo(w, g, K, a, Y, z), this.__originalBezierCurveTo(w, g, K, a, Y, z);
            }, Q.rect = function(w, g, K, a) {
              T.rect(w, g, K, a), this.__originalRect(w, g, K, a);
            }, Q.closePath = function() {
              T.closePath(), this.__originalClosePath();
            }, Q.beginPath = function() {
              T.beginPath(), this.__originalBeginPath();
            };
          }
          class e {
            constructor(T) {
              this.canvasFactory = T, this.cache = /* @__PURE__ */ Object.create(null);
            }
            getCanvas(T, w, g) {
              let K;
              return this.cache[T] !== void 0 ? (K = this.cache[T], this.canvasFactory.reset(K, w, g)) : (K = this.canvasFactory.create(w, g), this.cache[T] = K), K;
            }
            delete(T) {
              delete this.cache[T];
            }
            clear() {
              for (const T in this.cache) {
                const w = this.cache[T];
                this.canvasFactory.destroy(w), delete this.cache[T];
              }
            }
          }
          function m(Q, T, w, g, K, a, Y, z, C, F) {
            const [v, $, il, dl, el, bl] = (0, t.getCurrentTransform)(Q);
            if ($ === 0 && il === 0) {
              const Yl = Y * v + el, yl = Math.round(Yl), Vl = z * dl + bl, Dl = Math.round(Vl), Xl = (Y + C) * v + el, Hl = Math.abs(Math.round(Xl) - yl) || 1, Al = (z + F) * dl + bl, Sl = Math.abs(Math.round(Al) - Dl) || 1;
              return Q.setTransform(Math.sign(v), 0, 0, Math.sign(dl), yl, Dl), Q.drawImage(T, w, g, K, a, 0, 0, Hl, Sl), Q.setTransform(v, $, il, dl, el, bl), [Hl, Sl];
            }
            if (v === 0 && dl === 0) {
              const Yl = z * il + el, yl = Math.round(Yl), Vl = Y * $ + bl, Dl = Math.round(Vl), Xl = (z + F) * il + el, Hl = Math.abs(Math.round(Xl) - yl) || 1, Al = (Y + C) * $ + bl, Sl = Math.abs(Math.round(Al) - Dl) || 1;
              return Q.setTransform(0, Math.sign($), Math.sign(il), 0, yl, Dl), Q.drawImage(T, w, g, K, a, 0, 0, Sl, Hl), Q.setTransform(v, $, il, dl, el, bl), [Sl, Hl];
            }
            Q.drawImage(T, w, g, K, a, Y, z, C, F);
            const ml = Math.hypot(v, $), Gl = Math.hypot(il, dl);
            return [ml * C, Gl * F];
          }
          function d(Q) {
            const {
              width: T,
              height: w
            } = Q;
            if (T > R || w > R)
              return null;
            const g = 1e3, K = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), a = T + 1;
            let Y = new Uint8Array(a * (w + 1)), z, C, F;
            const v = T + 7 & -8;
            let $ = new Uint8Array(v * w), il = 0;
            for (const Gl of Q.data) {
              let Yl = 128;
              for (; Yl > 0; )
                $[il++] = Gl & Yl ? 0 : 255, Yl >>= 1;
            }
            let dl = 0;
            for (il = 0, $[il] !== 0 && (Y[0] = 1, ++dl), C = 1; C < T; C++)
              $[il] !== $[il + 1] && (Y[C] = $[il] ? 2 : 1, ++dl), il++;
            for ($[il] !== 0 && (Y[C] = 2, ++dl), z = 1; z < w; z++) {
              il = z * v, F = z * a, $[il - v] !== $[il] && (Y[F] = $[il] ? 1 : 8, ++dl);
              let Gl = ($[il] ? 4 : 0) + ($[il - v] ? 8 : 0);
              for (C = 1; C < T; C++)
                Gl = (Gl >> 2) + ($[il + 1] ? 4 : 0) + ($[il - v + 1] ? 8 : 0), K[Gl] && (Y[F + C] = K[Gl], ++dl), il++;
              if ($[il - v] !== $[il] && (Y[F + C] = $[il] ? 2 : 4, ++dl), dl > g)
                return null;
            }
            for (il = v * (w - 1), F = z * a, $[il] !== 0 && (Y[F] = 8, ++dl), C = 1; C < T; C++)
              $[il] !== $[il + 1] && (Y[F + C] = $[il] ? 4 : 8, ++dl), il++;
            if ($[il] !== 0 && (Y[F + C] = 4, ++dl), dl > g)
              return null;
            const el = new Int32Array([0, a, -1, 0, -a, 0, 0, 0, 1]), bl = new Path2D();
            for (z = 0; dl && z <= w; z++) {
              let Gl = z * a;
              const Yl = Gl + T;
              for (; Gl < Yl && !Y[Gl]; )
                Gl++;
              if (Gl === Yl)
                continue;
              bl.moveTo(Gl % a, z);
              const yl = Gl;
              let Vl = Y[Gl];
              do {
                const Dl = el[Vl];
                do
                  Gl += Dl;
                while (!Y[Gl]);
                const Xl = Y[Gl];
                Xl !== 5 && Xl !== 10 ? (Vl = Xl, Y[Gl] = 0) : (Vl = Xl & 51 * Vl >> 4, Y[Gl] &= Vl >> 2 | Vl << 2), bl.lineTo(Gl % a, Gl / a | 0), Y[Gl] || --dl;
              } while (yl !== Gl);
              --z;
            }
            return $ = null, Y = null, function(Gl) {
              Gl.save(), Gl.scale(1 / T, -1 / w), Gl.translate(0, -w), Gl.fill(bl), Gl.beginPath(), Gl.restore();
            };
          }
          class b {
            constructor(T, w) {
              this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = Z.IDENTITY_MATRIX, this.textMatrixScale = 1, this.fontMatrix = Z.FONT_IDENTITY_MATRIX, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = Z.TextRenderingMode.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = null, this.startNewPathAndClipBox([0, 0, T, w]);
            }
            clone() {
              const T = Object.create(this);
              return T.clipBox = this.clipBox.slice(), T;
            }
            setCurrentPoint(T, w) {
              this.x = T, this.y = w;
            }
            updatePathMinMax(T, w, g) {
              [w, g] = Z.Util.applyTransform([w, g], T), this.minX = Math.min(this.minX, w), this.minY = Math.min(this.minY, g), this.maxX = Math.max(this.maxX, w), this.maxY = Math.max(this.maxY, g);
            }
            updateRectMinMax(T, w) {
              const g = Z.Util.applyTransform(w, T), K = Z.Util.applyTransform(w.slice(2), T);
              this.minX = Math.min(this.minX, g[0], K[0]), this.minY = Math.min(this.minY, g[1], K[1]), this.maxX = Math.max(this.maxX, g[0], K[0]), this.maxY = Math.max(this.maxY, g[1], K[1]);
            }
            updateScalingPathMinMax(T, w) {
              Z.Util.scaleMinMax(T, w), this.minX = Math.min(this.minX, w[0]), this.maxX = Math.max(this.maxX, w[1]), this.minY = Math.min(this.minY, w[2]), this.maxY = Math.max(this.maxY, w[3]);
            }
            updateCurvePathMinMax(T, w, g, K, a, Y, z, C, F, v) {
              const $ = Z.Util.bezierBoundingBox(w, g, K, a, Y, z, C, F);
              if (v) {
                v[0] = Math.min(v[0], $[0], $[2]), v[1] = Math.max(v[1], $[0], $[2]), v[2] = Math.min(v[2], $[1], $[3]), v[3] = Math.max(v[3], $[1], $[3]);
                return;
              }
              this.updateRectMinMax(T, $);
            }
            getPathBoundingBox() {
              let T = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : W.PathType.FILL, w = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
              const g = [this.minX, this.minY, this.maxX, this.maxY];
              if (T === W.PathType.STROKE) {
                w || (0, Z.unreachable)("Stroke bounding box must include transform.");
                const K = Z.Util.singularValueDecompose2dScale(w), a = K[0] * this.lineWidth / 2, Y = K[1] * this.lineWidth / 2;
                g[0] -= a, g[1] -= Y, g[2] += a, g[3] += Y;
              }
              return g;
            }
            updateClipFromPath() {
              const T = Z.Util.intersect(this.clipBox, this.getPathBoundingBox());
              this.startNewPathAndClipBox(T || [0, 0, 0, 0]);
            }
            isEmptyClip() {
              return this.minX === 1 / 0;
            }
            startNewPathAndClipBox(T) {
              this.clipBox = T, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
            }
            getClippedPathBoundingBox() {
              let T = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : W.PathType.FILL, w = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
              return Z.Util.intersect(this.clipBox, this.getPathBoundingBox(T, w));
            }
          }
          function N(Q, T) {
            let w = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            if (typeof ImageData < "u" && T instanceof ImageData) {
              Q.putImageData(T, 0, 0);
              return;
            }
            const g = T.height, K = T.width, a = g % J, Y = (g - a) / J, z = a === 0 ? Y : Y + 1, C = Q.createImageData(K, J);
            let F = 0, v;
            const $ = T.data, il = C.data;
            let dl, el, bl, ml, Gl, Yl, yl, Vl;
            if (w)
              switch (w.length) {
                case 1:
                  Gl = w[0], Yl = w[0], yl = w[0], Vl = w[0];
                  break;
                case 4:
                  Gl = w[0], Yl = w[1], yl = w[2], Vl = w[3];
                  break;
              }
            if (T.kind === Z.ImageKind.GRAYSCALE_1BPP) {
              const Dl = $.byteLength, Xl = new Uint32Array(il.buffer, 0, il.byteLength >> 2), Hl = Xl.length, Al = K + 7 >> 3;
              let Sl = 4294967295, ol = Z.FeatureTest.isLittleEndian ? 4278190080 : 255;
              for (Vl && Vl[0] === 255 && Vl[255] === 0 && ([Sl, ol] = [ol, Sl]), dl = 0; dl < z; dl++) {
                for (bl = dl < Y ? J : a, v = 0, el = 0; el < bl; el++) {
                  const cl = Dl - F;
                  let Il = 0;
                  const Jl = cl > Al ? K : cl * 8 - 7, fl = Jl & -8;
                  let Nl = 0, zl = 0;
                  for (; Il < fl; Il += 8)
                    zl = $[F++], Xl[v++] = zl & 128 ? Sl : ol, Xl[v++] = zl & 64 ? Sl : ol, Xl[v++] = zl & 32 ? Sl : ol, Xl[v++] = zl & 16 ? Sl : ol, Xl[v++] = zl & 8 ? Sl : ol, Xl[v++] = zl & 4 ? Sl : ol, Xl[v++] = zl & 2 ? Sl : ol, Xl[v++] = zl & 1 ? Sl : ol;
                  for (; Il < Jl; Il++)
                    Nl === 0 && (zl = $[F++], Nl = 128), Xl[v++] = zl & Nl ? Sl : ol, Nl >>= 1;
                }
                for (; v < Hl; )
                  Xl[v++] = 0;
                Q.putImageData(C, 0, dl * J);
              }
            } else if (T.kind === Z.ImageKind.RGBA_32BPP) {
              const Dl = !!(Gl || Yl || yl);
              for (el = 0, ml = K * J * 4, dl = 0; dl < Y; dl++) {
                if (il.set($.subarray(F, F + ml)), F += ml, Dl)
                  for (let Xl = 0; Xl < ml; Xl += 4)
                    Gl && (il[Xl + 0] = Gl[il[Xl + 0]]), Yl && (il[Xl + 1] = Yl[il[Xl + 1]]), yl && (il[Xl + 2] = yl[il[Xl + 2]]);
                Q.putImageData(C, 0, el), el += J;
              }
              if (dl < z) {
                if (ml = K * a * 4, il.set($.subarray(F, F + ml)), Dl)
                  for (let Xl = 0; Xl < ml; Xl += 4)
                    Gl && (il[Xl + 0] = Gl[il[Xl + 0]]), Yl && (il[Xl + 1] = Yl[il[Xl + 1]]), yl && (il[Xl + 2] = yl[il[Xl + 2]]);
                Q.putImageData(C, 0, el);
              }
            } else if (T.kind === Z.ImageKind.RGB_24BPP) {
              const Dl = !!(Gl || Yl || yl);
              for (bl = J, ml = K * bl, dl = 0; dl < z; dl++) {
                for (dl >= Y && (bl = a, ml = K * bl), v = 0, el = ml; el--; )
                  il[v++] = $[F++], il[v++] = $[F++], il[v++] = $[F++], il[v++] = 255;
                if (Dl)
                  for (let Xl = 0; Xl < v; Xl += 4)
                    Gl && (il[Xl + 0] = Gl[il[Xl + 0]]), Yl && (il[Xl + 1] = Yl[il[Xl + 1]]), yl && (il[Xl + 2] = yl[il[Xl + 2]]);
                Q.putImageData(C, 0, dl * J);
              }
            } else
              throw new Error(`bad image kind: ${T.kind}`);
          }
          function G(Q, T) {
            if (T.bitmap) {
              Q.drawImage(T.bitmap, 0, 0);
              return;
            }
            const w = T.height, g = T.width, K = w % J, a = (w - K) / J, Y = K === 0 ? a : a + 1, z = Q.createImageData(g, J);
            let C = 0;
            const F = T.data, v = z.data;
            for (let $ = 0; $ < Y; $++) {
              const il = $ < a ? J : K;
              ({
                srcPos: C
              } = (0, y.applyMaskImageData)({
                src: F,
                srcPos: C,
                dest: v,
                width: g,
                height: il
              })), Q.putImageData(z, 0, $ * J);
            }
          }
          function r(Q, T) {
            const w = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];
            for (let g = 0, K = w.length; g < K; g++) {
              const a = w[g];
              Q[a] !== void 0 && (T[a] = Q[a]);
            }
            Q.setLineDash !== void 0 && (T.setLineDash(Q.getLineDash()), T.lineDashOffset = Q.lineDashOffset);
          }
          function j(Q, T) {
            Q.strokeStyle = Q.fillStyle = T || "#000000", Q.fillRule = "nonzero", Q.globalAlpha = 1, Q.lineWidth = 1, Q.lineCap = "butt", Q.lineJoin = "miter", Q.miterLimit = 10, Q.globalCompositeOperation = "source-over", Q.font = "10px sans-serif", Q.setLineDash !== void 0 && (Q.setLineDash([]), Q.lineDashOffset = 0);
          }
          function D(Q, T, w, g) {
            const K = Q.length;
            for (let a = 3; a < K; a += 4) {
              const Y = Q[a];
              if (Y === 0)
                Q[a - 3] = T, Q[a - 2] = w, Q[a - 1] = g;
              else if (Y < 255) {
                const z = 255 - Y;
                Q[a - 3] = Q[a - 3] * Y + T * z >> 8, Q[a - 2] = Q[a - 2] * Y + w * z >> 8, Q[a - 1] = Q[a - 1] * Y + g * z >> 8;
              }
            }
          }
          function f(Q, T, w) {
            const g = Q.length, K = 1 / 255;
            for (let a = 3; a < g; a += 4) {
              const Y = w ? w[Q[a]] : Q[a];
              T[a] = T[a] * Y * K | 0;
            }
          }
          function P(Q, T, w) {
            const g = Q.length;
            for (let K = 3; K < g; K += 4) {
              const a = Q[K - 3] * 77 + Q[K - 2] * 152 + Q[K - 1] * 28;
              T[K] = w ? T[K] * w[a >> 8] >> 8 : T[K] * a >> 16;
            }
          }
          function B(Q, T, w, g, K, a, Y, z, C, F, v) {
            const $ = !!a, il = $ ? a[0] : 0, dl = $ ? a[1] : 0, el = $ ? a[2] : 0;
            let bl;
            K === "Luminosity" ? bl = P : bl = f;
            const Gl = Math.min(g, Math.ceil(1048576 / w));
            for (let Yl = 0; Yl < g; Yl += Gl) {
              const yl = Math.min(Gl, g - Yl), Vl = Q.getImageData(z - F, Yl + (C - v), w, yl), Dl = T.getImageData(z, Yl + C, w, yl);
              $ && D(Vl.data, il, dl, el), bl(Vl.data, Dl.data, Y), T.putImageData(Dl, z, Yl + C);
            }
          }
          function A(Q, T, w, g) {
            const K = g[0], a = g[1], Y = g[2] - K, z = g[3] - a;
            Y === 0 || z === 0 || (B(T.context, w, Y, z, T.subtype, T.backdrop, T.transferMap, K, a, T.offsetX, T.offsetY), Q.save(), Q.globalAlpha = 1, Q.globalCompositeOperation = "source-over", Q.setTransform(1, 0, 0, 1, 0, 0), Q.drawImage(w.canvas, 0, 0), Q.restore());
          }
          function H(Q, T) {
            const w = Z.Util.singularValueDecompose2dScale(Q);
            w[0] = Math.fround(w[0]), w[1] = Math.fround(w[1]);
            const g = Math.fround((globalThis.devicePixelRatio || 1) * t.PixelsPerInch.PDF_TO_CSS_UNITS);
            return T !== void 0 ? T : w[0] <= g || w[1] <= g;
          }
          const O = ["butt", "round", "square"], U = ["miter", "round", "bevel"], k = {}, q = {};
          var al = /* @__PURE__ */ new WeakSet();
          class Ml {
            constructor(T, w, g, K, a, Y, z, C) {
              p(this, al), this.ctx = T, this.current = new b(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = w, this.objs = g, this.canvasFactory = K, this.imageLayer = a, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = [], this.optionalContentConfig = Y, this.cachedCanvases = new e(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = z, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.backgroundColor = (C == null ? void 0 : C.background) || null, this.foregroundColor = (C == null ? void 0 : C.foreground) || null, this._cachedScaleForStroking = null, this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
            }
            getObject(T) {
              let w = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
              return typeof T == "string" ? T.startsWith("g_") ? this.commonObjs.get(T) : this.objs.get(T) : w;
            }
            beginDrawing(T) {
              let {
                transform: w,
                viewport: g,
                transparency: K = !1,
                background: a = null
              } = T;
              const Y = this.ctx.canvas.width, z = this.ctx.canvas.height, C = a || "#ffffff";
              if (this.ctx.save(), this.foregroundColor && this.backgroundColor) {
                this.ctx.fillStyle = this.foregroundColor;
                const F = this.foregroundColor = this.ctx.fillStyle;
                this.ctx.fillStyle = this.backgroundColor;
                const v = this.backgroundColor = this.ctx.fillStyle;
                let $ = !0, il = C;
                if (this.ctx.fillStyle = C, il = this.ctx.fillStyle, $ = typeof il == "string" && /^#[0-9A-Fa-f]{6}$/.test(il), F === "#000000" && v === "#ffffff" || F === v || !$)
                  this.foregroundColor = this.backgroundColor = null;
                else {
                  const [dl, el, bl] = (0, t.getRGB)(il), ml = (Yl) => (Yl /= 255, Yl <= 0.03928 ? Yl / 12.92 : ((Yl + 0.055) / 1.055) ** 2.4), Gl = Math.round(0.2126 * ml(dl) + 0.7152 * ml(el) + 0.0722 * ml(bl));
                  this.selectColor = (Yl, yl, Vl) => {
                    const Dl = 0.2126 * ml(Yl) + 0.7152 * ml(yl) + 0.0722 * ml(Vl);
                    return Math.round(Dl) === Gl ? v : F;
                  };
                }
              }
              if (this.ctx.fillStyle = this.backgroundColor || C, this.ctx.fillRect(0, 0, Y, z), this.ctx.restore(), K) {
                const F = this.cachedCanvases.getCanvas("transparent", Y, z);
                this.compositeCtx = this.ctx, this.transparentCanvas = F.canvas, this.ctx = F.context, this.ctx.save(), this.ctx.transform(...(0, t.getCurrentTransform)(this.compositeCtx));
              }
              this.ctx.save(), j(this.ctx, this.foregroundColor), w && (this.ctx.transform(...w), this.outputScaleX = w[0], this.outputScaleY = w[0]), this.ctx.transform(...g.transform), this.viewportScale = g.scale, this.baseTransform = (0, t.getCurrentTransform)(this.ctx), this.imageLayer && ((0, t.deprecated)("The `imageLayer` functionality will be removed in the future."), this.imageLayer.beginLayout());
            }
            executeOperatorList(T, w, g, K) {
              const a = T.argsArray, Y = T.fnArray;
              let z = w || 0;
              const C = a.length;
              if (C === z)
                return z;
              const F = C - z > o && typeof g == "function", v = F ? Date.now() + S : 0;
              let $ = 0;
              const il = this.commonObjs, dl = this.objs;
              let el;
              for (; ; ) {
                if (K !== void 0 && z === K.nextBreakPoint)
                  return K.breakIt(z, g), z;
                if (el = Y[z], el !== Z.OPS.dependency)
                  this[el].apply(this, a[z]);
                else
                  for (const bl of a[z]) {
                    const ml = bl.startsWith("g_") ? il : dl;
                    if (!ml.has(bl))
                      return ml.get(bl, g), z;
                  }
                if (z++, z === C)
                  return z;
                if (F && ++$ > o) {
                  if (Date.now() > v)
                    return g(), z;
                  $ = 0;
                }
              }
            }
            endDrawing() {
              M(this, al, wl).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
              for (const T of this._cachedBitmapsMap.values()) {
                for (const w of T.values())
                  typeof HTMLCanvasElement < "u" && w instanceof HTMLCanvasElement && (w.width = w.height = 0);
                T.clear();
              }
              this._cachedBitmapsMap.clear(), this.imageLayer && this.imageLayer.endLayout();
            }
            _scaleImage(T, w) {
              const g = T.width, K = T.height;
              let a = Math.max(Math.hypot(w[0], w[1]), 1), Y = Math.max(Math.hypot(w[2], w[3]), 1), z = g, C = K, F = "prescale1", v, $;
              for (; a > 2 && z > 1 || Y > 2 && C > 1; ) {
                let il = z, dl = C;
                a > 2 && z > 1 && (il = Math.ceil(z / 2), a /= z / il), Y > 2 && C > 1 && (dl = Math.ceil(C / 2), Y /= C / dl), v = this.cachedCanvases.getCanvas(F, il, dl), $ = v.context, $.clearRect(0, 0, il, dl), $.drawImage(T, 0, 0, z, C, 0, 0, il, dl), T = v.canvas, z = il, C = dl, F = F === "prescale1" ? "prescale2" : "prescale1";
              }
              return {
                img: T,
                paintWidth: z,
                paintHeight: C
              };
            }
            _createMaskCanvas(T) {
              const w = this.ctx, {
                width: g,
                height: K
              } = T, a = this.current.fillColor, Y = this.current.patternFill, z = (0, t.getCurrentTransform)(w);
              let C, F, v, $;
              if ((T.bitmap || T.data) && T.count > 1) {
                const Hl = T.bitmap || T.data.buffer, Al = z.slice(0, 4);
                F = JSON.stringify(Y ? Al : [Al, a]), C = this._cachedBitmapsMap.get(Hl), C || (C = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(Hl, C));
                const Sl = C.get(F);
                if (Sl && !Y) {
                  const ol = Math.round(Math.min(z[0], z[2]) + z[4]), cl = Math.round(Math.min(z[1], z[3]) + z[5]);
                  return {
                    canvas: Sl,
                    offsetX: ol,
                    offsetY: cl
                  };
                }
                v = Sl;
              }
              v || ($ = this.cachedCanvases.getCanvas("maskCanvas", g, K), G($.context, T));
              let il = Z.Util.transform(z, [1 / g, 0, 0, -1 / K, 0, 0]);
              il = Z.Util.transform(il, [1, 0, 0, 1, 0, -K]);
              const dl = Z.Util.applyTransform([0, 0], il), el = Z.Util.applyTransform([g, K], il), bl = Z.Util.normalizeRect([dl[0], dl[1], el[0], el[1]]), ml = Math.round(bl[2] - bl[0]) || 1, Gl = Math.round(bl[3] - bl[1]) || 1, Yl = this.cachedCanvases.getCanvas("fillCanvas", ml, Gl), yl = Yl.context, Vl = Math.min(dl[0], el[0]), Dl = Math.min(dl[1], el[1]);
              yl.translate(-Vl, -Dl), yl.transform(...il), v || (v = this._scaleImage($.canvas, (0, t.getCurrentTransformInverse)(yl)), v = v.img, C && Y && C.set(F, v)), yl.imageSmoothingEnabled = H((0, t.getCurrentTransform)(yl), T.interpolate), m(yl, v, 0, 0, v.width, v.height, 0, 0, g, K), yl.globalCompositeOperation = "source-in";
              const Xl = Z.Util.transform((0, t.getCurrentTransformInverse)(yl), [1, 0, 0, 1, -Vl, -Dl]);
              return yl.fillStyle = Y ? a.getPattern(w, this, Xl, W.PathType.FILL) : a, yl.fillRect(0, 0, g, K), C && !Y && (this.cachedCanvases.delete("fillCanvas"), C.set(F, Yl.canvas)), {
                canvas: Yl.canvas,
                offsetX: Math.round(Vl),
                offsetY: Math.round(Dl)
              };
            }
            setLineWidth(T) {
              T !== this.current.lineWidth && (this._cachedScaleForStroking = null), this.current.lineWidth = T, this.ctx.lineWidth = T;
            }
            setLineCap(T) {
              this.ctx.lineCap = O[T];
            }
            setLineJoin(T) {
              this.ctx.lineJoin = U[T];
            }
            setMiterLimit(T) {
              this.ctx.miterLimit = T;
            }
            setDash(T, w) {
              const g = this.ctx;
              g.setLineDash !== void 0 && (g.setLineDash(T), g.lineDashOffset = w);
            }
            setRenderingIntent(T) {
            }
            setFlatness(T) {
            }
            setGState(T) {
              for (let w = 0, g = T.length; w < g; w++) {
                const K = T[w], a = K[0], Y = K[1];
                switch (a) {
                  case "LW":
                    this.setLineWidth(Y);
                    break;
                  case "LC":
                    this.setLineCap(Y);
                    break;
                  case "LJ":
                    this.setLineJoin(Y);
                    break;
                  case "ML":
                    this.setMiterLimit(Y);
                    break;
                  case "D":
                    this.setDash(Y[0], Y[1]);
                    break;
                  case "RI":
                    this.setRenderingIntent(Y);
                    break;
                  case "FL":
                    this.setFlatness(Y);
                    break;
                  case "Font":
                    this.setFont(Y[0], Y[1]);
                    break;
                  case "CA":
                    this.current.strokeAlpha = K[1];
                    break;
                  case "ca":
                    this.current.fillAlpha = K[1], this.ctx.globalAlpha = K[1];
                    break;
                  case "BM":
                    this.ctx.globalCompositeOperation = Y;
                    break;
                  case "SMask":
                    this.current.activeSMask = Y ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
                    break;
                  case "TR":
                    this.current.transferMaps = Y;
                }
              }
            }
            get inSMaskMode() {
              return !!this.suspendedCtx;
            }
            checkSMaskState() {
              const T = this.inSMaskMode;
              this.current.activeSMask && !T ? this.beginSMaskMode() : !this.current.activeSMask && T && this.endSMaskMode();
            }
            beginSMaskMode() {
              if (this.inSMaskMode)
                throw new Error("beginSMaskMode called while already in smask mode");
              const T = this.ctx.canvas.width, w = this.ctx.canvas.height, g = "smaskGroupAt" + this.groupLevel, K = this.cachedCanvases.getCanvas(g, T, w);
              this.suspendedCtx = this.ctx, this.ctx = K.context;
              const a = this.ctx;
              a.setTransform(...(0, t.getCurrentTransform)(this.suspendedCtx)), r(this.suspendedCtx, a), u(a, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
            }
            endSMaskMode() {
              if (!this.inSMaskMode)
                throw new Error("endSMaskMode called while not in smask mode");
              this.ctx._removeMirroring(), r(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
            }
            compose(T) {
              if (!this.current.activeSMask)
                return;
              T ? (T[0] = Math.floor(T[0]), T[1] = Math.floor(T[1]), T[2] = Math.ceil(T[2]), T[3] = Math.ceil(T[3])) : T = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
              const w = this.current.activeSMask, g = this.suspendedCtx;
              A(g, w, this.ctx, T), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
            }
            save() {
              this.inSMaskMode ? (r(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
              const T = this.current;
              this.stateStack.push(T), this.current = T.clone();
            }
            restore() {
              this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), r(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking = null, this._cachedGetSinglePixelWidth = null);
            }
            transform(T, w, g, K, a, Y) {
              this.ctx.transform(T, w, g, K, a, Y), this._cachedScaleForStroking = null, this._cachedGetSinglePixelWidth = null;
            }
            constructPath(T, w, g) {
              const K = this.ctx, a = this.current;
              let Y = a.x, z = a.y, C, F;
              const v = (0, t.getCurrentTransform)(K), $ = v[0] === 0 && v[3] === 0 || v[1] === 0 && v[2] === 0, il = $ ? g.slice(0) : null;
              for (let dl = 0, el = 0, bl = T.length; dl < bl; dl++)
                switch (T[dl] | 0) {
                  case Z.OPS.rectangle:
                    Y = w[el++], z = w[el++];
                    const ml = w[el++], Gl = w[el++], Yl = Y + ml, yl = z + Gl;
                    K.moveTo(Y, z), ml === 0 || Gl === 0 ? K.lineTo(Yl, yl) : (K.lineTo(Yl, z), K.lineTo(Yl, yl), K.lineTo(Y, yl)), $ || a.updateRectMinMax(v, [Y, z, Yl, yl]), K.closePath();
                    break;
                  case Z.OPS.moveTo:
                    Y = w[el++], z = w[el++], K.moveTo(Y, z), $ || a.updatePathMinMax(v, Y, z);
                    break;
                  case Z.OPS.lineTo:
                    Y = w[el++], z = w[el++], K.lineTo(Y, z), $ || a.updatePathMinMax(v, Y, z);
                    break;
                  case Z.OPS.curveTo:
                    C = Y, F = z, Y = w[el + 4], z = w[el + 5], K.bezierCurveTo(w[el], w[el + 1], w[el + 2], w[el + 3], Y, z), a.updateCurvePathMinMax(v, C, F, w[el], w[el + 1], w[el + 2], w[el + 3], Y, z, il), el += 6;
                    break;
                  case Z.OPS.curveTo2:
                    C = Y, F = z, K.bezierCurveTo(Y, z, w[el], w[el + 1], w[el + 2], w[el + 3]), a.updateCurvePathMinMax(v, C, F, Y, z, w[el], w[el + 1], w[el + 2], w[el + 3], il), Y = w[el + 2], z = w[el + 3], el += 4;
                    break;
                  case Z.OPS.curveTo3:
                    C = Y, F = z, Y = w[el + 2], z = w[el + 3], K.bezierCurveTo(w[el], w[el + 1], Y, z, Y, z), a.updateCurvePathMinMax(v, C, F, w[el], w[el + 1], Y, z, Y, z, il), el += 4;
                    break;
                  case Z.OPS.closePath:
                    K.closePath();
                    break;
                }
              $ && a.updateScalingPathMinMax(v, il), a.setCurrentPoint(Y, z);
            }
            closePath() {
              this.ctx.closePath();
            }
            stroke(T) {
              T = typeof T < "u" ? T : !0;
              const w = this.ctx, g = this.current.strokeColor;
              w.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof g == "object" && g !== null && g !== void 0 && g.getPattern ? (w.save(), w.strokeStyle = g.getPattern(w, this, (0, t.getCurrentTransformInverse)(w), W.PathType.STROKE), this.rescaleAndStroke(!1), w.restore()) : this.rescaleAndStroke(!0)), T && this.consumePath(this.current.getClippedPathBoundingBox()), w.globalAlpha = this.current.fillAlpha;
            }
            closeStroke() {
              this.closePath(), this.stroke();
            }
            fill(T) {
              T = typeof T < "u" ? T : !0;
              const w = this.ctx, g = this.current.fillColor, K = this.current.patternFill;
              let a = !1;
              K && (w.save(), w.fillStyle = g.getPattern(w, this, (0, t.getCurrentTransformInverse)(w), W.PathType.FILL), a = !0);
              const Y = this.current.getClippedPathBoundingBox();
              this.contentVisible && Y !== null && (this.pendingEOFill ? (w.fill("evenodd"), this.pendingEOFill = !1) : w.fill()), a && w.restore(), T && this.consumePath(Y);
            }
            eoFill() {
              this.pendingEOFill = !0, this.fill();
            }
            fillStroke() {
              this.fill(!1), this.stroke(!1), this.consumePath();
            }
            eoFillStroke() {
              this.pendingEOFill = !0, this.fillStroke();
            }
            closeFillStroke() {
              this.closePath(), this.fillStroke();
            }
            closeEOFillStroke() {
              this.pendingEOFill = !0, this.closePath(), this.fillStroke();
            }
            endPath() {
              this.consumePath();
            }
            clip() {
              this.pendingClip = k;
            }
            eoClip() {
              this.pendingClip = q;
            }
            beginText() {
              this.current.textMatrix = Z.IDENTITY_MATRIX, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
            }
            endText() {
              const T = this.pendingTextPaths, w = this.ctx;
              if (T === void 0) {
                w.beginPath();
                return;
              }
              w.save(), w.beginPath();
              for (const g of T)
                w.setTransform(...g.transform), w.translate(g.x, g.y), g.addToPath(w, g.fontSize);
              w.restore(), w.clip(), w.beginPath(), delete this.pendingTextPaths;
            }
            setCharSpacing(T) {
              this.current.charSpacing = T;
            }
            setWordSpacing(T) {
              this.current.wordSpacing = T;
            }
            setHScale(T) {
              this.current.textHScale = T / 100;
            }
            setLeading(T) {
              this.current.leading = -T;
            }
            setFont(T, w) {
              const g = this.commonObjs.get(T), K = this.current;
              if (!g)
                throw new Error(`Can't find font for ${T}`);
              if (K.fontMatrix = g.fontMatrix || Z.FONT_IDENTITY_MATRIX, (K.fontMatrix[0] === 0 || K.fontMatrix[3] === 0) && (0, Z.warn)("Invalid font matrix for font " + T), w < 0 ? (w = -w, K.fontDirection = -1) : K.fontDirection = 1, this.current.font = g, this.current.fontSize = w, g.isType3Font)
                return;
              const a = g.loadedName || "sans-serif";
              let Y = "normal";
              g.black ? Y = "900" : g.bold && (Y = "bold");
              const z = g.italic ? "italic" : "normal", C = `"${a}", ${g.fallbackName}`;
              let F = w;
              w < x ? F = x : w > n && (F = n), this.current.fontSizeScale = w / F, this.ctx.font = `${z} ${Y} ${F}px ${C}`;
            }
            setTextRenderingMode(T) {
              this.current.textRenderingMode = T;
            }
            setTextRise(T) {
              this.current.textRise = T;
            }
            moveText(T, w) {
              this.current.x = this.current.lineX += T, this.current.y = this.current.lineY += w;
            }
            setLeadingMoveText(T, w) {
              this.setLeading(-w), this.moveText(T, w);
            }
            setTextMatrix(T, w, g, K, a, Y) {
              this.current.textMatrix = [T, w, g, K, a, Y], this.current.textMatrixScale = Math.hypot(T, w), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
            }
            nextLine() {
              this.moveText(0, this.current.leading);
            }
            paintChar(T, w, g, K) {
              const a = this.ctx, Y = this.current, z = Y.font, C = Y.textRenderingMode, F = Y.fontSize / Y.fontSizeScale, v = C & Z.TextRenderingMode.FILL_STROKE_MASK, $ = !!(C & Z.TextRenderingMode.ADD_TO_PATH_FLAG), il = Y.patternFill && !z.missingFile;
              let dl;
              (z.disableFontFace || $ || il) && (dl = z.getPathGenerator(this.commonObjs, T)), z.disableFontFace || il ? (a.save(), a.translate(w, g), a.beginPath(), dl(a, F), K && a.setTransform(...K), (v === Z.TextRenderingMode.FILL || v === Z.TextRenderingMode.FILL_STROKE) && a.fill(), (v === Z.TextRenderingMode.STROKE || v === Z.TextRenderingMode.FILL_STROKE) && a.stroke(), a.restore()) : ((v === Z.TextRenderingMode.FILL || v === Z.TextRenderingMode.FILL_STROKE) && a.fillText(T, w, g), (v === Z.TextRenderingMode.STROKE || v === Z.TextRenderingMode.FILL_STROKE) && a.strokeText(T, w, g)), $ && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
                transform: (0, t.getCurrentTransform)(a),
                x: w,
                y: g,
                fontSize: F,
                addToPath: dl
              });
            }
            get isFontSubpixelAAEnabled() {
              const {
                context: T
              } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
              T.scale(1.5, 1), T.fillText("I", 0, 10);
              const w = T.getImageData(0, 0, 10, 10).data;
              let g = !1;
              for (let K = 3; K < w.length; K += 4)
                if (w[K] > 0 && w[K] < 255) {
                  g = !0;
                  break;
                }
              return (0, Z.shadow)(this, "isFontSubpixelAAEnabled", g);
            }
            showText(T) {
              const w = this.current, g = w.font;
              if (g.isType3Font)
                return this.showType3Text(T);
              const K = w.fontSize;
              if (K === 0)
                return;
              const a = this.ctx, Y = w.fontSizeScale, z = w.charSpacing, C = w.wordSpacing, F = w.fontDirection, v = w.textHScale * F, $ = T.length, il = g.vertical, dl = il ? 1 : -1, el = g.defaultVMetrics, bl = K * w.fontMatrix[0], ml = w.textRenderingMode === Z.TextRenderingMode.FILL && !g.disableFontFace && !w.patternFill;
              a.save(), a.transform(...w.textMatrix), a.translate(w.x, w.y + w.textRise), F > 0 ? a.scale(v, -1) : a.scale(v, 1);
              let Gl;
              if (w.patternFill) {
                a.save();
                const Xl = w.fillColor.getPattern(a, this, (0, t.getCurrentTransformInverse)(a), W.PathType.FILL);
                Gl = (0, t.getCurrentTransform)(a), a.restore(), a.fillStyle = Xl;
              }
              let Yl = w.lineWidth;
              const yl = w.textMatrixScale;
              if (yl === 0 || Yl === 0) {
                const Xl = w.textRenderingMode & Z.TextRenderingMode.FILL_STROKE_MASK;
                (Xl === Z.TextRenderingMode.STROKE || Xl === Z.TextRenderingMode.FILL_STROKE) && (Yl = this.getSinglePixelWidth());
              } else
                Yl /= yl;
              Y !== 1 && (a.scale(Y, Y), Yl /= Y), a.lineWidth = Yl;
              let Vl = 0, Dl;
              for (Dl = 0; Dl < $; ++Dl) {
                const Xl = T[Dl];
                if (typeof Xl == "number") {
                  Vl += dl * Xl * K / 1e3;
                  continue;
                }
                let Hl = !1;
                const Al = (Xl.isSpace ? C : 0) + z, Sl = Xl.fontChar, ol = Xl.accent;
                let cl, Il, Jl = Xl.width;
                if (il) {
                  const Nl = Xl.vmetric || el, zl = -(Xl.vmetric ? Nl[1] : Jl * 0.5) * bl, kl = Nl[2] * bl;
                  Jl = Nl ? -Nl[0] : Jl, cl = zl / Y, Il = (Vl + kl) / Y;
                } else
                  cl = Vl / Y, Il = 0;
                if (g.remeasure && Jl > 0) {
                  const Nl = a.measureText(Sl).width * 1e3 / K * Y;
                  if (Jl < Nl && this.isFontSubpixelAAEnabled) {
                    const zl = Jl / Nl;
                    Hl = !0, a.save(), a.scale(zl, 1), cl /= zl;
                  } else Jl !== Nl && (cl += (Jl - Nl) / 2e3 * K / Y);
                }
                if (this.contentVisible && (Xl.isInFont || g.missingFile)) {
                  if (ml && !ol)
                    a.fillText(Sl, cl, Il);
                  else if (this.paintChar(Sl, cl, Il, Gl), ol) {
                    const Nl = cl + K * ol.offset.x / Y, zl = Il - K * ol.offset.y / Y;
                    this.paintChar(ol.fontChar, Nl, zl, Gl);
                  }
                }
                let fl;
                il ? fl = Jl * bl - Al * F : fl = Jl * bl + Al * F, Vl += fl, Hl && a.restore();
              }
              il ? w.y -= Vl : w.x += Vl * v, a.restore(), this.compose();
            }
            showType3Text(T) {
              const w = this.ctx, g = this.current, K = g.font, a = g.fontSize, Y = g.fontDirection, z = K.vertical ? 1 : -1, C = g.charSpacing, F = g.wordSpacing, v = g.textHScale * Y, $ = g.fontMatrix || Z.FONT_IDENTITY_MATRIX, il = T.length, dl = g.textRenderingMode === Z.TextRenderingMode.INVISIBLE;
              let el, bl, ml, Gl;
              if (!(dl || a === 0)) {
                for (this._cachedScaleForStroking = null, this._cachedGetSinglePixelWidth = null, w.save(), w.transform(...g.textMatrix), w.translate(g.x, g.y), w.scale(v, Y), el = 0; el < il; ++el) {
                  if (bl = T[el], typeof bl == "number") {
                    Gl = z * bl * a / 1e3, this.ctx.translate(Gl, 0), g.x += Gl * v;
                    continue;
                  }
                  const Yl = (bl.isSpace ? F : 0) + C, yl = K.charProcOperatorList[bl.operatorListId];
                  if (!yl) {
                    (0, Z.warn)(`Type3 character "${bl.operatorListId}" is not available.`);
                    continue;
                  }
                  this.contentVisible && (this.processingType3 = bl, this.save(), w.scale(a, a), w.transform(...$), this.executeOperatorList(yl), this.restore()), ml = Z.Util.applyTransform([bl.width, 0], $)[0] * a + Yl, w.translate(ml, 0), g.x += ml * v;
                }
                w.restore(), this.processingType3 = null;
              }
            }
            setCharWidth(T, w) {
            }
            setCharWidthAndBounds(T, w, g, K, a, Y) {
              this.ctx.rect(g, K, a - g, Y - K), this.ctx.clip(), this.endPath();
            }
            getColorN_Pattern(T) {
              let w;
              if (T[0] === "TilingPattern") {
                const g = T[1], K = this.baseTransform || (0, t.getCurrentTransform)(this.ctx), a = {
                  createCanvasGraphics: (Y) => new Ml(Y, this.commonObjs, this.objs, this.canvasFactory)
                };
                w = new W.TilingPattern(T, g, this.ctx, a, K);
              } else
                w = this._getPattern(T[1], T[2]);
              return w;
            }
            setStrokeColorN() {
              this.current.strokeColor = this.getColorN_Pattern(arguments);
            }
            setFillColorN() {
              this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
            }
            setStrokeRGBColor(T, w, g) {
              var K;
              const a = ((K = this.selectColor) === null || K === void 0 ? void 0 : K.call(this, T, w, g)) || Z.Util.makeHexColor(T, w, g);
              this.ctx.strokeStyle = a, this.current.strokeColor = a;
            }
            setFillRGBColor(T, w, g) {
              var K;
              const a = ((K = this.selectColor) === null || K === void 0 ? void 0 : K.call(this, T, w, g)) || Z.Util.makeHexColor(T, w, g);
              this.ctx.fillStyle = a, this.current.fillColor = a, this.current.patternFill = !1;
            }
            _getPattern(T) {
              let w = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, g;
              return this.cachedPatterns.has(T) ? g = this.cachedPatterns.get(T) : (g = (0, W.getShadingPattern)(this.objs.get(T)), this.cachedPatterns.set(T, g)), w && (g.matrix = w), g;
            }
            shadingFill(T) {
              if (!this.contentVisible)
                return;
              const w = this.ctx;
              this.save();
              const g = this._getPattern(T);
              w.fillStyle = g.getPattern(w, this, (0, t.getCurrentTransformInverse)(w), W.PathType.SHADING);
              const K = (0, t.getCurrentTransformInverse)(w);
              if (K) {
                const a = w.canvas, Y = a.width, z = a.height, C = Z.Util.applyTransform([0, 0], K), F = Z.Util.applyTransform([0, z], K), v = Z.Util.applyTransform([Y, 0], K), $ = Z.Util.applyTransform([Y, z], K), il = Math.min(C[0], F[0], v[0], $[0]), dl = Math.min(C[1], F[1], v[1], $[1]), el = Math.max(C[0], F[0], v[0], $[0]), bl = Math.max(C[1], F[1], v[1], $[1]);
                this.ctx.fillRect(il, dl, el - il, bl - dl);
              } else
                this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
              this.compose(this.current.getClippedPathBoundingBox()), this.restore();
            }
            beginInlineImage() {
              (0, Z.unreachable)("Should not call beginInlineImage");
            }
            beginImageData() {
              (0, Z.unreachable)("Should not call beginImageData");
            }
            paintFormXObjectBegin(T, w) {
              if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), Array.isArray(T) && T.length === 6 && this.transform(...T), this.baseTransform = (0, t.getCurrentTransform)(this.ctx), w)) {
                const g = w[2] - w[0], K = w[3] - w[1];
                this.ctx.rect(w[0], w[1], g, K), this.current.updateRectMinMax((0, t.getCurrentTransform)(this.ctx), w), this.clip(), this.endPath();
              }
            }
            paintFormXObjectEnd() {
              this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
            }
            beginGroup(T) {
              if (!this.contentVisible)
                return;
              this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
              const w = this.ctx;
              T.isolated || (0, Z.info)("TODO: Support non-isolated groups."), T.knockout && (0, Z.warn)("Knockout groups not supported.");
              const g = (0, t.getCurrentTransform)(w);
              if (T.matrix && w.transform(...T.matrix), !T.bbox)
                throw new Error("Bounding box is required.");
              let K = Z.Util.getAxialAlignedBoundingBox(T.bbox, (0, t.getCurrentTransform)(w));
              const a = [0, 0, w.canvas.width, w.canvas.height];
              K = Z.Util.intersect(K, a) || [0, 0, 0, 0];
              const Y = Math.floor(K[0]), z = Math.floor(K[1]);
              let C = Math.max(Math.ceil(K[2]) - Y, 1), F = Math.max(Math.ceil(K[3]) - z, 1), v = 1, $ = 1;
              C > V && (v = C / V, C = V), F > V && ($ = F / V, F = V), this.current.startNewPathAndClipBox([0, 0, C, F]);
              let il = "groupAt" + this.groupLevel;
              T.smask && (il += "_smask_" + this.smaskCounter++ % 2);
              const dl = this.cachedCanvases.getCanvas(il, C, F), el = dl.context;
              el.scale(1 / v, 1 / $), el.translate(-Y, -z), el.transform(...g), T.smask ? this.smaskStack.push({
                canvas: dl.canvas,
                context: el,
                offsetX: Y,
                offsetY: z,
                scaleX: v,
                scaleY: $,
                subtype: T.smask.subtype,
                backdrop: T.smask.backdrop,
                transferMap: T.smask.transferMap || null,
                startTransformInverse: null
              }) : (w.setTransform(1, 0, 0, 1, 0, 0), w.translate(Y, z), w.scale(v, $), w.save()), r(w, el), this.ctx = el, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(w), this.groupLevel++;
            }
            endGroup(T) {
              if (!this.contentVisible)
                return;
              this.groupLevel--;
              const w = this.ctx, g = this.groupStack.pop();
              if (this.ctx = g, this.ctx.imageSmoothingEnabled = !1, T.smask)
                this.tempSMask = this.smaskStack.pop(), this.restore();
              else {
                this.ctx.restore();
                const K = (0, t.getCurrentTransform)(this.ctx);
                this.restore(), this.ctx.save(), this.ctx.setTransform(...K);
                const a = Z.Util.getAxialAlignedBoundingBox([0, 0, w.canvas.width, w.canvas.height], K);
                this.ctx.drawImage(w.canvas, 0, 0), this.ctx.restore(), this.compose(a);
              }
            }
            beginAnnotation(T, w, g, K, a) {
              if (M(this, al, wl).call(this), j(this.ctx, this.foregroundColor), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), Array.isArray(w) && w.length === 4) {
                const Y = w[2] - w[0], z = w[3] - w[1];
                if (a && this.annotationCanvasMap) {
                  g = g.slice(), g[4] -= w[0], g[5] -= w[1], w = w.slice(), w[0] = w[1] = 0, w[2] = Y, w[3] = z;
                  const [C, F] = Z.Util.singularValueDecompose2dScale((0, t.getCurrentTransform)(this.ctx)), {
                    viewportScale: v
                  } = this, $ = Math.ceil(Y * this.outputScaleX * v), il = Math.ceil(z * this.outputScaleY * v);
                  this.annotationCanvas = this.canvasFactory.create($, il);
                  const {
                    canvas: dl,
                    context: el
                  } = this.annotationCanvas;
                  this.annotationCanvasMap.set(T, dl), this.annotationCanvas.savedCtx = this.ctx, this.ctx = el, this.ctx.setTransform(C, 0, 0, -F, 0, z * F), j(this.ctx, this.foregroundColor);
                } else
                  j(this.ctx, this.foregroundColor), this.ctx.rect(w[0], w[1], Y, z), this.ctx.clip(), this.endPath();
              }
              this.current = new b(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...g), this.transform(...K);
            }
            endAnnotation() {
              this.annotationCanvas && (this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
            }
            paintImageMaskXObject(T) {
              if (!this.contentVisible)
                return;
              const w = T.count;
              T = this.getObject(T.data, T), T.count = w;
              const g = this.ctx, K = this.processingType3;
              if (K && (K.compiled === void 0 && (K.compiled = d(T)), K.compiled)) {
                K.compiled(g);
                return;
              }
              const a = this._createMaskCanvas(T), Y = a.canvas;
              g.save(), g.setTransform(1, 0, 0, 1, 0, 0), g.drawImage(Y, a.offsetX, a.offsetY), g.restore(), this.compose();
            }
            paintImageMaskXObjectRepeat(T, w) {
              let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, K = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, a = arguments.length > 4 ? arguments[4] : void 0, Y = arguments.length > 5 ? arguments[5] : void 0;
              if (!this.contentVisible)
                return;
              T = this.getObject(T.data, T);
              const z = this.ctx;
              z.save();
              const C = (0, t.getCurrentTransform)(z);
              z.transform(w, g, K, a, 0, 0);
              const F = this._createMaskCanvas(T);
              z.setTransform(1, 0, 0, 1, 0, 0);
              for (let v = 0, $ = Y.length; v < $; v += 2) {
                const il = Z.Util.transform(C, [w, g, K, a, Y[v], Y[v + 1]]), [dl, el] = Z.Util.applyTransform([0, 0], il);
                z.drawImage(F.canvas, dl, el);
              }
              z.restore(), this.compose();
            }
            paintImageMaskXObjectGroup(T) {
              if (!this.contentVisible)
                return;
              const w = this.ctx, g = this.current.fillColor, K = this.current.patternFill;
              for (const a of T) {
                const {
                  data: Y,
                  width: z,
                  height: C,
                  transform: F
                } = a, v = this.cachedCanvases.getCanvas("maskCanvas", z, C), $ = v.context;
                $.save();
                const il = this.getObject(Y, a);
                G($, il), $.globalCompositeOperation = "source-in", $.fillStyle = K ? g.getPattern($, this, (0, t.getCurrentTransformInverse)(w), W.PathType.FILL) : g, $.fillRect(0, 0, z, C), $.restore(), w.save(), w.transform(...F), w.scale(1, -1), m(w, v.canvas, 0, 0, z, C, 0, -1, 1, 1), w.restore();
              }
              this.compose();
            }
            paintImageXObject(T) {
              if (!this.contentVisible)
                return;
              const w = this.getObject(T);
              if (!w) {
                (0, Z.warn)("Dependent image isn't ready yet");
                return;
              }
              this.paintInlineImageXObject(w);
            }
            paintImageXObjectRepeat(T, w, g, K) {
              if (!this.contentVisible)
                return;
              const a = this.getObject(T);
              if (!a) {
                (0, Z.warn)("Dependent image isn't ready yet");
                return;
              }
              const Y = a.width, z = a.height, C = [];
              for (let F = 0, v = K.length; F < v; F += 2)
                C.push({
                  transform: [w, 0, 0, g, K[F], K[F + 1]],
                  x: 0,
                  y: 0,
                  w: Y,
                  h: z
                });
              this.paintInlineImageXObjectGroup(a, C);
            }
            paintInlineImageXObject(T) {
              if (!this.contentVisible)
                return;
              const w = T.width, g = T.height, K = this.ctx;
              this.save(), K.scale(1 / w, -1 / g);
              let a;
              if (typeof HTMLElement == "function" && T instanceof HTMLElement || !T.data)
                a = T;
              else {
                const F = this.cachedCanvases.getCanvas("inlineImage", w, g), v = F.context;
                N(v, T, this.current.transferMaps), a = F.canvas;
              }
              const Y = this._scaleImage(a, (0, t.getCurrentTransformInverse)(K));
              K.imageSmoothingEnabled = H((0, t.getCurrentTransform)(K), T.interpolate);
              const [z, C] = m(K, Y.img, 0, 0, Y.paintWidth, Y.paintHeight, 0, -g, w, g);
              if (this.imageLayer) {
                const [F, v] = Z.Util.applyTransform([0, -g], (0, t.getCurrentTransform)(this.ctx));
                this.imageLayer.appendImage({
                  imgData: T,
                  left: F,
                  top: v,
                  width: z,
                  height: C
                });
              }
              this.compose(), this.restore();
            }
            paintInlineImageXObjectGroup(T, w) {
              if (!this.contentVisible)
                return;
              const g = this.ctx, K = T.width, a = T.height, Y = this.cachedCanvases.getCanvas("inlineImage", K, a), z = Y.context;
              N(z, T, this.current.transferMaps);
              for (const C of w) {
                if (g.save(), g.transform(...C.transform), g.scale(1, -1), m(g, Y.canvas, C.x, C.y, C.w, C.h, 0, -1, 1, 1), this.imageLayer) {
                  const [F, v] = Z.Util.applyTransform([C.x, C.y], (0, t.getCurrentTransform)(this.ctx));
                  this.imageLayer.appendImage({
                    imgData: T,
                    left: F,
                    top: v,
                    width: K,
                    height: a
                  });
                }
                g.restore();
              }
              this.compose();
            }
            paintSolidColorImageMask() {
              this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
            }
            markPoint(T) {
            }
            markPointProps(T, w) {
            }
            beginMarkedContent(T) {
              this.markedContentStack.push({
                visible: !0
              });
            }
            beginMarkedContentProps(T, w) {
              T === "OC" ? this.markedContentStack.push({
                visible: this.optionalContentConfig.isVisible(w)
              }) : this.markedContentStack.push({
                visible: !0
              }), this.contentVisible = this.isContentVisible();
            }
            endMarkedContent() {
              this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
            }
            beginCompat() {
            }
            endCompat() {
            }
            consumePath(T) {
              const w = this.current.isEmptyClip();
              this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(T);
              const g = this.ctx;
              this.pendingClip && (w || (this.pendingClip === q ? g.clip("evenodd") : g.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), g.beginPath();
            }
            getSinglePixelWidth() {
              if (!this._cachedGetSinglePixelWidth) {
                const T = (0, t.getCurrentTransform)(this.ctx);
                if (T[1] === 0 && T[2] === 0)
                  this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(T[0]), Math.abs(T[3]));
                else {
                  const w = Math.abs(T[0] * T[3] - T[2] * T[1]), g = Math.hypot(T[0], T[2]), K = Math.hypot(T[1], T[3]);
                  this._cachedGetSinglePixelWidth = Math.max(g, K) / w;
                }
              }
              return this._cachedGetSinglePixelWidth;
            }
            getScaleForStroking() {
              if (!this._cachedScaleForStroking) {
                const {
                  lineWidth: T
                } = this.current, w = (0, t.getCurrentTransform)(this.ctx);
                let g, K;
                if (w[1] === 0 && w[2] === 0) {
                  const a = Math.abs(w[0]), Y = Math.abs(w[3]);
                  if (T === 0)
                    g = 1 / a, K = 1 / Y;
                  else {
                    const z = a * T, C = Y * T;
                    g = z < 1 ? 1 / z : 1, K = C < 1 ? 1 / C : 1;
                  }
                } else {
                  const a = Math.abs(w[0] * w[3] - w[2] * w[1]), Y = Math.hypot(w[0], w[1]), z = Math.hypot(w[2], w[3]);
                  if (T === 0)
                    g = z / a, K = Y / a;
                  else {
                    const C = T * a;
                    g = z > C ? z / C : 1, K = Y > C ? Y / C : 1;
                  }
                }
                this._cachedScaleForStroking = [g, K];
              }
              return this._cachedScaleForStroking;
            }
            rescaleAndStroke(T) {
              const {
                ctx: w
              } = this, {
                lineWidth: g
              } = this.current, [K, a] = this.getScaleForStroking();
              if (w.lineWidth = g || 1, K === 1 && a === 1) {
                w.stroke();
                return;
              }
              let Y, z, C;
              T && (Y = (0, t.getCurrentTransform)(w), z = w.getLineDash().slice(), C = w.lineDashOffset), w.scale(K, a);
              const F = Math.max(K, a);
              w.setLineDash(w.getLineDash().map((v) => v / F)), w.lineDashOffset /= F, w.stroke(), T && (w.setTransform(...Y), w.setLineDash(z), w.lineDashOffset = C);
            }
            isContentVisible() {
              for (let T = this.markedContentStack.length - 1; T >= 0; T--)
                if (!this.markedContentStack[T].visible)
                  return !1;
              return !0;
            }
          }
          c.CanvasGraphics = Ml;
          function wl() {
            for (; this.stateStack.length || this.inSMaskMode; )
              this.restore();
            this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
          }
          for (const Q in Z.OPS)
            Ml.prototype[Q] !== void 0 && (Ml.prototype[Z.OPS[Q]] = Ml.prototype[Q]);
        },
        /* 138 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.TilingPattern = c.PathType = void 0, c.getShadingPattern = S;
          var t = i(1), Z = i(133), W = i(3);
          const y = {
            FILL: "Fill",
            STROKE: "Stroke",
            SHADING: "Shading"
          };
          c.PathType = y;
          function h(J, u) {
            if (!u || W.isNodeJS)
              return;
            const e = u[2] - u[0], m = u[3] - u[1], d = new Path2D();
            d.rect(u[0], u[1], e, m), J.clip(d);
          }
          class p {
            constructor() {
              this.constructor === p && (0, t.unreachable)("Cannot initialize BaseShadingPattern.");
            }
            getPattern() {
              (0, t.unreachable)("Abstract method `getPattern` called.");
            }
          }
          class X extends p {
            constructor(u) {
              super(), this._type = u[1], this._bbox = u[2], this._colorStops = u[3], this._p0 = u[4], this._p1 = u[5], this._r0 = u[6], this._r1 = u[7], this.matrix = null;
            }
            _createGradient(u) {
              let e;
              this._type === "axial" ? e = u.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (e = u.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
              for (const m of this._colorStops)
                e.addColorStop(m[0], m[1]);
              return e;
            }
            getPattern(u, e, m, d) {
              let b;
              if (d === y.STROKE || d === y.FILL) {
                const N = e.current.getClippedPathBoundingBox(d, (0, Z.getCurrentTransform)(u)) || [0, 0, 0, 0], G = Math.ceil(N[2] - N[0]) || 1, r = Math.ceil(N[3] - N[1]) || 1, j = e.cachedCanvases.getCanvas("pattern", G, r, !0), D = j.context;
                D.clearRect(0, 0, D.canvas.width, D.canvas.height), D.beginPath(), D.rect(0, 0, D.canvas.width, D.canvas.height), D.translate(-N[0], -N[1]), m = t.Util.transform(m, [1, 0, 0, 1, N[0], N[1]]), D.transform(...e.baseTransform), this.matrix && D.transform(...this.matrix), h(D, this._bbox), D.fillStyle = this._createGradient(D), D.fill(), b = u.createPattern(j.canvas, "no-repeat");
                const f = new DOMMatrix(m);
                try {
                  b.setTransform(f);
                } catch (P) {
                  (0, t.warn)(`RadialAxialShadingPattern.getPattern: "${P == null ? void 0 : P.message}".`);
                }
              } else
                h(u, this._bbox), b = this._createGradient(u);
              return b;
            }
          }
          function M(J, u, e, m, d, b, N, G) {
            const r = u.coords, j = u.colors, D = J.data, f = J.width * 4;
            let P;
            r[e + 1] > r[m + 1] && (P = e, e = m, m = P, P = b, b = N, N = P), r[m + 1] > r[d + 1] && (P = m, m = d, d = P, P = N, N = G, G = P), r[e + 1] > r[m + 1] && (P = e, e = m, m = P, P = b, b = N, N = P);
            const B = (r[e] + u.offsetX) * u.scaleX, A = (r[e + 1] + u.offsetY) * u.scaleY, H = (r[m] + u.offsetX) * u.scaleX, O = (r[m + 1] + u.offsetY) * u.scaleY, U = (r[d] + u.offsetX) * u.scaleX, k = (r[d + 1] + u.offsetY) * u.scaleY;
            if (A >= k)
              return;
            const q = j[b], al = j[b + 1], Ml = j[b + 2], wl = j[N], Q = j[N + 1], T = j[N + 2], w = j[G], g = j[G + 1], K = j[G + 2], a = Math.round(A), Y = Math.round(k);
            let z, C, F, v, $, il, dl, el;
            for (let bl = a; bl <= Y; bl++) {
              if (bl < O) {
                let Vl;
                bl < A ? Vl = 0 : Vl = (A - bl) / (A - O), z = B - (B - H) * Vl, C = q - (q - wl) * Vl, F = al - (al - Q) * Vl, v = Ml - (Ml - T) * Vl;
              } else {
                let Vl;
                bl > k ? Vl = 1 : O === k ? Vl = 0 : Vl = (O - bl) / (O - k), z = H - (H - U) * Vl, C = wl - (wl - w) * Vl, F = Q - (Q - g) * Vl, v = T - (T - K) * Vl;
              }
              let ml;
              bl < A ? ml = 0 : bl > k ? ml = 1 : ml = (A - bl) / (A - k), $ = B - (B - U) * ml, il = q - (q - w) * ml, dl = al - (al - g) * ml, el = Ml - (Ml - K) * ml;
              const Gl = Math.round(Math.min(z, $)), Yl = Math.round(Math.max(z, $));
              let yl = f * bl + Gl * 4;
              for (let Vl = Gl; Vl <= Yl; Vl++)
                ml = (z - Vl) / (z - $), ml < 0 ? ml = 0 : ml > 1 && (ml = 1), D[yl++] = C - (C - il) * ml | 0, D[yl++] = F - (F - dl) * ml | 0, D[yl++] = v - (v - el) * ml | 0, D[yl++] = 255;
            }
          }
          function x(J, u, e) {
            const m = u.coords, d = u.colors;
            let b, N;
            switch (u.type) {
              case "lattice":
                const G = u.verticesPerRow, r = Math.floor(m.length / G) - 1, j = G - 1;
                for (b = 0; b < r; b++) {
                  let D = b * G;
                  for (let f = 0; f < j; f++, D++)
                    M(J, e, m[D], m[D + 1], m[D + G], d[D], d[D + 1], d[D + G]), M(J, e, m[D + G + 1], m[D + 1], m[D + G], d[D + G + 1], d[D + 1], d[D + G]);
                }
                break;
              case "triangles":
                for (b = 0, N = m.length; b < N; b += 3)
                  M(J, e, m[b], m[b + 1], m[b + 2], d[b], d[b + 1], d[b + 2]);
                break;
              default:
                throw new Error("illegal figure");
            }
          }
          class n extends p {
            constructor(u) {
              super(), this._coords = u[2], this._colors = u[3], this._figures = u[4], this._bounds = u[5], this._bbox = u[7], this._background = u[8], this.matrix = null;
            }
            _createMeshCanvas(u, e, m) {
              const G = Math.floor(this._bounds[0]), r = Math.floor(this._bounds[1]), j = Math.ceil(this._bounds[2]) - G, D = Math.ceil(this._bounds[3]) - r, f = Math.min(Math.ceil(Math.abs(j * u[0] * 1.1)), 3e3), P = Math.min(Math.ceil(Math.abs(D * u[1] * 1.1)), 3e3), B = j / f, A = D / P, H = {
                coords: this._coords,
                colors: this._colors,
                offsetX: -G,
                offsetY: -r,
                scaleX: 1 / B,
                scaleY: 1 / A
              }, O = f + 2 * 2, U = P + 2 * 2, k = m.getCanvas("mesh", O, U, !1), q = k.context, al = q.createImageData(f, P);
              if (e) {
                const wl = al.data;
                for (let Q = 0, T = wl.length; Q < T; Q += 4)
                  wl[Q] = e[0], wl[Q + 1] = e[1], wl[Q + 2] = e[2], wl[Q + 3] = 255;
              }
              for (const wl of this._figures)
                x(al, wl, H);
              return q.putImageData(al, 2, 2), {
                canvas: k.canvas,
                offsetX: G - 2 * B,
                offsetY: r - 2 * A,
                scaleX: B,
                scaleY: A
              };
            }
            getPattern(u, e, m, d) {
              h(u, this._bbox);
              let b;
              if (d === y.SHADING)
                b = t.Util.singularValueDecompose2dScale((0, Z.getCurrentTransform)(u));
              else if (b = t.Util.singularValueDecompose2dScale(e.baseTransform), this.matrix) {
                const G = t.Util.singularValueDecompose2dScale(this.matrix);
                b = [b[0] * G[0], b[1] * G[1]];
              }
              const N = this._createMeshCanvas(b, d === y.SHADING ? null : this._background, e.cachedCanvases);
              return d !== y.SHADING && (u.setTransform(...e.baseTransform), this.matrix && u.transform(...this.matrix)), u.translate(N.offsetX, N.offsetY), u.scale(N.scaleX, N.scaleY), u.createPattern(N.canvas, "no-repeat");
            }
          }
          class V extends p {
            getPattern() {
              return "hotpink";
            }
          }
          function S(J) {
            switch (J[0]) {
              case "RadialAxial":
                return new X(J);
              case "Mesh":
                return new n(J);
              case "Dummy":
                return new V();
            }
            throw new Error(`Unknown IR type: ${J[0]}`);
          }
          const o = {
            COLORED: 1,
            UNCOLORED: 2
          };
          class R {
            static get MAX_PATTERN_SIZE() {
              return (0, t.shadow)(this, "MAX_PATTERN_SIZE", 3e3);
            }
            constructor(u, e, m, d, b) {
              this.operatorList = u[2], this.matrix = u[3] || [1, 0, 0, 1, 0, 0], this.bbox = u[4], this.xstep = u[5], this.ystep = u[6], this.paintType = u[7], this.tilingType = u[8], this.color = e, this.ctx = m, this.canvasGraphicsFactory = d, this.baseTransform = b;
            }
            createPatternCanvas(u) {
              const e = this.operatorList, m = this.bbox, d = this.xstep, b = this.ystep, N = this.paintType, G = this.tilingType, r = this.color, j = this.canvasGraphicsFactory;
              (0, t.info)("TilingType: " + G);
              const D = m[0], f = m[1], P = m[2], B = m[3], A = t.Util.singularValueDecompose2dScale(this.matrix), H = t.Util.singularValueDecompose2dScale(this.baseTransform), O = [A[0] * H[0], A[1] * H[1]], U = this.getSizeAndScale(d, this.ctx.canvas.width, O[0]), k = this.getSizeAndScale(b, this.ctx.canvas.height, O[1]), q = u.cachedCanvases.getCanvas("pattern", U.size, k.size, !0), al = q.context, Ml = j.createCanvasGraphics(al);
              Ml.groupLevel = u.groupLevel, this.setFillAndStrokeStyleToContext(Ml, N, r);
              let wl = D, Q = f, T = P, w = B;
              return D < 0 && (wl = 0, T += Math.abs(D)), f < 0 && (Q = 0, w += Math.abs(f)), al.translate(-(U.scale * wl), -(k.scale * Q)), Ml.transform(U.scale, 0, 0, k.scale, 0, 0), al.save(), this.clipBbox(Ml, wl, Q, T, w), Ml.baseTransform = (0, Z.getCurrentTransform)(Ml.ctx), Ml.executeOperatorList(e), Ml.endDrawing(), {
                canvas: q.canvas,
                scaleX: U.scale,
                scaleY: k.scale,
                offsetX: wl,
                offsetY: Q
              };
            }
            getSizeAndScale(u, e, m) {
              u = Math.abs(u);
              const d = Math.max(R.MAX_PATTERN_SIZE, e);
              let b = Math.ceil(u * m);
              return b >= d ? b = d : m = b / u, {
                scale: m,
                size: b
              };
            }
            clipBbox(u, e, m, d, b) {
              const N = d - e, G = b - m;
              u.ctx.rect(e, m, N, G), u.current.updateRectMinMax((0, Z.getCurrentTransform)(u.ctx), [e, m, d, b]), u.clip(), u.endPath();
            }
            setFillAndStrokeStyleToContext(u, e, m) {
              const d = u.ctx, b = u.current;
              switch (e) {
                case o.COLORED:
                  const N = this.ctx;
                  d.fillStyle = N.fillStyle, d.strokeStyle = N.strokeStyle, b.fillColor = N.fillStyle, b.strokeColor = N.strokeStyle;
                  break;
                case o.UNCOLORED:
                  const G = t.Util.makeHexColor(m[0], m[1], m[2]);
                  d.fillStyle = G, d.strokeStyle = G, b.fillColor = G, b.strokeColor = G;
                  break;
                default:
                  throw new t.FormatError(`Unsupported paint type: ${e}`);
              }
            }
            getPattern(u, e, m, d) {
              let b = m;
              d !== y.SHADING && (b = t.Util.transform(b, e.baseTransform), this.matrix && (b = t.Util.transform(b, this.matrix)));
              const N = this.createPatternCanvas(e);
              let G = new DOMMatrix(b);
              G = G.translate(N.offsetX, N.offsetY), G = G.scale(1 / N.scaleX, 1 / N.scaleY);
              const r = u.createPattern(N.canvas, "repeat");
              try {
                r.setTransform(G);
              } catch (j) {
                (0, t.warn)(`TilingPattern.getPattern: "${j == null ? void 0 : j.message}".`);
              }
              return r;
            }
          }
          c.TilingPattern = R;
        },
        /* 139 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.applyMaskImageData = Z;
          var t = i(1);
          function Z(W) {
            let {
              src: y,
              srcPos: h = 0,
              dest: p,
              destPos: X = 0,
              width: M,
              height: x,
              inverseDecode: n = !1
            } = W;
            const V = t.FeatureTest.isLittleEndian ? 4278190080 : 255, [S, o] = n ? [0, V] : [V, 0], R = M >> 3, J = M & 7, u = y.length;
            p = new Uint32Array(p.buffer);
            for (let e = 0; e < x; e++) {
              for (const d = h + R; h < d; h++) {
                const b = h < u ? y[h] : 255;
                p[X++] = b & 128 ? o : S, p[X++] = b & 64 ? o : S, p[X++] = b & 32 ? o : S, p[X++] = b & 16 ? o : S, p[X++] = b & 8 ? o : S, p[X++] = b & 4 ? o : S, p[X++] = b & 2 ? o : S, p[X++] = b & 1 ? o : S;
              }
              if (J === 0)
                continue;
              const m = h < u ? y[h++] : 255;
              for (let d = 0; d < J; d++)
                p[X++] = m & 1 << 7 - d ? o : S;
            }
            return {
              srcPos: h,
              destPos: X
            };
          }
        },
        /* 140 */
        /***/
        (L, c) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.GlobalWorkerOptions = void 0;
          const i = /* @__PURE__ */ Object.create(null);
          c.GlobalWorkerOptions = i, i.workerPort = i.workerPort === void 0 ? null : i.workerPort, i.workerSrc = i.workerSrc === void 0 ? "" : i.workerSrc;
        },
        /* 141 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.MessageHandler = void 0;
          var t = i(1);
          const Z = {
            DATA: 1,
            ERROR: 2
          }, W = {
            CANCEL: 1,
            CANCEL_COMPLETE: 2,
            CLOSE: 3,
            ENQUEUE: 4,
            ERROR: 5,
            PULL: 6,
            PULL_COMPLETE: 7,
            START_COMPLETE: 8
          };
          function y(p) {
            switch (p instanceof Error || typeof p == "object" && p !== null || (0, t.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), p.name) {
              case "AbortException":
                return new t.AbortException(p.message);
              case "MissingPDFException":
                return new t.MissingPDFException(p.message);
              case "PasswordException":
                return new t.PasswordException(p.message, p.code);
              case "UnexpectedResponseException":
                return new t.UnexpectedResponseException(p.message, p.status);
              case "UnknownErrorException":
                return new t.UnknownErrorException(p.message, p.details);
              default:
                return new t.UnknownErrorException(p.message, p.toString());
            }
          }
          class h {
            constructor(X, M, x) {
              this.sourceName = X, this.targetName = M, this.comObj = x, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (n) => {
                const V = n.data;
                if (V.targetName !== this.sourceName)
                  return;
                if (V.stream) {
                  this._processStreamMessage(V);
                  return;
                }
                if (V.callback) {
                  const o = V.callbackId, R = this.callbackCapabilities[o];
                  if (!R)
                    throw new Error(`Cannot resolve callback ${o}`);
                  if (delete this.callbackCapabilities[o], V.callback === Z.DATA)
                    R.resolve(V.data);
                  else if (V.callback === Z.ERROR)
                    R.reject(y(V.reason));
                  else
                    throw new Error("Unexpected callback case");
                  return;
                }
                const S = this.actionHandler[V.action];
                if (!S)
                  throw new Error(`Unknown action from worker: ${V.action}`);
                if (V.callbackId) {
                  const o = this.sourceName, R = V.sourceName;
                  new Promise(function(J) {
                    J(S(V.data));
                  }).then(function(J) {
                    x.postMessage({
                      sourceName: o,
                      targetName: R,
                      callback: Z.DATA,
                      callbackId: V.callbackId,
                      data: J
                    });
                  }, function(J) {
                    x.postMessage({
                      sourceName: o,
                      targetName: R,
                      callback: Z.ERROR,
                      callbackId: V.callbackId,
                      reason: y(J)
                    });
                  });
                  return;
                }
                if (V.streamId) {
                  this._createStreamSink(V);
                  return;
                }
                S(V.data);
              }, x.addEventListener("message", this._onComObjOnMessage);
            }
            on(X, M) {
              const x = this.actionHandler;
              if (x[X])
                throw new Error(`There is already an actionName called "${X}"`);
              x[X] = M;
            }
            send(X, M, x) {
              this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: X,
                data: M
              }, x);
            }
            sendWithPromise(X, M, x) {
              const n = this.callbackId++, V = (0, t.createPromiseCapability)();
              this.callbackCapabilities[n] = V;
              try {
                this.comObj.postMessage({
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: X,
                  callbackId: n,
                  data: M
                }, x);
              } catch (S) {
                V.reject(S);
              }
              return V.promise;
            }
            sendWithStream(X, M, x, n) {
              const V = this.streamId++, S = this.sourceName, o = this.targetName, R = this.comObj;
              return new ReadableStream({
                start: (J) => {
                  const u = (0, t.createPromiseCapability)();
                  return this.streamControllers[V] = {
                    controller: J,
                    startCall: u,
                    pullCall: null,
                    cancelCall: null,
                    isClosed: !1
                  }, R.postMessage({
                    sourceName: S,
                    targetName: o,
                    action: X,
                    streamId: V,
                    data: M,
                    desiredSize: J.desiredSize
                  }, n), u.promise;
                },
                pull: (J) => {
                  const u = (0, t.createPromiseCapability)();
                  return this.streamControllers[V].pullCall = u, R.postMessage({
                    sourceName: S,
                    targetName: o,
                    stream: W.PULL,
                    streamId: V,
                    desiredSize: J.desiredSize
                  }), u.promise;
                },
                cancel: (J) => {
                  (0, t.assert)(J instanceof Error, "cancel must have a valid reason");
                  const u = (0, t.createPromiseCapability)();
                  return this.streamControllers[V].cancelCall = u, this.streamControllers[V].isClosed = !0, R.postMessage({
                    sourceName: S,
                    targetName: o,
                    stream: W.CANCEL,
                    streamId: V,
                    reason: y(J)
                  }), u.promise;
                }
              }, x);
            }
            _createStreamSink(X) {
              const M = X.streamId, x = this.sourceName, n = X.sourceName, V = this.comObj, S = this, o = this.actionHandler[X.action], R = {
                enqueue(J) {
                  let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, e = arguments.length > 2 ? arguments[2] : void 0;
                  if (this.isCancelled)
                    return;
                  const m = this.desiredSize;
                  this.desiredSize -= u, m > 0 && this.desiredSize <= 0 && (this.sinkCapability = (0, t.createPromiseCapability)(), this.ready = this.sinkCapability.promise), V.postMessage({
                    sourceName: x,
                    targetName: n,
                    stream: W.ENQUEUE,
                    streamId: M,
                    chunk: J
                  }, e);
                },
                close() {
                  this.isCancelled || (this.isCancelled = !0, V.postMessage({
                    sourceName: x,
                    targetName: n,
                    stream: W.CLOSE,
                    streamId: M
                  }), delete S.streamSinks[M]);
                },
                error(J) {
                  (0, t.assert)(J instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, V.postMessage({
                    sourceName: x,
                    targetName: n,
                    stream: W.ERROR,
                    streamId: M,
                    reason: y(J)
                  }));
                },
                sinkCapability: (0, t.createPromiseCapability)(),
                onPull: null,
                onCancel: null,
                isCancelled: !1,
                desiredSize: X.desiredSize,
                ready: null
              };
              R.sinkCapability.resolve(), R.ready = R.sinkCapability.promise, this.streamSinks[M] = R, new Promise(function(J) {
                J(o(X.data, R));
              }).then(function() {
                V.postMessage({
                  sourceName: x,
                  targetName: n,
                  stream: W.START_COMPLETE,
                  streamId: M,
                  success: !0
                });
              }, function(J) {
                V.postMessage({
                  sourceName: x,
                  targetName: n,
                  stream: W.START_COMPLETE,
                  streamId: M,
                  reason: y(J)
                });
              });
            }
            _processStreamMessage(X) {
              const M = X.streamId, x = this.sourceName, n = X.sourceName, V = this.comObj, S = this.streamControllers[M], o = this.streamSinks[M];
              switch (X.stream) {
                case W.START_COMPLETE:
                  X.success ? S.startCall.resolve() : S.startCall.reject(y(X.reason));
                  break;
                case W.PULL_COMPLETE:
                  X.success ? S.pullCall.resolve() : S.pullCall.reject(y(X.reason));
                  break;
                case W.PULL:
                  if (!o) {
                    V.postMessage({
                      sourceName: x,
                      targetName: n,
                      stream: W.PULL_COMPLETE,
                      streamId: M,
                      success: !0
                    });
                    break;
                  }
                  o.desiredSize <= 0 && X.desiredSize > 0 && o.sinkCapability.resolve(), o.desiredSize = X.desiredSize, new Promise(function(R) {
                    R(o.onPull && o.onPull());
                  }).then(function() {
                    V.postMessage({
                      sourceName: x,
                      targetName: n,
                      stream: W.PULL_COMPLETE,
                      streamId: M,
                      success: !0
                    });
                  }, function(R) {
                    V.postMessage({
                      sourceName: x,
                      targetName: n,
                      stream: W.PULL_COMPLETE,
                      streamId: M,
                      reason: y(R)
                    });
                  });
                  break;
                case W.ENQUEUE:
                  if ((0, t.assert)(S, "enqueue should have stream controller"), S.isClosed)
                    break;
                  S.controller.enqueue(X.chunk);
                  break;
                case W.CLOSE:
                  if ((0, t.assert)(S, "close should have stream controller"), S.isClosed)
                    break;
                  S.isClosed = !0, S.controller.close(), this._deleteStreamController(S, M);
                  break;
                case W.ERROR:
                  (0, t.assert)(S, "error should have stream controller"), S.controller.error(y(X.reason)), this._deleteStreamController(S, M);
                  break;
                case W.CANCEL_COMPLETE:
                  X.success ? S.cancelCall.resolve() : S.cancelCall.reject(y(X.reason)), this._deleteStreamController(S, M);
                  break;
                case W.CANCEL:
                  if (!o)
                    break;
                  new Promise(function(R) {
                    R(o.onCancel && o.onCancel(y(X.reason)));
                  }).then(function() {
                    V.postMessage({
                      sourceName: x,
                      targetName: n,
                      stream: W.CANCEL_COMPLETE,
                      streamId: M,
                      success: !0
                    });
                  }, function(R) {
                    V.postMessage({
                      sourceName: x,
                      targetName: n,
                      stream: W.CANCEL_COMPLETE,
                      streamId: M,
                      reason: y(R)
                    });
                  }), o.sinkCapability.reject(y(X.reason)), o.isCancelled = !0, delete this.streamSinks[M];
                  break;
                default:
                  throw new Error("Unexpected stream case");
              }
            }
            async _deleteStreamController(X, M) {
              await Promise.allSettled([X.startCall && X.startCall.promise, X.pullCall && X.pullCall.promise, X.cancelCall && X.cancelCall.promise]), delete this.streamControllers[M];
            }
            destroy() {
              this.comObj.removeEventListener("message", this._onComObjOnMessage);
            }
          }
          c.MessageHandler = h;
        },
        /* 142 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.Metadata = void 0;
          var t = i(1);
          function Z(S, o, R) {
            W(S, o), o.set(S, R);
          }
          function W(S, o) {
            if (o.has(S))
              throw new TypeError("Cannot initialize the same private elements twice on an object");
          }
          function y(S, o) {
            var R = X(S, o, "get");
            return h(S, R);
          }
          function h(S, o) {
            return o.get ? o.get.call(S) : o.value;
          }
          function p(S, o, R) {
            var J = X(S, o, "set");
            return M(S, J, R), R;
          }
          function X(S, o, R) {
            if (!o.has(S))
              throw new TypeError("attempted to " + R + " private field on non-instance");
            return o.get(S);
          }
          function M(S, o, R) {
            if (o.set)
              o.set.call(S, R);
            else {
              if (!o.writable)
                throw new TypeError("attempted to set read only private field");
              o.value = R;
            }
          }
          var x = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
          class V {
            constructor(o) {
              let {
                parsedData: R,
                rawData: J
              } = o;
              Z(this, x, {
                writable: !0,
                value: void 0
              }), Z(this, n, {
                writable: !0,
                value: void 0
              }), p(this, x, R), p(this, n, J);
            }
            getRaw() {
              return y(this, n);
            }
            get(o) {
              var R;
              return (R = y(this, x).get(o)) !== null && R !== void 0 ? R : null;
            }
            getAll() {
              return (0, t.objectFromMap)(y(this, x));
            }
            has(o) {
              return y(this, x).has(o);
            }
          }
          c.Metadata = V;
        },
        /* 143 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.OptionalContentConfig = void 0;
          var t = i(1);
          function Z(N, G) {
            h(N, G), G.add(N);
          }
          function W(N, G, r) {
            if (!G.has(N))
              throw new TypeError("attempted to get private field on non-instance");
            return r;
          }
          function y(N, G, r) {
            h(N, G), G.set(N, r);
          }
          function h(N, G) {
            if (G.has(N))
              throw new TypeError("Cannot initialize the same private elements twice on an object");
          }
          function p(N, G, r) {
            var j = x(N, G, "set");
            return X(N, j, r), r;
          }
          function X(N, G, r) {
            if (G.set)
              G.set.call(N, r);
            else {
              if (!G.writable)
                throw new TypeError("attempted to set read only private field");
              G.value = r;
            }
          }
          function M(N, G) {
            var r = x(N, G, "get");
            return n(N, r);
          }
          function x(N, G, r) {
            if (!G.has(N))
              throw new TypeError("attempted to " + r + " private field on non-instance");
            return G.get(N);
          }
          function n(N, G) {
            return G.get ? G.get.call(N) : G.value;
          }
          const V = Symbol("INTERNAL");
          var S = /* @__PURE__ */ new WeakMap();
          class o {
            constructor(G, r) {
              y(this, S, {
                writable: !0,
                value: !0
              }), this.name = G, this.intent = r;
            }
            get visible() {
              return M(this, S);
            }
            _setVisible(G, r) {
              G !== V && (0, t.unreachable)("Internal method `_setVisible` called."), p(this, S, r);
            }
          }
          var R = /* @__PURE__ */ new WeakMap(), J = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap(), e = /* @__PURE__ */ new WeakMap(), m = /* @__PURE__ */ new WeakSet();
          class d {
            constructor(G) {
              if (Z(this, m), y(this, R, {
                writable: !0,
                value: !0
              }), y(this, J, {
                writable: !0,
                value: /* @__PURE__ */ new Map()
              }), y(this, u, {
                writable: !0,
                value: null
              }), y(this, e, {
                writable: !0,
                value: null
              }), this.name = null, this.creator = null, G !== null) {
                this.name = G.name, this.creator = G.creator, p(this, e, G.order);
                for (const r of G.groups)
                  M(this, J).set(r.id, new o(r.name, r.intent));
                if (G.baseState === "OFF")
                  for (const r of M(this, J).values())
                    r._setVisible(V, !1);
                for (const r of G.on)
                  M(this, J).get(r)._setVisible(V, !0);
                for (const r of G.off)
                  M(this, J).get(r)._setVisible(V, !1);
                p(this, u, /* @__PURE__ */ new Map());
                for (const [r, j] of M(this, J))
                  M(this, u).set(r, j.visible);
              }
            }
            isVisible(G) {
              if (M(this, J).size === 0)
                return !0;
              if (!G)
                return (0, t.warn)("Optional content group not defined."), !0;
              if (G.type === "OCG")
                return M(this, J).has(G.id) ? M(this, J).get(G.id).visible : ((0, t.warn)(`Optional content group not found: ${G.id}`), !0);
              if (G.type === "OCMD") {
                if (G.expression)
                  return W(this, m, b).call(this, G.expression);
                if (!G.policy || G.policy === "AnyOn") {
                  for (const r of G.ids) {
                    if (!M(this, J).has(r))
                      return (0, t.warn)(`Optional content group not found: ${r}`), !0;
                    if (M(this, J).get(r).visible)
                      return !0;
                  }
                  return !1;
                } else if (G.policy === "AllOn") {
                  for (const r of G.ids) {
                    if (!M(this, J).has(r))
                      return (0, t.warn)(`Optional content group not found: ${r}`), !0;
                    if (!M(this, J).get(r).visible)
                      return !1;
                  }
                  return !0;
                } else if (G.policy === "AnyOff") {
                  for (const r of G.ids) {
                    if (!M(this, J).has(r))
                      return (0, t.warn)(`Optional content group not found: ${r}`), !0;
                    if (!M(this, J).get(r).visible)
                      return !0;
                  }
                  return !1;
                } else if (G.policy === "AllOff") {
                  for (const r of G.ids) {
                    if (!M(this, J).has(r))
                      return (0, t.warn)(`Optional content group not found: ${r}`), !0;
                    if (M(this, J).get(r).visible)
                      return !1;
                  }
                  return !0;
                }
                return (0, t.warn)(`Unknown optional content policy ${G.policy}.`), !0;
              }
              return (0, t.warn)(`Unknown group type ${G.type}.`), !0;
            }
            setVisibility(G) {
              let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
              if (!M(this, J).has(G)) {
                (0, t.warn)(`Optional content group not found: ${G}`);
                return;
              }
              M(this, J).get(G)._setVisible(V, !!r), p(this, R, null);
            }
            get hasInitialVisibility() {
              if (M(this, R) !== null)
                return M(this, R);
              for (const [G, r] of M(this, J)) {
                const j = M(this, u).get(G);
                if (r.visible !== j)
                  return p(this, R, !1);
              }
              return p(this, R, !0);
            }
            getOrder() {
              return M(this, J).size ? M(this, e) ? M(this, e).slice() : [...M(this, J).keys()] : null;
            }
            getGroups() {
              return M(this, J).size > 0 ? (0, t.objectFromMap)(M(this, J)) : null;
            }
            getGroup(G) {
              return M(this, J).get(G) || null;
            }
          }
          c.OptionalContentConfig = d;
          function b(N) {
            const G = N.length;
            if (G < 2)
              return !0;
            const r = N[0];
            for (let j = 1; j < G; j++) {
              const D = N[j];
              let f;
              if (Array.isArray(D))
                f = W(this, m, b).call(this, D);
              else if (M(this, J).has(D))
                f = M(this, J).get(D).visible;
              else
                return (0, t.warn)(`Optional content group not found: ${D}`), !0;
              switch (r) {
                case "And":
                  if (!f)
                    return !1;
                  break;
                case "Or":
                  if (f)
                    return !0;
                  break;
                case "Not":
                  return !f;
                default:
                  return !0;
              }
            }
            return r === "And";
          }
        },
        /* 144 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.PDFDataTransportStream = void 0;
          var t = i(1), Z = i(133);
          class W {
            constructor(X, M) {
              (0, t.assert)(M, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'), this._queuedChunks = [], this._progressiveDone = X.progressiveDone || !1, this._contentDispositionFilename = X.contentDispositionFilename || null;
              const x = X.initialData;
              if ((x == null ? void 0 : x.length) > 0) {
                const n = new Uint8Array(x).buffer;
                this._queuedChunks.push(n);
              }
              this._pdfDataRangeTransport = M, this._isStreamingSupported = !X.disableStream, this._isRangeSupported = !X.disableRange, this._contentLength = X.length, this._fullRequestReader = null, this._rangeReaders = [], this._pdfDataRangeTransport.addRangeListener((n, V) => {
                this._onReceiveData({
                  begin: n,
                  chunk: V
                });
              }), this._pdfDataRangeTransport.addProgressListener((n, V) => {
                this._onProgress({
                  loaded: n,
                  total: V
                });
              }), this._pdfDataRangeTransport.addProgressiveReadListener((n) => {
                this._onReceiveData({
                  chunk: n
                });
              }), this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                this._onProgressiveDone();
              }), this._pdfDataRangeTransport.transportReady();
            }
            _onReceiveData(X) {
              const M = new Uint8Array(X.chunk).buffer;
              if (X.begin === void 0)
                this._fullRequestReader ? this._fullRequestReader._enqueue(M) : this._queuedChunks.push(M);
              else {
                const x = this._rangeReaders.some(function(n) {
                  return n._begin !== X.begin ? !1 : (n._enqueue(M), !0);
                });
                (0, t.assert)(x, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
              }
            }
            get _progressiveDataLength() {
              var X, M;
              return (X = (M = this._fullRequestReader) === null || M === void 0 ? void 0 : M._loaded) !== null && X !== void 0 ? X : 0;
            }
            _onProgress(X) {
              if (X.total === void 0) {
                const M = this._rangeReaders[0];
                M != null && M.onProgress && M.onProgress({
                  loaded: X.loaded
                });
              } else {
                const M = this._fullRequestReader;
                M != null && M.onProgress && M.onProgress({
                  loaded: X.loaded,
                  total: X.total
                });
              }
            }
            _onProgressiveDone() {
              this._fullRequestReader && this._fullRequestReader.progressiveDone(), this._progressiveDone = !0;
            }
            _removeRangeReader(X) {
              const M = this._rangeReaders.indexOf(X);
              M >= 0 && this._rangeReaders.splice(M, 1);
            }
            getFullReader() {
              (0, t.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
              const X = this._queuedChunks;
              return this._queuedChunks = null, new y(this, X, this._progressiveDone, this._contentDispositionFilename);
            }
            getRangeReader(X, M) {
              if (M <= this._progressiveDataLength)
                return null;
              const x = new h(this, X, M);
              return this._pdfDataRangeTransport.requestDataRange(X, M), this._rangeReaders.push(x), x;
            }
            cancelAllRequests(X) {
              this._fullRequestReader && this._fullRequestReader.cancel(X);
              for (const M of this._rangeReaders.slice(0))
                M.cancel(X);
              this._pdfDataRangeTransport.abort();
            }
          }
          c.PDFDataTransportStream = W;
          class y {
            constructor(X, M) {
              let x = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
              this._stream = X, this._done = x || !1, this._filename = (0, Z.isPdfFile)(n) ? n : null, this._queuedChunks = M || [], this._loaded = 0;
              for (const V of this._queuedChunks)
                this._loaded += V.byteLength;
              this._requests = [], this._headersReady = Promise.resolve(), X._fullRequestReader = this, this.onProgress = null;
            }
            _enqueue(X) {
              this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
                value: X,
                done: !1
              }) : this._queuedChunks.push(X), this._loaded += X.byteLength);
            }
            get headersReady() {
              return this._headersReady;
            }
            get filename() {
              return this._filename;
            }
            get isRangeSupported() {
              return this._stream._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._stream._isStreamingSupported;
            }
            get contentLength() {
              return this._stream._contentLength;
            }
            async read() {
              if (this._queuedChunks.length > 0)
                return {
                  value: this._queuedChunks.shift(),
                  done: !1
                };
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const X = (0, t.createPromiseCapability)();
              return this._requests.push(X), X.promise;
            }
            cancel(X) {
              this._done = !0;
              for (const M of this._requests)
                M.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0;
            }
            progressiveDone() {
              this._done || (this._done = !0);
            }
          }
          class h {
            constructor(X, M, x) {
              this._stream = X, this._begin = M, this._end = x, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
            }
            _enqueue(X) {
              if (!this._done) {
                if (this._requests.length === 0)
                  this._queuedChunk = X;
                else {
                  this._requests.shift().resolve({
                    value: X,
                    done: !1
                  });
                  for (const x of this._requests)
                    x.resolve({
                      value: void 0,
                      done: !0
                    });
                  this._requests.length = 0;
                }
                this._done = !0, this._stream._removeRangeReader(this);
              }
            }
            get isStreamingSupported() {
              return !1;
            }
            async read() {
              if (this._queuedChunk) {
                const M = this._queuedChunk;
                return this._queuedChunk = null, {
                  value: M,
                  done: !1
                };
              }
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const X = (0, t.createPromiseCapability)();
              return this._requests.push(X), X.promise;
            }
            cancel(X) {
              this._done = !0;
              for (const M of this._requests)
                M.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._stream._removeRangeReader(this);
            }
          }
        },
        /* 145 */
        /***/
        (L, c) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.XfaText = void 0;
          class i {
            static textContent(Z) {
              const W = [], y = {
                items: W,
                styles: /* @__PURE__ */ Object.create(null)
              };
              function h(p) {
                var X;
                if (!p)
                  return;
                let M = null;
                const x = p.name;
                if (x === "#text")
                  M = p.value;
                else if (i.shouldBuildText(x))
                  p != null && (X = p.attributes) !== null && X !== void 0 && X.textContent ? M = p.attributes.textContent : p.value && (M = p.value);
                else return;
                if (M !== null && W.push({
                  str: M
                }), !!p.children)
                  for (const n of p.children)
                    h(n);
              }
              return h(Z), y;
            }
            static shouldBuildText(Z) {
              return !(Z === "textarea" || Z === "input" || Z === "option" || Z === "select");
            }
          }
          c.XfaText = i;
        },
        /* 146 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.NodeStandardFontDataFactory = c.NodeCanvasFactory = c.NodeCMapReaderFactory = void 0;
          var t = i(134);
          const Z = function(p) {
            return new Promise((X, M) => {
              require$$7.readFile(p, (n, V) => {
                if (n || !V) {
                  M(new Error(n));
                  return;
                }
                X(new Uint8Array(V));
              });
            });
          };
          class W extends t.BaseCanvasFactory {
            _createCanvas(X, M) {
              return require$$7.createCanvas(X, M);
            }
          }
          c.NodeCanvasFactory = W;
          class y extends t.BaseCMapReaderFactory {
            _fetchData(X, M) {
              return Z(X).then((x) => ({
                cMapData: x,
                compressionType: M
              }));
            }
          }
          c.NodeCMapReaderFactory = y;
          class h extends t.BaseStandardFontDataFactory {
            _fetchData(X) {
              return Z(X);
            }
          }
          c.NodeStandardFontDataFactory = h;
        },
        /* 147 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.AnnotationEditorLayer = void 0;
          var t = i(132), Z = i(1), W = i(148), y = i(149);
          function h(U, k) {
            M(U, k), k.add(U);
          }
          function p(U, k, q) {
            return k in U ? Object.defineProperty(U, k, { value: q, enumerable: !0, configurable: !0, writable: !0 }) : U[k] = q, U;
          }
          function X(U, k, q) {
            M(U, k), k.set(U, q);
          }
          function M(U, k) {
            if (k.has(U))
              throw new TypeError("Cannot initialize the same private elements twice on an object");
          }
          function x(U, k, q) {
            if (!k.has(U))
              throw new TypeError("attempted to get private field on non-instance");
            return q;
          }
          function n(U, k) {
            var q = o(U, k, "get");
            return V(U, q);
          }
          function V(U, k) {
            return k.get ? k.get.call(U) : k.value;
          }
          function S(U, k, q) {
            var al = o(U, k, "set");
            return R(U, al, q), q;
          }
          function o(U, k, q) {
            if (!k.has(U))
              throw new TypeError("attempted to " + q + " private field on non-instance");
            return k.get(U);
          }
          function R(U, k, q) {
            if (k.set)
              k.set.call(U, q);
            else {
              if (!k.writable)
                throw new TypeError("attempted to set read only private field");
              k.value = q;
            }
          }
          var J = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap(), e = /* @__PURE__ */ new WeakMap(), m = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakMap(), b = /* @__PURE__ */ new WeakMap(), N = /* @__PURE__ */ new WeakMap(), G = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakSet(), j = /* @__PURE__ */ new WeakSet(), D = /* @__PURE__ */ new WeakSet(), f = /* @__PURE__ */ new WeakSet();
          class P {
            constructor(k) {
              h(this, f), h(this, D), h(this, j), h(this, r), X(this, J, {
                writable: !0,
                value: void 0
              }), X(this, u, {
                writable: !0,
                value: !1
              }), X(this, e, {
                writable: !0,
                value: this.pointerup.bind(this)
              }), X(this, m, {
                writable: !0,
                value: this.pointerdown.bind(this)
              }), X(this, d, {
                writable: !0,
                value: /* @__PURE__ */ new Map()
              }), X(this, b, {
                writable: !0,
                value: !1
              }), X(this, N, {
                writable: !0,
                value: !1
              }), X(this, G, {
                writable: !0,
                value: void 0
              }), P._initialized || (P._initialized = !0, W.FreeTextEditor.initialize(k.l10n), y.InkEditor.initialize(k.l10n), k.uiManager.registerEditorTypes([W.FreeTextEditor, y.InkEditor])), S(this, G, k.uiManager), this.annotationStorage = k.annotationStorage, this.pageIndex = k.pageIndex, this.div = k.div, S(this, J, k.accessibilityManager), n(this, G).addLayer(this);
            }
            updateToolbar(k) {
              n(this, G).updateToolbar(k);
            }
            updateMode() {
              let k = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : n(this, G).getMode();
              x(this, f, O).call(this), k === Z.AnnotationEditorType.INK ? (this.addInkEditorIfNeeded(!1), this.disableClick()) : this.enableClick(), n(this, G).unselectAll();
            }
            addInkEditorIfNeeded(k) {
              if (!k && n(this, G).getMode() !== Z.AnnotationEditorType.INK)
                return;
              if (!k) {
                for (const al of n(this, d).values())
                  if (al.isEmpty()) {
                    al.setInBackground();
                    return;
                  }
              }
              x(this, D, H).call(this, {
                offsetX: 0,
                offsetY: 0
              }).setInBackground();
            }
            setEditingState(k) {
              n(this, G).setEditingState(k);
            }
            addCommands(k) {
              n(this, G).addCommands(k);
            }
            enable() {
              this.div.style.pointerEvents = "auto";
              for (const k of n(this, d).values())
                k.enableEditing();
            }
            disable() {
              this.div.style.pointerEvents = "none";
              for (const k of n(this, d).values())
                k.disableEditing();
            }
            setActiveEditor(k) {
              n(this, G).getActive() !== k && n(this, G).setActiveEditor(k);
            }
            enableClick() {
              this.div.addEventListener("pointerdown", n(this, m)), this.div.addEventListener("pointerup", n(this, e));
            }
            disableClick() {
              this.div.removeEventListener("pointerdown", n(this, m)), this.div.removeEventListener("pointerup", n(this, e));
            }
            attach(k) {
              n(this, d).set(k.id, k);
            }
            detach(k) {
              var q;
              n(this, d).delete(k.id), (q = n(this, J)) === null || q === void 0 || q.removePointerInTextLayer(k.contentDiv);
            }
            remove(k) {
              n(this, G).removeEditor(k), this.detach(k), this.annotationStorage.remove(k.id), k.div.style.display = "none", setTimeout(() => {
                k.div.style.display = "", k.div.remove(), k.isAttachedToDOM = !1, document.activeElement === document.body && n(this, G).focusMainContainer();
              }, 0), n(this, N) || this.addInkEditorIfNeeded(!1);
            }
            add(k) {
              if (x(this, r, B).call(this, k), n(this, G).addEditor(k), this.attach(k), !k.isAttachedToDOM) {
                const q = k.render();
                this.div.append(q), k.isAttachedToDOM = !0;
              }
              this.moveEditorInDOM(k), k.onceAdded(), this.addToAnnotationStorage(k);
            }
            moveEditorInDOM(k) {
              var q;
              (q = n(this, J)) === null || q === void 0 || q.moveElementInDOM(this.div, k.div, k.contentDiv, !0);
            }
            addToAnnotationStorage(k) {
              !k.isEmpty() && !this.annotationStorage.has(k.id) && this.annotationStorage.setValue(k.id, k);
            }
            addOrRebuild(k) {
              k.needsToBeRebuilt() ? k.rebuild() : this.add(k);
            }
            addANewEditor(k) {
              const q = () => {
                this.addOrRebuild(k);
              }, al = () => {
                k.remove();
              };
              this.addCommands({
                cmd: q,
                undo: al,
                mustExec: !0
              });
            }
            addUndoableEditor(k) {
              const q = () => {
                this.addOrRebuild(k);
              }, al = () => {
                k.remove();
              };
              this.addCommands({
                cmd: q,
                undo: al,
                mustExec: !1
              });
            }
            getNextId() {
              return n(this, G).getId();
            }
            deserialize(k) {
              switch (k.annotationType) {
                case Z.AnnotationEditorType.FREETEXT:
                  return W.FreeTextEditor.deserialize(k, this);
                case Z.AnnotationEditorType.INK:
                  return y.InkEditor.deserialize(k, this);
              }
              return null;
            }
            setSelected(k) {
              n(this, G).setSelected(k);
            }
            toggleSelected(k) {
              n(this, G).toggleSelected(k);
            }
            isSelected(k) {
              return n(this, G).isSelected(k);
            }
            unselect(k) {
              n(this, G).unselect(k);
            }
            pointerup(k) {
              const q = t.KeyboardManager.platform.isMac;
              if (!(k.button !== 0 || k.ctrlKey && q) && k.target === this.div && n(this, b)) {
                if (S(this, b, !1), !n(this, u)) {
                  S(this, u, !0);
                  return;
                }
                x(this, D, H).call(this, k);
              }
            }
            pointerdown(k) {
              const q = t.KeyboardManager.platform.isMac;
              if (k.button !== 0 || k.ctrlKey && q || k.target !== this.div)
                return;
              S(this, b, !0);
              const al = n(this, G).getActive();
              S(this, u, !al || al.isEmpty());
            }
            drop(k) {
              const q = k.dataTransfer.getData("text/plain"), al = n(this, G).getEditor(q);
              if (!al)
                return;
              k.preventDefault(), k.dataTransfer.dropEffect = "move", x(this, r, B).call(this, al);
              const Ml = this.div.getBoundingClientRect(), wl = k.clientX - Ml.x, Q = k.clientY - Ml.y;
              al.translate(wl - al.startX, Q - al.startY), this.moveEditorInDOM(al), al.div.focus();
            }
            dragover(k) {
              k.preventDefault();
            }
            destroy() {
              var k;
              ((k = n(this, G).getActive()) === null || k === void 0 ? void 0 : k.parent) === this && n(this, G).setActiveEditor(null);
              for (const al of n(this, d).values()) {
                var q;
                (q = n(this, J)) === null || q === void 0 || q.removePointerInTextLayer(al.contentDiv), al.isAttachedToDOM = !1, al.div.remove(), al.parent = null;
              }
              this.div = null, n(this, d).clear(), n(this, G).removeLayer(this);
            }
            render(k) {
              this.viewport = k.viewport, (0, t.bindEvents)(this, this.div, ["dragover", "drop"]), this.setDimensions();
              for (const q of n(this, G).getEditors(this.pageIndex))
                this.add(q);
              this.updateMode();
            }
            update(k) {
              this.viewport = k.viewport, this.setDimensions(), this.updateMode();
            }
            get scaleFactor() {
              return this.viewport.scale;
            }
            get pageDimensions() {
              const [k, q, al, Ml] = this.viewport.viewBox, wl = al - k, Q = Ml - q;
              return [wl, Q];
            }
            get viewportBaseDimensions() {
              const {
                width: k,
                height: q,
                rotation: al
              } = this.viewport;
              return al % 180 === 0 ? [k, q] : [q, k];
            }
            setDimensions() {
              const {
                width: k,
                height: q,
                rotation: al
              } = this.viewport, Ml = al % 180 !== 0, wl = Math.floor(k) + "px", Q = Math.floor(q) + "px";
              this.div.style.width = Ml ? Q : wl, this.div.style.height = Ml ? wl : Q, this.div.setAttribute("data-main-rotation", al);
            }
          }
          c.AnnotationEditorLayer = P;
          function B(U) {
            var k;
            U.parent !== this && (this.attach(U), U.pageIndex = this.pageIndex, (k = U.parent) === null || k === void 0 || k.detach(U), U.parent = this, U.div && U.isAttachedToDOM && (U.div.remove(), this.div.append(U.div)));
          }
          function A(U) {
            switch (n(this, G).getMode()) {
              case Z.AnnotationEditorType.FREETEXT:
                return new W.FreeTextEditor(U);
              case Z.AnnotationEditorType.INK:
                return new y.InkEditor(U);
            }
            return null;
          }
          function H(U) {
            const k = this.getNextId(), q = x(this, j, A).call(this, {
              parent: this,
              id: k,
              x: U.offsetX,
              y: U.offsetY
            });
            return q && this.add(q), q;
          }
          function O() {
            S(this, N, !0);
            for (const U of n(this, d).values())
              U.isEmpty() && U.remove();
            S(this, N, !1);
          }
          p(P, "_initialized", !1);
        },
        /* 148 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.FreeTextEditor = void 0;
          var t = i(1), Z = i(132), W = i(131);
          function y(H, O) {
            X(H, O), O.add(H);
          }
          function h(H, O, U) {
            return O in H ? Object.defineProperty(H, O, { value: U, enumerable: !0, configurable: !0, writable: !0 }) : H[O] = U, H;
          }
          function p(H, O, U) {
            X(H, O), O.set(H, U);
          }
          function X(H, O) {
            if (O.has(H))
              throw new TypeError("Cannot initialize the same private elements twice on an object");
          }
          function M(H, O) {
            var U = S(H, O, "get");
            return x(H, U);
          }
          function x(H, O) {
            return O.get ? O.get.call(H) : O.value;
          }
          function n(H, O, U) {
            if (!O.has(H))
              throw new TypeError("attempted to get private field on non-instance");
            return U;
          }
          function V(H, O, U) {
            var k = S(H, O, "set");
            return o(H, k, U), U;
          }
          function S(H, O, U) {
            if (!O.has(H))
              throw new TypeError("attempted to " + U + " private field on non-instance");
            return O.get(H);
          }
          function o(H, O, U) {
            if (O.set)
              O.set.call(H, U);
            else {
              if (!O.writable)
                throw new TypeError("attempted to set read only private field");
              O.value = U;
            }
          }
          var R = /* @__PURE__ */ new WeakMap(), J = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap(), e = /* @__PURE__ */ new WeakMap(), m = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakMap(), b = /* @__PURE__ */ new WeakMap(), N = /* @__PURE__ */ new WeakSet(), G = /* @__PURE__ */ new WeakSet(), r = /* @__PURE__ */ new WeakSet(), j = /* @__PURE__ */ new WeakSet();
          class D extends W.AnnotationEditor {
            constructor(O) {
              super({
                ...O,
                name: "freeTextEditor"
              }), y(this, j), y(this, r), y(this, G), y(this, N), p(this, R, {
                writable: !0,
                value: this.editorDivBlur.bind(this)
              }), p(this, J, {
                writable: !0,
                value: this.editorDivFocus.bind(this)
              }), p(this, u, {
                writable: !0,
                value: this.editorDivKeydown.bind(this)
              }), p(this, e, {
                writable: !0,
                value: void 0
              }), p(this, m, {
                writable: !0,
                value: ""
              }), p(this, d, {
                writable: !0,
                value: !1
              }), p(this, b, {
                writable: !0,
                value: void 0
              }), V(this, e, O.color || D._defaultColor || W.AnnotationEditor._defaultLineColor), V(this, b, O.fontSize || D._defaultFontSize);
            }
            static initialize(O) {
              this._l10nPromise = new Map(["free_text_default_content", "editor_free_text_aria_label"].map((k) => [k, O.get(k)]));
              const U = getComputedStyle(document.documentElement);
              this._internalPadding = parseFloat(U.getPropertyValue("--freetext-padding"));
            }
            static updateDefaultParams(O, U) {
              switch (O) {
                case t.AnnotationEditorParamsType.FREETEXT_SIZE:
                  D._defaultFontSize = U;
                  break;
                case t.AnnotationEditorParamsType.FREETEXT_COLOR:
                  D._defaultColor = U;
                  break;
              }
            }
            updateParams(O, U) {
              switch (O) {
                case t.AnnotationEditorParamsType.FREETEXT_SIZE:
                  n(this, N, f).call(this, U);
                  break;
                case t.AnnotationEditorParamsType.FREETEXT_COLOR:
                  n(this, G, P).call(this, U);
                  break;
              }
            }
            static get defaultPropertiesToUpdate() {
              return [[t.AnnotationEditorParamsType.FREETEXT_SIZE, D._defaultFontSize], [t.AnnotationEditorParamsType.FREETEXT_COLOR, D._defaultColor || W.AnnotationEditor._defaultLineColor]];
            }
            get propertiesToUpdate() {
              return [[t.AnnotationEditorParamsType.FREETEXT_SIZE, M(this, b)], [t.AnnotationEditorParamsType.FREETEXT_COLOR, M(this, e)]];
            }
            getInitialTranslation() {
              return [-D._internalPadding * this.parent.scaleFactor, -(D._internalPadding + M(this, b)) * this.parent.scaleFactor];
            }
            rebuild() {
              super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this));
            }
            enableEditMode() {
              this.isInEditMode() || (this.parent.setEditingState(!1), this.parent.updateToolbar(t.AnnotationEditorType.FREETEXT), super.enableEditMode(), this.enableEditing(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this.div.draggable = !1, this.editorDiv.addEventListener("keydown", M(this, u)), this.editorDiv.addEventListener("focus", M(this, J)), this.editorDiv.addEventListener("blur", M(this, R)));
            }
            disableEditMode() {
              this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.disableEditing(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.draggable = !0, this.editorDiv.removeEventListener("keydown", M(this, u)), this.editorDiv.removeEventListener("focus", M(this, J)), this.editorDiv.removeEventListener("blur", M(this, R)), this.div.focus(), this.isEditing = !1);
            }
            focusin(O) {
              super.focusin(O), O.target !== this.editorDiv && this.editorDiv.focus();
            }
            onceAdded() {
              this.width || (this.enableEditMode(), this.editorDiv.focus());
            }
            isEmpty() {
              return !this.editorDiv || this.editorDiv.innerText.trim() === "";
            }
            remove() {
              this.isEditing = !1, this.parent.setEditingState(!0), super.remove();
            }
            commit() {
              super.commit(), M(this, d) || (V(this, d, !0), this.parent.addUndoableEditor(this)), this.disableEditMode(), V(this, m, n(this, r, B).call(this).trimEnd()), n(this, j, A).call(this);
            }
            shouldGetKeyboardEvents() {
              return this.isInEditMode();
            }
            dblclick(O) {
              this.enableEditMode(), this.editorDiv.focus();
            }
            keydown(O) {
              O.target === this.div && O.key === "Enter" && (this.enableEditMode(), this.editorDiv.focus());
            }
            editorDivKeydown(O) {
              D._keyboardManager.exec(this, O);
            }
            editorDivFocus(O) {
              this.isEditing = !0;
            }
            editorDivBlur(O) {
              this.isEditing = !1;
            }
            disableEditing() {
              this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
            }
            enableEditing() {
              this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
            }
            render() {
              if (this.div)
                return this.div;
              let O, U;
              this.width && (O = this.x, U = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", `${this.id}-editor`), this.enableEditing(), D._l10nPromise.get("editor_free_text_aria_label").then((q) => {
                var al;
                return (al = this.editorDiv) === null || al === void 0 ? void 0 : al.setAttribute("aria-label", q);
              }), D._l10nPromise.get("free_text_default_content").then((q) => {
                var al;
                return (al = this.editorDiv) === null || al === void 0 ? void 0 : al.setAttribute("default-content", q);
              }), this.editorDiv.contentEditable = !0;
              const {
                style: k
              } = this.editorDiv;
              if (k.fontSize = `calc(${M(this, b)}px * var(--scale-factor))`, k.color = M(this, e), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), (0, Z.bindEvents)(this, this.div, ["dblclick", "keydown"]), this.width) {
                const [q, al] = this.parent.viewportBaseDimensions;
                this.setAt(O * q, U * al, this.width * q, this.height * al);
                for (const Ml of M(this, m).split(`
`)) {
                  const wl = document.createElement("div");
                  wl.append(Ml ? document.createTextNode(Ml) : document.createElement("br")), this.editorDiv.append(wl);
                }
                this.div.draggable = !0, this.editorDiv.contentEditable = !1;
              } else
                this.div.draggable = !1, this.editorDiv.contentEditable = !0;
              return this.div;
            }
            get contentDiv() {
              return this.editorDiv;
            }
            static deserialize(O, U) {
              const k = super.deserialize(O, U);
              return V(k, b, O.fontSize), V(k, e, t.Util.makeHexColor(...O.color)), V(k, m, O.value), k;
            }
            serialize() {
              if (this.isEmpty())
                return null;
              const O = D._internalPadding * this.parent.scaleFactor, U = this.getRect(O, O), k = W.AnnotationEditor._colorManager.convert(getComputedStyle(this.editorDiv).color);
              return {
                annotationType: t.AnnotationEditorType.FREETEXT,
                color: k,
                fontSize: M(this, b),
                value: M(this, m),
                pageIndex: this.parent.pageIndex,
                rect: U,
                rotation: this.rotation
              };
            }
          }
          c.FreeTextEditor = D;
          function f(H) {
            const O = (k) => {
              this.editorDiv.style.fontSize = `calc(${k}px * var(--scale-factor))`, this.translate(0, -(k - M(this, b)) * this.parent.scaleFactor), V(this, b, k), n(this, j, A).call(this);
            }, U = M(this, b);
            this.parent.addCommands({
              cmd: () => {
                O(H);
              },
              undo: () => {
                O(U);
              },
              mustExec: !0,
              type: t.AnnotationEditorParamsType.FREETEXT_SIZE,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }
          function P(H) {
            const O = M(this, e);
            this.parent.addCommands({
              cmd: () => {
                V(this, e, H), this.editorDiv.style.color = H;
              },
              undo: () => {
                V(this, e, O), this.editorDiv.style.color = O;
              },
              mustExec: !0,
              type: t.AnnotationEditorParamsType.FREETEXT_COLOR,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }
          function B() {
            const H = this.editorDiv.getElementsByTagName("div");
            if (H.length === 0)
              return this.editorDiv.innerText;
            const O = [];
            for (let U = 0, k = H.length; U < k; U++) {
              const al = H[U].firstChild;
              (al == null ? void 0 : al.nodeName) === "#text" ? O.push(al.data) : O.push("");
            }
            return O.join(`
`);
          }
          function A() {
            const [H, O] = this.parent.viewportBaseDimensions, U = this.div.getBoundingClientRect();
            this.width = U.width / H, this.height = U.height / O;
          }
          h(D, "_freeTextDefaultContent", ""), h(D, "_l10nPromise", void 0), h(D, "_internalPadding", 0), h(D, "_defaultColor", null), h(D, "_defaultFontSize", 10), h(D, "_keyboardManager", new Z.KeyboardManager([[["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], D.prototype.commitOrRemove]])), h(D, "_type", "freetext");
        },
        /* 149 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.InkEditor = void 0, Object.defineProperty(c, "fitCurve", {
            enumerable: !0,
            get: function() {
              return W.fitCurve;
            }
          });
          var t = i(1), Z = i(131), W = i(150), y = i(132);
          function h(ul, Zl) {
            M(ul, Zl), Zl.add(ul);
          }
          function p(ul, Zl, Ll) {
            return Zl in ul ? Object.defineProperty(ul, Zl, { value: Ll, enumerable: !0, configurable: !0, writable: !0 }) : ul[Zl] = Ll, ul;
          }
          function X(ul, Zl, Ll) {
            M(ul, Zl), Zl.set(ul, Ll);
          }
          function M(ul, Zl) {
            if (Zl.has(ul))
              throw new TypeError("Cannot initialize the same private elements twice on an object");
          }
          function x(ul, Zl, Ll) {
            return n(ul, Zl), Ll;
          }
          function n(ul, Zl) {
            if (ul !== Zl)
              throw new TypeError("Private static access of wrong provenance");
          }
          function V(ul, Zl, Ll) {
            var rl = R(ul, Zl, "set");
            return S(ul, rl, Ll), Ll;
          }
          function S(ul, Zl, Ll) {
            if (Zl.set)
              Zl.set.call(ul, Ll);
            else {
              if (!Zl.writable)
                throw new TypeError("attempted to set read only private field");
              Zl.value = Ll;
            }
          }
          function o(ul, Zl) {
            var Ll = R(ul, Zl, "get");
            return J(ul, Ll);
          }
          function R(ul, Zl, Ll) {
            if (!Zl.has(ul))
              throw new TypeError("attempted to " + Ll + " private field on non-instance");
            return Zl.get(ul);
          }
          function J(ul, Zl) {
            return Zl.get ? Zl.get.call(ul) : Zl.value;
          }
          function u(ul, Zl, Ll) {
            if (!Zl.has(ul))
              throw new TypeError("attempted to get private field on non-instance");
            return Ll;
          }
          const e = 16;
          var m = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakMap(), b = /* @__PURE__ */ new WeakMap(), N = /* @__PURE__ */ new WeakMap(), G = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap(), j = /* @__PURE__ */ new WeakMap(), D = /* @__PURE__ */ new WeakMap(), f = /* @__PURE__ */ new WeakMap(), P = /* @__PURE__ */ new WeakMap(), B = /* @__PURE__ */ new WeakMap(), A = /* @__PURE__ */ new WeakMap(), H = /* @__PURE__ */ new WeakMap(), O = /* @__PURE__ */ new WeakMap(), U = /* @__PURE__ */ new WeakSet(), k = /* @__PURE__ */ new WeakSet(), q = /* @__PURE__ */ new WeakSet(), al = /* @__PURE__ */ new WeakSet(), Ml = /* @__PURE__ */ new WeakSet(), wl = /* @__PURE__ */ new WeakSet(), Q = /* @__PURE__ */ new WeakSet(), T = /* @__PURE__ */ new WeakSet(), w = /* @__PURE__ */ new WeakSet(), g = /* @__PURE__ */ new WeakSet(), K = /* @__PURE__ */ new WeakSet(), a = /* @__PURE__ */ new WeakSet(), Y = /* @__PURE__ */ new WeakSet(), z = /* @__PURE__ */ new WeakSet(), C = /* @__PURE__ */ new WeakSet(), F = /* @__PURE__ */ new WeakSet(), v = /* @__PURE__ */ new WeakSet(), $ = /* @__PURE__ */ new WeakSet(), il = /* @__PURE__ */ new WeakSet(), dl = /* @__PURE__ */ new WeakSet(), el = /* @__PURE__ */ new WeakSet(), bl = /* @__PURE__ */ new WeakSet();
          class ml extends Z.AnnotationEditor {
            constructor(Zl) {
              super({
                ...Zl,
                name: "inkEditor"
              }), h(this, bl), h(this, el), h(this, dl), h(this, il), h(this, $), h(this, v), h(this, F), h(this, C), h(this, z), h(this, Y), h(this, a), h(this, K), h(this, g), h(this, w), h(this, T), h(this, Q), h(this, wl), h(this, Ml), h(this, al), h(this, q), h(this, k), h(this, U), X(this, m, {
                writable: !0,
                value: 0
              }), X(this, d, {
                writable: !0,
                value: 0
              }), X(this, b, {
                writable: !0,
                value: 0
              }), X(this, N, {
                writable: !0,
                value: this.canvasPointermove.bind(this)
              }), X(this, G, {
                writable: !0,
                value: this.canvasPointerleave.bind(this)
              }), X(this, r, {
                writable: !0,
                value: this.canvasPointerup.bind(this)
              }), X(this, j, {
                writable: !0,
                value: this.canvasPointerdown.bind(this)
              }), X(this, D, {
                writable: !0,
                value: !1
              }), X(this, f, {
                writable: !0,
                value: !1
              }), X(this, P, {
                writable: !0,
                value: null
              }), X(this, B, {
                writable: !0,
                value: null
              }), X(this, A, {
                writable: !0,
                value: 0
              }), X(this, H, {
                writable: !0,
                value: 0
              }), X(this, O, {
                writable: !0,
                value: null
              }), this.color = Zl.color || null, this.thickness = Zl.thickness || null, this.opacity = Zl.opacity || null, this.paths = [], this.bezierPath2D = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0;
            }
            static initialize(Zl) {
              this._l10nPromise = new Map(["editor_ink_canvas_aria_label", "editor_ink_aria_label"].map((Ll) => [Ll, Zl.get(Ll)]));
            }
            static updateDefaultParams(Zl, Ll) {
              switch (Zl) {
                case t.AnnotationEditorParamsType.INK_THICKNESS:
                  ml._defaultThickness = Ll;
                  break;
                case t.AnnotationEditorParamsType.INK_COLOR:
                  ml._defaultColor = Ll;
                  break;
                case t.AnnotationEditorParamsType.INK_OPACITY:
                  ml._defaultOpacity = Ll / 100;
                  break;
              }
            }
            updateParams(Zl, Ll) {
              switch (Zl) {
                case t.AnnotationEditorParamsType.INK_THICKNESS:
                  u(this, U, Gl).call(this, Ll);
                  break;
                case t.AnnotationEditorParamsType.INK_COLOR:
                  u(this, k, Yl).call(this, Ll);
                  break;
                case t.AnnotationEditorParamsType.INK_OPACITY:
                  u(this, q, yl).call(this, Ll);
                  break;
              }
            }
            static get defaultPropertiesToUpdate() {
              return [[t.AnnotationEditorParamsType.INK_THICKNESS, ml._defaultThickness], [t.AnnotationEditorParamsType.INK_COLOR, ml._defaultColor || Z.AnnotationEditor._defaultLineColor], [t.AnnotationEditorParamsType.INK_OPACITY, Math.round(ml._defaultOpacity * 100)]];
            }
            get propertiesToUpdate() {
              var Zl;
              return [[t.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || ml._defaultThickness], [t.AnnotationEditorParamsType.INK_COLOR, this.color || ml._defaultColor || Z.AnnotationEditor._defaultLineColor], [t.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * ((Zl = this.opacity) !== null && Zl !== void 0 ? Zl : ml._defaultOpacity))]];
            }
            rebuild() {
              super.rebuild(), this.div !== null && (this.canvas || (u(this, K, cl).call(this), u(this, a, Il).call(this)), this.isAttachedToDOM || (this.parent.add(this), u(this, Y, Jl).call(this)), u(this, el, Cl).call(this));
            }
            remove() {
              this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, o(this, B).disconnect(), V(this, B, null), super.remove());
            }
            enableEditMode() {
              o(this, D) || this.canvas === null || (super.enableEditMode(), this.div.draggable = !1, this.canvas.addEventListener("pointerdown", o(this, j)), this.canvas.addEventListener("pointerup", o(this, r)));
            }
            disableEditMode() {
              !this.isInEditMode() || this.canvas === null || (super.disableEditMode(), this.div.draggable = !this.isEmpty(), this.div.classList.remove("editing"), this.canvas.removeEventListener("pointerdown", o(this, j)), this.canvas.removeEventListener("pointerup", o(this, r)));
            }
            onceAdded() {
              this.div.draggable = !this.isEmpty();
            }
            isEmpty() {
              return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
            }
            commit() {
              o(this, D) || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), V(this, D, !0), this.div.classList.add("disabled"), u(this, el, Cl).call(this, !0), this.parent.addInkEditorIfNeeded(!0), this.parent.moveEditorInDOM(this), this.div.focus());
            }
            focusin(Zl) {
              super.focusin(Zl), this.enableEditMode();
            }
            canvasPointerdown(Zl) {
              Zl.button !== 0 || !this.isInEditMode() || o(this, D) || (this.setInForeground(), Zl.type !== "mouse" && this.div.focus(), Zl.stopPropagation(), this.canvas.addEventListener("pointerleave", o(this, G)), this.canvas.addEventListener("pointermove", o(this, N)), u(this, wl, Xl).call(this, Zl.offsetX, Zl.offsetY));
            }
            canvasPointermove(Zl) {
              Zl.stopPropagation(), u(this, Q, Hl).call(this, Zl.offsetX, Zl.offsetY);
            }
            canvasPointerup(Zl) {
              Zl.button === 0 && this.isInEditMode() && this.currentPath.length !== 0 && (Zl.stopPropagation(), u(this, g, ol).call(this, Zl), this.setInBackground());
            }
            canvasPointerleave(Zl) {
              u(this, g, ol).call(this, Zl), this.setInBackground();
            }
            render() {
              if (this.div)
                return this.div;
              let Zl, Ll;
              this.width && (Zl = this.x, Ll = this.y), super.render(), ml._l10nPromise.get("editor_ink_aria_label").then((El) => {
                var xl;
                return (xl = this.div) === null || xl === void 0 ? void 0 : xl.setAttribute("aria-label", El);
              });
              const [rl, Fl, Kl, Ol] = u(this, al, Vl).call(this);
              if (this.setAt(rl, Fl, 0, 0), this.setDims(Kl, Ol), u(this, K, cl).call(this), this.width) {
                const [El, xl] = this.parent.viewportBaseDimensions;
                this.setAt(Zl * El, Ll * xl, this.width * El, this.height * xl), V(this, f, !0), u(this, Y, Jl).call(this), this.setDims(this.width * El, this.height * xl), u(this, w, Sl).call(this), u(this, bl, jl).call(this), this.div.classList.add("disabled");
              } else
                this.div.classList.add("editing"), this.enableEditMode();
              return u(this, a, Il).call(this), this.div;
            }
            setDimensions(Zl, Ll) {
              const rl = Math.round(Zl), Fl = Math.round(Ll);
              if (o(this, A) === rl && o(this, H) === Fl)
                return;
              V(this, A, rl), V(this, H, Fl), this.canvas.style.visibility = "hidden", o(this, m) && Math.abs(o(this, m) - Zl / Ll) > 0.01 && (Ll = Math.ceil(Zl / o(this, m)), this.setDims(Zl, Ll));
              const [Kl, Ol] = this.parent.viewportBaseDimensions;
              this.width = Zl / Kl, this.height = Ll / Ol, o(this, D) && u(this, z, fl).call(this, Zl, Ll), u(this, Y, Jl).call(this), u(this, w, Sl).call(this), this.canvas.style.visibility = "visible";
            }
            static deserialize(Zl, Ll) {
              const rl = super.deserialize(Zl, Ll);
              rl.thickness = Zl.thickness, rl.color = t.Util.makeHexColor(...Zl.color), rl.opacity = Zl.opacity;
              const [Fl, Kl] = Ll.pageDimensions, Ol = rl.width * Fl, El = rl.height * Kl, xl = Ll.scaleFactor, Bl = Zl.thickness / 2;
              V(rl, m, Ol / El), V(rl, D, !0), V(rl, A, Math.round(Ol)), V(rl, H, Math.round(El));
              for (const {
                bezier: Pl
              } of Zl.paths) {
                const ql = [];
                rl.paths.push(ql);
                let ci = xl * (Pl[0] - Bl), $l = xl * (El - Pl[1] - Bl);
                for (let li = 2, Gi = Pl.length; li < Gi; li += 6) {
                  const Ti = xl * (Pl[li] - Bl), ei = xl * (El - Pl[li + 1] - Bl), Di = xl * (Pl[li + 2] - Bl), Ki = xl * (El - Pl[li + 3] - Bl), xi = xl * (Pl[li + 4] - Bl), mi = xl * (El - Pl[li + 5] - Bl);
                  ql.push([[ci, $l], [Ti, ei], [Di, Ki], [xi, mi]]), ci = xi, $l = mi;
                }
                const Zi = x(this, ml, zl).call(this, ql);
                rl.bezierPath2D.push(Zi);
              }
              const si = u(rl, il, sl).call(rl);
              return V(rl, b, Math.max(e, si[2] - si[0])), V(rl, d, Math.max(e, si[3] - si[1])), u(rl, z, fl).call(rl, Ol, El), rl;
            }
            serialize() {
              if (this.isEmpty())
                return null;
              const Zl = this.getRect(0, 0), Ll = this.rotation % 180 === 0 ? Zl[3] - Zl[1] : Zl[2] - Zl[0], rl = Z.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
              return {
                annotationType: t.AnnotationEditorType.INK,
                color: rl,
                thickness: this.thickness,
                opacity: this.opacity,
                paths: u(this, F, kl).call(this, this.scaleFactor / this.parent.scaleFactor, this.translationX, this.translationY, Ll),
                pageIndex: this.parent.pageIndex,
                rect: Zl,
                rotation: this.rotation
              };
            }
          }
          c.InkEditor = ml;
          function Gl(ul) {
            const Zl = this.thickness;
            this.parent.addCommands({
              cmd: () => {
                this.thickness = ul, u(this, el, Cl).call(this);
              },
              undo: () => {
                this.thickness = Zl, u(this, el, Cl).call(this);
              },
              mustExec: !0,
              type: t.AnnotationEditorParamsType.INK_THICKNESS,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }
          function Yl(ul) {
            const Zl = this.color;
            this.parent.addCommands({
              cmd: () => {
                this.color = ul, u(this, w, Sl).call(this);
              },
              undo: () => {
                this.color = Zl, u(this, w, Sl).call(this);
              },
              mustExec: !0,
              type: t.AnnotationEditorParamsType.INK_COLOR,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }
          function yl(ul) {
            ul /= 100;
            const Zl = this.opacity;
            this.parent.addCommands({
              cmd: () => {
                this.opacity = ul, u(this, w, Sl).call(this);
              },
              undo: () => {
                this.opacity = Zl, u(this, w, Sl).call(this);
              },
              mustExec: !0,
              type: t.AnnotationEditorParamsType.INK_OPACITY,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }
          function Vl() {
            const {
              width: ul,
              height: Zl,
              rotation: Ll
            } = this.parent.viewport;
            switch (Ll) {
              case 90:
                return [0, ul, ul, Zl];
              case 180:
                return [ul, Zl, ul, Zl];
              case 270:
                return [Zl, 0, ul, Zl];
              default:
                return [0, 0, ul, Zl];
            }
          }
          function Dl() {
            this.ctx.lineWidth = this.thickness * this.parent.scaleFactor / this.scaleFactor, this.ctx.lineCap = "round", this.ctx.lineJoin = "round", this.ctx.miterLimit = 10, this.ctx.strokeStyle = `${this.color}${(0, y.opacityToHex)(this.opacity)}`;
          }
          function Xl(ul, Zl) {
            if (this.isEditing = !0, !o(this, f)) {
              var Ll;
              V(this, f, !0), u(this, Y, Jl).call(this), this.thickness || (this.thickness = ml._defaultThickness), this.color || (this.color = ml._defaultColor || Z.AnnotationEditor._defaultLineColor), (Ll = this.opacity) !== null && Ll !== void 0 || (this.opacity = ml._defaultOpacity);
            }
            this.currentPath.push([ul, Zl]), V(this, P, null), u(this, Ml, Dl).call(this), this.ctx.beginPath(), this.ctx.moveTo(ul, Zl), V(this, O, () => {
              o(this, O) && (o(this, P) && (this.isEmpty() ? (this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)) : u(this, w, Sl).call(this), this.ctx.lineTo(...o(this, P)), V(this, P, null), this.ctx.stroke()), window.requestAnimationFrame(o(this, O)));
            }), window.requestAnimationFrame(o(this, O));
          }
          function Hl(ul, Zl) {
            const [Ll, rl] = this.currentPath.at(-1);
            ul === Ll && Zl === rl || (this.currentPath.push([ul, Zl]), V(this, P, [ul, Zl]));
          }
          function Al(ul, Zl) {
            this.ctx.closePath(), V(this, O, null), ul = Math.min(Math.max(ul, 0), this.canvas.width), Zl = Math.min(Math.max(Zl, 0), this.canvas.height);
            const [Ll, rl] = this.currentPath.at(-1);
            (ul !== Ll || Zl !== rl) && this.currentPath.push([ul, Zl]);
            let Fl;
            if (this.currentPath.length !== 1)
              Fl = (0, W.fitCurve)(this.currentPath, 30, null);
            else {
              const xl = [ul, Zl];
              Fl = [[xl, xl.slice(), xl.slice(), xl]];
            }
            const Kl = x(ml, ml, zl).call(ml, Fl);
            this.currentPath.length = 0;
            const Ol = () => {
              this.paths.push(Fl), this.bezierPath2D.push(Kl), this.rebuild();
            }, El = () => {
              this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (u(this, K, cl).call(this), u(this, a, Il).call(this)), u(this, el, Cl).call(this));
            };
            this.parent.addCommands({
              cmd: Ol,
              undo: El,
              mustExec: !0
            });
          }
          function Sl() {
            if (this.isEmpty()) {
              u(this, C, Nl).call(this);
              return;
            }
            u(this, Ml, Dl).call(this);
            const {
              canvas: ul,
              ctx: Zl
            } = this;
            Zl.setTransform(1, 0, 0, 1, 0, 0), Zl.clearRect(0, 0, ul.width, ul.height), u(this, C, Nl).call(this);
            for (const Ll of this.bezierPath2D)
              Zl.stroke(Ll);
          }
          function ol(ul) {
            u(this, T, Al).call(this, ul.offsetX, ul.offsetY), this.canvas.removeEventListener("pointerleave", o(this, G)), this.canvas.removeEventListener("pointermove", o(this, N)), this.parent.addToAnnotationStorage(this);
          }
          function cl() {
            this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", ml._l10nPromise.get("editor_ink_canvas_aria_label").then((ul) => {
              var Zl;
              return (Zl = this.canvas) === null || Zl === void 0 ? void 0 : Zl.setAttribute("aria-label", ul);
            }), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
          }
          function Il() {
            V(this, B, new ResizeObserver((ul) => {
              const Zl = ul[0].contentRect;
              Zl.width && Zl.height && this.setDimensions(Zl.width, Zl.height);
            })), o(this, B).observe(this.div);
          }
          function Jl() {
            if (!o(this, f))
              return;
            const [ul, Zl] = this.parent.viewportBaseDimensions;
            this.canvas.width = Math.ceil(this.width * ul), this.canvas.height = Math.ceil(this.height * Zl), u(this, C, Nl).call(this);
          }
          function fl(ul, Zl) {
            const Ll = u(this, dl, hl).call(this), rl = (ul - Ll) / o(this, b), Fl = (Zl - Ll) / o(this, d);
            this.scaleFactor = Math.min(rl, Fl);
          }
          function Nl() {
            const ul = u(this, dl, hl).call(this) / 2;
            this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + ul, this.translationY * this.scaleFactor + ul);
          }
          function zl(ul) {
            const Zl = new Path2D();
            for (let Ll = 0, rl = ul.length; Ll < rl; Ll++) {
              const [Fl, Kl, Ol, El] = ul[Ll];
              Ll === 0 && Zl.moveTo(...Fl), Zl.bezierCurveTo(Kl[0], Kl[1], Ol[0], Ol[1], El[0], El[1]);
            }
            return Zl;
          }
          function kl(ul, Zl, Ll, rl) {
            const Kl = [], Ol = this.thickness / 2;
            let El, xl;
            for (const Bl of this.paths) {
              El = [], xl = [];
              for (let si = 0, Pl = Bl.length; si < Pl; si++) {
                const [ql, ci, $l, Zi] = Bl[si], li = ul * (ql[0] + Zl) + Ol, Gi = rl - ul * (ql[1] + Ll) - Ol, Ti = ul * (ci[0] + Zl) + Ol, ei = rl - ul * (ci[1] + Ll) - Ol, Di = ul * ($l[0] + Zl) + Ol, Ki = rl - ul * ($l[1] + Ll) - Ol, xi = ul * (Zi[0] + Zl) + Ol, mi = rl - ul * (Zi[1] + Ll) - Ol;
                si === 0 && (El.push(li, Gi), xl.push(li, Gi)), El.push(Ti, ei, Di, Ki, xi, mi), u(this, v, nl).call(this, li, Gi, Ti, ei, Di, Ki, xi, mi, 4, xl);
              }
              Kl.push({
                bezier: El,
                points: xl
              });
            }
            return Kl;
          }
          function nl(ul, Zl, Ll, rl, Fl, Kl, Ol, El, xl, Bl) {
            if (u(this, $, ll).call(this, ul, Zl, Ll, rl, Fl, Kl, Ol, El)) {
              Bl.push(Ol, El);
              return;
            }
            for (let si = 1; si < xl - 1; si++) {
              const Pl = si / xl, ql = 1 - Pl;
              let ci = Pl * ul + ql * Ll, $l = Pl * Zl + ql * rl, Zi = Pl * Ll + ql * Fl, li = Pl * rl + ql * Kl;
              const Gi = Pl * Fl + ql * Ol, Ti = Pl * Kl + ql * El;
              ci = Pl * ci + ql * Zi, $l = Pl * $l + ql * li, Zi = Pl * Zi + ql * Gi, li = Pl * li + ql * Ti, ci = Pl * ci + ql * Zi, $l = Pl * $l + ql * li, Bl.push(ci, $l);
            }
            Bl.push(Ol, El);
          }
          function ll(ul, Zl, Ll, rl, Fl, Kl, Ol, El) {
            const Bl = (3 * Ll - 2 * ul - Ol) ** 2, si = (3 * rl - 2 * Zl - El) ** 2, Pl = (3 * Fl - ul - 2 * Ol) ** 2, ql = (3 * Kl - Zl - 2 * El) ** 2;
            return Math.max(Bl, Pl) + Math.max(si, ql) <= 10;
          }
          function sl() {
            let ul = 1 / 0, Zl = -1 / 0, Ll = 1 / 0, rl = -1 / 0;
            for (const Fl of this.paths)
              for (const [Kl, Ol, El, xl] of Fl) {
                const Bl = t.Util.bezierBoundingBox(...Kl, ...Ol, ...El, ...xl);
                ul = Math.min(ul, Bl[0]), Ll = Math.min(Ll, Bl[1]), Zl = Math.max(Zl, Bl[2]), rl = Math.max(rl, Bl[3]);
              }
            return [ul, Ll, Zl, rl];
          }
          function hl() {
            return o(this, D) ? Math.ceil(this.thickness * this.parent.scaleFactor) : 0;
          }
          function Cl() {
            let ul = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
            if (this.isEmpty())
              return;
            if (!o(this, D)) {
              u(this, w, Sl).call(this);
              return;
            }
            const Zl = u(this, il, sl).call(this), Ll = u(this, dl, hl).call(this);
            V(this, b, Math.max(e, Zl[2] - Zl[0])), V(this, d, Math.max(e, Zl[3] - Zl[1]));
            const rl = Math.ceil(Ll + o(this, b) * this.scaleFactor), Fl = Math.ceil(Ll + o(this, d) * this.scaleFactor), [Kl, Ol] = this.parent.viewportBaseDimensions;
            this.width = rl / Kl, this.height = Fl / Ol, V(this, m, rl / Fl), u(this, bl, jl).call(this);
            const El = this.translationX, xl = this.translationY;
            this.translationX = -Zl[0], this.translationY = -Zl[1], u(this, Y, Jl).call(this), u(this, w, Sl).call(this), V(this, A, rl), V(this, H, Fl), this.setDims(rl, Fl);
            const Bl = ul ? Ll / this.scaleFactor / 2 : 0;
            this.translate(El - this.translationX - Bl, xl - this.translationY - Bl);
          }
          function jl() {
            const {
              style: ul
            } = this.div;
            o(this, m) >= 1 ? (ul.minHeight = `${e}px`, ul.minWidth = `${Math.round(o(this, m) * e)}px`) : (ul.minWidth = `${e}px`, ul.minHeight = `${Math.round(e / o(this, m))}px`);
          }
          p(ml, "_defaultColor", null), p(ml, "_defaultOpacity", 1), p(ml, "_defaultThickness", 1), p(ml, "_l10nPromise", void 0), p(ml, "_type", "ink");
        },
        /* 150 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.fitCurve = void 0;
          const t = i(151);
          c.fitCurve = t;
        },
        /* 151 */
        /***/
        (L) => {
          function c(S, o, R) {
            if (!Array.isArray(S))
              throw new TypeError("First argument should be an array");
            if (S.forEach((m) => {
              if (!Array.isArray(m) || m.some((d) => typeof d != "number") || m.length !== S[0].length)
                throw Error("Each point should be an array of numbers. Each point should have the same amount of numbers.");
            }), S = S.filter((m, d) => d === 0 || !m.every((b, N) => b === S[d - 1][N])), S.length < 2)
              return [];
            const J = S.length, u = x(S[1], S[0]), e = x(S[J - 2], S[J - 1]);
            return i(S, u, e, o, R);
          }
          function i(S, o, R, J, u) {
            var m, d, b, N, G, r, j, D, f, P, B, A, H;
            if (S.length === 2)
              return A = n.vectorLen(n.subtract(S[0], S[1])) / 3, m = [S[0], n.addArrays(S[0], n.mulItems(o, A)), n.addArrays(S[1], n.mulItems(R, A)), S[1]], [m];
            if (d = h(S), [m, N, r] = t(S, d, d, o, R, u), N === 0 || N < J)
              return [m];
            if (N < J * J)
              for (b = d, G = N, j = r, H = 0; H < 20; H++) {
                if (b = W(m, S, b), [m, N, r] = t(S, d, b, o, R, u), N < J)
                  return [m];
                if (r === j) {
                  let O = N / G;
                  if (O > 0.9999 && O < 1.0001)
                    break;
                }
                G = N, j = r;
              }
            return B = [], D = n.subtract(S[r - 1], S[r + 1]), D.every((O) => O === 0) && (D = n.subtract(S[r - 1], S[r]), [D[0], D[1]] = [-D[1], D[0]]), f = n.normalize(D), P = n.mulItems(f, -1), B = B.concat(i(S.slice(0, r + 1), o, f, J, u)), B = B.concat(i(S.slice(r), P, R, J, u)), B;
          }
          function t(S, o, R, J, u, e) {
            var m, d, b;
            return m = Z(S, R, J, u), [d, b] = p(S, m, o), e && e({
              bez: m,
              points: S,
              params: o,
              maxErr: d,
              maxPoint: b
            }), [m, d, b];
          }
          function Z(S, o, R, J) {
            var u, e, m, d, b, N, G, r, j, D, f, P, B, A, H, O, U, k = S[0], q = S[S.length - 1];
            for (u = [k, null, null, q], e = n.zeros_Xx2x2(o.length), B = 0, A = o.length; B < A; B++)
              O = o[B], U = 1 - O, m = e[B], m[0] = n.mulItems(R, 3 * O * (U * U)), m[1] = n.mulItems(J, 3 * U * (O * O));
            for (d = [[0, 0], [0, 0]], b = [0, 0], B = 0, A = S.length; B < A; B++)
              O = o[B], m = e[B], d[0][0] += n.dot(m[0], m[0]), d[0][1] += n.dot(m[0], m[1]), d[1][0] += n.dot(m[0], m[1]), d[1][1] += n.dot(m[1], m[1]), H = n.subtract(S[B], V.q([k, k, q, q], O)), b[0] += n.dot(m[0], H), b[1] += n.dot(m[1], H);
            return N = d[0][0] * d[1][1] - d[1][0] * d[0][1], G = d[0][0] * b[1] - d[1][0] * b[0], r = b[0] * d[1][1] - b[1] * d[0][1], j = N === 0 ? 0 : r / N, D = N === 0 ? 0 : G / N, P = n.vectorLen(n.subtract(k, q)), f = 1e-6 * P, j < f || D < f ? (u[1] = n.addArrays(k, n.mulItems(R, P / 3)), u[2] = n.addArrays(q, n.mulItems(J, P / 3))) : (u[1] = n.addArrays(k, n.mulItems(R, j)), u[2] = n.addArrays(q, n.mulItems(J, D))), u;
          }
          function W(S, o, R) {
            return R.map((J, u) => y(S, o[u], J));
          }
          function y(S, o, R) {
            var J = n.subtract(V.q(S, R), o), u = V.qprime(S, R), e = n.mulMatrix(J, u), m = n.sum(n.squareItems(u)) + 2 * n.mulMatrix(J, V.qprimeprime(S, R));
            return m === 0 ? R : R - e / m;
          }
          function h(S) {
            var o = [], R, J, u;
            return S.forEach((e, m) => {
              R = m ? J + n.vectorLen(n.subtract(e, u)) : 0, o.push(R), J = R, u = e;
            }), o = o.map((e) => e / J), o;
          }
          function p(S, o, R) {
            var J, u, e, m, d, b, N, G;
            u = 0, e = Math.floor(S.length / 2);
            const r = X(o, 10);
            for (d = 0, b = S.length; d < b; d++)
              N = S[d], G = M(o, R[d], r, 10), m = n.subtract(V.q(o, G), N), J = m[0] * m[0] + m[1] * m[1], J > u && (u = J, e = d);
            return [u, e];
          }
          var X = function(S, o) {
            for (var R, J = [0], u = S[0], e = 0, m = 1; m <= o; m++)
              R = V.q(S, m / o), e += n.vectorLen(n.subtract(R, u)), J.push(e), u = R;
            return J = J.map((d) => d / e), J;
          };
          function M(S, o, R, J) {
            if (o < 0)
              return 0;
            if (o > 1)
              return 1;
            for (var u, e, m, d, b, N = 1; N <= J; N++)
              if (o <= R[N]) {
                d = (N - 1) / J, m = N / J, e = R[N - 1], u = R[N], b = (o - e) / (u - e) * (m - d) + d;
                break;
              }
            return b;
          }
          function x(S, o) {
            return n.normalize(n.subtract(S, o));
          }
          class n {
            static zeros_Xx2x2(o) {
              for (var R = []; o--; )
                R.push([0, 0]);
              return R;
            }
            static mulItems(o, R) {
              return o.map((J) => J * R);
            }
            static mulMatrix(o, R) {
              return o.reduce((J, u, e) => J + u * R[e], 0);
            }
            static subtract(o, R) {
              return o.map((J, u) => J - R[u]);
            }
            static addArrays(o, R) {
              return o.map((J, u) => J + R[u]);
            }
            static addItems(o, R) {
              return o.map((J) => J + R);
            }
            static sum(o) {
              return o.reduce((R, J) => R + J);
            }
            static dot(o, R) {
              return n.mulMatrix(o, R);
            }
            static vectorLen(o) {
              return Math.hypot(...o);
            }
            static divItems(o, R) {
              return o.map((J) => J / R);
            }
            static squareItems(o) {
              return o.map((R) => R * R);
            }
            static normalize(o) {
              return this.divItems(o, this.vectorLen(o));
            }
          }
          class V {
            static q(o, R) {
              var J = 1 - R, u = n.mulItems(o[0], J * J * J), e = n.mulItems(o[1], 3 * J * J * R), m = n.mulItems(o[2], 3 * J * R * R), d = n.mulItems(o[3], R * R * R);
              return n.addArrays(n.addArrays(u, e), n.addArrays(m, d));
            }
            static qprime(o, R) {
              var J = 1 - R, u = n.mulItems(n.subtract(o[1], o[0]), 3 * J * J), e = n.mulItems(n.subtract(o[2], o[1]), 6 * J * R), m = n.mulItems(n.subtract(o[3], o[2]), 3 * R * R);
              return n.addArrays(n.addArrays(u, e), m);
            }
            static qprimeprime(o, R) {
              return n.addArrays(n.mulItems(n.addArrays(n.subtract(o[2], n.mulItems(o[1], 2)), o[0]), 6 * (1 - R)), n.mulItems(n.addArrays(n.subtract(o[3], n.mulItems(o[2], 2)), o[1]), 6 * R));
            }
          }
          L.exports = c, L.exports.fitCubic = i, L.exports.createTangent = x;
        },
        /* 152 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.AnnotationLayer = void 0;
          var t = i(1), Z = i(133), W = i(130), y = i(153), h = i(154);
          function p(K, a, Y) {
            return X(K, a), Y;
          }
          function X(K, a) {
            if (K !== a)
              throw new TypeError("Private static access of wrong provenance");
          }
          const M = 1e3, x = 9, n = /* @__PURE__ */ new WeakSet();
          function V(K) {
            return {
              width: K[2] - K[0],
              height: K[3] - K[1]
            };
          }
          class S {
            static create(a) {
              switch (a.data.annotationType) {
                case t.AnnotationType.LINK:
                  return new R(a);
                case t.AnnotationType.TEXT:
                  return new J(a);
                case t.AnnotationType.WIDGET:
                  switch (a.data.fieldType) {
                    case "Tx":
                      return new e(a);
                    case "Btn":
                      return a.data.radioButton ? new d(a) : a.data.checkBox ? new m(a) : new b(a);
                    case "Ch":
                      return new N(a);
                  }
                  return new u(a);
                case t.AnnotationType.POPUP:
                  return new G(a);
                case t.AnnotationType.FREETEXT:
                  return new j(a);
                case t.AnnotationType.LINE:
                  return new D(a);
                case t.AnnotationType.SQUARE:
                  return new f(a);
                case t.AnnotationType.CIRCLE:
                  return new P(a);
                case t.AnnotationType.POLYLINE:
                  return new B(a);
                case t.AnnotationType.CARET:
                  return new H(a);
                case t.AnnotationType.INK:
                  return new O(a);
                case t.AnnotationType.POLYGON:
                  return new A(a);
                case t.AnnotationType.HIGHLIGHT:
                  return new U(a);
                case t.AnnotationType.UNDERLINE:
                  return new k(a);
                case t.AnnotationType.SQUIGGLY:
                  return new q(a);
                case t.AnnotationType.STRIKEOUT:
                  return new al(a);
                case t.AnnotationType.STAMP:
                  return new Ml(a);
                case t.AnnotationType.FILEATTACHMENT:
                  return new wl(a);
                default:
                  return new o(a);
              }
            }
          }
          class o {
            constructor(a) {
              let {
                isRenderable: Y = !1,
                ignoreBorder: z = !1,
                createQuadrilaterals: C = !1
              } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              this.isRenderable = Y, this.data = a.data, this.layer = a.layer, this.page = a.page, this.viewport = a.viewport, this.linkService = a.linkService, this.downloadManager = a.downloadManager, this.imageResourcesPath = a.imageResourcesPath, this.renderForms = a.renderForms, this.svgFactory = a.svgFactory, this.annotationStorage = a.annotationStorage, this.enableScripting = a.enableScripting, this.hasJSActions = a.hasJSActions, this._fieldObjects = a.fieldObjects, this._mouseState = a.mouseState, Y && (this.container = this._createContainer(z)), C && (this.quadrilaterals = this._createQuadrilaterals(z));
            }
            _createContainer() {
              let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
              const Y = this.data, z = this.page, C = this.viewport, F = document.createElement("section"), {
                width: v,
                height: $
              } = V(Y.rect), [il, dl, el, bl] = C.viewBox, ml = el - il, Gl = bl - dl;
              F.setAttribute("data-annotation-id", Y.id);
              const Yl = t.Util.normalizeRect([Y.rect[0], z.view[3] - Y.rect[1] + z.view[1], Y.rect[2], z.view[3] - Y.rect[3] + z.view[1]]);
              if (!a && Y.borderStyle.width > 0) {
                F.style.borderWidth = `${Y.borderStyle.width}px`;
                const Vl = Y.borderStyle.horizontalCornerRadius, Dl = Y.borderStyle.verticalCornerRadius;
                if (Vl > 0 || Dl > 0) {
                  const Hl = `calc(${Vl}px * var(--scale-factor)) / calc(${Dl}px * var(--scale-factor))`;
                  F.style.borderRadius = Hl;
                } else if (this instanceof d) {
                  const Hl = `calc(${v}px * var(--scale-factor)) / calc(${$}px * var(--scale-factor))`;
                  F.style.borderRadius = Hl;
                }
                switch (Y.borderStyle.style) {
                  case t.AnnotationBorderStyleType.SOLID:
                    F.style.borderStyle = "solid";
                    break;
                  case t.AnnotationBorderStyleType.DASHED:
                    F.style.borderStyle = "dashed";
                    break;
                  case t.AnnotationBorderStyleType.BEVELED:
                    (0, t.warn)("Unimplemented border style: beveled");
                    break;
                  case t.AnnotationBorderStyleType.INSET:
                    (0, t.warn)("Unimplemented border style: inset");
                    break;
                  case t.AnnotationBorderStyleType.UNDERLINE:
                    F.style.borderBottomStyle = "solid";
                    break;
                }
                const Xl = Y.borderColor || null;
                Xl ? F.style.borderColor = t.Util.makeHexColor(Xl[0] | 0, Xl[1] | 0, Xl[2] | 0) : F.style.borderWidth = 0;
              }
              F.style.left = `${100 * (Yl[0] - il) / ml}%`, F.style.top = `${100 * (Yl[1] - dl) / Gl}%`;
              const {
                rotation: yl
              } = Y;
              return Y.hasOwnCanvas || yl === 0 ? (F.style.width = `${100 * v / ml}%`, F.style.height = `${100 * $ / Gl}%`) : this.setRotation(yl, F), F;
            }
            setRotation(a) {
              let Y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.container;
              const [z, C, F, v] = this.viewport.viewBox, $ = F - z, il = v - C, {
                width: dl,
                height: el
              } = V(this.data.rect);
              let bl, ml;
              a % 180 === 0 ? (bl = 100 * dl / $, ml = 100 * el / il) : (bl = 100 * el / $, ml = 100 * dl / il), Y.style.width = `${bl}%`, Y.style.height = `${ml}%`, Y.setAttribute("data-main-rotation", (360 - a) % 360);
            }
            get _commonActions() {
              const a = (Y, z, C) => {
                const F = C.detail[Y];
                C.target.style[z] = y.ColorConverters[`${F[0]}_HTML`](F.slice(1));
              };
              return (0, t.shadow)(this, "_commonActions", {
                display: (Y) => {
                  const z = Y.detail.display % 2 === 1;
                  this.container.style.visibility = z ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                    hidden: z,
                    print: Y.detail.display === 0 || Y.detail.display === 3
                  });
                },
                print: (Y) => {
                  this.annotationStorage.setValue(this.data.id, {
                    print: Y.detail.print
                  });
                },
                hidden: (Y) => {
                  this.container.style.visibility = Y.detail.hidden ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                    hidden: Y.detail.hidden
                  });
                },
                focus: (Y) => {
                  setTimeout(() => Y.target.focus({
                    preventScroll: !1
                  }), 0);
                },
                userName: (Y) => {
                  Y.target.title = Y.detail.userName;
                },
                readonly: (Y) => {
                  Y.detail.readonly ? Y.target.setAttribute("readonly", "") : Y.target.removeAttribute("readonly");
                },
                required: (Y) => {
                  this._setRequired(Y.target, Y.detail.required);
                },
                bgColor: (Y) => {
                  a("bgColor", "backgroundColor", Y);
                },
                fillColor: (Y) => {
                  a("fillColor", "backgroundColor", Y);
                },
                fgColor: (Y) => {
                  a("fgColor", "color", Y);
                },
                textColor: (Y) => {
                  a("textColor", "color", Y);
                },
                borderColor: (Y) => {
                  a("borderColor", "borderColor", Y);
                },
                strokeColor: (Y) => {
                  a("strokeColor", "borderColor", Y);
                },
                rotation: (Y) => {
                  const z = Y.detail.rotation;
                  this.setRotation(z), this.annotationStorage.setValue(this.data.id, {
                    rotation: z
                  });
                }
              });
            }
            _dispatchEventFromSandbox(a, Y) {
              const z = this._commonActions;
              for (const C of Object.keys(Y.detail)) {
                const F = a[C] || z[C];
                F && F(Y);
              }
            }
            _setDefaultPropertiesFromJS(a) {
              if (!this.enableScripting)
                return;
              const Y = this.annotationStorage.getRawValue(this.data.id);
              if (!Y)
                return;
              const z = this._commonActions;
              for (const [C, F] of Object.entries(Y)) {
                const v = z[C];
                if (v) {
                  const $ = {
                    detail: {
                      [C]: F
                    },
                    target: a
                  };
                  v($), delete Y[C];
                }
              }
            }
            _createQuadrilaterals() {
              let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
              if (!this.data.quadPoints)
                return null;
              const Y = [], z = this.data.rect;
              for (const C of this.data.quadPoints)
                this.data.rect = [C[2].x, C[2].y, C[1].x, C[1].y], Y.push(this._createContainer(a));
              return this.data.rect = z, Y;
            }
            _createPopup(a, Y) {
              let z = this.container;
              this.quadrilaterals && (a = a || this.quadrilaterals, z = this.quadrilaterals[0]), a || (a = document.createElement("div"), a.className = "popupTriggerArea", z.append(a));
              const F = new r({
                container: z,
                trigger: a,
                color: Y.color,
                titleObj: Y.titleObj,
                modificationDate: Y.modificationDate,
                contentsObj: Y.contentsObj,
                richText: Y.richText,
                hideWrapper: !0
              }).render();
              F.style.left = "100%", z.append(F);
            }
            _renderQuadrilaterals(a) {
              for (const Y of this.quadrilaterals)
                Y.className = a;
              return this.quadrilaterals;
            }
            render() {
              (0, t.unreachable)("Abstract method `AnnotationElement.render` called");
            }
            _getElementsByName(a) {
              let Y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
              const z = [];
              if (this._fieldObjects) {
                const C = this._fieldObjects[a];
                if (C)
                  for (const {
                    page: F,
                    id: v,
                    exportValues: $
                  } of C) {
                    if (F === -1 || v === Y)
                      continue;
                    const il = typeof $ == "string" ? $ : null, dl = document.querySelector(`[data-element-id="${v}"]`);
                    if (dl && !n.has(dl)) {
                      (0, t.warn)(`_getElementsByName - element not allowed: ${v}`);
                      continue;
                    }
                    z.push({
                      id: v,
                      exportValue: il,
                      domElement: dl
                    });
                  }
                return z;
              }
              for (const C of document.getElementsByName(a)) {
                const {
                  id: F,
                  exportValue: v
                } = C;
                F !== Y && n.has(C) && z.push({
                  id: F,
                  exportValue: v,
                  domElement: C
                });
              }
              return z;
            }
            static get platform() {
              const a = typeof navigator < "u" ? navigator.platform : "";
              return (0, t.shadow)(this, "platform", {
                isWin: a.includes("Win"),
                isMac: a.includes("Mac")
              });
            }
          }
          class R extends o {
            constructor(a) {
              let Y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
              super(a, {
                isRenderable: !0,
                ignoreBorder: !!(Y != null && Y.ignoreBorder),
                createQuadrilaterals: !0
              }), this.isTooltipOnly = a.data.isTooltipOnly;
            }
            render() {
              const {
                data: a,
                linkService: Y
              } = this, z = document.createElement("a");
              z.setAttribute("data-element-id", a.id);
              let C = !1;
              return a.url ? (Y.addLinkAttributes(z, a.url, a.newWindow), C = !0) : a.action ? (this._bindNamedAction(z, a.action), C = !0) : a.dest ? (this._bindLink(z, a.dest), C = !0) : (a.actions && (a.actions.Action || a.actions["Mouse Up"] || a.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(z, a), C = !0), a.resetForm ? (this._bindResetFormAction(z, a.resetForm), C = !0) : this.isTooltipOnly && !C && (this._bindLink(z, ""), C = !0)), this.quadrilaterals ? this._renderQuadrilaterals("linkAnnotation").map((F, v) => {
                const $ = v === 0 ? z : z.cloneNode();
                return F.append($), F;
              }) : (this.container.className = "linkAnnotation", C && this.container.append(z), this.container);
            }
            _bindLink(a, Y) {
              a.href = this.linkService.getDestinationHash(Y), a.onclick = () => (Y && this.linkService.goToDestination(Y), !1), (Y || Y === "") && (a.className = "internalLink");
            }
            _bindNamedAction(a, Y) {
              a.href = this.linkService.getAnchorUrl(""), a.onclick = () => (this.linkService.executeNamedAction(Y), !1), a.className = "internalLink";
            }
            _bindJSAction(a, Y) {
              a.href = this.linkService.getAnchorUrl("");
              const z = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
              for (const C of Object.keys(Y.actions)) {
                const F = z.get(C);
                F && (a[F] = () => {
                  var v;
                  return (v = this.linkService.eventBus) === null || v === void 0 || v.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id: Y.id,
                      name: C
                    }
                  }), !1;
                });
              }
              a.onclick || (a.onclick = () => !1), a.className = "internalLink";
            }
            _bindResetFormAction(a, Y) {
              const z = a.onclick;
              if (z || (a.href = this.linkService.getAnchorUrl("")), a.className = "internalLink", !this._fieldObjects) {
                (0, t.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), z || (a.onclick = () => !1);
                return;
              }
              a.onclick = () => {
                z && z();
                const {
                  fields: C,
                  refs: F,
                  include: v
                } = Y, $ = [];
                if (C.length !== 0 || F.length !== 0) {
                  const bl = new Set(F);
                  for (const ml of C) {
                    const Gl = this._fieldObjects[ml] || [];
                    for (const {
                      id: Yl
                    } of Gl)
                      bl.add(Yl);
                  }
                  for (const ml of Object.values(this._fieldObjects))
                    for (const Gl of ml)
                      bl.has(Gl.id) === v && $.push(Gl);
                } else
                  for (const bl of Object.values(this._fieldObjects))
                    $.push(...bl);
                const il = this.annotationStorage, dl = [];
                for (const bl of $) {
                  const {
                    id: ml
                  } = bl;
                  switch (dl.push(ml), bl.type) {
                    case "text": {
                      const Yl = bl.defaultValue || "";
                      il.setValue(ml, {
                        value: Yl
                      });
                      break;
                    }
                    case "checkbox":
                    case "radiobutton": {
                      const Yl = bl.defaultValue === bl.exportValues;
                      il.setValue(ml, {
                        value: Yl
                      });
                      break;
                    }
                    case "combobox":
                    case "listbox": {
                      const Yl = bl.defaultValue || "";
                      il.setValue(ml, {
                        value: Yl
                      });
                      break;
                    }
                    default:
                      continue;
                  }
                  const Gl = document.querySelector(`[data-element-id="${ml}"]`);
                  if (Gl) {
                    if (!n.has(Gl)) {
                      (0, t.warn)(`_bindResetFormAction - element not allowed: ${ml}`);
                      continue;
                    }
                  } else continue;
                  Gl.dispatchEvent(new Event("resetform"));
                }
                if (this.enableScripting) {
                  var el;
                  (el = this.linkService.eventBus) === null || el === void 0 || el.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id: "app",
                      ids: dl,
                      name: "ResetForm"
                    }
                  });
                }
                return !1;
              };
            }
          }
          class J extends o {
            constructor(a) {
              var Y, z, C;
              const F = !!(a.data.hasPopup || (Y = a.data.titleObj) !== null && Y !== void 0 && Y.str || (z = a.data.contentsObj) !== null && z !== void 0 && z.str || (C = a.data.richText) !== null && C !== void 0 && C.str);
              super(a, {
                isRenderable: F
              });
            }
            render() {
              this.container.className = "textAnnotation";
              const a = document.createElement("img");
              return a.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", a.alt = "[{{type}} Annotation]", a.dataset.l10nId = "text_annotation_type", a.dataset.l10nArgs = JSON.stringify({
                type: this.data.name
              }), this.data.hasPopup || this._createPopup(a, this.data), this.container.append(a), this.container;
            }
          }
          class u extends o {
            render() {
              return this.data.alternativeText && (this.container.title = this.data.alternativeText), this.container;
            }
            _getKeyModifier(a) {
              const {
                isWin: Y,
                isMac: z
              } = o.platform;
              return Y && a.ctrlKey || z && a.metaKey;
            }
            _setEventListener(a, Y, z, C) {
              Y.includes("mouse") ? a.addEventListener(Y, (F) => {
                var v;
                (v = this.linkService.eventBus) === null || v === void 0 || v.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: z,
                    value: C(F),
                    shift: F.shiftKey,
                    modifier: this._getKeyModifier(F)
                  }
                });
              }) : a.addEventListener(Y, (F) => {
                var v;
                (v = this.linkService.eventBus) === null || v === void 0 || v.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: z,
                    value: C(F)
                  }
                });
              });
            }
            _setEventListeners(a, Y, z) {
              for (const [F, v] of Y) {
                var C;
                (v === "Action" || (C = this.data.actions) !== null && C !== void 0 && C[v]) && this._setEventListener(a, F, v, z);
              }
            }
            _setBackgroundColor(a) {
              const Y = this.data.backgroundColor || null;
              a.style.backgroundColor = Y === null ? "transparent" : t.Util.makeHexColor(Y[0], Y[1], Y[2]);
            }
            _setTextStyle(a) {
              const Y = ["left", "center", "right"], {
                fontColor: z
              } = this.data.defaultAppearanceData, C = this.data.defaultAppearanceData.fontSize || x, F = a.style;
              let v;
              if (this.data.multiLine) {
                const $ = Math.abs(this.data.rect[3] - this.data.rect[1]), il = Math.round($ / (t.LINE_FACTOR * C)) || 1, dl = $ / il;
                v = Math.min(C, Math.round(dl / t.LINE_FACTOR));
              } else {
                const $ = Math.abs(this.data.rect[3] - this.data.rect[1]);
                v = Math.min(C, Math.round($ / t.LINE_FACTOR));
              }
              F.fontSize = `calc(${v}px * var(--scale-factor))`, F.color = t.Util.makeHexColor(z[0], z[1], z[2]), this.data.textAlignment !== null && (F.textAlign = Y[this.data.textAlignment]);
            }
            _setRequired(a, Y) {
              Y ? a.setAttribute("required", !0) : a.removeAttribute("required"), a.setAttribute("aria-required", Y);
            }
          }
          class e extends u {
            constructor(a) {
              const Y = a.renderForms || !a.data.hasAppearance && !!a.data.fieldValue;
              super(a, {
                isRenderable: Y
              });
            }
            setPropertyOnSiblings(a, Y, z, C) {
              const F = this.annotationStorage;
              for (const v of this._getElementsByName(a.name, a.id))
                v.domElement && (v.domElement[Y] = z), F.setValue(v.id, {
                  [C]: z
                });
            }
            render() {
              const a = this.annotationStorage, Y = this.data.id;
              this.container.className = "textWidgetAnnotation";
              let z = null;
              if (this.renderForms) {
                const F = a.getValue(Y, {
                  value: this.data.fieldValue
                });
                let v = F.formattedValue || F.value || "";
                const $ = a.getValue(Y, {
                  charLimit: this.data.maxLen
                }).charLimit;
                $ && v.length > $ && (v = v.slice(0, $));
                const il = {
                  userValue: v,
                  formattedValue: null,
                  valueOnFocus: ""
                };
                this.data.multiLine ? (z = document.createElement("textarea"), z.textContent = v, this.data.doNotScroll && (z.style.overflowY = "hidden")) : (z = document.createElement("input"), z.type = "text", z.setAttribute("value", v), this.data.doNotScroll && (z.style.overflowX = "hidden")), n.add(z), z.setAttribute("data-element-id", Y), z.disabled = this.data.readOnly, z.name = this.data.fieldName, z.tabIndex = M, this._setRequired(z, this.data.required), $ && (z.maxLength = $), z.addEventListener("input", (el) => {
                  a.setValue(Y, {
                    value: el.target.value
                  }), this.setPropertyOnSiblings(z, "value", el.target.value, "value");
                }), z.addEventListener("resetform", (el) => {
                  var bl;
                  const ml = (bl = this.data.defaultFieldValue) !== null && bl !== void 0 ? bl : "";
                  z.value = il.userValue = ml, il.formattedValue = null;
                });
                let dl = (el) => {
                  const {
                    formattedValue: bl
                  } = il;
                  bl != null && (el.target.value = bl), el.target.scrollLeft = 0;
                };
                if (this.enableScripting && this.hasJSActions) {
                  var C;
                  z.addEventListener("focus", (bl) => {
                    il.userValue && (bl.target.value = il.userValue), il.valueOnFocus = bl.target.value;
                  }), z.addEventListener("updatefromsandbox", (bl) => {
                    const ml = {
                      value(Gl) {
                        var Yl;
                        il.userValue = (Yl = Gl.detail.value) !== null && Yl !== void 0 ? Yl : "", a.setValue(Y, {
                          value: il.userValue.toString()
                        }), Gl.target.value = il.userValue;
                      },
                      formattedValue(Gl) {
                        const {
                          formattedValue: Yl
                        } = Gl.detail;
                        il.formattedValue = Yl, Yl != null && Gl.target !== document.activeElement && (Gl.target.value = Yl), a.setValue(Y, {
                          formattedValue: Yl
                        });
                      },
                      selRange(Gl) {
                        Gl.target.setSelectionRange(...Gl.detail.selRange);
                      },
                      charLimit: (Gl) => {
                        var Yl;
                        const {
                          charLimit: yl
                        } = Gl.detail, {
                          target: Vl
                        } = Gl;
                        if (yl === 0) {
                          Vl.removeAttribute("maxLength");
                          return;
                        }
                        Vl.setAttribute("maxLength", yl);
                        let Dl = il.userValue;
                        !Dl || Dl.length <= yl || (Dl = Dl.slice(0, yl), Vl.value = il.userValue = Dl, a.setValue(Y, {
                          value: Dl
                        }), (Yl = this.linkService.eventBus) === null || Yl === void 0 || Yl.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id: Y,
                            name: "Keystroke",
                            value: Dl,
                            willCommit: !0,
                            commitKey: 1,
                            selStart: Vl.selectionStart,
                            selEnd: Vl.selectionEnd
                          }
                        }));
                      }
                    };
                    this._dispatchEventFromSandbox(ml, bl);
                  }), z.addEventListener("keydown", (bl) => {
                    var ml;
                    let Gl = -1;
                    if (bl.key === "Escape" ? Gl = 0 : bl.key === "Enter" ? Gl = 2 : bl.key === "Tab" && (Gl = 3), Gl === -1)
                      return;
                    const {
                      value: Yl
                    } = bl.target;
                    il.valueOnFocus !== Yl && (il.userValue = Yl, (ml = this.linkService.eventBus) === null || ml === void 0 || ml.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: Y,
                        name: "Keystroke",
                        value: Yl,
                        willCommit: !0,
                        commitKey: Gl,
                        selStart: bl.target.selectionStart,
                        selEnd: bl.target.selectionEnd
                      }
                    }));
                  });
                  const el = dl;
                  dl = null, z.addEventListener("blur", (bl) => {
                    const {
                      value: ml
                    } = bl.target;
                    if (il.userValue = ml, this._mouseState.isDown && il.valueOnFocus !== ml) {
                      var Gl;
                      (Gl = this.linkService.eventBus) === null || Gl === void 0 || Gl.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: Y,
                          name: "Keystroke",
                          value: ml,
                          willCommit: !0,
                          commitKey: 1,
                          selStart: bl.target.selectionStart,
                          selEnd: bl.target.selectionEnd
                        }
                      });
                    }
                    el(bl);
                  }), (C = this.data.actions) !== null && C !== void 0 && C.Keystroke && z.addEventListener("beforeinput", (bl) => {
                    var ml;
                    const {
                      data: Gl,
                      target: Yl
                    } = bl, {
                      value: yl,
                      selectionStart: Vl,
                      selectionEnd: Dl
                    } = Yl;
                    let Xl = Vl, Hl = Dl;
                    switch (bl.inputType) {
                      case "deleteWordBackward": {
                        const Al = yl.substring(0, Vl).match(/\w*[^\w]*$/);
                        Al && (Xl -= Al[0].length);
                        break;
                      }
                      case "deleteWordForward": {
                        const Al = yl.substring(Vl).match(/^[^\w]*\w*/);
                        Al && (Hl += Al[0].length);
                        break;
                      }
                      case "deleteContentBackward":
                        Vl === Dl && (Xl -= 1);
                        break;
                      case "deleteContentForward":
                        Vl === Dl && (Hl += 1);
                        break;
                    }
                    bl.preventDefault(), (ml = this.linkService.eventBus) === null || ml === void 0 || ml.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: Y,
                        name: "Keystroke",
                        value: yl,
                        change: Gl || "",
                        willCommit: !1,
                        selStart: Xl,
                        selEnd: Hl
                      }
                    });
                  }), this._setEventListeners(z, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (bl) => bl.target.value);
                }
                if (dl && z.addEventListener("blur", dl), this.data.comb) {
                  const bl = (this.data.rect[2] - this.data.rect[0]) / $;
                  z.classList.add("comb"), z.style.letterSpacing = `calc(${bl}px * var(--scale-factor) - 1ch)`;
                }
              } else
                z = document.createElement("div"), z.textContent = this.data.fieldValue, z.style.verticalAlign = "middle", z.style.display = "table-cell";
              return this._setTextStyle(z), this._setBackgroundColor(z), this._setDefaultPropertiesFromJS(z), this.container.append(z), this.container;
            }
          }
          class m extends u {
            constructor(a) {
              super(a, {
                isRenderable: a.renderForms
              });
            }
            render() {
              const a = this.annotationStorage, Y = this.data, z = Y.id;
              let C = a.getValue(z, {
                value: Y.exportValue === Y.fieldValue
              }).value;
              typeof C == "string" && (C = C !== "Off", a.setValue(z, {
                value: C
              })), this.container.className = "buttonWidgetAnnotation checkBox";
              const F = document.createElement("input");
              return n.add(F), F.setAttribute("data-element-id", z), F.disabled = Y.readOnly, this._setRequired(F, this.data.required), F.type = "checkbox", F.name = Y.fieldName, C && F.setAttribute("checked", !0), F.setAttribute("exportValue", Y.exportValue), F.tabIndex = M, F.addEventListener("change", (v) => {
                const {
                  name: $,
                  checked: il
                } = v.target;
                for (const dl of this._getElementsByName($, z)) {
                  const el = il && dl.exportValue === Y.exportValue;
                  dl.domElement && (dl.domElement.checked = el), a.setValue(dl.id, {
                    value: el
                  });
                }
                a.setValue(z, {
                  value: il
                });
              }), F.addEventListener("resetform", (v) => {
                const $ = Y.defaultFieldValue || "Off";
                v.target.checked = $ === Y.exportValue;
              }), this.enableScripting && this.hasJSActions && (F.addEventListener("updatefromsandbox", (v) => {
                const $ = {
                  value(il) {
                    il.target.checked = il.detail.value !== "Off", a.setValue(z, {
                      value: il.target.checked
                    });
                  }
                };
                this._dispatchEventFromSandbox($, v);
              }), this._setEventListeners(F, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (v) => v.target.checked)), this._setBackgroundColor(F), this._setDefaultPropertiesFromJS(F), this.container.append(F), this.container;
            }
          }
          class d extends u {
            constructor(a) {
              super(a, {
                isRenderable: a.renderForms
              });
            }
            render() {
              this.container.className = "buttonWidgetAnnotation radioButton";
              const a = this.annotationStorage, Y = this.data, z = Y.id;
              let C = a.getValue(z, {
                value: Y.fieldValue === Y.buttonValue
              }).value;
              typeof C == "string" && (C = C !== Y.buttonValue, a.setValue(z, {
                value: C
              }));
              const F = document.createElement("input");
              if (n.add(F), F.setAttribute("data-element-id", z), F.disabled = Y.readOnly, this._setRequired(F, this.data.required), F.type = "radio", F.name = Y.fieldName, C && F.setAttribute("checked", !0), F.tabIndex = M, F.addEventListener("change", (v) => {
                const {
                  name: $,
                  checked: il
                } = v.target;
                for (const dl of this._getElementsByName($, z))
                  a.setValue(dl.id, {
                    value: !1
                  });
                a.setValue(z, {
                  value: il
                });
              }), F.addEventListener("resetform", (v) => {
                const $ = Y.defaultFieldValue;
                v.target.checked = $ != null && $ === Y.buttonValue;
              }), this.enableScripting && this.hasJSActions) {
                const v = Y.buttonValue;
                F.addEventListener("updatefromsandbox", ($) => {
                  const il = {
                    value: (dl) => {
                      const el = v === dl.detail.value;
                      for (const bl of this._getElementsByName(dl.target.name)) {
                        const ml = el && bl.id === z;
                        bl.domElement && (bl.domElement.checked = ml), a.setValue(bl.id, {
                          value: ml
                        });
                      }
                    }
                  };
                  this._dispatchEventFromSandbox(il, $);
                }), this._setEventListeners(F, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], ($) => $.target.checked);
              }
              return this._setBackgroundColor(F), this._setDefaultPropertiesFromJS(F), this.container.append(F), this.container;
            }
          }
          class b extends R {
            constructor(a) {
              super(a, {
                ignoreBorder: a.data.hasAppearance
              });
            }
            render() {
              const a = super.render();
              a.className = "buttonWidgetAnnotation pushButton", this.data.alternativeText && (a.title = this.data.alternativeText);
              const Y = a.lastChild;
              return this.enableScripting && this.hasJSActions && Y && (this._setDefaultPropertiesFromJS(Y), Y.addEventListener("updatefromsandbox", (z) => {
                this._dispatchEventFromSandbox({}, z);
              })), a;
            }
          }
          class N extends u {
            constructor(a) {
              super(a, {
                isRenderable: a.renderForms
              });
            }
            render() {
              this.container.className = "choiceWidgetAnnotation";
              const a = this.annotationStorage, Y = this.data.id, z = a.getValue(Y, {
                value: this.data.fieldValue
              }), C = document.createElement("select");
              n.add(C), C.setAttribute("data-element-id", Y), C.disabled = this.data.readOnly, this._setRequired(C, this.data.required), C.name = this.data.fieldName, C.tabIndex = M;
              let F = this.data.combo && this.data.options.length > 0;
              this.data.combo || (C.size = this.data.options.length, this.data.multiSelect && (C.multiple = !0)), C.addEventListener("resetform", (dl) => {
                const el = this.data.defaultFieldValue;
                for (const bl of C.options)
                  bl.selected = bl.value === el;
              });
              for (const dl of this.data.options) {
                const el = document.createElement("option");
                el.textContent = dl.displayValue, el.value = dl.exportValue, z.value.includes(dl.exportValue) && (el.setAttribute("selected", !0), F = !1), C.append(el);
              }
              let v = null;
              if (F) {
                const dl = document.createElement("option");
                dl.value = " ", dl.setAttribute("hidden", !0), dl.setAttribute("selected", !0), C.prepend(dl), v = () => {
                  dl.remove(), C.removeEventListener("input", v), v = null;
                }, C.addEventListener("input", v);
              }
              const $ = (dl, el) => {
                const bl = el ? "value" : "textContent", ml = dl.target.options;
                return dl.target.multiple ? Array.prototype.filter.call(ml, (Gl) => Gl.selected).map((Gl) => Gl[bl]) : ml.selectedIndex === -1 ? null : ml[ml.selectedIndex][bl];
              }, il = (dl) => {
                const el = dl.target.options;
                return Array.prototype.map.call(el, (bl) => ({
                  displayValue: bl.textContent,
                  exportValue: bl.value
                }));
              };
              return this.enableScripting && this.hasJSActions ? (C.addEventListener("updatefromsandbox", (dl) => {
                const el = {
                  value(bl) {
                    var ml;
                    (ml = v) === null || ml === void 0 || ml();
                    const Gl = bl.detail.value, Yl = new Set(Array.isArray(Gl) ? Gl : [Gl]);
                    for (const yl of C.options)
                      yl.selected = Yl.has(yl.value);
                    a.setValue(Y, {
                      value: $(bl, !0)
                    });
                  },
                  multipleSelection(bl) {
                    C.multiple = !0;
                  },
                  remove(bl) {
                    const ml = C.options, Gl = bl.detail.remove;
                    ml[Gl].selected = !1, C.remove(Gl), ml.length > 0 && Array.prototype.findIndex.call(ml, (yl) => yl.selected) === -1 && (ml[0].selected = !0), a.setValue(Y, {
                      value: $(bl, !0),
                      items: il(bl)
                    });
                  },
                  clear(bl) {
                    for (; C.length !== 0; )
                      C.remove(0);
                    a.setValue(Y, {
                      value: null,
                      items: []
                    });
                  },
                  insert(bl) {
                    const {
                      index: ml,
                      displayValue: Gl,
                      exportValue: Yl
                    } = bl.detail.insert, yl = C.children[ml], Vl = document.createElement("option");
                    Vl.textContent = Gl, Vl.value = Yl, yl ? yl.before(Vl) : C.append(Vl), a.setValue(Y, {
                      value: $(bl, !0),
                      items: il(bl)
                    });
                  },
                  items(bl) {
                    const {
                      items: ml
                    } = bl.detail;
                    for (; C.length !== 0; )
                      C.remove(0);
                    for (const Gl of ml) {
                      const {
                        displayValue: Yl,
                        exportValue: yl
                      } = Gl, Vl = document.createElement("option");
                      Vl.textContent = Yl, Vl.value = yl, C.append(Vl);
                    }
                    C.options.length > 0 && (C.options[0].selected = !0), a.setValue(Y, {
                      value: $(bl, !0),
                      items: il(bl)
                    });
                  },
                  indices(bl) {
                    const ml = new Set(bl.detail.indices);
                    for (const Gl of bl.target.options)
                      Gl.selected = ml.has(Gl.index);
                    a.setValue(Y, {
                      value: $(bl, !0)
                    });
                  },
                  editable(bl) {
                    bl.target.disabled = !bl.detail.editable;
                  }
                };
                this._dispatchEventFromSandbox(el, dl);
              }), C.addEventListener("input", (dl) => {
                var el;
                const bl = $(dl, !0), ml = $(dl, !1);
                a.setValue(Y, {
                  value: bl
                }), (el = this.linkService.eventBus) === null || el === void 0 || el.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: Y,
                    name: "Keystroke",
                    value: ml,
                    changeEx: bl,
                    willCommit: !0,
                    commitKey: 1,
                    keyDown: !1
                  }
                });
              }), this._setEventListeners(C, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], (dl) => dl.target.checked)) : C.addEventListener("input", function(dl) {
                a.setValue(Y, {
                  value: $(dl, !0)
                });
              }), this.data.combo && this._setTextStyle(C), this._setBackgroundColor(C), this._setDefaultPropertiesFromJS(C), this.container.append(C), this.container;
            }
          }
          class G extends o {
            constructor(a) {
              var Y, z, C;
              const F = !!((Y = a.data.titleObj) !== null && Y !== void 0 && Y.str || (z = a.data.contentsObj) !== null && z !== void 0 && z.str || (C = a.data.richText) !== null && C !== void 0 && C.str);
              super(a, {
                isRenderable: F
              });
            }
            render() {
              const a = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
              if (this.container.className = "popupAnnotation", a.includes(this.data.parentType))
                return this.container;
              const Y = `[data-annotation-id="${this.data.parentId}"]`, z = this.layer.querySelectorAll(Y);
              if (z.length === 0)
                return this.container;
              const C = new r({
                container: this.container,
                trigger: Array.from(z),
                color: this.data.color,
                titleObj: this.data.titleObj,
                modificationDate: this.data.modificationDate,
                contentsObj: this.data.contentsObj,
                richText: this.data.richText
              }), F = this.page, v = t.Util.normalizeRect([this.data.parentRect[0], F.view[3] - this.data.parentRect[1] + F.view[1], this.data.parentRect[2], F.view[3] - this.data.parentRect[3] + F.view[1]]), $ = v[0] + this.data.parentRect[2] - this.data.parentRect[0], il = v[1], [dl, el, bl, ml] = this.viewport.viewBox, Gl = bl - dl, Yl = ml - el;
              return this.container.style.left = `${100 * ($ - dl) / Gl}%`, this.container.style.top = `${100 * (il - el) / Yl}%`, this.container.append(C.render()), this.container;
            }
          }
          class r {
            constructor(a) {
              this.container = a.container, this.trigger = a.trigger, this.color = a.color, this.titleObj = a.titleObj, this.modificationDate = a.modificationDate, this.contentsObj = a.contentsObj, this.richText = a.richText, this.hideWrapper = a.hideWrapper || !1, this.pinned = !1;
            }
            render() {
              var a, Y;
              const C = document.createElement("div");
              C.className = "popupWrapper", this.hideElement = this.hideWrapper ? C : this.container, this.hideElement.hidden = !0;
              const F = document.createElement("div");
              F.className = "popup";
              const v = this.color;
              if (v) {
                const dl = 0.7 * (255 - v[0]) + v[0], el = 0.7 * (255 - v[1]) + v[1], bl = 0.7 * (255 - v[2]) + v[2];
                F.style.backgroundColor = t.Util.makeHexColor(dl | 0, el | 0, bl | 0);
              }
              const $ = document.createElement("h1");
              $.dir = this.titleObj.dir, $.textContent = this.titleObj.str, F.append($);
              const il = Z.PDFDateString.toDateObject(this.modificationDate);
              if (il) {
                const dl = document.createElement("span");
                dl.className = "popupDate", dl.textContent = "{{date}}, {{time}}", dl.dataset.l10nId = "annotation_date_string", dl.dataset.l10nArgs = JSON.stringify({
                  date: il.toLocaleDateString(),
                  time: il.toLocaleTimeString()
                }), F.append(dl);
              }
              if ((a = this.richText) !== null && a !== void 0 && a.str && (!((Y = this.contentsObj) !== null && Y !== void 0 && Y.str) || this.contentsObj.str === this.richText.str))
                h.XfaLayer.render({
                  xfaHtml: this.richText.html,
                  intent: "richText",
                  div: F
                }), F.lastChild.className = "richText popupContent";
              else {
                const dl = this._formatContents(this.contentsObj);
                F.append(dl);
              }
              Array.isArray(this.trigger) || (this.trigger = [this.trigger]);
              for (const dl of this.trigger)
                dl.addEventListener("click", this._toggle.bind(this)), dl.addEventListener("mouseover", this._show.bind(this, !1)), dl.addEventListener("mouseout", this._hide.bind(this, !1));
              return F.addEventListener("click", this._hide.bind(this, !0)), C.append(F), C;
            }
            _formatContents(a) {
              let {
                str: Y,
                dir: z
              } = a;
              const C = document.createElement("p");
              C.className = "popupContent", C.dir = z;
              const F = Y.split(/(?:\r\n?|\n)/);
              for (let v = 0, $ = F.length; v < $; ++v) {
                const il = F[v];
                C.append(document.createTextNode(il)), v < $ - 1 && C.append(document.createElement("br"));
              }
              return C;
            }
            _toggle() {
              this.pinned ? this._hide(!0) : this._show(!0);
            }
            _show() {
              (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1) && (this.pinned = !0), this.hideElement.hidden && (this.hideElement.hidden = !1, this.container.style.zIndex = parseInt(this.container.style.zIndex) + 1e3);
            }
            _hide() {
              (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0) && (this.pinned = !1), !this.hideElement.hidden && !this.pinned && (this.hideElement.hidden = !0, this.container.style.zIndex = parseInt(this.container.style.zIndex) - 1e3);
            }
          }
          class j extends o {
            constructor(a) {
              var Y, z, C;
              const F = !!(a.data.hasPopup || (Y = a.data.titleObj) !== null && Y !== void 0 && Y.str || (z = a.data.contentsObj) !== null && z !== void 0 && z.str || (C = a.data.richText) !== null && C !== void 0 && C.str);
              super(a, {
                isRenderable: F,
                ignoreBorder: !0
              }), this.textContent = a.data.textContent;
            }
            render() {
              if (this.container.className = "freeTextAnnotation", this.textContent) {
                const a = document.createElement("div");
                a.className = "annotationTextContent", a.setAttribute("role", "comment");
                for (const Y of this.textContent) {
                  const z = document.createElement("span");
                  z.textContent = Y, a.append(z);
                }
                this.container.append(a);
              }
              return this.data.hasPopup || this._createPopup(null, this.data), this.container;
            }
          }
          class D extends o {
            constructor(a) {
              var Y, z, C;
              const F = !!(a.data.hasPopup || (Y = a.data.titleObj) !== null && Y !== void 0 && Y.str || (z = a.data.contentsObj) !== null && z !== void 0 && z.str || (C = a.data.richText) !== null && C !== void 0 && C.str);
              super(a, {
                isRenderable: F,
                ignoreBorder: !0
              });
            }
            render() {
              this.container.className = "lineAnnotation";
              const a = this.data, {
                width: Y,
                height: z
              } = V(a.rect), C = this.svgFactory.create(Y, z, !0), F = this.svgFactory.createElement("svg:line");
              return F.setAttribute("x1", a.rect[2] - a.lineCoordinates[0]), F.setAttribute("y1", a.rect[3] - a.lineCoordinates[1]), F.setAttribute("x2", a.rect[2] - a.lineCoordinates[2]), F.setAttribute("y2", a.rect[3] - a.lineCoordinates[3]), F.setAttribute("stroke-width", a.borderStyle.width || 1), F.setAttribute("stroke", "transparent"), F.setAttribute("fill", "transparent"), C.append(F), this.container.append(C), this._createPopup(F, a), this.container;
            }
          }
          class f extends o {
            constructor(a) {
              var Y, z, C;
              const F = !!(a.data.hasPopup || (Y = a.data.titleObj) !== null && Y !== void 0 && Y.str || (z = a.data.contentsObj) !== null && z !== void 0 && z.str || (C = a.data.richText) !== null && C !== void 0 && C.str);
              super(a, {
                isRenderable: F,
                ignoreBorder: !0
              });
            }
            render() {
              this.container.className = "squareAnnotation";
              const a = this.data, {
                width: Y,
                height: z
              } = V(a.rect), C = this.svgFactory.create(Y, z, !0), F = a.borderStyle.width, v = this.svgFactory.createElement("svg:rect");
              return v.setAttribute("x", F / 2), v.setAttribute("y", F / 2), v.setAttribute("width", Y - F), v.setAttribute("height", z - F), v.setAttribute("stroke-width", F || 1), v.setAttribute("stroke", "transparent"), v.setAttribute("fill", "transparent"), C.append(v), this.container.append(C), this._createPopup(v, a), this.container;
            }
          }
          class P extends o {
            constructor(a) {
              var Y, z, C;
              const F = !!(a.data.hasPopup || (Y = a.data.titleObj) !== null && Y !== void 0 && Y.str || (z = a.data.contentsObj) !== null && z !== void 0 && z.str || (C = a.data.richText) !== null && C !== void 0 && C.str);
              super(a, {
                isRenderable: F,
                ignoreBorder: !0
              });
            }
            render() {
              this.container.className = "circleAnnotation";
              const a = this.data, {
                width: Y,
                height: z
              } = V(a.rect), C = this.svgFactory.create(Y, z, !0), F = a.borderStyle.width, v = this.svgFactory.createElement("svg:ellipse");
              return v.setAttribute("cx", Y / 2), v.setAttribute("cy", z / 2), v.setAttribute("rx", Y / 2 - F / 2), v.setAttribute("ry", z / 2 - F / 2), v.setAttribute("stroke-width", F || 1), v.setAttribute("stroke", "transparent"), v.setAttribute("fill", "transparent"), C.append(v), this.container.append(C), this._createPopup(v, a), this.container;
            }
          }
          class B extends o {
            constructor(a) {
              var Y, z, C;
              const F = !!(a.data.hasPopup || (Y = a.data.titleObj) !== null && Y !== void 0 && Y.str || (z = a.data.contentsObj) !== null && z !== void 0 && z.str || (C = a.data.richText) !== null && C !== void 0 && C.str);
              super(a, {
                isRenderable: F,
                ignoreBorder: !0
              }), this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
            }
            render() {
              this.container.className = this.containerClassName;
              const a = this.data, {
                width: Y,
                height: z
              } = V(a.rect), C = this.svgFactory.create(Y, z, !0);
              let F = [];
              for (const $ of a.vertices) {
                const il = $.x - a.rect[0], dl = a.rect[3] - $.y;
                F.push(il + "," + dl);
              }
              F = F.join(" ");
              const v = this.svgFactory.createElement(this.svgElementName);
              return v.setAttribute("points", F), v.setAttribute("stroke-width", a.borderStyle.width || 1), v.setAttribute("stroke", "transparent"), v.setAttribute("fill", "transparent"), C.append(v), this.container.append(C), this._createPopup(v, a), this.container;
            }
          }
          class A extends B {
            constructor(a) {
              super(a), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
            }
          }
          class H extends o {
            constructor(a) {
              var Y, z, C;
              const F = !!(a.data.hasPopup || (Y = a.data.titleObj) !== null && Y !== void 0 && Y.str || (z = a.data.contentsObj) !== null && z !== void 0 && z.str || (C = a.data.richText) !== null && C !== void 0 && C.str);
              super(a, {
                isRenderable: F,
                ignoreBorder: !0
              });
            }
            render() {
              return this.container.className = "caretAnnotation", this.data.hasPopup || this._createPopup(null, this.data), this.container;
            }
          }
          class O extends o {
            constructor(a) {
              var Y, z, C;
              const F = !!(a.data.hasPopup || (Y = a.data.titleObj) !== null && Y !== void 0 && Y.str || (z = a.data.contentsObj) !== null && z !== void 0 && z.str || (C = a.data.richText) !== null && C !== void 0 && C.str);
              super(a, {
                isRenderable: F,
                ignoreBorder: !0
              }), this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline";
            }
            render() {
              this.container.className = this.containerClassName;
              const a = this.data, {
                width: Y,
                height: z
              } = V(a.rect), C = this.svgFactory.create(Y, z, !0);
              for (const F of a.inkLists) {
                let v = [];
                for (const il of F) {
                  const dl = il.x - a.rect[0], el = a.rect[3] - il.y;
                  v.push(`${dl},${el}`);
                }
                v = v.join(" ");
                const $ = this.svgFactory.createElement(this.svgElementName);
                $.setAttribute("points", v), $.setAttribute("stroke-width", a.borderStyle.width || 1), $.setAttribute("stroke", "transparent"), $.setAttribute("fill", "transparent"), this._createPopup($, a), C.append($);
              }
              return this.container.append(C), this.container;
            }
          }
          class U extends o {
            constructor(a) {
              var Y, z, C;
              const F = !!(a.data.hasPopup || (Y = a.data.titleObj) !== null && Y !== void 0 && Y.str || (z = a.data.contentsObj) !== null && z !== void 0 && z.str || (C = a.data.richText) !== null && C !== void 0 && C.str);
              super(a, {
                isRenderable: F,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return this.data.hasPopup || this._createPopup(null, this.data), this.quadrilaterals ? this._renderQuadrilaterals("highlightAnnotation") : (this.container.className = "highlightAnnotation", this.container);
            }
          }
          class k extends o {
            constructor(a) {
              var Y, z, C;
              const F = !!(a.data.hasPopup || (Y = a.data.titleObj) !== null && Y !== void 0 && Y.str || (z = a.data.contentsObj) !== null && z !== void 0 && z.str || (C = a.data.richText) !== null && C !== void 0 && C.str);
              super(a, {
                isRenderable: F,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return this.data.hasPopup || this._createPopup(null, this.data), this.quadrilaterals ? this._renderQuadrilaterals("underlineAnnotation") : (this.container.className = "underlineAnnotation", this.container);
            }
          }
          class q extends o {
            constructor(a) {
              var Y, z, C;
              const F = !!(a.data.hasPopup || (Y = a.data.titleObj) !== null && Y !== void 0 && Y.str || (z = a.data.contentsObj) !== null && z !== void 0 && z.str || (C = a.data.richText) !== null && C !== void 0 && C.str);
              super(a, {
                isRenderable: F,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return this.data.hasPopup || this._createPopup(null, this.data), this.quadrilaterals ? this._renderQuadrilaterals("squigglyAnnotation") : (this.container.className = "squigglyAnnotation", this.container);
            }
          }
          class al extends o {
            constructor(a) {
              var Y, z, C;
              const F = !!(a.data.hasPopup || (Y = a.data.titleObj) !== null && Y !== void 0 && Y.str || (z = a.data.contentsObj) !== null && z !== void 0 && z.str || (C = a.data.richText) !== null && C !== void 0 && C.str);
              super(a, {
                isRenderable: F,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return this.data.hasPopup || this._createPopup(null, this.data), this.quadrilaterals ? this._renderQuadrilaterals("strikeoutAnnotation") : (this.container.className = "strikeoutAnnotation", this.container);
            }
          }
          class Ml extends o {
            constructor(a) {
              var Y, z, C;
              const F = !!(a.data.hasPopup || (Y = a.data.titleObj) !== null && Y !== void 0 && Y.str || (z = a.data.contentsObj) !== null && z !== void 0 && z.str || (C = a.data.richText) !== null && C !== void 0 && C.str);
              super(a, {
                isRenderable: F,
                ignoreBorder: !0
              });
            }
            render() {
              return this.container.className = "stampAnnotation", this.data.hasPopup || this._createPopup(null, this.data), this.container;
            }
          }
          class wl extends o {
            constructor(a) {
              var Y;
              super(a, {
                isRenderable: !0
              });
              const {
                filename: z,
                content: C
              } = this.data.file;
              this.filename = (0, Z.getFilenameFromUrl)(z), this.content = C, (Y = this.linkService.eventBus) === null || Y === void 0 || Y.dispatch("fileattachmentannotation", {
                source: this,
                filename: z,
                content: C
              });
            }
            render() {
              var a, Y;
              this.container.className = "fileAttachmentAnnotation";
              const z = document.createElement("div");
              return z.className = "popupTriggerArea", z.addEventListener("dblclick", this._download.bind(this)), !this.data.hasPopup && ((a = this.data.titleObj) !== null && a !== void 0 && a.str || (Y = this.data.contentsObj) !== null && Y !== void 0 && Y.str || this.data.richText) && this._createPopup(z, this.data), this.container.append(z), this.container;
            }
            _download() {
              var a;
              (a = this.downloadManager) === null || a === void 0 || a.openOrDownloadData(this.container, this.content, this.filename);
            }
          }
          class Q {
            static render(a) {
              const {
                annotations: Y,
                div: z,
                viewport: C,
                accessibilityManager: F
              } = a;
              p(this, Q, w).call(this, z, C);
              let v = 0;
              for (const $ of Y) {
                if ($.annotationType !== t.AnnotationType.POPUP) {
                  const {
                    width: dl,
                    height: el
                  } = V($.rect);
                  if (dl <= 0 || el <= 0)
                    continue;
                }
                const il = S.create({
                  data: $,
                  layer: z,
                  page: a.page,
                  viewport: C,
                  linkService: a.linkService,
                  downloadManager: a.downloadManager,
                  imageResourcesPath: a.imageResourcesPath || "",
                  renderForms: a.renderForms !== !1,
                  svgFactory: new Z.DOMSVGFactory(),
                  annotationStorage: a.annotationStorage || new W.AnnotationStorage(),
                  enableScripting: a.enableScripting,
                  hasJSActions: a.hasJSActions,
                  fieldObjects: a.fieldObjects,
                  mouseState: a.mouseState || {
                    isDown: !1
                  }
                });
                if (il.isRenderable) {
                  const dl = il.render();
                  if ($.hidden && (dl.style.visibility = "hidden"), Array.isArray(dl))
                    for (const el of dl)
                      el.style.zIndex = v++, p(Q, Q, T).call(Q, el, $.id, z, F);
                  else
                    dl.style.zIndex = v++, il instanceof G ? z.prepend(dl) : p(Q, Q, T).call(Q, dl, $.id, z, F);
                }
              }
              p(this, Q, g).call(this, z, a.annotationCanvasMap);
            }
            static update(a) {
              const {
                annotationCanvasMap: Y,
                div: z,
                viewport: C
              } = a;
              p(this, Q, w).call(this, z, C), p(this, Q, g).call(this, z, Y), z.hidden = !1;
            }
          }
          c.AnnotationLayer = Q;
          function T(K, a, Y, z) {
            const C = K.firstChild || K;
            C.id = `${Z.AnnotationPrefix}${a}`, Y.append(K), z == null || z.moveElementInDOM(Y, K, C, !1);
          }
          function w(K, a) {
            let {
              width: Y,
              height: z,
              rotation: C
            } = a;
            const {
              style: F
            } = K, v = C % 180 !== 0, $ = Math.floor(Y) + "px", il = Math.floor(z) + "px";
            F.width = v ? il : $, F.height = v ? $ : il, K.setAttribute("data-main-rotation", C);
          }
          function g(K, a) {
            if (a) {
              for (const [Y, z] of a) {
                const C = K.querySelector(`[data-annotation-id="${Y}"]`);
                if (!C)
                  continue;
                const {
                  firstChild: F
                } = C;
                F ? F.nodeName === "CANVAS" ? F.replaceWith(z) : F.before(z) : C.append(z);
              }
              a.clear();
            }
          }
        },
        /* 153 */
        /***/
        (L, c) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.ColorConverters = void 0;
          function i(Z) {
            return Math.floor(Math.max(0, Math.min(1, Z)) * 255).toString(16).padStart(2, "0");
          }
          class t {
            static CMYK_G(W) {
              let [y, h, p, X] = W;
              return ["G", 1 - Math.min(1, 0.3 * y + 0.59 * p + 0.11 * h + X)];
            }
            static G_CMYK(W) {
              let [y] = W;
              return ["CMYK", 0, 0, 0, 1 - y];
            }
            static G_RGB(W) {
              let [y] = W;
              return ["RGB", y, y, y];
            }
            static G_HTML(W) {
              let [y] = W;
              const h = i(y);
              return `#${h}${h}${h}`;
            }
            static RGB_G(W) {
              let [y, h, p] = W;
              return ["G", 0.3 * y + 0.59 * h + 0.11 * p];
            }
            static RGB_HTML(W) {
              let [y, h, p] = W;
              const X = i(y), M = i(h), x = i(p);
              return `#${X}${M}${x}`;
            }
            static T_HTML() {
              return "#00000000";
            }
            static CMYK_RGB(W) {
              let [y, h, p, X] = W;
              return ["RGB", 1 - Math.min(1, y + X), 1 - Math.min(1, p + X), 1 - Math.min(1, h + X)];
            }
            static CMYK_HTML(W) {
              const y = this.CMYK_RGB(W).slice(1);
              return this.RGB_HTML(y);
            }
            static RGB_CMYK(W) {
              let [y, h, p] = W;
              const X = 1 - y, M = 1 - h, x = 1 - p, n = Math.min(X, M, x);
              return ["CMYK", X, M, x, n];
            }
          }
          c.ColorConverters = t;
        },
        /* 154 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.XfaLayer = void 0;
          var t = i(145);
          class Z {
            static setupStorage(y, h, p, X, M) {
              const x = X.getValue(h, {
                value: null
              });
              switch (p.name) {
                case "textarea":
                  if (x.value !== null && (y.textContent = x.value), M === "print")
                    break;
                  y.addEventListener("input", (n) => {
                    X.setValue(h, {
                      value: n.target.value
                    });
                  });
                  break;
                case "input":
                  if (p.attributes.type === "radio" || p.attributes.type === "checkbox") {
                    if (x.value === p.attributes.xfaOn ? y.setAttribute("checked", !0) : x.value === p.attributes.xfaOff && y.removeAttribute("checked"), M === "print")
                      break;
                    y.addEventListener("change", (n) => {
                      X.setValue(h, {
                        value: n.target.checked ? n.target.getAttribute("xfaOn") : n.target.getAttribute("xfaOff")
                      });
                    });
                  } else {
                    if (x.value !== null && y.setAttribute("value", x.value), M === "print")
                      break;
                    y.addEventListener("input", (n) => {
                      X.setValue(h, {
                        value: n.target.value
                      });
                    });
                  }
                  break;
                case "select":
                  if (x.value !== null)
                    for (const n of p.children)
                      n.attributes.value === x.value && (n.attributes.selected = !0);
                  y.addEventListener("input", (n) => {
                    const V = n.target.options, S = V.selectedIndex === -1 ? "" : V[V.selectedIndex].value;
                    X.setValue(h, {
                      value: S
                    });
                  });
                  break;
              }
            }
            static setAttributes(y) {
              let {
                html: h,
                element: p,
                storage: X = null,
                intent: M,
                linkService: x
              } = y;
              const {
                attributes: n
              } = p, V = h instanceof HTMLAnchorElement;
              n.type === "radio" && (n.name = `${n.name}-${M}`);
              for (const [S, o] of Object.entries(n))
                if (o != null)
                  switch (S) {
                    case "class":
                      o.length && h.setAttribute(S, o.join(" "));
                      break;
                    case "dataId":
                      break;
                    case "id":
                      h.setAttribute("data-element-id", o);
                      break;
                    case "style":
                      Object.assign(h.style, o);
                      break;
                    case "textContent":
                      h.textContent = o;
                      break;
                    default:
                      (!V || S !== "href" && S !== "newWindow") && h.setAttribute(S, o);
                  }
              V && x.addLinkAttributes(h, n.href, n.newWindow), X && n.dataId && this.setupStorage(h, n.dataId, p, X);
            }
            static render(y) {
              const h = y.annotationStorage, p = y.linkService, X = y.xfaHtml, M = y.intent || "display", x = document.createElement(X.name);
              X.attributes && this.setAttributes({
                html: x,
                element: X,
                intent: M,
                linkService: p
              });
              const n = [[X, -1, x]], V = y.div;
              if (V.append(x), y.viewport) {
                const R = `matrix(${y.viewport.transform.join(",")})`;
                V.style.transform = R;
              }
              M !== "richText" && V.setAttribute("class", "xfaLayer xfaFont");
              const S = [];
              for (; n.length > 0; ) {
                var o;
                const [R, J, u] = n.at(-1);
                if (J + 1 === R.children.length) {
                  n.pop();
                  continue;
                }
                const e = R.children[++n.at(-1)[1]];
                if (e === null)
                  continue;
                const {
                  name: m
                } = e;
                if (m === "#text") {
                  const b = document.createTextNode(e.value);
                  S.push(b), u.append(b);
                  continue;
                }
                let d;
                if (e != null && (o = e.attributes) !== null && o !== void 0 && o.xmlns ? d = document.createElementNS(e.attributes.xmlns, m) : d = document.createElement(m), u.append(d), e.attributes && this.setAttributes({
                  html: d,
                  element: e,
                  storage: h,
                  intent: M,
                  linkService: p
                }), e.children && e.children.length > 0)
                  n.push([e, -1, d]);
                else if (e.value) {
                  const b = document.createTextNode(e.value);
                  t.XfaText.shouldBuildText(m) && S.push(b), d.append(b);
                }
              }
              for (const R of V.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
                R.setAttribute("readOnly", !0);
              return {
                textDivs: S
              };
            }
            static update(y) {
              const h = `matrix(${y.viewport.transform.join(",")})`;
              y.div.style.transform = h, y.div.hidden = !1;
            }
          }
          c.XfaLayer = Z;
        },
        /* 155 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.TextLayerRenderTask = void 0, c.renderTextLayer = u;
          var t = i(1), Z = i(133);
          const W = 1e5, y = 30, h = 0.8, p = /* @__PURE__ */ new Map(), X = /^\s+$/g;
          function M(e, m) {
            const d = p.get(e);
            if (d)
              return d;
            m.save(), m.font = `${y}px ${e}`;
            const b = m.measureText("");
            let N = b.fontBoundingBoxAscent, G = Math.abs(b.fontBoundingBoxDescent);
            if (N) {
              m.restore();
              const j = N / (N + G);
              return p.set(e, j), j;
            }
            m.strokeStyle = "red", m.clearRect(0, 0, y, y), m.strokeText("g", 0, 0);
            let r = m.getImageData(0, 0, y, y).data;
            G = 0;
            for (let j = r.length - 1 - 3; j >= 0; j -= 4)
              if (r[j] > 0) {
                G = Math.ceil(j / 4 / y);
                break;
              }
            m.clearRect(0, 0, y, y), m.strokeText("A", 0, y), r = m.getImageData(0, 0, y, y).data, N = 0;
            for (let j = 0, D = r.length; j < D; j += 4)
              if (r[j] > 0) {
                N = y - Math.floor(j / 4 / y);
                break;
              }
            if (m.restore(), N) {
              const j = N / (N + G);
              return p.set(e, j), j;
            }
            return p.set(e, h), h;
          }
          function x(e, m, d, b) {
            const N = document.createElement("span"), G = e._enhanceTextSelection ? {
              angle: 0,
              canvasWidth: 0,
              hasText: m.str !== "",
              hasEOL: m.hasEOL,
              originalTransform: null,
              paddingBottom: 0,
              paddingLeft: 0,
              paddingRight: 0,
              paddingTop: 0,
              scale: 1,
              fontSize: 0
            } : {
              angle: 0,
              canvasWidth: 0,
              hasText: m.str !== "",
              hasEOL: m.hasEOL,
              fontSize: 0
            };
            e._textDivs.push(N);
            const r = t.Util.transform(e._viewport.transform, m.transform);
            let j = Math.atan2(r[1], r[0]);
            const D = d[m.fontName];
            D.vertical && (j += Math.PI / 2);
            const f = Math.hypot(r[2], r[3]), P = f * M(D.fontFamily, b);
            let B, A;
            j === 0 ? (B = r[4], A = r[5] - P) : (B = r[4] + P * Math.sin(j), A = r[5] - P * Math.cos(j)), N.style.left = `${B}px`, N.style.top = `${A}px`, N.style.fontSize = `${f}px`, N.style.fontFamily = D.fontFamily, G.fontSize = f, N.setAttribute("role", "presentation"), N.textContent = m.str, N.dir = m.dir, e._fontInspectorEnabled && (N.dataset.fontName = m.fontName), j !== 0 && (G.angle = j * (180 / Math.PI));
            let H = !1;
            if (m.str.length > 1 || e._enhanceTextSelection && X.test(m.str))
              H = !0;
            else if (m.str !== " " && m.transform[0] !== m.transform[3]) {
              const O = Math.abs(m.transform[0]), U = Math.abs(m.transform[3]);
              O !== U && Math.max(O, U) / Math.min(O, U) > 1.5 && (H = !0);
            }
            if (H && (D.vertical ? G.canvasWidth = m.height * e._viewport.scale : G.canvasWidth = m.width * e._viewport.scale), e._textDivProperties.set(N, G), e._textContentStream && e._layoutText(N), e._enhanceTextSelection && G.hasText) {
              let O = 1, U = 0;
              j !== 0 && (O = Math.cos(j), U = Math.sin(j));
              const k = (D.vertical ? m.height : m.width) * e._viewport.scale, q = f;
              let al, Ml;
              j !== 0 ? (al = [O, U, -U, O, B, A], Ml = t.Util.getAxialAlignedBoundingBox([0, 0, k, q], al)) : Ml = [B, A, B + k, A + q], e._bounds.push({
                left: Ml[0],
                top: Ml[1],
                right: Ml[2],
                bottom: Ml[3],
                div: N,
                size: [k, q],
                m: al
              });
            }
          }
          function n(e) {
            if (e._canceled)
              return;
            const m = e._textDivs, d = e._capability, b = m.length;
            if (b > W) {
              e._renderingDone = !0, d.resolve();
              return;
            }
            if (!e._textContentStream)
              for (let N = 0; N < b; N++)
                e._layoutText(m[N]);
            e._renderingDone = !0, d.resolve();
          }
          function V(e, m, d) {
            let b = 0;
            for (let N = 0; N < d; N++) {
              const G = e[m++];
              G > 0 && (b = b ? Math.min(G, b) : G);
            }
            return b;
          }
          function S(e) {
            const m = e._bounds, d = e._viewport, b = o(d.width, d.height, m);
            for (let N = 0; N < b.length; N++) {
              const G = m[N].div, r = e._textDivProperties.get(G);
              if (r.angle === 0) {
                r.paddingLeft = m[N].left - b[N].left, r.paddingTop = m[N].top - b[N].top, r.paddingRight = b[N].right - m[N].right, r.paddingBottom = b[N].bottom - m[N].bottom, e._textDivProperties.set(G, r);
                continue;
              }
              const j = b[N], D = m[N], f = D.m, P = f[0], B = f[1], A = [[0, 0], [0, D.size[1]], [D.size[0], 0], D.size], H = new Float64Array(64);
              for (let U = 0, k = A.length; U < k; U++) {
                const q = t.Util.applyTransform(A[U], f);
                H[U + 0] = P && (j.left - q[0]) / P, H[U + 4] = B && (j.top - q[1]) / B, H[U + 8] = P && (j.right - q[0]) / P, H[U + 12] = B && (j.bottom - q[1]) / B, H[U + 16] = B && (j.left - q[0]) / -B, H[U + 20] = P && (j.top - q[1]) / P, H[U + 24] = B && (j.right - q[0]) / -B, H[U + 28] = P && (j.bottom - q[1]) / P, H[U + 32] = P && (j.left - q[0]) / -P, H[U + 36] = B && (j.top - q[1]) / -B, H[U + 40] = P && (j.right - q[0]) / -P, H[U + 44] = B && (j.bottom - q[1]) / -B, H[U + 48] = B && (j.left - q[0]) / B, H[U + 52] = P && (j.top - q[1]) / -P, H[U + 56] = B && (j.right - q[0]) / B, H[U + 60] = P && (j.bottom - q[1]) / -P;
              }
              const O = 1 + Math.min(Math.abs(P), Math.abs(B));
              r.paddingLeft = V(H, 32, 16) / O, r.paddingTop = V(H, 48, 16) / O, r.paddingRight = V(H, 0, 16) / O, r.paddingBottom = V(H, 16, 16) / O, e._textDivProperties.set(G, r);
            }
          }
          function o(e, m, d) {
            const b = d.map(function(G, r) {
              return {
                x1: G.left,
                y1: G.top,
                x2: G.right,
                y2: G.bottom,
                index: r,
                x1New: void 0,
                x2New: void 0
              };
            });
            R(e, b);
            const N = new Array(d.length);
            for (const G of b) {
              const r = G.index;
              N[r] = {
                left: G.x1New,
                top: 0,
                right: G.x2New,
                bottom: 0
              };
            }
            d.map(function(G, r) {
              const j = N[r], D = b[r];
              D.x1 = G.top, D.y1 = e - j.right, D.x2 = G.bottom, D.y2 = e - j.left, D.index = r, D.x1New = void 0, D.x2New = void 0;
            }), R(m, b);
            for (const G of b) {
              const r = G.index;
              N[r].top = G.x1New, N[r].bottom = G.x2New;
            }
            return N;
          }
          function R(e, m) {
            m.sort(function(N, G) {
              return N.x1 - G.x1 || N.index - G.index;
            });
            const b = [{
              start: -1 / 0,
              end: 1 / 0,
              boundary: {
                x1: -1 / 0,
                y1: -1 / 0,
                x2: 0,
                y2: 1 / 0,
                index: -1,
                x1New: 0,
                x2New: 0
              }
            }];
            for (const N of m) {
              let G = 0;
              for (; G < b.length && b[G].end <= N.y1; )
                G++;
              let r = b.length - 1;
              for (; r >= 0 && b[r].start >= N.y2; )
                r--;
              let j, D, f, P, B = -1 / 0;
              for (f = G; f <= r; f++) {
                j = b[f], D = j.boundary;
                let O;
                D.x2 > N.x1 ? O = D.index > N.index ? D.x1New : N.x1 : D.x2New === void 0 ? O = (D.x2 + N.x1) / 2 : O = D.x2New, O > B && (B = O);
              }
              for (N.x1New = B, f = G; f <= r; f++)
                j = b[f], D = j.boundary, D.x2New === void 0 ? D.x2 > N.x1 ? D.index > N.index && (D.x2New = D.x2) : D.x2New = B : D.x2New > B && (D.x2New = Math.max(B, D.x2));
              const A = [];
              let H = null;
              for (f = G; f <= r; f++) {
                j = b[f], D = j.boundary;
                const O = D.x2 > N.x2 ? D : N;
                H === O ? A.at(-1).end = j.end : (A.push({
                  start: j.start,
                  end: j.end,
                  boundary: O
                }), H = O);
              }
              for (b[G].start < N.y1 && (A[0].start = N.y1, A.unshift({
                start: b[G].start,
                end: N.y1,
                boundary: b[G].boundary
              })), N.y2 < b[r].end && (A.at(-1).end = N.y2, A.push({
                start: N.y2,
                end: b[r].end,
                boundary: b[r].boundary
              })), f = G; f <= r; f++) {
                if (j = b[f], D = j.boundary, D.x2New !== void 0)
                  continue;
                let O = !1;
                for (P = G - 1; !O && P >= 0 && b[P].start >= D.y1; P--)
                  O = b[P].boundary === D;
                for (P = r + 1; !O && P < b.length && b[P].end <= D.y2; P++)
                  O = b[P].boundary === D;
                for (P = 0; !O && P < A.length; P++)
                  O = A[P].boundary === D;
                O || (D.x2New = B);
              }
              Array.prototype.splice.apply(b, [G, r - G + 1, ...A]);
            }
            for (const N of b) {
              const G = N.boundary;
              G.x2New === void 0 && (G.x2New = Math.max(e, G.x2));
            }
          }
          class J {
            constructor(m) {
              var d;
              let {
                textContent: b,
                textContentStream: N,
                container: G,
                viewport: r,
                textDivs: j,
                textContentItemsStr: D,
                enhanceTextSelection: f
              } = m;
              f && (0, Z.deprecated)("The `enhanceTextSelection` functionality will be removed in the future."), this._textContent = b, this._textContentStream = N, this._container = G, this._document = G.ownerDocument, this._viewport = r, this._textDivs = j || [], this._textContentItemsStr = D || [], this._enhanceTextSelection = !!f, this._fontInspectorEnabled = !!((d = globalThis.FontInspector) !== null && d !== void 0 && d.enabled), this._reader = null, this._layoutTextLastFontSize = null, this._layoutTextLastFontFamily = null, this._layoutTextCtx = null, this._textDivProperties = /* @__PURE__ */ new WeakMap(), this._renderingDone = !1, this._canceled = !1, this._capability = (0, t.createPromiseCapability)(), this._renderTimer = null, this._bounds = [], this._devicePixelRatio = globalThis.devicePixelRatio || 1, this._capability.promise.finally(() => {
                this._enhanceTextSelection || (this._textDivProperties = null), this._layoutTextCtx && (this._layoutTextCtx.canvas.width = 0, this._layoutTextCtx.canvas.height = 0, this._layoutTextCtx = null);
              }).catch(() => {
              });
            }
            get promise() {
              return this._capability.promise;
            }
            cancel() {
              this._canceled = !0, this._reader && (this._reader.cancel(new t.AbortException("TextLayer task cancelled.")).catch(() => {
              }), this._reader = null), this._renderTimer !== null && (clearTimeout(this._renderTimer), this._renderTimer = null), this._capability.reject(new Error("TextLayer task cancelled."));
            }
            _processItems(m, d) {
              for (let b = 0, N = m.length; b < N; b++) {
                if (m[b].str === void 0) {
                  if (m[b].type === "beginMarkedContentProps" || m[b].type === "beginMarkedContent") {
                    const G = this._container;
                    this._container = document.createElement("span"), this._container.classList.add("markedContent"), m[b].id !== null && this._container.setAttribute("id", `${m[b].id}`), G.append(this._container);
                  } else m[b].type === "endMarkedContent" && (this._container = this._container.parentNode);
                  continue;
                }
                this._textContentItemsStr.push(m[b].str), x(this, m[b], d, this._layoutTextCtx);
              }
            }
            _layoutText(m) {
              const d = this._textDivProperties.get(m);
              let b = "";
              if (d.canvasWidth !== 0 && d.hasText) {
                const {
                  fontFamily: N
                } = m.style, {
                  fontSize: G
                } = d;
                (G !== this._layoutTextLastFontSize || N !== this._layoutTextLastFontFamily) && (this._layoutTextCtx.font = `${G * this._devicePixelRatio}px ${N}`, this._layoutTextLastFontSize = G, this._layoutTextLastFontFamily = N);
                const {
                  width: r
                } = this._layoutTextCtx.measureText(m.textContent);
                if (r > 0) {
                  const j = this._devicePixelRatio * d.canvasWidth / r;
                  this._enhanceTextSelection && (d.scale = j), b = `scaleX(${j})`;
                }
              }
              if (d.angle !== 0 && (b = `rotate(${d.angle}deg) ${b}`), b.length > 0 && (this._enhanceTextSelection && (d.originalTransform = b), m.style.transform = b), d.hasText && this._container.append(m), d.hasEOL) {
                const N = document.createElement("br");
                N.setAttribute("role", "presentation"), this._container.append(N);
              }
            }
            _render() {
              let m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              const d = (0, t.createPromiseCapability)();
              let b = /* @__PURE__ */ Object.create(null);
              const N = this._document.createElement("canvas");
              if (N.height = N.width = y, this._layoutTextCtx = N.getContext("2d", {
                alpha: !1
              }), this._textContent) {
                const G = this._textContent.items, r = this._textContent.styles;
                this._processItems(G, r), d.resolve();
              } else if (this._textContentStream) {
                const G = () => {
                  this._reader.read().then((r) => {
                    let {
                      value: j,
                      done: D
                    } = r;
                    if (D) {
                      d.resolve();
                      return;
                    }
                    Object.assign(b, j.styles), this._processItems(j.items, b), G();
                  }, d.reject);
                };
                this._reader = this._textContentStream.getReader(), G();
              } else
                throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
              d.promise.then(() => {
                b = null, m ? this._renderTimer = setTimeout(() => {
                  n(this), this._renderTimer = null;
                }, m) : n(this);
              }, this._capability.reject);
            }
            expandTextDivs() {
              let m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
              if (!this._enhanceTextSelection || !this._renderingDone)
                return;
              this._bounds !== null && (S(this), this._bounds = null);
              const d = [], b = [];
              for (let N = 0, G = this._textDivs.length; N < G; N++) {
                const r = this._textDivs[N], j = this._textDivProperties.get(r);
                j.hasText && (m ? (d.length = 0, b.length = 0, j.originalTransform && d.push(j.originalTransform), j.paddingTop > 0 ? (b.push(`${j.paddingTop}px`), d.push(`translateY(${-j.paddingTop}px)`)) : b.push(0), j.paddingRight > 0 ? b.push(`${j.paddingRight / j.scale}px`) : b.push(0), j.paddingBottom > 0 ? b.push(`${j.paddingBottom}px`) : b.push(0), j.paddingLeft > 0 ? (b.push(`${j.paddingLeft / j.scale}px`), d.push(`translateX(${-j.paddingLeft / j.scale}px)`)) : b.push(0), r.style.padding = b.join(" "), d.length && (r.style.transform = d.join(" "))) : (r.style.padding = null, r.style.transform = j.originalTransform));
              }
            }
          }
          c.TextLayerRenderTask = J;
          function u(e) {
            const m = new J({
              textContent: e.textContent,
              textContentStream: e.textContentStream,
              container: e.container,
              viewport: e.viewport,
              textDivs: e.textDivs,
              textContentItemsStr: e.textContentItemsStr,
              enhanceTextSelection: e.enhanceTextSelection
            });
            return m._render(e.timeout), m;
          }
        },
        /* 156 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.SVGGraphics = void 0;
          var t = i(133), Z = i(1), W = i(3);
          let y = class {
            constructor() {
              (0, Z.unreachable)("Not implemented: SVGGraphics");
            }
          };
          c.SVGGraphics = y;
          {
            let o = function(d) {
              let b = [];
              const N = [];
              for (const G of d) {
                if (G.fn === "save") {
                  b.push({
                    fnId: 92,
                    fn: "group",
                    items: []
                  }), N.push(b), b = b.at(-1).items;
                  continue;
                }
                G.fn === "restore" ? b = N.pop() : b.push(G);
              }
              return b;
            }, R = function(d) {
              if (Number.isInteger(d))
                return d.toString();
              const b = d.toFixed(10);
              let N = b.length - 1;
              if (b[N] !== "0")
                return b;
              do
                N--;
              while (b[N] === "0");
              return b.substring(0, b[N] === "." ? N : N + 1);
            }, J = function(d) {
              if (d[4] === 0 && d[5] === 0) {
                if (d[1] === 0 && d[2] === 0)
                  return d[0] === 1 && d[3] === 1 ? "" : `scale(${R(d[0])} ${R(d[3])})`;
                if (d[0] === d[3] && d[1] === -d[2]) {
                  const b = Math.acos(d[0]) * 180 / Math.PI;
                  return `rotate(${R(b)})`;
                }
              } else if (d[0] === 1 && d[1] === 0 && d[2] === 0 && d[3] === 1)
                return `translate(${R(d[4])} ${R(d[5])})`;
              return `matrix(${R(d[0])} ${R(d[1])} ${R(d[2])} ${R(d[3])} ${R(d[4])} ${R(d[5])})`;
            };
            const h = {
              fontStyle: "normal",
              fontWeight: "normal",
              fillColor: "#000000"
            }, p = "http://www.w3.org/XML/1998/namespace", X = "http://www.w3.org/1999/xlink", M = ["butt", "round", "square"], x = ["miter", "round", "bevel"], n = function(d) {
              let b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", N = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
              if (URL.createObjectURL && typeof Blob < "u" && !N)
                return URL.createObjectURL(new Blob([d], {
                  type: b
                }));
              const G = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
              let r = `data:${b};base64,`;
              for (let j = 0, D = d.length; j < D; j += 3) {
                const f = d[j] & 255, P = d[j + 1] & 255, B = d[j + 2] & 255, A = f >> 2, H = (f & 3) << 4 | P >> 4, O = j + 1 < D ? (P & 15) << 2 | B >> 6 : 64, U = j + 2 < D ? B & 63 : 64;
                r += G[A] + G[H] + G[O] + G[U];
              }
              return r;
            }, V = function() {
              const d = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]), b = 12, N = new Int32Array(256);
              for (let B = 0; B < 256; B++) {
                let A = B;
                for (let H = 0; H < 8; H++)
                  A & 1 ? A = 3988292384 ^ A >> 1 & 2147483647 : A = A >> 1 & 2147483647;
                N[B] = A;
              }
              function G(B, A, H) {
                let O = -1;
                for (let U = A; U < H; U++) {
                  const k = (O ^ B[U]) & 255, q = N[k];
                  O = O >>> 8 ^ q;
                }
                return O ^ -1;
              }
              function r(B, A, H, O) {
                let U = O;
                const k = A.length;
                H[U] = k >> 24 & 255, H[U + 1] = k >> 16 & 255, H[U + 2] = k >> 8 & 255, H[U + 3] = k & 255, U += 4, H[U] = B.charCodeAt(0) & 255, H[U + 1] = B.charCodeAt(1) & 255, H[U + 2] = B.charCodeAt(2) & 255, H[U + 3] = B.charCodeAt(3) & 255, U += 4, H.set(A, U), U += A.length;
                const q = G(H, O + 4, U);
                H[U] = q >> 24 & 255, H[U + 1] = q >> 16 & 255, H[U + 2] = q >> 8 & 255, H[U + 3] = q & 255;
              }
              function j(B, A, H) {
                let O = 1, U = 0;
                for (let k = A; k < H; ++k)
                  O = (O + (B[k] & 255)) % 65521, U = (U + O) % 65521;
                return U << 16 | O;
              }
              function D(B) {
                if (!W.isNodeJS)
                  return f(B);
                try {
                  let A;
                  parseInt(process.versions.node) >= 8 ? A = B : A = Buffer.from(B);
                  const H = require$$7.deflateSync(A, {
                    level: 9
                  });
                  return H instanceof Uint8Array ? H : new Uint8Array(H);
                } catch (A) {
                  (0, Z.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + A);
                }
                return f(B);
              }
              function f(B) {
                let A = B.length;
                const H = 65535, O = Math.ceil(A / H), U = new Uint8Array(2 + A + O * 5 + 4);
                let k = 0;
                U[k++] = 120, U[k++] = 156;
                let q = 0;
                for (; A > H; )
                  U[k++] = 0, U[k++] = 255, U[k++] = 255, U[k++] = 0, U[k++] = 0, U.set(B.subarray(q, q + H), k), k += H, q += H, A -= H;
                U[k++] = 1, U[k++] = A & 255, U[k++] = A >> 8 & 255, U[k++] = ~A & 65535 & 255, U[k++] = (~A & 65535) >> 8 & 255, U.set(B.subarray(q), k), k += B.length - q;
                const al = j(B, 0, B.length);
                return U[k++] = al >> 24 & 255, U[k++] = al >> 16 & 255, U[k++] = al >> 8 & 255, U[k++] = al & 255, U;
              }
              function P(B, A, H, O) {
                const U = B.width, k = B.height;
                let q, al, Ml;
                const wl = B.data;
                switch (A) {
                  case Z.ImageKind.GRAYSCALE_1BPP:
                    al = 0, q = 1, Ml = U + 7 >> 3;
                    break;
                  case Z.ImageKind.RGB_24BPP:
                    al = 2, q = 8, Ml = U * 3;
                    break;
                  case Z.ImageKind.RGBA_32BPP:
                    al = 6, q = 8, Ml = U * 4;
                    break;
                  default:
                    throw new Error("invalid format");
                }
                const Q = new Uint8Array((1 + Ml) * k);
                let T = 0, w = 0;
                for (let C = 0; C < k; ++C)
                  Q[T++] = 0, Q.set(wl.subarray(w, w + Ml), T), w += Ml, T += Ml;
                if (A === Z.ImageKind.GRAYSCALE_1BPP && O) {
                  T = 0;
                  for (let C = 0; C < k; C++) {
                    T++;
                    for (let F = 0; F < Ml; F++)
                      Q[T++] ^= 255;
                  }
                }
                const g = new Uint8Array([U >> 24 & 255, U >> 16 & 255, U >> 8 & 255, U & 255, k >> 24 & 255, k >> 16 & 255, k >> 8 & 255, k & 255, q, al, 0, 0, 0]), K = D(Q), a = d.length + b * 3 + g.length + K.length, Y = new Uint8Array(a);
                let z = 0;
                return Y.set(d, z), z += d.length, r("IHDR", g, Y, z), z += b + g.length, r("IDATA", K, Y, z), z += b + K.length, r("IEND", new Uint8Array(0), Y, z), n(Y, "image/png", H);
              }
              return function(A, H, O) {
                const U = A.kind === void 0 ? Z.ImageKind.GRAYSCALE_1BPP : A.kind;
                return P(A, U, H, O);
              };
            }();
            class S {
              constructor() {
                this.fontSizeScale = 1, this.fontWeight = h.fontWeight, this.fontSize = 0, this.textMatrix = Z.IDENTITY_MATRIX, this.fontMatrix = Z.FONT_IDENTITY_MATRIX, this.leading = 0, this.textRenderingMode = Z.TextRenderingMode.FILL, this.textMatrixScale = 1, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRise = 0, this.fillColor = h.fillColor, this.strokeColor = "#000000", this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.lineJoin = "", this.lineCap = "", this.miterLimit = 0, this.dashArray = [], this.dashPhase = 0, this.dependencies = [], this.activeClipUrl = null, this.clipGroup = null, this.maskId = "";
              }
              clone() {
                return Object.create(this);
              }
              setCurrentPoint(b, N) {
                this.x = b, this.y = N;
              }
            }
            let u = 0, e = 0, m = 0;
            c.SVGGraphics = y = class {
              constructor(d, b) {
                let N = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
                (0, t.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future."), this.svgFactory = new t.DOMSVGFactory(), this.current = new S(), this.transformMatrix = Z.IDENTITY_MATRIX, this.transformStack = [], this.extraStack = [], this.commonObjs = d, this.objs = b, this.pendingClip = null, this.pendingEOFill = !1, this.embedFonts = !1, this.embeddedFonts = /* @__PURE__ */ Object.create(null), this.cssStyle = null, this.forceDataSchema = !!N, this._operatorIdMapping = [];
                for (const G in Z.OPS)
                  this._operatorIdMapping[Z.OPS[G]] = G;
              }
              save() {
                this.transformStack.push(this.transformMatrix);
                const d = this.current;
                this.extraStack.push(d), this.current = d.clone();
              }
              restore() {
                this.transformMatrix = this.transformStack.pop(), this.current = this.extraStack.pop(), this.pendingClip = null, this.tgrp = null;
              }
              group(d) {
                this.save(), this.executeOpTree(d), this.restore();
              }
              loadDependencies(d) {
                const b = d.fnArray, N = d.argsArray;
                for (let G = 0, r = b.length; G < r; G++)
                  if (b[G] === Z.OPS.dependency)
                    for (const j of N[G]) {
                      const D = j.startsWith("g_") ? this.commonObjs : this.objs, f = new Promise((P) => {
                        D.get(j, P);
                      });
                      this.current.dependencies.push(f);
                    }
                return Promise.all(this.current.dependencies);
              }
              transform(d, b, N, G, r, j) {
                const D = [d, b, N, G, r, j];
                this.transformMatrix = Z.Util.transform(this.transformMatrix, D), this.tgrp = null;
              }
              getSVG(d, b) {
                this.viewport = b;
                const N = this._initialize(b);
                return this.loadDependencies(d).then(() => (this.transformMatrix = Z.IDENTITY_MATRIX, this.executeOpTree(this.convertOpList(d)), N));
              }
              convertOpList(d) {
                const b = this._operatorIdMapping, N = d.argsArray, G = d.fnArray, r = [];
                for (let j = 0, D = G.length; j < D; j++) {
                  const f = G[j];
                  r.push({
                    fnId: f,
                    fn: b[f],
                    args: N[j]
                  });
                }
                return o(r);
              }
              executeOpTree(d) {
                for (const b of d) {
                  const N = b.fn, G = b.fnId, r = b.args;
                  switch (G | 0) {
                    case Z.OPS.beginText:
                      this.beginText();
                      break;
                    case Z.OPS.dependency:
                      break;
                    case Z.OPS.setLeading:
                      this.setLeading(r);
                      break;
                    case Z.OPS.setLeadingMoveText:
                      this.setLeadingMoveText(r[0], r[1]);
                      break;
                    case Z.OPS.setFont:
                      this.setFont(r);
                      break;
                    case Z.OPS.showText:
                      this.showText(r[0]);
                      break;
                    case Z.OPS.showSpacedText:
                      this.showText(r[0]);
                      break;
                    case Z.OPS.endText:
                      this.endText();
                      break;
                    case Z.OPS.moveText:
                      this.moveText(r[0], r[1]);
                      break;
                    case Z.OPS.setCharSpacing:
                      this.setCharSpacing(r[0]);
                      break;
                    case Z.OPS.setWordSpacing:
                      this.setWordSpacing(r[0]);
                      break;
                    case Z.OPS.setHScale:
                      this.setHScale(r[0]);
                      break;
                    case Z.OPS.setTextMatrix:
                      this.setTextMatrix(r[0], r[1], r[2], r[3], r[4], r[5]);
                      break;
                    case Z.OPS.setTextRise:
                      this.setTextRise(r[0]);
                      break;
                    case Z.OPS.setTextRenderingMode:
                      this.setTextRenderingMode(r[0]);
                      break;
                    case Z.OPS.setLineWidth:
                      this.setLineWidth(r[0]);
                      break;
                    case Z.OPS.setLineJoin:
                      this.setLineJoin(r[0]);
                      break;
                    case Z.OPS.setLineCap:
                      this.setLineCap(r[0]);
                      break;
                    case Z.OPS.setMiterLimit:
                      this.setMiterLimit(r[0]);
                      break;
                    case Z.OPS.setFillRGBColor:
                      this.setFillRGBColor(r[0], r[1], r[2]);
                      break;
                    case Z.OPS.setStrokeRGBColor:
                      this.setStrokeRGBColor(r[0], r[1], r[2]);
                      break;
                    case Z.OPS.setStrokeColorN:
                      this.setStrokeColorN(r);
                      break;
                    case Z.OPS.setFillColorN:
                      this.setFillColorN(r);
                      break;
                    case Z.OPS.shadingFill:
                      this.shadingFill(r[0]);
                      break;
                    case Z.OPS.setDash:
                      this.setDash(r[0], r[1]);
                      break;
                    case Z.OPS.setRenderingIntent:
                      this.setRenderingIntent(r[0]);
                      break;
                    case Z.OPS.setFlatness:
                      this.setFlatness(r[0]);
                      break;
                    case Z.OPS.setGState:
                      this.setGState(r[0]);
                      break;
                    case Z.OPS.fill:
                      this.fill();
                      break;
                    case Z.OPS.eoFill:
                      this.eoFill();
                      break;
                    case Z.OPS.stroke:
                      this.stroke();
                      break;
                    case Z.OPS.fillStroke:
                      this.fillStroke();
                      break;
                    case Z.OPS.eoFillStroke:
                      this.eoFillStroke();
                      break;
                    case Z.OPS.clip:
                      this.clip("nonzero");
                      break;
                    case Z.OPS.eoClip:
                      this.clip("evenodd");
                      break;
                    case Z.OPS.paintSolidColorImageMask:
                      this.paintSolidColorImageMask();
                      break;
                    case Z.OPS.paintImageXObject:
                      this.paintImageXObject(r[0]);
                      break;
                    case Z.OPS.paintInlineImageXObject:
                      this.paintInlineImageXObject(r[0]);
                      break;
                    case Z.OPS.paintImageMaskXObject:
                      this.paintImageMaskXObject(r[0]);
                      break;
                    case Z.OPS.paintFormXObjectBegin:
                      this.paintFormXObjectBegin(r[0], r[1]);
                      break;
                    case Z.OPS.paintFormXObjectEnd:
                      this.paintFormXObjectEnd();
                      break;
                    case Z.OPS.closePath:
                      this.closePath();
                      break;
                    case Z.OPS.closeStroke:
                      this.closeStroke();
                      break;
                    case Z.OPS.closeFillStroke:
                      this.closeFillStroke();
                      break;
                    case Z.OPS.closeEOFillStroke:
                      this.closeEOFillStroke();
                      break;
                    case Z.OPS.nextLine:
                      this.nextLine();
                      break;
                    case Z.OPS.transform:
                      this.transform(r[0], r[1], r[2], r[3], r[4], r[5]);
                      break;
                    case Z.OPS.constructPath:
                      this.constructPath(r[0], r[1]);
                      break;
                    case Z.OPS.endPath:
                      this.endPath();
                      break;
                    case 92:
                      this.group(b.items);
                      break;
                    default:
                      (0, Z.warn)(`Unimplemented operator ${N}`);
                      break;
                  }
                }
              }
              setWordSpacing(d) {
                this.current.wordSpacing = d;
              }
              setCharSpacing(d) {
                this.current.charSpacing = d;
              }
              nextLine() {
                this.moveText(0, this.current.leading);
              }
              setTextMatrix(d, b, N, G, r, j) {
                const D = this.current;
                D.textMatrix = D.lineMatrix = [d, b, N, G, r, j], D.textMatrixScale = Math.hypot(d, b), D.x = D.lineX = 0, D.y = D.lineY = 0, D.xcoords = [], D.ycoords = [], D.tspan = this.svgFactory.createElement("svg:tspan"), D.tspan.setAttributeNS(null, "font-family", D.fontFamily), D.tspan.setAttributeNS(null, "font-size", `${R(D.fontSize)}px`), D.tspan.setAttributeNS(null, "y", R(-D.y)), D.txtElement = this.svgFactory.createElement("svg:text"), D.txtElement.append(D.tspan);
              }
              beginText() {
                const d = this.current;
                d.x = d.lineX = 0, d.y = d.lineY = 0, d.textMatrix = Z.IDENTITY_MATRIX, d.lineMatrix = Z.IDENTITY_MATRIX, d.textMatrixScale = 1, d.tspan = this.svgFactory.createElement("svg:tspan"), d.txtElement = this.svgFactory.createElement("svg:text"), d.txtgrp = this.svgFactory.createElement("svg:g"), d.xcoords = [], d.ycoords = [];
              }
              moveText(d, b) {
                const N = this.current;
                N.x = N.lineX += d, N.y = N.lineY += b, N.xcoords = [], N.ycoords = [], N.tspan = this.svgFactory.createElement("svg:tspan"), N.tspan.setAttributeNS(null, "font-family", N.fontFamily), N.tspan.setAttributeNS(null, "font-size", `${R(N.fontSize)}px`), N.tspan.setAttributeNS(null, "y", R(-N.y));
              }
              showText(d) {
                const b = this.current, N = b.font, G = b.fontSize;
                if (G === 0)
                  return;
                const r = b.fontSizeScale, j = b.charSpacing, D = b.wordSpacing, f = b.fontDirection, P = b.textHScale * f, B = N.vertical, A = B ? 1 : -1, H = N.defaultVMetrics, O = G * b.fontMatrix[0];
                let U = 0;
                for (const al of d) {
                  if (al === null) {
                    U += f * D;
                    continue;
                  } else if (typeof al == "number") {
                    U += A * al * G / 1e3;
                    continue;
                  }
                  const Ml = (al.isSpace ? D : 0) + j, wl = al.fontChar;
                  let Q, T, w = al.width;
                  if (B) {
                    let K;
                    const a = al.vmetric || H;
                    K = al.vmetric ? a[1] : w * 0.5, K = -K * O;
                    const Y = a[2] * O;
                    w = a ? -a[0] : w, Q = K / r, T = (U + Y) / r;
                  } else
                    Q = U / r, T = 0;
                  (al.isInFont || N.missingFile) && (b.xcoords.push(b.x + Q), B && b.ycoords.push(-b.y + T), b.tspan.textContent += wl);
                  let g;
                  B ? g = w * O - Ml * f : g = w * O + Ml * f, U += g;
                }
                b.tspan.setAttributeNS(null, "x", b.xcoords.map(R).join(" ")), B ? b.tspan.setAttributeNS(null, "y", b.ycoords.map(R).join(" ")) : b.tspan.setAttributeNS(null, "y", R(-b.y)), B ? b.y -= U : b.x += U * P, b.tspan.setAttributeNS(null, "font-family", b.fontFamily), b.tspan.setAttributeNS(null, "font-size", `${R(b.fontSize)}px`), b.fontStyle !== h.fontStyle && b.tspan.setAttributeNS(null, "font-style", b.fontStyle), b.fontWeight !== h.fontWeight && b.tspan.setAttributeNS(null, "font-weight", b.fontWeight);
                const k = b.textRenderingMode & Z.TextRenderingMode.FILL_STROKE_MASK;
                if (k === Z.TextRenderingMode.FILL || k === Z.TextRenderingMode.FILL_STROKE ? (b.fillColor !== h.fillColor && b.tspan.setAttributeNS(null, "fill", b.fillColor), b.fillAlpha < 1 && b.tspan.setAttributeNS(null, "fill-opacity", b.fillAlpha)) : b.textRenderingMode === Z.TextRenderingMode.ADD_TO_PATH ? b.tspan.setAttributeNS(null, "fill", "transparent") : b.tspan.setAttributeNS(null, "fill", "none"), k === Z.TextRenderingMode.STROKE || k === Z.TextRenderingMode.FILL_STROKE) {
                  const al = 1 / (b.textMatrixScale || 1);
                  this._setStrokeAttributes(b.tspan, al);
                }
                let q = b.textMatrix;
                b.textRise !== 0 && (q = q.slice(), q[5] += b.textRise), b.txtElement.setAttributeNS(null, "transform", `${J(q)} scale(${R(P)}, -1)`), b.txtElement.setAttributeNS(p, "xml:space", "preserve"), b.txtElement.append(b.tspan), b.txtgrp.append(b.txtElement), this._ensureTransformGroup().append(b.txtElement);
              }
              setLeadingMoveText(d, b) {
                this.setLeading(-b), this.moveText(d, b);
              }
              addFontStyle(d) {
                if (!d.data)
                  throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
                this.cssStyle || (this.cssStyle = this.svgFactory.createElement("svg:style"), this.cssStyle.setAttributeNS(null, "type", "text/css"), this.defs.append(this.cssStyle));
                const b = n(d.data, d.mimetype, this.forceDataSchema);
                this.cssStyle.textContent += `@font-face { font-family: "${d.loadedName}"; src: url(${b}); }
`;
              }
              setFont(d) {
                const b = this.current, N = this.commonObjs.get(d[0]);
                let G = d[1];
                b.font = N, this.embedFonts && !N.missingFile && !this.embeddedFonts[N.loadedName] && (this.addFontStyle(N), this.embeddedFonts[N.loadedName] = N), b.fontMatrix = N.fontMatrix || Z.FONT_IDENTITY_MATRIX;
                let r = "normal";
                N.black ? r = "900" : N.bold && (r = "bold");
                const j = N.italic ? "italic" : "normal";
                G < 0 ? (G = -G, b.fontDirection = -1) : b.fontDirection = 1, b.fontSize = G, b.fontFamily = N.loadedName, b.fontWeight = r, b.fontStyle = j, b.tspan = this.svgFactory.createElement("svg:tspan"), b.tspan.setAttributeNS(null, "y", R(-b.y)), b.xcoords = [], b.ycoords = [];
              }
              endText() {
                var d;
                const b = this.current;
                b.textRenderingMode & Z.TextRenderingMode.ADD_TO_PATH_FLAG && (d = b.txtElement) !== null && d !== void 0 && d.hasChildNodes() && (b.element = b.txtElement, this.clip("nonzero"), this.endPath());
              }
              setLineWidth(d) {
                d > 0 && (this.current.lineWidth = d);
              }
              setLineCap(d) {
                this.current.lineCap = M[d];
              }
              setLineJoin(d) {
                this.current.lineJoin = x[d];
              }
              setMiterLimit(d) {
                this.current.miterLimit = d;
              }
              setStrokeAlpha(d) {
                this.current.strokeAlpha = d;
              }
              setStrokeRGBColor(d, b, N) {
                this.current.strokeColor = Z.Util.makeHexColor(d, b, N);
              }
              setFillAlpha(d) {
                this.current.fillAlpha = d;
              }
              setFillRGBColor(d, b, N) {
                this.current.fillColor = Z.Util.makeHexColor(d, b, N), this.current.tspan = this.svgFactory.createElement("svg:tspan"), this.current.xcoords = [], this.current.ycoords = [];
              }
              setStrokeColorN(d) {
                this.current.strokeColor = this._makeColorN_Pattern(d);
              }
              setFillColorN(d) {
                this.current.fillColor = this._makeColorN_Pattern(d);
              }
              shadingFill(d) {
                const b = this.viewport.width, N = this.viewport.height, G = Z.Util.inverseTransform(this.transformMatrix), r = Z.Util.applyTransform([0, 0], G), j = Z.Util.applyTransform([0, N], G), D = Z.Util.applyTransform([b, 0], G), f = Z.Util.applyTransform([b, N], G), P = Math.min(r[0], j[0], D[0], f[0]), B = Math.min(r[1], j[1], D[1], f[1]), A = Math.max(r[0], j[0], D[0], f[0]), H = Math.max(r[1], j[1], D[1], f[1]), O = this.svgFactory.createElement("svg:rect");
                O.setAttributeNS(null, "x", P), O.setAttributeNS(null, "y", B), O.setAttributeNS(null, "width", A - P), O.setAttributeNS(null, "height", H - B), O.setAttributeNS(null, "fill", this._makeShadingPattern(d)), this.current.fillAlpha < 1 && O.setAttributeNS(null, "fill-opacity", this.current.fillAlpha), this._ensureTransformGroup().append(O);
              }
              _makeColorN_Pattern(d) {
                return d[0] === "TilingPattern" ? this._makeTilingPattern(d) : this._makeShadingPattern(d);
              }
              _makeTilingPattern(d) {
                const b = d[1], N = d[2], G = d[3] || Z.IDENTITY_MATRIX, [r, j, D, f] = d[4], P = d[5], B = d[6], A = d[7], H = `shading${m++}`, [O, U, k, q] = Z.Util.normalizeRect([...Z.Util.applyTransform([r, j], G), ...Z.Util.applyTransform([D, f], G)]), [al, Ml] = Z.Util.singularValueDecompose2dScale(G), wl = P * al, Q = B * Ml, T = this.svgFactory.createElement("svg:pattern");
                T.setAttributeNS(null, "id", H), T.setAttributeNS(null, "patternUnits", "userSpaceOnUse"), T.setAttributeNS(null, "width", wl), T.setAttributeNS(null, "height", Q), T.setAttributeNS(null, "x", `${O}`), T.setAttributeNS(null, "y", `${U}`);
                const w = this.svg, g = this.transformMatrix, K = this.current.fillColor, a = this.current.strokeColor, Y = this.svgFactory.create(k - O, q - U);
                if (this.svg = Y, this.transformMatrix = G, A === 2) {
                  const z = Z.Util.makeHexColor(...b);
                  this.current.fillColor = z, this.current.strokeColor = z;
                }
                return this.executeOpTree(this.convertOpList(N)), this.svg = w, this.transformMatrix = g, this.current.fillColor = K, this.current.strokeColor = a, T.append(Y.childNodes[0]), this.defs.append(T), `url(#${H})`;
              }
              _makeShadingPattern(d) {
                switch (typeof d == "string" && (d = this.objs.get(d)), d[0]) {
                  case "RadialAxial":
                    const b = `shading${m++}`, N = d[3];
                    let G;
                    switch (d[1]) {
                      case "axial":
                        const r = d[4], j = d[5];
                        G = this.svgFactory.createElement("svg:linearGradient"), G.setAttributeNS(null, "id", b), G.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), G.setAttributeNS(null, "x1", r[0]), G.setAttributeNS(null, "y1", r[1]), G.setAttributeNS(null, "x2", j[0]), G.setAttributeNS(null, "y2", j[1]);
                        break;
                      case "radial":
                        const D = d[4], f = d[5], P = d[6], B = d[7];
                        G = this.svgFactory.createElement("svg:radialGradient"), G.setAttributeNS(null, "id", b), G.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), G.setAttributeNS(null, "cx", f[0]), G.setAttributeNS(null, "cy", f[1]), G.setAttributeNS(null, "r", B), G.setAttributeNS(null, "fx", D[0]), G.setAttributeNS(null, "fy", D[1]), G.setAttributeNS(null, "fr", P);
                        break;
                      default:
                        throw new Error(`Unknown RadialAxial type: ${d[1]}`);
                    }
                    for (const r of N) {
                      const j = this.svgFactory.createElement("svg:stop");
                      j.setAttributeNS(null, "offset", r[0]), j.setAttributeNS(null, "stop-color", r[1]), G.append(j);
                    }
                    return this.defs.append(G), `url(#${b})`;
                  case "Mesh":
                    return (0, Z.warn)("Unimplemented pattern Mesh"), null;
                  case "Dummy":
                    return "hotpink";
                  default:
                    throw new Error(`Unknown IR type: ${d[0]}`);
                }
              }
              setDash(d, b) {
                this.current.dashArray = d, this.current.dashPhase = b;
              }
              constructPath(d, b) {
                const N = this.current;
                let G = N.x, r = N.y, j = [], D = 0;
                for (const f of d)
                  switch (f | 0) {
                    case Z.OPS.rectangle:
                      G = b[D++], r = b[D++];
                      const P = b[D++], B = b[D++], A = G + P, H = r + B;
                      j.push("M", R(G), R(r), "L", R(A), R(r), "L", R(A), R(H), "L", R(G), R(H), "Z");
                      break;
                    case Z.OPS.moveTo:
                      G = b[D++], r = b[D++], j.push("M", R(G), R(r));
                      break;
                    case Z.OPS.lineTo:
                      G = b[D++], r = b[D++], j.push("L", R(G), R(r));
                      break;
                    case Z.OPS.curveTo:
                      G = b[D + 4], r = b[D + 5], j.push("C", R(b[D]), R(b[D + 1]), R(b[D + 2]), R(b[D + 3]), R(G), R(r)), D += 6;
                      break;
                    case Z.OPS.curveTo2:
                      j.push("C", R(G), R(r), R(b[D]), R(b[D + 1]), R(b[D + 2]), R(b[D + 3])), G = b[D + 2], r = b[D + 3], D += 4;
                      break;
                    case Z.OPS.curveTo3:
                      G = b[D + 2], r = b[D + 3], j.push("C", R(b[D]), R(b[D + 1]), R(G), R(r), R(G), R(r)), D += 4;
                      break;
                    case Z.OPS.closePath:
                      j.push("Z");
                      break;
                  }
                j = j.join(" "), N.path && d.length > 0 && d[0] !== Z.OPS.rectangle && d[0] !== Z.OPS.moveTo ? j = N.path.getAttributeNS(null, "d") + j : (N.path = this.svgFactory.createElement("svg:path"), this._ensureTransformGroup().append(N.path)), N.path.setAttributeNS(null, "d", j), N.path.setAttributeNS(null, "fill", "none"), N.element = N.path, N.setCurrentPoint(G, r);
              }
              endPath() {
                const d = this.current;
                if (d.path = null, !this.pendingClip)
                  return;
                if (!d.element) {
                  this.pendingClip = null;
                  return;
                }
                const b = `clippath${u++}`, N = this.svgFactory.createElement("svg:clipPath");
                N.setAttributeNS(null, "id", b), N.setAttributeNS(null, "transform", J(this.transformMatrix));
                const G = d.element.cloneNode(!0);
                if (this.pendingClip === "evenodd" ? G.setAttributeNS(null, "clip-rule", "evenodd") : G.setAttributeNS(null, "clip-rule", "nonzero"), this.pendingClip = null, N.append(G), this.defs.append(N), d.activeClipUrl) {
                  d.clipGroup = null;
                  for (const r of this.extraStack)
                    r.clipGroup = null;
                  N.setAttributeNS(null, "clip-path", d.activeClipUrl);
                }
                d.activeClipUrl = `url(#${b})`, this.tgrp = null;
              }
              clip(d) {
                this.pendingClip = d;
              }
              closePath() {
                const d = this.current;
                if (d.path) {
                  const b = `${d.path.getAttributeNS(null, "d")}Z`;
                  d.path.setAttributeNS(null, "d", b);
                }
              }
              setLeading(d) {
                this.current.leading = -d;
              }
              setTextRise(d) {
                this.current.textRise = d;
              }
              setTextRenderingMode(d) {
                this.current.textRenderingMode = d;
              }
              setHScale(d) {
                this.current.textHScale = d / 100;
              }
              setRenderingIntent(d) {
              }
              setFlatness(d) {
              }
              setGState(d) {
                for (const [b, N] of d)
                  switch (b) {
                    case "LW":
                      this.setLineWidth(N);
                      break;
                    case "LC":
                      this.setLineCap(N);
                      break;
                    case "LJ":
                      this.setLineJoin(N);
                      break;
                    case "ML":
                      this.setMiterLimit(N);
                      break;
                    case "D":
                      this.setDash(N[0], N[1]);
                      break;
                    case "RI":
                      this.setRenderingIntent(N);
                      break;
                    case "FL":
                      this.setFlatness(N);
                      break;
                    case "Font":
                      this.setFont(N);
                      break;
                    case "CA":
                      this.setStrokeAlpha(N);
                      break;
                    case "ca":
                      this.setFillAlpha(N);
                      break;
                    default:
                      (0, Z.warn)(`Unimplemented graphic state operator ${b}`);
                      break;
                  }
              }
              fill() {
                const d = this.current;
                d.element && (d.element.setAttributeNS(null, "fill", d.fillColor), d.element.setAttributeNS(null, "fill-opacity", d.fillAlpha), this.endPath());
              }
              stroke() {
                const d = this.current;
                d.element && (this._setStrokeAttributes(d.element), d.element.setAttributeNS(null, "fill", "none"), this.endPath());
              }
              _setStrokeAttributes(d) {
                let b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
                const N = this.current;
                let G = N.dashArray;
                b !== 1 && G.length > 0 && (G = G.map(function(r) {
                  return b * r;
                })), d.setAttributeNS(null, "stroke", N.strokeColor), d.setAttributeNS(null, "stroke-opacity", N.strokeAlpha), d.setAttributeNS(null, "stroke-miterlimit", R(N.miterLimit)), d.setAttributeNS(null, "stroke-linecap", N.lineCap), d.setAttributeNS(null, "stroke-linejoin", N.lineJoin), d.setAttributeNS(null, "stroke-width", R(b * N.lineWidth) + "px"), d.setAttributeNS(null, "stroke-dasharray", G.map(R).join(" ")), d.setAttributeNS(null, "stroke-dashoffset", R(b * N.dashPhase) + "px");
              }
              eoFill() {
                this.current.element && this.current.element.setAttributeNS(null, "fill-rule", "evenodd"), this.fill();
              }
              fillStroke() {
                this.stroke(), this.fill();
              }
              eoFillStroke() {
                this.current.element && this.current.element.setAttributeNS(null, "fill-rule", "evenodd"), this.fillStroke();
              }
              closeStroke() {
                this.closePath(), this.stroke();
              }
              closeFillStroke() {
                this.closePath(), this.fillStroke();
              }
              closeEOFillStroke() {
                this.closePath(), this.eoFillStroke();
              }
              paintSolidColorImageMask() {
                const d = this.svgFactory.createElement("svg:rect");
                d.setAttributeNS(null, "x", "0"), d.setAttributeNS(null, "y", "0"), d.setAttributeNS(null, "width", "1px"), d.setAttributeNS(null, "height", "1px"), d.setAttributeNS(null, "fill", this.current.fillColor), this._ensureTransformGroup().append(d);
              }
              paintImageXObject(d) {
                const b = d.startsWith("g_") ? this.commonObjs.get(d) : this.objs.get(d);
                if (!b) {
                  (0, Z.warn)(`Dependent image with object ID ${d} is not ready yet`);
                  return;
                }
                this.paintInlineImageXObject(b);
              }
              paintInlineImageXObject(d, b) {
                const N = d.width, G = d.height, r = V(d, this.forceDataSchema, !!b), j = this.svgFactory.createElement("svg:rect");
                j.setAttributeNS(null, "x", "0"), j.setAttributeNS(null, "y", "0"), j.setAttributeNS(null, "width", R(N)), j.setAttributeNS(null, "height", R(G)), this.current.element = j, this.clip("nonzero");
                const D = this.svgFactory.createElement("svg:image");
                D.setAttributeNS(X, "xlink:href", r), D.setAttributeNS(null, "x", "0"), D.setAttributeNS(null, "y", R(-G)), D.setAttributeNS(null, "width", R(N) + "px"), D.setAttributeNS(null, "height", R(G) + "px"), D.setAttributeNS(null, "transform", `scale(${R(1 / N)} ${R(-1 / G)})`), b ? b.append(D) : this._ensureTransformGroup().append(D);
              }
              paintImageMaskXObject(d) {
                const b = this.current, N = d.width, G = d.height, r = b.fillColor;
                b.maskId = `mask${e++}`;
                const j = this.svgFactory.createElement("svg:mask");
                j.setAttributeNS(null, "id", b.maskId);
                const D = this.svgFactory.createElement("svg:rect");
                D.setAttributeNS(null, "x", "0"), D.setAttributeNS(null, "y", "0"), D.setAttributeNS(null, "width", R(N)), D.setAttributeNS(null, "height", R(G)), D.setAttributeNS(null, "fill", r), D.setAttributeNS(null, "mask", `url(#${b.maskId})`), this.defs.append(j), this._ensureTransformGroup().append(D), this.paintInlineImageXObject(d, j);
              }
              paintFormXObjectBegin(d, b) {
                if (Array.isArray(d) && d.length === 6 && this.transform(d[0], d[1], d[2], d[3], d[4], d[5]), b) {
                  const N = b[2] - b[0], G = b[3] - b[1], r = this.svgFactory.createElement("svg:rect");
                  r.setAttributeNS(null, "x", b[0]), r.setAttributeNS(null, "y", b[1]), r.setAttributeNS(null, "width", R(N)), r.setAttributeNS(null, "height", R(G)), this.current.element = r, this.clip("nonzero"), this.endPath();
                }
              }
              paintFormXObjectEnd() {
              }
              _initialize(d) {
                const b = this.svgFactory.create(d.width, d.height), N = this.svgFactory.createElement("svg:defs");
                b.append(N), this.defs = N;
                const G = this.svgFactory.createElement("svg:g");
                return G.setAttributeNS(null, "transform", J(d.transform)), b.append(G), this.svg = G, b;
              }
              _ensureClipGroup() {
                if (!this.current.clipGroup) {
                  const d = this.svgFactory.createElement("svg:g");
                  d.setAttributeNS(null, "clip-path", this.current.activeClipUrl), this.svg.append(d), this.current.clipGroup = d;
                }
                return this.current.clipGroup;
              }
              _ensureTransformGroup() {
                return this.tgrp || (this.tgrp = this.svgFactory.createElement("svg:g"), this.tgrp.setAttributeNS(null, "transform", J(this.transformMatrix)), this.current.activeClipUrl ? this._ensureClipGroup().append(this.tgrp) : this.svg.append(this.tgrp)), this.tgrp;
              }
            };
          }
        },
        /* 157 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.PDFNodeStream = void 0;
          var t = i(1), Z = i(158);
          const W = require$$7, y = require$$7, h = require$$7, p = require$$7, X = /^file:\/\/\/[a-zA-Z]:\//;
          function M(e) {
            const m = p.parse(e);
            return m.protocol === "file:" || m.host ? m : /^[a-z]:[/\\]/i.test(e) ? p.parse(`file:///${e}`) : (m.host || (m.protocol = "file:"), m);
          }
          class x {
            constructor(m) {
              this.source = m, this.url = M(m.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && m.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            get _progressiveDataLength() {
              var m, d;
              return (m = (d = this._fullRequestReader) === null || d === void 0 ? void 0 : d._loaded) !== null && m !== void 0 ? m : 0;
            }
            getFullReader() {
              return (0, t.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new J(this) : new o(this), this._fullRequestReader;
            }
            getRangeReader(m, d) {
              if (d <= this._progressiveDataLength)
                return null;
              const b = this.isFsUrl ? new u(this, m, d) : new R(this, m, d);
              return this._rangeRequestReaders.push(b), b;
            }
            cancelAllRequests(m) {
              this._fullRequestReader && this._fullRequestReader.cancel(m);
              for (const d of this._rangeRequestReaders.slice(0))
                d.cancel(m);
            }
          }
          c.PDFNodeStream = x;
          class n {
            constructor(m) {
              this._url = m.url, this._done = !1, this._storedError = null, this.onProgress = null;
              const d = m.source;
              this._contentLength = d.length, this._loaded = 0, this._filename = null, this._disableRange = d.disableRange || !1, this._rangeChunkSize = d.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !d.disableStream, this._isRangeSupported = !d.disableRange, this._readableStream = null, this._readCapability = (0, t.createPromiseCapability)(), this._headersCapability = (0, t.createPromiseCapability)();
            }
            get headersReady() {
              return this._headersCapability.promise;
            }
            get filename() {
              return this._filename;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              if (await this._readCapability.promise, this._done)
                return {
                  value: void 0,
                  done: !0
                };
              if (this._storedError)
                throw this._storedError;
              const m = this._readableStream.read();
              return m === null ? (this._readCapability = (0, t.createPromiseCapability)(), this.read()) : (this._loaded += m.length, this.onProgress && this.onProgress({
                loaded: this._loaded,
                total: this._contentLength
              }), {
                value: new Uint8Array(m).buffer,
                done: !1
              });
            }
            cancel(m) {
              if (!this._readableStream) {
                this._error(m);
                return;
              }
              this._readableStream.destroy(m);
            }
            _error(m) {
              this._storedError = m, this._readCapability.resolve();
            }
            _setReadableStream(m) {
              this._readableStream = m, m.on("readable", () => {
                this._readCapability.resolve();
              }), m.on("end", () => {
                m.destroy(), this._done = !0, this._readCapability.resolve();
              }), m.on("error", (d) => {
                this._error(d);
              }), !this._isStreamingSupported && this._isRangeSupported && this._error(new t.AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
            }
          }
          class V {
            constructor(m) {
              this._url = m.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = (0, t.createPromiseCapability)();
              const d = m.source;
              this._isStreamingSupported = !d.disableStream;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              if (await this._readCapability.promise, this._done)
                return {
                  value: void 0,
                  done: !0
                };
              if (this._storedError)
                throw this._storedError;
              const m = this._readableStream.read();
              return m === null ? (this._readCapability = (0, t.createPromiseCapability)(), this.read()) : (this._loaded += m.length, this.onProgress && this.onProgress({
                loaded: this._loaded
              }), {
                value: new Uint8Array(m).buffer,
                done: !1
              });
            }
            cancel(m) {
              if (!this._readableStream) {
                this._error(m);
                return;
              }
              this._readableStream.destroy(m);
            }
            _error(m) {
              this._storedError = m, this._readCapability.resolve();
            }
            _setReadableStream(m) {
              this._readableStream = m, m.on("readable", () => {
                this._readCapability.resolve();
              }), m.on("end", () => {
                m.destroy(), this._done = !0, this._readCapability.resolve();
              }), m.on("error", (d) => {
                this._error(d);
              }), this._storedError && this._readableStream.destroy(this._storedError);
            }
          }
          function S(e, m) {
            return {
              protocol: e.protocol,
              auth: e.auth,
              host: e.hostname,
              port: e.port,
              path: e.path,
              method: "GET",
              headers: m
            };
          }
          class o extends n {
            constructor(m) {
              super(m);
              const d = (b) => {
                if (b.statusCode === 404) {
                  const j = new t.MissingPDFException(`Missing PDF "${this._url}".`);
                  this._storedError = j, this._headersCapability.reject(j);
                  return;
                }
                this._headersCapability.resolve(), this._setReadableStream(b);
                const N = (j) => this._readableStream.headers[j.toLowerCase()], {
                  allowRangeRequests: G,
                  suggestedLength: r
                } = (0, Z.validateRangeRequestCapabilities)({
                  getResponseHeader: N,
                  isHttp: m.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                this._isRangeSupported = G, this._contentLength = r || this._contentLength, this._filename = (0, Z.extractFilenameFromHeader)(N);
              };
              this._request = null, this._url.protocol === "http:" ? this._request = y.request(S(this._url, m.httpHeaders), d) : this._request = h.request(S(this._url, m.httpHeaders), d), this._request.on("error", (b) => {
                this._storedError = b, this._headersCapability.reject(b);
              }), this._request.end();
            }
          }
          class R extends V {
            constructor(m, d, b) {
              super(m), this._httpHeaders = {};
              for (const G in m.httpHeaders) {
                const r = m.httpHeaders[G];
                typeof r > "u" || (this._httpHeaders[G] = r);
              }
              this._httpHeaders.Range = `bytes=${d}-${b - 1}`;
              const N = (G) => {
                if (G.statusCode === 404) {
                  const r = new t.MissingPDFException(`Missing PDF "${this._url}".`);
                  this._storedError = r;
                  return;
                }
                this._setReadableStream(G);
              };
              this._request = null, this._url.protocol === "http:" ? this._request = y.request(S(this._url, this._httpHeaders), N) : this._request = h.request(S(this._url, this._httpHeaders), N), this._request.on("error", (G) => {
                this._storedError = G;
              }), this._request.end();
            }
          }
          class J extends n {
            constructor(m) {
              super(m);
              let d = decodeURIComponent(this._url.path);
              X.test(this._url.href) && (d = d.replace(/^\//, "")), W.lstat(d, (b, N) => {
                if (b) {
                  b.code === "ENOENT" && (b = new t.MissingPDFException(`Missing PDF "${d}".`)), this._storedError = b, this._headersCapability.reject(b);
                  return;
                }
                this._contentLength = N.size, this._setReadableStream(W.createReadStream(d)), this._headersCapability.resolve();
              });
            }
          }
          class u extends V {
            constructor(m, d, b) {
              super(m);
              let N = decodeURIComponent(this._url.path);
              X.test(this._url.href) && (N = N.replace(/^\//, "")), this._setReadableStream(W.createReadStream(N, {
                start: d,
                end: b - 1
              }));
            }
          }
        },
        /* 158 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.createResponseStatusError = p, c.extractFilenameFromHeader = h, c.validateRangeRequestCapabilities = y, c.validateResponseStatus = X;
          var t = i(1), Z = i(159), W = i(133);
          function y(M) {
            let {
              getResponseHeader: x,
              isHttp: n,
              rangeChunkSize: V,
              disableRange: S
            } = M;
            const o = {
              allowRangeRequests: !1,
              suggestedLength: void 0
            }, R = parseInt(x("Content-Length"), 10);
            return !Number.isInteger(R) || (o.suggestedLength = R, R <= 2 * V) || S || !n || x("Accept-Ranges") !== "bytes" || (x("Content-Encoding") || "identity") !== "identity" || (o.allowRangeRequests = !0), o;
          }
          function h(M) {
            const x = M("Content-Disposition");
            if (x) {
              let n = (0, Z.getFilenameFromContentDispositionHeader)(x);
              if (n.includes("%"))
                try {
                  n = decodeURIComponent(n);
                } catch {
                }
              if ((0, W.isPdfFile)(n))
                return n;
            }
            return null;
          }
          function p(M, x) {
            return M === 404 || M === 0 && x.startsWith("file:") ? new t.MissingPDFException('Missing PDF "' + x + '".') : new t.UnexpectedResponseException(`Unexpected server response (${M}) while retrieving PDF "${x}".`, M);
          }
          function X(M) {
            return M === 200 || M === 206;
          }
        },
        /* 159 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.getFilenameFromContentDispositionHeader = Z;
          var t = i(1);
          function Z(W) {
            let y = !0, h = p("filename\\*", "i").exec(W);
            if (h) {
              h = h[1];
              let o = n(h);
              return o = unescape(o), o = V(o), o = S(o), M(o);
            }
            if (h = x(W), h) {
              const o = S(h);
              return M(o);
            }
            if (h = p("filename", "i").exec(W), h) {
              h = h[1];
              let o = n(h);
              return o = S(o), M(o);
            }
            function p(o, R) {
              return new RegExp("(?:^|;)\\s*" + o + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', R);
            }
            function X(o, R) {
              if (o) {
                if (!/^[\x00-\xFF]+$/.test(R))
                  return R;
                try {
                  const J = new TextDecoder(o, {
                    fatal: !0
                  }), u = (0, t.stringToBytes)(R);
                  R = J.decode(u), y = !1;
                } catch {
                }
              }
              return R;
            }
            function M(o) {
              return y && /[\x80-\xff]/.test(o) && (o = X("utf-8", o), y && (o = X("iso-8859-1", o))), o;
            }
            function x(o) {
              const R = [];
              let J;
              const u = p("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
              for (; (J = u.exec(o)) !== null; ) {
                let [, m, d, b] = J;
                if (m = parseInt(m, 10), m in R) {
                  if (m === 0)
                    break;
                  continue;
                }
                R[m] = [d, b];
              }
              const e = [];
              for (let m = 0; m < R.length && m in R; ++m) {
                let [d, b] = R[m];
                b = n(b), d && (b = unescape(b), m === 0 && (b = V(b))), e.push(b);
              }
              return e.join("");
            }
            function n(o) {
              if (o.startsWith('"')) {
                const R = o.slice(1).split('\\"');
                for (let J = 0; J < R.length; ++J) {
                  const u = R[J].indexOf('"');
                  u !== -1 && (R[J] = R[J].slice(0, u), R.length = J + 1), R[J] = R[J].replace(/\\(.)/g, "$1");
                }
                o = R.join('"');
              }
              return o;
            }
            function V(o) {
              const R = o.indexOf("'");
              if (R === -1)
                return o;
              const J = o.slice(0, R), e = o.slice(R + 1).replace(/^[^']*'/, "");
              return X(J, e);
            }
            function S(o) {
              return !o.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(o) ? o : o.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(R, J, u, e) {
                if (u === "q" || u === "Q")
                  return e = e.replace(/_/g, " "), e = e.replace(/=([0-9a-fA-F]{2})/g, function(m, d) {
                    return String.fromCharCode(parseInt(d, 16));
                  }), X(J, e);
                try {
                  e = atob(e);
                } catch {
                }
                return X(J, e);
              });
            }
            return "";
          }
        },
        /* 160 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.PDFNetworkStream = void 0;
          var t = i(1), Z = i(158);
          const W = 200, y = 206;
          function h(n) {
            const V = n.response;
            return typeof V != "string" ? V : (0, t.stringToBytes)(V).buffer;
          }
          class p {
            constructor(V) {
              let S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              this.url = V, this.isHttp = /^https?:/i.test(V), this.httpHeaders = this.isHttp && S.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = S.withCredentials || !1, this.getXhr = S.getXhr || function() {
                return new XMLHttpRequest();
              }, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
            }
            requestRange(V, S, o) {
              const R = {
                begin: V,
                end: S
              };
              for (const J in o)
                R[J] = o[J];
              return this.request(R);
            }
            requestFull(V) {
              return this.request(V);
            }
            request(V) {
              const S = this.getXhr(), o = this.currXhrId++, R = this.pendingRequests[o] = {
                xhr: S
              };
              S.open("GET", this.url), S.withCredentials = this.withCredentials;
              for (const J in this.httpHeaders) {
                const u = this.httpHeaders[J];
                typeof u > "u" || S.setRequestHeader(J, u);
              }
              return this.isHttp && "begin" in V && "end" in V ? (S.setRequestHeader("Range", `bytes=${V.begin}-${V.end - 1}`), R.expectedStatus = y) : R.expectedStatus = W, S.responseType = "arraybuffer", V.onError && (S.onerror = function(J) {
                V.onError(S.status);
              }), S.onreadystatechange = this.onStateChange.bind(this, o), S.onprogress = this.onProgress.bind(this, o), R.onHeadersReceived = V.onHeadersReceived, R.onDone = V.onDone, R.onError = V.onError, R.onProgress = V.onProgress, S.send(null), o;
            }
            onProgress(V, S) {
              var o;
              const R = this.pendingRequests[V];
              R && ((o = R.onProgress) === null || o === void 0 || o.call(R, S));
            }
            onStateChange(V, S) {
              const o = this.pendingRequests[V];
              if (!o)
                return;
              const R = o.xhr;
              if (R.readyState >= 2 && o.onHeadersReceived && (o.onHeadersReceived(), delete o.onHeadersReceived), R.readyState !== 4 || !(V in this.pendingRequests))
                return;
              if (delete this.pendingRequests[V], R.status === 0 && this.isHttp) {
                var J;
                (J = o.onError) === null || J === void 0 || J.call(o, R.status);
                return;
              }
              const u = R.status || W;
              if (!(u === W && o.expectedStatus === y) && u !== o.expectedStatus) {
                var m;
                (m = o.onError) === null || m === void 0 || m.call(o, R.status);
                return;
              }
              const d = h(R);
              if (u === y) {
                const N = R.getResponseHeader("Content-Range"), G = /bytes (\d+)-(\d+)\/(\d+)/.exec(N);
                o.onDone({
                  begin: parseInt(G[1], 10),
                  chunk: d
                });
              } else if (d)
                o.onDone({
                  begin: 0,
                  chunk: d
                });
              else {
                var b;
                (b = o.onError) === null || b === void 0 || b.call(o, R.status);
              }
            }
            getRequestXhr(V) {
              return this.pendingRequests[V].xhr;
            }
            isPendingRequest(V) {
              return V in this.pendingRequests;
            }
            abortRequest(V) {
              const S = this.pendingRequests[V].xhr;
              delete this.pendingRequests[V], S.abort();
            }
          }
          class X {
            constructor(V) {
              this._source = V, this._manager = new p(V.url, {
                httpHeaders: V.httpHeaders,
                withCredentials: V.withCredentials
              }), this._rangeChunkSize = V.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            _onRangeRequestReaderClosed(V) {
              const S = this._rangeRequestReaders.indexOf(V);
              S >= 0 && this._rangeRequestReaders.splice(S, 1);
            }
            getFullReader() {
              return (0, t.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new M(this._manager, this._source), this._fullRequestReader;
            }
            getRangeReader(V, S) {
              const o = new x(this._manager, V, S);
              return o.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(o), o;
            }
            cancelAllRequests(V) {
              var S;
              (S = this._fullRequestReader) === null || S === void 0 || S.cancel(V);
              for (const o of this._rangeRequestReaders.slice(0))
                o.cancel(V);
            }
          }
          c.PDFNetworkStream = X;
          class M {
            constructor(V, S) {
              this._manager = V;
              const o = {
                onHeadersReceived: this._onHeadersReceived.bind(this),
                onDone: this._onDone.bind(this),
                onError: this._onError.bind(this),
                onProgress: this._onProgress.bind(this)
              };
              this._url = S.url, this._fullRequestId = V.requestFull(o), this._headersReceivedCapability = (0, t.createPromiseCapability)(), this._disableRange = S.disableRange || !1, this._contentLength = S.length, this._rangeChunkSize = S.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
            }
            _onHeadersReceived() {
              const V = this._fullRequestId, S = this._manager.getRequestXhr(V), o = (u) => S.getResponseHeader(u), {
                allowRangeRequests: R,
                suggestedLength: J
              } = (0, Z.validateRangeRequestCapabilities)({
                getResponseHeader: o,
                isHttp: this._manager.isHttp,
                rangeChunkSize: this._rangeChunkSize,
                disableRange: this._disableRange
              });
              R && (this._isRangeSupported = !0), this._contentLength = J || this._contentLength, this._filename = (0, Z.extractFilenameFromHeader)(o), this._isRangeSupported && this._manager.abortRequest(V), this._headersReceivedCapability.resolve();
            }
            _onDone(V) {
              if (V && (this._requests.length > 0 ? this._requests.shift().resolve({
                value: V.chunk,
                done: !1
              }) : this._cachedChunks.push(V.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
                for (const S of this._requests)
                  S.resolve({
                    value: void 0,
                    done: !0
                  });
                this._requests.length = 0;
              }
            }
            _onError(V) {
              this._storedError = (0, Z.createResponseStatusError)(V, this._url), this._headersReceivedCapability.reject(this._storedError);
              for (const S of this._requests)
                S.reject(this._storedError);
              this._requests.length = 0, this._cachedChunks.length = 0;
            }
            _onProgress(V) {
              var S;
              (S = this.onProgress) === null || S === void 0 || S.call(this, {
                loaded: V.loaded,
                total: V.lengthComputable ? V.total : this._contentLength
              });
            }
            get filename() {
              return this._filename;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            get contentLength() {
              return this._contentLength;
            }
            get headersReady() {
              return this._headersReceivedCapability.promise;
            }
            async read() {
              if (this._storedError)
                throw this._storedError;
              if (this._cachedChunks.length > 0)
                return {
                  value: this._cachedChunks.shift(),
                  done: !1
                };
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const V = (0, t.createPromiseCapability)();
              return this._requests.push(V), V.promise;
            }
            cancel(V) {
              this._done = !0, this._headersReceivedCapability.reject(V);
              for (const S of this._requests)
                S.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
            }
          }
          class x {
            constructor(V, S, o) {
              this._manager = V;
              const R = {
                onDone: this._onDone.bind(this),
                onError: this._onError.bind(this),
                onProgress: this._onProgress.bind(this)
              };
              this._url = V.url, this._requestId = V.requestRange(S, o, R), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
            }
            _close() {
              var V;
              (V = this.onClosed) === null || V === void 0 || V.call(this, this);
            }
            _onDone(V) {
              const S = V.chunk;
              this._requests.length > 0 ? this._requests.shift().resolve({
                value: S,
                done: !1
              }) : this._queuedChunk = S, this._done = !0;
              for (const o of this._requests)
                o.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._close();
            }
            _onError(V) {
              this._storedError = (0, Z.createResponseStatusError)(V, this._url);
              for (const S of this._requests)
                S.reject(this._storedError);
              this._requests.length = 0, this._queuedChunk = null;
            }
            _onProgress(V) {
              if (!this.isStreamingSupported) {
                var S;
                (S = this.onProgress) === null || S === void 0 || S.call(this, {
                  loaded: V.loaded
                });
              }
            }
            get isStreamingSupported() {
              return !1;
            }
            async read() {
              if (this._storedError)
                throw this._storedError;
              if (this._queuedChunk !== null) {
                const S = this._queuedChunk;
                return this._queuedChunk = null, {
                  value: S,
                  done: !1
                };
              }
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const V = (0, t.createPromiseCapability)();
              return this._requests.push(V), V.promise;
            }
            cancel(V) {
              this._done = !0;
              for (const S of this._requests)
                S.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
            }
          }
        },
        /* 161 */
        /***/
        (L, c, i) => {
          Object.defineProperty(c, "__esModule", {
            value: !0
          }), c.PDFFetchStream = void 0;
          var t = i(1), Z = i(158);
          function W(M, x, n) {
            return {
              method: "GET",
              headers: M,
              signal: n.signal,
              mode: "cors",
              credentials: x ? "include" : "same-origin",
              redirect: "follow"
            };
          }
          function y(M) {
            const x = new Headers();
            for (const n in M) {
              const V = M[n];
              typeof V > "u" || x.append(n, V);
            }
            return x;
          }
          class h {
            constructor(x) {
              this.source = x, this.isHttp = /^https?:/i.test(x.url), this.httpHeaders = this.isHttp && x.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            get _progressiveDataLength() {
              var x, n;
              return (x = (n = this._fullRequestReader) === null || n === void 0 ? void 0 : n._loaded) !== null && x !== void 0 ? x : 0;
            }
            getFullReader() {
              return (0, t.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new p(this), this._fullRequestReader;
            }
            getRangeReader(x, n) {
              if (n <= this._progressiveDataLength)
                return null;
              const V = new X(this, x, n);
              return this._rangeRequestReaders.push(V), V;
            }
            cancelAllRequests(x) {
              this._fullRequestReader && this._fullRequestReader.cancel(x);
              for (const n of this._rangeRequestReaders.slice(0))
                n.cancel(x);
            }
          }
          c.PDFFetchStream = h;
          class p {
            constructor(x) {
              this._stream = x, this._reader = null, this._loaded = 0, this._filename = null;
              const n = x.source;
              this._withCredentials = n.withCredentials || !1, this._contentLength = n.length, this._headersCapability = (0, t.createPromiseCapability)(), this._disableRange = n.disableRange || !1, this._rangeChunkSize = n.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !n.disableStream, this._isRangeSupported = !n.disableRange, this._headers = y(this._stream.httpHeaders);
              const V = n.url;
              fetch(V, W(this._headers, this._withCredentials, this._abortController)).then((S) => {
                if (!(0, Z.validateResponseStatus)(S.status))
                  throw (0, Z.createResponseStatusError)(S.status, V);
                this._reader = S.body.getReader(), this._headersCapability.resolve();
                const o = (u) => S.headers.get(u), {
                  allowRangeRequests: R,
                  suggestedLength: J
                } = (0, Z.validateRangeRequestCapabilities)({
                  getResponseHeader: o,
                  isHttp: this._stream.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                this._isRangeSupported = R, this._contentLength = J || this._contentLength, this._filename = (0, Z.extractFilenameFromHeader)(o), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new t.AbortException("Streaming is disabled."));
              }).catch(this._headersCapability.reject), this.onProgress = null;
            }
            get headersReady() {
              return this._headersCapability.promise;
            }
            get filename() {
              return this._filename;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              await this._headersCapability.promise;
              const {
                value: x,
                done: n
              } = await this._reader.read();
              return n ? {
                value: x,
                done: n
              } : (this._loaded += x.byteLength, this.onProgress && this.onProgress({
                loaded: this._loaded,
                total: this._contentLength
              }), {
                value: new Uint8Array(x).buffer,
                done: !1
              });
            }
            cancel(x) {
              this._reader && this._reader.cancel(x), this._abortController.abort();
            }
          }
          class X {
            constructor(x, n, V) {
              this._stream = x, this._reader = null, this._loaded = 0;
              const S = x.source;
              this._withCredentials = S.withCredentials || !1, this._readCapability = (0, t.createPromiseCapability)(), this._isStreamingSupported = !S.disableStream, this._abortController = new AbortController(), this._headers = y(this._stream.httpHeaders), this._headers.append("Range", `bytes=${n}-${V - 1}`);
              const o = S.url;
              fetch(o, W(this._headers, this._withCredentials, this._abortController)).then((R) => {
                if (!(0, Z.validateResponseStatus)(R.status))
                  throw (0, Z.createResponseStatusError)(R.status, o);
                this._readCapability.resolve(), this._reader = R.body.getReader();
              }).catch(this._readCapability.reject), this.onProgress = null;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              await this._readCapability.promise;
              const {
                value: x,
                done: n
              } = await this._reader.read();
              return n ? {
                value: x,
                done: n
              } : (this._loaded += x.byteLength, this.onProgress && this.onProgress({
                loaded: this._loaded
              }), {
                value: new Uint8Array(x).buffer,
                done: !1
              });
            }
            cancel(x) {
              this._reader && this._reader.cancel(x), this._abortController.abort();
            }
          }
        }
        /******/
      ], __webpack_module_cache__ = {};
      function __w_pdfjs_require__(L) {
        var c = __webpack_module_cache__[L];
        if (c !== void 0)
          return c.exports;
        var i = __webpack_module_cache__[L] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        return __webpack_modules__[L](i, i.exports, __w_pdfjs_require__), i.exports;
      }
      var __webpack_exports__ = {};
      return (() => {
        var L = __webpack_exports__;
        Object.defineProperty(L, "__esModule", {
          value: !0
        }), Object.defineProperty(L, "AnnotationEditorLayer", {
          enumerable: !0,
          get: function() {
            return Z.AnnotationEditorLayer;
          }
        }), Object.defineProperty(L, "AnnotationEditorParamsType", {
          enumerable: !0,
          get: function() {
            return c.AnnotationEditorParamsType;
          }
        }), Object.defineProperty(L, "AnnotationEditorType", {
          enumerable: !0,
          get: function() {
            return c.AnnotationEditorType;
          }
        }), Object.defineProperty(L, "AnnotationEditorUIManager", {
          enumerable: !0,
          get: function() {
            return W.AnnotationEditorUIManager;
          }
        }), Object.defineProperty(L, "AnnotationLayer", {
          enumerable: !0,
          get: function() {
            return y.AnnotationLayer;
          }
        }), Object.defineProperty(L, "AnnotationMode", {
          enumerable: !0,
          get: function() {
            return c.AnnotationMode;
          }
        }), Object.defineProperty(L, "CMapCompressionType", {
          enumerable: !0,
          get: function() {
            return c.CMapCompressionType;
          }
        }), Object.defineProperty(L, "GlobalWorkerOptions", {
          enumerable: !0,
          get: function() {
            return h.GlobalWorkerOptions;
          }
        }), Object.defineProperty(L, "InvalidPDFException", {
          enumerable: !0,
          get: function() {
            return c.InvalidPDFException;
          }
        }), Object.defineProperty(L, "LoopbackPort", {
          enumerable: !0,
          get: function() {
            return i.LoopbackPort;
          }
        }), Object.defineProperty(L, "MissingPDFException", {
          enumerable: !0,
          get: function() {
            return c.MissingPDFException;
          }
        }), Object.defineProperty(L, "OPS", {
          enumerable: !0,
          get: function() {
            return c.OPS;
          }
        }), Object.defineProperty(L, "PDFDataRangeTransport", {
          enumerable: !0,
          get: function() {
            return i.PDFDataRangeTransport;
          }
        }), Object.defineProperty(L, "PDFDateString", {
          enumerable: !0,
          get: function() {
            return t.PDFDateString;
          }
        }), Object.defineProperty(L, "PDFWorker", {
          enumerable: !0,
          get: function() {
            return i.PDFWorker;
          }
        }), Object.defineProperty(L, "PasswordResponses", {
          enumerable: !0,
          get: function() {
            return c.PasswordResponses;
          }
        }), Object.defineProperty(L, "PermissionFlag", {
          enumerable: !0,
          get: function() {
            return c.PermissionFlag;
          }
        }), Object.defineProperty(L, "PixelsPerInch", {
          enumerable: !0,
          get: function() {
            return t.PixelsPerInch;
          }
        }), Object.defineProperty(L, "RenderingCancelledException", {
          enumerable: !0,
          get: function() {
            return t.RenderingCancelledException;
          }
        }), Object.defineProperty(L, "SVGGraphics", {
          enumerable: !0,
          get: function() {
            return M.SVGGraphics;
          }
        }), Object.defineProperty(L, "UNSUPPORTED_FEATURES", {
          enumerable: !0,
          get: function() {
            return c.UNSUPPORTED_FEATURES;
          }
        }), Object.defineProperty(L, "UnexpectedResponseException", {
          enumerable: !0,
          get: function() {
            return c.UnexpectedResponseException;
          }
        }), Object.defineProperty(L, "Util", {
          enumerable: !0,
          get: function() {
            return c.Util;
          }
        }), Object.defineProperty(L, "VerbosityLevel", {
          enumerable: !0,
          get: function() {
            return c.VerbosityLevel;
          }
        }), Object.defineProperty(L, "XfaLayer", {
          enumerable: !0,
          get: function() {
            return x.XfaLayer;
          }
        }), Object.defineProperty(L, "build", {
          enumerable: !0,
          get: function() {
            return i.build;
          }
        }), Object.defineProperty(L, "createPromiseCapability", {
          enumerable: !0,
          get: function() {
            return c.createPromiseCapability;
          }
        }), Object.defineProperty(L, "createValidAbsoluteUrl", {
          enumerable: !0,
          get: function() {
            return c.createValidAbsoluteUrl;
          }
        }), Object.defineProperty(L, "getDocument", {
          enumerable: !0,
          get: function() {
            return i.getDocument;
          }
        }), Object.defineProperty(L, "getFilenameFromUrl", {
          enumerable: !0,
          get: function() {
            return t.getFilenameFromUrl;
          }
        }), Object.defineProperty(L, "getPdfFilenameFromUrl", {
          enumerable: !0,
          get: function() {
            return t.getPdfFilenameFromUrl;
          }
        }), Object.defineProperty(L, "getXfaPageViewport", {
          enumerable: !0,
          get: function() {
            return t.getXfaPageViewport;
          }
        }), Object.defineProperty(L, "isPdfFile", {
          enumerable: !0,
          get: function() {
            return t.isPdfFile;
          }
        }), Object.defineProperty(L, "loadScript", {
          enumerable: !0,
          get: function() {
            return t.loadScript;
          }
        }), Object.defineProperty(L, "renderTextLayer", {
          enumerable: !0,
          get: function() {
            return X.renderTextLayer;
          }
        }), Object.defineProperty(L, "shadow", {
          enumerable: !0,
          get: function() {
            return c.shadow;
          }
        }), Object.defineProperty(L, "version", {
          enumerable: !0,
          get: function() {
            return i.version;
          }
        });
        var c = __w_pdfjs_require__(1), i = __w_pdfjs_require__(129), t = __w_pdfjs_require__(133), Z = __w_pdfjs_require__(147), W = __w_pdfjs_require__(132), y = __w_pdfjs_require__(152), h = __w_pdfjs_require__(140), p = __w_pdfjs_require__(3), X = __w_pdfjs_require__(155), M = __w_pdfjs_require__(156), x = __w_pdfjs_require__(154);
        if (p.isNodeJS) {
          const {
            PDFNodeStream: n
          } = __w_pdfjs_require__(157);
          (0, i.setPDFNetworkStreamFactory)((V) => new n(V));
        } else {
          const {
            PDFNetworkStream: n
          } = __w_pdfjs_require__(160), {
            PDFFetchStream: V
          } = __w_pdfjs_require__(161);
          (0, i.setPDFNetworkStreamFactory)((S) => (0, t.isValidFetchUrl)(S.url) ? new V(S) : new n(S));
        }
      })(), __webpack_exports__;
    })()
  ));
})(pdf);
var pdfExports = pdf.exports;
const workerSrc = "data:text/javascript;base64,LyoqCiAqIEBsaWNzdGFydCBUaGUgZm9sbG93aW5nIGlzIHRoZSBlbnRpcmUgbGljZW5zZSBub3RpY2UgZm9yIHRoZQogKiBKYXZhU2NyaXB0IGNvZGUgaW4gdGhpcyBwYWdlCiAqCiAqIENvcHlyaWdodCAyMDIyIE1vemlsbGEgRm91bmRhdGlvbgogKgogKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgogKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKICoKICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAogKgogKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLgogKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgogKgogKiBAbGljZW5kIFRoZSBhYm92ZSBpcyB0aGUgZW50aXJlIGxpY2Vuc2Ugbm90aWNlIGZvciB0aGUKICogSmF2YVNjcmlwdCBjb2RlIGluIHRoaXMgcGFnZQogKi8KIWZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKGUsdCl7Im9iamVjdCI9PXR5cGVvZiBleHBvcnRzJiYib2JqZWN0Ij09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoInBkZmpzLWRpc3QvYnVpbGQvcGRmLndvcmtlciIsW10sdCk6Im9iamVjdCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHNbInBkZmpzLWRpc3QvYnVpbGQvcGRmLndvcmtlciJdPXQoKTplWyJwZGZqcy1kaXN0L2J1aWxkL3BkZi53b3JrZXIiXT1lLnBkZmpzV29ya2VyPXQoKX0oZ2xvYmFsVGhpcywoKCk9PigoKT0+eyJ1c2Ugc3RyaWN0Ijt2YXIgZT1bLChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5Xb3JrZXJUYXNrPXQuV29ya2VyTWVzc2FnZUhhbmRsZXI9dm9pZCAwO3ZhciByPWEoMiksbj1hKDUpLGk9YSg2KSxzPWEoOCksbz1hKDcxKSxjPWEoNjUpLGw9YSg0KSxoPWEoMTAyKSx1PWEoMTAzKTtjbGFzcyBXb3JrZXJUYXNre2NvbnN0cnVjdG9yKGUpe3RoaXMubmFtZT1lO3RoaXMudGVybWluYXRlZD0hMTt0aGlzLl9jYXBhYmlsaXR5PSgwLHIuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCl9Z2V0IGZpbmlzaGVkKCl7cmV0dXJuIHRoaXMuX2NhcGFiaWxpdHkucHJvbWlzZX1maW5pc2goKXt0aGlzLl9jYXBhYmlsaXR5LnJlc29sdmUoKX10ZXJtaW5hdGUoKXt0aGlzLnRlcm1pbmF0ZWQ9ITB9ZW5zdXJlTm90VGVybWluYXRlZCgpe2lmKHRoaXMudGVybWluYXRlZCl0aHJvdyBuZXcgRXJyb3IoIldvcmtlciB0YXNrIHdhcyB0ZXJtaW5hdGVkIil9fXQuV29ya2VyVGFzaz1Xb3JrZXJUYXNrO2NsYXNzIFdvcmtlck1lc3NhZ2VIYW5kbGVye3N0YXRpYyBzZXR1cChlLHQpe2xldCBhPSExO2Uub24oInRlc3QiLChmdW5jdGlvbiB3cGhTZXR1cFRlc3QodCl7aWYoIWEpe2E9ITA7ZS5zZW5kKCJ0ZXN0Iix0IGluc3RhbmNlb2YgVWludDhBcnJheSl9fSkpO2Uub24oImNvbmZpZ3VyZSIsKGZ1bmN0aW9uIHdwaENvbmZpZ3VyZShlKXsoMCxyLnNldFZlcmJvc2l0eUxldmVsKShlLnZlcmJvc2l0eSl9KSk7ZS5vbigiR2V0RG9jUmVxdWVzdCIsKGZ1bmN0aW9uIHdwaFNldHVwRG9jKGUpe3JldHVybiBXb3JrZXJNZXNzYWdlSGFuZGxlci5jcmVhdGVEb2N1bWVudEhhbmRsZXIoZSx0KX0pKX1zdGF0aWMgY3JlYXRlRG9jdW1lbnRIYW5kbGVyKGUsdCl7bGV0IGEsZD0hMSxmPW51bGw7Y29uc3QgZz1bXSxwPSgwLHIuZ2V0VmVyYm9zaXR5TGV2ZWwpKCksbT1lLmFwaVZlcnNpb24sYj0iMi4xNi4xMDUiO2lmKG0hPT1iKXRocm93IG5ldyBFcnJvcihgVGhlIEFQSSB2ZXJzaW9uICIke219IiBkb2VzIG5vdCBtYXRjaCB0aGUgV29ya2VyIHZlcnNpb24gIjIuMTYuMTA1Ii5gKTtjb25zdCB5PVtdO2Zvcihjb25zdCBlIGluW10peS5wdXNoKGUpO2lmKHkubGVuZ3RoKXRocm93IG5ldyBFcnJvcigiVGhlIGBBcnJheS5wcm90b3R5cGVgIGNvbnRhaW5zIHVuZXhwZWN0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzOiAiK3kuam9pbigiLCAiKSsiOyB0aHVzIGJyZWFraW5nIGUuZy4gYGZvci4uLmluYCBpdGVyYXRpb24gb2YgYEFycmF5YHMuIik7aWYoInVuZGVmaW5lZCI9PXR5cGVvZiBSZWFkYWJsZVN0cmVhbSl7Y29uc3QgZT0iVGhlIGJyb3dzZXIvZW52aXJvbm1lbnQgbGFja3MgbmF0aXZlIHN1cHBvcnQgZm9yIGNyaXRpY2FsIGZ1bmN0aW9uYWxpdHkgdXNlZCBieSB0aGUgUERGLmpzIGxpYnJhcnkgKGUuZy4gYFJlYWRhYmxlU3RyZWFtYCk7ICI7aWYobC5pc05vZGVKUyl0aHJvdyBuZXcgRXJyb3IoZSsicGxlYXNlIHVzZSBhIGBsZWdhY3lgLWJ1aWxkIGluc3RlYWQuIik7dGhyb3cgbmV3IEVycm9yKGUrInBsZWFzZSB1cGRhdGUgdG8gYSBzdXBwb3J0ZWQgYnJvd3Nlci4iKX1jb25zdCB3PWUuZG9jSWQsUz1lLmRvY0Jhc2VVcmwseD1lLmRvY0lkKyJfd29ya2VyIjtsZXQgaz1uZXcgaC5NZXNzYWdlSGFuZGxlcih4LHcsdCk7ZnVuY3Rpb24gZW5zdXJlTm90VGVybWluYXRlZCgpe2lmKGQpdGhyb3cgbmV3IEVycm9yKCJXb3JrZXIgd2FzIHRlcm1pbmF0ZWQiKX1mdW5jdGlvbiBzdGFydFdvcmtlclRhc2soZSl7Zy5wdXNoKGUpfWZ1bmN0aW9uIGZpbmlzaFdvcmtlclRhc2soZSl7ZS5maW5pc2goKTtjb25zdCB0PWcuaW5kZXhPZihlKTtnLnNwbGljZSh0LDEpfWFzeW5jIGZ1bmN0aW9uIGxvYWREb2N1bWVudChlKXthd2FpdCBhLmVuc3VyZURvYygiY2hlY2tIZWFkZXIiKTthd2FpdCBhLmVuc3VyZURvYygicGFyc2VTdGFydFhSZWYiKTthd2FpdCBhLmVuc3VyZURvYygicGFyc2UiLFtlXSk7YXdhaXQgYS5lbnN1cmVEb2MoImNoZWNrRmlyc3RQYWdlIixbZV0pO2F3YWl0IGEuZW5zdXJlRG9jKCJjaGVja0xhc3RQYWdlIixbZV0pO2NvbnN0IHQ9YXdhaXQgYS5lbnN1cmVEb2MoImlzUHVyZVhmYSIpO2lmKHQpe2NvbnN0IGU9bmV3IFdvcmtlclRhc2soImxvYWRYZmFGb250cyIpO3N0YXJ0V29ya2VyVGFzayhlKTthd2FpdCBQcm9taXNlLmFsbChbYS5sb2FkWGZhRm9udHMoayxlKS5jYXRjaCgoZT0+e30pKS50aGVuKCgoKT0+ZmluaXNoV29ya2VyVGFzayhlKSkpLGEubG9hZFhmYUltYWdlcygpXSl9Y29uc3RbcixuXT1hd2FpdCBQcm9taXNlLmFsbChbYS5lbnN1cmVEb2MoIm51bVBhZ2VzIiksYS5lbnN1cmVEb2MoImZpbmdlcnByaW50cyIpXSk7cmV0dXJue251bVBhZ2VzOnIsZmluZ2VycHJpbnRzOm4saHRtbEZvclhmYTp0P2F3YWl0IGEuZW5zdXJlRG9jKCJodG1sRm9yWGZhIik6bnVsbH19ZnVuY3Rpb24gZ2V0UGRmTWFuYWdlcihlLHQsYSl7Y29uc3Qgbj0oMCxyLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO2xldCBpO2NvbnN0IG89ZS5zb3VyY2U7aWYoby5kYXRhKXt0cnl7aT1uZXcgcy5Mb2NhbFBkZk1hbmFnZXIodyxvLmRhdGEsby5wYXNzd29yZCxrLHQsYSxTKTtuLnJlc29sdmUoaSl9Y2F0Y2goZSl7bi5yZWplY3QoZSl9cmV0dXJuIG4ucHJvbWlzZX1sZXQgYyxsPVtdO3RyeXtjPW5ldyB1LlBERldvcmtlclN0cmVhbShrKX1jYXRjaChlKXtuLnJlamVjdChlKTtyZXR1cm4gbi5wcm9taXNlfWNvbnN0IGg9Yy5nZXRGdWxsUmVhZGVyKCk7aC5oZWFkZXJzUmVhZHkudGhlbigoZnVuY3Rpb24oKXtpZighaC5pc1JhbmdlU3VwcG9ydGVkKXJldHVybjtjb25zdCBlPW8uZGlzYWJsZUF1dG9GZXRjaHx8aC5pc1N0cmVhbWluZ1N1cHBvcnRlZDtpPW5ldyBzLk5ldHdvcmtQZGZNYW5hZ2VyKHcsYyx7bXNnSGFuZGxlcjprLHBhc3N3b3JkOm8ucGFzc3dvcmQsbGVuZ3RoOmguY29udGVudExlbmd0aCxkaXNhYmxlQXV0b0ZldGNoOmUscmFuZ2VDaHVua1NpemU6by5yYW5nZUNodW5rU2l6ZX0sdCxhLFMpO2Zvcihjb25zdCBlIG9mIGwpaS5zZW5kUHJvZ3Jlc3NpdmVEYXRhKGUpO2w9W107bi5yZXNvbHZlKGkpO2Y9bnVsbH0pKS5jYXRjaCgoZnVuY3Rpb24oZSl7bi5yZWplY3QoZSk7Zj1udWxsfSkpO2xldCBkPTA7bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsYyl7Y29uc3QgcmVhZENodW5rPWZ1bmN0aW9uKHt2YWx1ZTplLGRvbmU6dX0pe3RyeXtlbnN1cmVOb3RUZXJtaW5hdGVkKCk7aWYodSl7aXx8ZnVuY3Rpb24oKXtjb25zdCBlPSgwLHIuYXJyYXlzVG9CeXRlcykobCk7by5sZW5ndGgmJmUubGVuZ3RoIT09by5sZW5ndGgmJigwLHIud2FybikoInJlcG9ydGVkIEhUVFAgbGVuZ3RoIGlzIGRpZmZlcmVudCBmcm9tIGFjdHVhbCIpO3RyeXtpPW5ldyBzLkxvY2FsUGRmTWFuYWdlcih3LGUsby5wYXNzd29yZCxrLHQsYSxTKTtuLnJlc29sdmUoaSl9Y2F0Y2goZSl7bi5yZWplY3QoZSl9bD1bXX0oKTtmPW51bGw7cmV0dXJufWQrPSgwLHIuYXJyYXlCeXRlTGVuZ3RoKShlKTtoLmlzU3RyZWFtaW5nU3VwcG9ydGVkfHxrLnNlbmQoIkRvY1Byb2dyZXNzIix7bG9hZGVkOmQsdG90YWw6TWF0aC5tYXgoZCxoLmNvbnRlbnRMZW5ndGh8fDApfSk7aT9pLnNlbmRQcm9ncmVzc2l2ZURhdGEoZSk6bC5wdXNoKGUpO2gucmVhZCgpLnRoZW4ocmVhZENodW5rLGMpfWNhdGNoKGUpe2MoZSl9fTtoLnJlYWQoKS50aGVuKHJlYWRDaHVuayxjKX0pKS5jYXRjaCgoZnVuY3Rpb24oZSl7bi5yZWplY3QoZSk7Zj1udWxsfSkpO2Y9ZnVuY3Rpb24oZSl7Yy5jYW5jZWxBbGxSZXF1ZXN0cyhlKX07cmV0dXJuIG4ucHJvbWlzZX1rLm9uKCJHZXRQYWdlIiwoZnVuY3Rpb24gd3BoU2V0dXBHZXRQYWdlKGUpe3JldHVybiBhLmdldFBhZ2UoZS5wYWdlSW5kZXgpLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBQcm9taXNlLmFsbChbYS5lbnN1cmUoZSwicm90YXRlIiksYS5lbnN1cmUoZSwicmVmIiksYS5lbnN1cmUoZSwidXNlclVuaXQiKSxhLmVuc3VyZShlLCJ2aWV3IildKS50aGVuKChmdW5jdGlvbihbZSx0LGEscl0pe3JldHVybntyb3RhdGU6ZSxyZWY6dCx1c2VyVW5pdDphLHZpZXc6cn19KSl9KSl9KSk7ay5vbigiR2V0UGFnZUluZGV4IiwoZnVuY3Rpb24gd3BoU2V0dXBHZXRQYWdlSW5kZXgoZSl7Y29uc3QgdD1uLlJlZi5nZXQoZS5udW0sZS5nZW4pO3JldHVybiBhLmVuc3VyZUNhdGFsb2coImdldFBhZ2VJbmRleCIsW3RdKX0pKTtrLm9uKCJHZXREZXN0aW5hdGlvbnMiLChmdW5jdGlvbiB3cGhTZXR1cEdldERlc3RpbmF0aW9ucyhlKXtyZXR1cm4gYS5lbnN1cmVDYXRhbG9nKCJkZXN0aW5hdGlvbnMiKX0pKTtrLm9uKCJHZXREZXN0aW5hdGlvbiIsKGZ1bmN0aW9uIHdwaFNldHVwR2V0RGVzdGluYXRpb24oZSl7cmV0dXJuIGEuZW5zdXJlQ2F0YWxvZygiZ2V0RGVzdGluYXRpb24iLFtlLmlkXSl9KSk7ay5vbigiR2V0UGFnZUxhYmVscyIsKGZ1bmN0aW9uIHdwaFNldHVwR2V0UGFnZUxhYmVscyhlKXtyZXR1cm4gYS5lbnN1cmVDYXRhbG9nKCJwYWdlTGFiZWxzIil9KSk7ay5vbigiR2V0UGFnZUxheW91dCIsKGZ1bmN0aW9uIHdwaFNldHVwR2V0UGFnZUxheW91dChlKXtyZXR1cm4gYS5lbnN1cmVDYXRhbG9nKCJwYWdlTGF5b3V0Iil9KSk7ay5vbigiR2V0UGFnZU1vZGUiLChmdW5jdGlvbiB3cGhTZXR1cEdldFBhZ2VNb2RlKGUpe3JldHVybiBhLmVuc3VyZUNhdGFsb2coInBhZ2VNb2RlIil9KSk7ay5vbigiR2V0Vmlld2VyUHJlZmVyZW5jZXMiLChmdW5jdGlvbihlKXtyZXR1cm4gYS5lbnN1cmVDYXRhbG9nKCJ2aWV3ZXJQcmVmZXJlbmNlcyIpfSkpO2sub24oIkdldE9wZW5BY3Rpb24iLChmdW5jdGlvbihlKXtyZXR1cm4gYS5lbnN1cmVDYXRhbG9nKCJvcGVuQWN0aW9uIil9KSk7ay5vbigiR2V0QXR0YWNobWVudHMiLChmdW5jdGlvbiB3cGhTZXR1cEdldEF0dGFjaG1lbnRzKGUpe3JldHVybiBhLmVuc3VyZUNhdGFsb2coImF0dGFjaG1lbnRzIil9KSk7ay5vbigiR2V0SmF2YVNjcmlwdCIsKGZ1bmN0aW9uIHdwaFNldHVwR2V0SmF2YVNjcmlwdChlKXtyZXR1cm4gYS5lbnN1cmVDYXRhbG9nKCJqYXZhU2NyaXB0Iil9KSk7ay5vbigiR2V0RG9jSlNBY3Rpb25zIiwoZnVuY3Rpb24gd3BoU2V0dXBHZXREb2NKU0FjdGlvbnMoZSl7cmV0dXJuIGEuZW5zdXJlQ2F0YWxvZygianNBY3Rpb25zIil9KSk7ay5vbigiR2V0UGFnZUpTQWN0aW9ucyIsKGZ1bmN0aW9uKHtwYWdlSW5kZXg6ZX0pe3JldHVybiBhLmdldFBhZ2UoZSkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIGEuZW5zdXJlKGUsImpzQWN0aW9ucyIpfSkpfSkpO2sub24oIkdldE91dGxpbmUiLChmdW5jdGlvbiB3cGhTZXR1cEdldE91dGxpbmUoZSl7cmV0dXJuIGEuZW5zdXJlQ2F0YWxvZygiZG9jdW1lbnRPdXRsaW5lIil9KSk7ay5vbigiR2V0T3B0aW9uYWxDb250ZW50Q29uZmlnIiwoZnVuY3Rpb24oZSl7cmV0dXJuIGEuZW5zdXJlQ2F0YWxvZygib3B0aW9uYWxDb250ZW50Q29uZmlnIil9KSk7ay5vbigiR2V0UGVybWlzc2lvbnMiLChmdW5jdGlvbihlKXtyZXR1cm4gYS5lbnN1cmVDYXRhbG9nKCJwZXJtaXNzaW9ucyIpfSkpO2sub24oIkdldE1ldGFkYXRhIiwoZnVuY3Rpb24gd3BoU2V0dXBHZXRNZXRhZGF0YShlKXtyZXR1cm4gUHJvbWlzZS5hbGwoW2EuZW5zdXJlRG9jKCJkb2N1bWVudEluZm8iKSxhLmVuc3VyZUNhdGFsb2coIm1ldGFkYXRhIildKX0pKTtrLm9uKCJHZXRNYXJrSW5mbyIsKGZ1bmN0aW9uIHdwaFNldHVwR2V0TWFya0luZm8oZSl7cmV0dXJuIGEuZW5zdXJlQ2F0YWxvZygibWFya0luZm8iKX0pKTtrLm9uKCJHZXREYXRhIiwoZnVuY3Rpb24gd3BoU2V0dXBHZXREYXRhKGUpe2EucmVxdWVzdExvYWRlZFN0cmVhbSgpO3JldHVybiBhLm9uTG9hZGVkU3RyZWFtKCkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYnl0ZXN9KSl9KSk7ay5vbigiR2V0QW5ub3RhdGlvbnMiLChmdW5jdGlvbih7cGFnZUluZGV4OmUsaW50ZW50OnR9KXtyZXR1cm4gYS5nZXRQYWdlKGUpLnRoZW4oKGZ1bmN0aW9uKGEpe2NvbnN0IHI9bmV3IFdvcmtlclRhc2soYEdldEFubm90YXRpb25zOiBwYWdlICR7ZX1gKTtzdGFydFdvcmtlclRhc2socik7cmV0dXJuIGEuZ2V0QW5ub3RhdGlvbnNEYXRhKGsscix0KS50aGVuKChlPT57ZmluaXNoV29ya2VyVGFzayhyKTtyZXR1cm4gZX0pLChlPT57ZmluaXNoV29ya2VyVGFzayhyKX0pKX0pKX0pKTtrLm9uKCJHZXRGaWVsZE9iamVjdHMiLChmdW5jdGlvbihlKXtyZXR1cm4gYS5lbnN1cmVEb2MoImZpZWxkT2JqZWN0cyIpfSkpO2sub24oIkhhc0pTQWN0aW9ucyIsKGZ1bmN0aW9uKGUpe3JldHVybiBhLmVuc3VyZURvYygiaGFzSlNBY3Rpb25zIil9KSk7ay5vbigiR2V0Q2FsY3VsYXRpb25PcmRlcklkcyIsKGZ1bmN0aW9uKGUpe3JldHVybiBhLmVuc3VyZURvYygiY2FsY3VsYXRpb25PcmRlcklkcyIpfSkpO2sub24oIlNhdmVEb2N1bWVudCIsKGZ1bmN0aW9uKHtpc1B1cmVYZmE6ZSxudW1QYWdlczp0LGFubm90YXRpb25TdG9yYWdlOnMsZmlsZW5hbWU6b30pe2EucmVxdWVzdExvYWRlZFN0cmVhbSgpO2NvbnN0IGw9ZT9udWxsOigwLGkuZ2V0TmV3QW5ub3RhdGlvbnNNYXApKHMpLGg9W2Eub25Mb2FkZWRTdHJlYW0oKSxhLmVuc3VyZUNhdGFsb2coImFjcm9Gb3JtIiksYS5lbnN1cmVDYXRhbG9nKCJhY3JvRm9ybVJlZiIpLGEuZW5zdXJlRG9jKCJ4cmVmIiksYS5lbnN1cmVEb2MoInN0YXJ0WFJlZiIpXTtpZihsKWZvcihjb25zdFtlLHRdb2YgbCloLnB1c2goYS5nZXRQYWdlKGUpLnRoZW4oKGE9Pntjb25zdCByPW5ldyBXb3JrZXJUYXNrKGBTYXZlIChlZGl0b3IpOiBwYWdlICR7ZX1gKTtyZXR1cm4gYS5zYXZlTmV3QW5ub3RhdGlvbnMoayxyLHQpLmZpbmFsbHkoKGZ1bmN0aW9uKCl7ZmluaXNoV29ya2VyVGFzayhyKX0pKX0pKSk7aWYoZSloLnB1c2goYS5zZXJpYWxpemVYZmFEYXRhKHMpKTtlbHNlIGZvcihsZXQgZT0wO2U8dDtlKyspaC5wdXNoKGEuZ2V0UGFnZShlKS50aGVuKChmdW5jdGlvbih0KXtjb25zdCBhPW5ldyBXb3JrZXJUYXNrKGBTYXZlOiBwYWdlICR7ZX1gKTtyZXR1cm4gdC5zYXZlKGssYSxzKS5maW5hbGx5KChmdW5jdGlvbigpe2ZpbmlzaFdvcmtlclRhc2soYSl9KSl9KSkpO3JldHVybiBQcm9taXNlLmFsbChoKS50aGVuKChmdW5jdGlvbihbdCxhLGkscyxsLC4uLmhdKXtsZXQgdT1bXSxkPW51bGw7aWYoZSl7ZD1oWzBdO2lmKCFkKXJldHVybiB0LmJ5dGVzfWVsc2V7dT1oLmZsYXQoMik7aWYoMD09PXUubGVuZ3RoKXJldHVybiB0LmJ5dGVzfWNvbnN0IGY9YSBpbnN0YW5jZW9mIG4uRGljdCYmYS5nZXQoIlhGQSIpfHxudWxsO2xldCBnPW51bGwscD0hMTtpZihBcnJheS5pc0FycmF5KGYpKXtmb3IobGV0IGU9MCx0PWYubGVuZ3RoO2U8dDtlKz0yKWlmKCJkYXRhc2V0cyI9PT1mW2VdKXtnPWZbZSsxXTtpPW51bGw7cD0hMH1udWxsPT09ZyYmKGc9cy5nZXROZXdSZWYoKSl9ZWxzZSBpZihmKXtpPW51bGw7KDAsci53YXJuKSgiVW5zdXBwb3J0ZWQgWEZBIHR5cGUuIil9bGV0IG09T2JqZWN0LmNyZWF0ZShudWxsKTtpZihzLnRyYWlsZXIpe2NvbnN0IGU9T2JqZWN0LmNyZWF0ZShudWxsKSx0PXMudHJhaWxlci5nZXQoIkluZm8iKXx8bnVsbDt0IGluc3RhbmNlb2Ygbi5EaWN0JiZ0LmZvckVhY2goKCh0LGEpPT57InN0cmluZyI9PXR5cGVvZiBhJiYoZVt0XT0oMCxyLnN0cmluZ1RvUERGU3RyaW5nKShhKSl9KSk7bT17cm9vdFJlZjpzLnRyYWlsZXIuZ2V0UmF3KCJSb290Iil8fG51bGwsZW5jcnlwdFJlZjpzLnRyYWlsZXIuZ2V0UmF3KCJFbmNyeXB0Iil8fG51bGwsbmV3UmVmOnMuZ2V0TmV3UmVmKCksaW5mb1JlZjpzLnRyYWlsZXIuZ2V0UmF3KCJJbmZvIil8fG51bGwsaW5mbzplLGZpbGVJZHM6cy50cmFpbGVyLmdldCgiSUQiKXx8bnVsbCxzdGFydFhSZWY6bCxmaWxlbmFtZTpvfX1zLnJlc2V0TmV3UmVmKCk7cmV0dXJuKDAsYy5pbmNyZW1lbnRhbFVwZGF0ZSkoe29yaWdpbmFsRGF0YTp0LmJ5dGVzLHhyZWZJbmZvOm0sbmV3UmVmczp1LHhyZWY6cyxoYXNYZmE6ISFmLHhmYURhdGFzZXRzUmVmOmcsaGFzWGZhRGF0YXNldHNFbnRyeTpwLGFjcm9Gb3JtUmVmOmksYWNyb0Zvcm06YSx4ZmFEYXRhOmR9KX0pKX0pKTtrLm9uKCJHZXRPcGVyYXRvckxpc3QiLChmdW5jdGlvbiB3cGhTZXR1cFJlbmRlclBhZ2UoZSx0KXtjb25zdCBuPWUucGFnZUluZGV4O2EuZ2V0UGFnZShuKS50aGVuKChmdW5jdGlvbihhKXtjb25zdCBpPW5ldyBXb3JrZXJUYXNrKGBHZXRPcGVyYXRvckxpc3Q6IHBhZ2UgJHtufWApO3N0YXJ0V29ya2VyVGFzayhpKTtjb25zdCBzPXA+PXIuVmVyYm9zaXR5TGV2ZWwuSU5GT1M/RGF0ZS5ub3coKTowO2EuZ2V0T3BlcmF0b3JMaXN0KHtoYW5kbGVyOmssc2luazp0LHRhc2s6aSxpbnRlbnQ6ZS5pbnRlbnQsY2FjaGVLZXk6ZS5jYWNoZUtleSxhbm5vdGF0aW9uU3RvcmFnZTplLmFubm90YXRpb25TdG9yYWdlfSkudGhlbigoZnVuY3Rpb24oZSl7ZmluaXNoV29ya2VyVGFzayhpKTtzJiYoMCxyLmluZm8pKGBwYWdlPSR7bisxfSAtIGdldE9wZXJhdG9yTGlzdDogdGltZT0ke0RhdGUubm93KCktc31tcywgbGVuPSR7ZS5sZW5ndGh9YCk7dC5jbG9zZSgpfSksKGZ1bmN0aW9uKGUpe2ZpbmlzaFdvcmtlclRhc2soaSk7aWYoIWkudGVybWluYXRlZCl7ay5zZW5kKCJVbnN1cHBvcnRlZEZlYXR1cmUiLHtmZWF0dXJlSWQ6ci5VTlNVUFBPUlRFRF9GRUFUVVJFUy5lcnJvck9wZXJhdG9yTGlzdH0pO3QuZXJyb3IoZSl9fSkpfSkpfSkpO2sub24oIkdldFRleHRDb250ZW50IiwoZnVuY3Rpb24gd3BoRXh0cmFjdFRleHQoZSx0KXtjb25zdCBuPWUucGFnZUluZGV4O2EuZ2V0UGFnZShuKS50aGVuKChmdW5jdGlvbihhKXtjb25zdCBpPW5ldyBXb3JrZXJUYXNrKCJHZXRUZXh0Q29udGVudDogcGFnZSAiK24pO3N0YXJ0V29ya2VyVGFzayhpKTtjb25zdCBzPXA+PXIuVmVyYm9zaXR5TGV2ZWwuSU5GT1M/RGF0ZS5ub3coKTowO2EuZXh0cmFjdFRleHRDb250ZW50KHtoYW5kbGVyOmssdGFzazppLHNpbms6dCxpbmNsdWRlTWFya2VkQ29udGVudDplLmluY2x1ZGVNYXJrZWRDb250ZW50LGNvbWJpbmVUZXh0SXRlbXM6ZS5jb21iaW5lVGV4dEl0ZW1zfSkudGhlbigoZnVuY3Rpb24oKXtmaW5pc2hXb3JrZXJUYXNrKGkpO3MmJigwLHIuaW5mbykoYHBhZ2U9JHtuKzF9IC0gZ2V0VGV4dENvbnRlbnQ6IHRpbWU9YCsoRGF0ZS5ub3coKS1zKSsibXMiKTt0LmNsb3NlKCl9KSwoZnVuY3Rpb24oZSl7ZmluaXNoV29ya2VyVGFzayhpKTtpLnRlcm1pbmF0ZWR8fHQuZXJyb3IoZSl9KSl9KSl9KSk7ay5vbigiR2V0U3RydWN0VHJlZSIsKGZ1bmN0aW9uIHdwaEdldFN0cnVjdFRyZWUoZSl7cmV0dXJuIGEuZ2V0UGFnZShlLnBhZ2VJbmRleCkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIGEuZW5zdXJlKGUsImdldFN0cnVjdFRyZWUiKX0pKX0pKTtrLm9uKCJGb250RmFsbGJhY2siLChmdW5jdGlvbihlKXtyZXR1cm4gYS5mb250RmFsbGJhY2soZS5pZCxrKX0pKTtrLm9uKCJDbGVhbnVwIiwoZnVuY3Rpb24gd3BoQ2xlYW51cChlKXtyZXR1cm4gYS5jbGVhbnVwKCEwKX0pKTtrLm9uKCJUZXJtaW5hdGUiLChmdW5jdGlvbiB3cGhUZXJtaW5hdGUoZSl7ZD0hMDtjb25zdCB0PVtdO2lmKGEpe2EudGVybWluYXRlKG5ldyByLkFib3J0RXhjZXB0aW9uKCJXb3JrZXIgd2FzIHRlcm1pbmF0ZWQuIikpO2NvbnN0IGU9YS5jbGVhbnVwKCk7dC5wdXNoKGUpO2E9bnVsbH1lbHNlKDAsby5jbGVhckdsb2JhbENhY2hlcykoKTtmJiZmKG5ldyByLkFib3J0RXhjZXB0aW9uKCJXb3JrZXIgd2FzIHRlcm1pbmF0ZWQuIikpO2Zvcihjb25zdCBlIG9mIGcpe3QucHVzaChlLmZpbmlzaGVkKTtlLnRlcm1pbmF0ZSgpfXJldHVybiBQcm9taXNlLmFsbCh0KS50aGVuKChmdW5jdGlvbigpe2suZGVzdHJveSgpO2s9bnVsbH0pKX0pKTtrLm9uKCJSZWFkeSIsKGZ1bmN0aW9uIHdwaFJlYWR5KHQpeyFmdW5jdGlvbiBzZXR1cERvYyhlKXtmdW5jdGlvbiBvblN1Y2Nlc3MoZSl7ZW5zdXJlTm90VGVybWluYXRlZCgpO2suc2VuZCgiR2V0RG9jIix7cGRmSW5mbzplfSl9ZnVuY3Rpb24gb25GYWlsdXJlKGUpe2Vuc3VyZU5vdFRlcm1pbmF0ZWQoKTtpZihlIGluc3RhbmNlb2Ygci5QYXNzd29yZEV4Y2VwdGlvbil7Y29uc3QgdD1uZXcgV29ya2VyVGFzayhgUGFzc3dvcmRFeGNlcHRpb246IHJlc3BvbnNlICR7ZS5jb2RlfWApO3N0YXJ0V29ya2VyVGFzayh0KTtrLnNlbmRXaXRoUHJvbWlzZSgiUGFzc3dvcmRSZXF1ZXN0IixlKS50aGVuKChmdW5jdGlvbih7cGFzc3dvcmQ6ZX0pe2ZpbmlzaFdvcmtlclRhc2sodCk7YS51cGRhdGVQYXNzd29yZChlKTtwZGZNYW5hZ2VyUmVhZHkoKX0pKS5jYXRjaCgoZnVuY3Rpb24oKXtmaW5pc2hXb3JrZXJUYXNrKHQpO2suc2VuZCgiRG9jRXhjZXB0aW9uIixlKX0pKX1lbHNlIGUgaW5zdGFuY2VvZiByLkludmFsaWRQREZFeGNlcHRpb258fGUgaW5zdGFuY2VvZiByLk1pc3NpbmdQREZFeGNlcHRpb258fGUgaW5zdGFuY2VvZiByLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbnx8ZSBpbnN0YW5jZW9mIHIuVW5rbm93bkVycm9yRXhjZXB0aW9uP2suc2VuZCgiRG9jRXhjZXB0aW9uIixlKTprLnNlbmQoIkRvY0V4Y2VwdGlvbiIsbmV3IHIuVW5rbm93bkVycm9yRXhjZXB0aW9uKGUubWVzc2FnZSxlLnRvU3RyaW5nKCkpKX1mdW5jdGlvbiBwZGZNYW5hZ2VyUmVhZHkoKXtlbnN1cmVOb3RUZXJtaW5hdGVkKCk7bG9hZERvY3VtZW50KCExKS50aGVuKG9uU3VjY2VzcywoZnVuY3Rpb24oZSl7ZW5zdXJlTm90VGVybWluYXRlZCgpO2lmKGUgaW5zdGFuY2VvZiBpLlhSZWZQYXJzZUV4Y2VwdGlvbil7YS5yZXF1ZXN0TG9hZGVkU3RyZWFtKCk7YS5vbkxvYWRlZFN0cmVhbSgpLnRoZW4oKGZ1bmN0aW9uKCl7ZW5zdXJlTm90VGVybWluYXRlZCgpO2xvYWREb2N1bWVudCghMCkudGhlbihvblN1Y2Nlc3Msb25GYWlsdXJlKX0pKX1lbHNlIG9uRmFpbHVyZShlKX0pKX1lbnN1cmVOb3RUZXJtaW5hdGVkKCk7Z2V0UGRmTWFuYWdlcihlLHttYXhJbWFnZVNpemU6ZS5tYXhJbWFnZVNpemUsZGlzYWJsZUZvbnRGYWNlOmUuZGlzYWJsZUZvbnRGYWNlLGlnbm9yZUVycm9yczplLmlnbm9yZUVycm9ycyxpc0V2YWxTdXBwb3J0ZWQ6ZS5pc0V2YWxTdXBwb3J0ZWQsZm9udEV4dHJhUHJvcGVydGllczplLmZvbnRFeHRyYVByb3BlcnRpZXMsdXNlU3lzdGVtRm9udHM6ZS51c2VTeXN0ZW1Gb250cyxjTWFwVXJsOmUuY01hcFVybCxzdGFuZGFyZEZvbnREYXRhVXJsOmUuc3RhbmRhcmRGb250RGF0YVVybH0sZS5lbmFibGVYZmEpLnRoZW4oKGZ1bmN0aW9uKGUpe2lmKGQpe2UudGVybWluYXRlKG5ldyByLkFib3J0RXhjZXB0aW9uKCJXb3JrZXIgd2FzIHRlcm1pbmF0ZWQuIikpO3Rocm93IG5ldyBFcnJvcigiV29ya2VyIHdhcyB0ZXJtaW5hdGVkIil9YT1lO2Eub25Mb2FkZWRTdHJlYW0oKS50aGVuKChmdW5jdGlvbihlKXtrLnNlbmQoIkRhdGFMb2FkZWQiLHtsZW5ndGg6ZS5ieXRlcy5ieXRlTGVuZ3RofSl9KSl9KSkudGhlbihwZGZNYW5hZ2VyUmVhZHksb25GYWlsdXJlKX0oZSk7ZT1udWxsfSkpO3JldHVybiB4fXN0YXRpYyBpbml0aWFsaXplRnJvbVBvcnQoZSl7Y29uc3QgdD1uZXcgaC5NZXNzYWdlSGFuZGxlcigid29ya2VyIiwibWFpbiIsZSk7V29ya2VyTWVzc2FnZUhhbmRsZXIuc2V0dXAodCxlKTt0LnNlbmQoInJlYWR5IixudWxsKX19dC5Xb3JrZXJNZXNzYWdlSGFuZGxlcj1Xb3JrZXJNZXNzYWdlSGFuZGxlcjsidW5kZWZpbmVkIj09dHlwZW9mIHdpbmRvdyYmIWwuaXNOb2RlSlMmJiJ1bmRlZmluZWQiIT10eXBlb2Ygc2VsZiYmZnVuY3Rpb24gaXNNZXNzYWdlUG9ydChlKXtyZXR1cm4iZnVuY3Rpb24iPT10eXBlb2YgZS5wb3N0TWVzc2FnZSYmIm9ubWVzc2FnZSJpbiBlfShzZWxmKSYmV29ya2VyTWVzc2FnZUhhbmRsZXIuaW5pdGlhbGl6ZUZyb21Qb3J0KHNlbGYpfSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuVmVyYm9zaXR5TGV2ZWw9dC5VdGlsPXQuVW5rbm93bkVycm9yRXhjZXB0aW9uPXQuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uPXQuVU5TVVBQT1JURURfRkVBVFVSRVM9dC5UZXh0UmVuZGVyaW5nTW9kZT10LlN0cmVhbVR5cGU9dC5SZW5kZXJpbmdJbnRlbnRGbGFnPXQuUGVybWlzc2lvbkZsYWc9dC5QYXNzd29yZFJlc3BvbnNlcz10LlBhc3N3b3JkRXhjZXB0aW9uPXQuUGFnZUFjdGlvbkV2ZW50VHlwZT10Lk9QUz10Lk1pc3NpbmdQREZFeGNlcHRpb249dC5MSU5FX0ZBQ1RPUj10LkxJTkVfREVTQ0VOVF9GQUNUT1I9dC5JbnZhbGlkUERGRXhjZXB0aW9uPXQuSW1hZ2VLaW5kPXQuSURFTlRJVFlfTUFUUklYPXQuRm9ybWF0RXJyb3I9dC5Gb250VHlwZT10LkZlYXR1cmVUZXN0PXQuRk9OVF9JREVOVElUWV9NQVRSSVg9dC5Eb2N1bWVudEFjdGlvbkV2ZW50VHlwZT10LkNNYXBDb21wcmVzc2lvblR5cGU9dC5CYXNlRXhjZXB0aW9uPXQuQW5ub3RhdGlvblR5cGU9dC5Bbm5vdGF0aW9uU3RhdGVNb2RlbFR5cGU9dC5Bbm5vdGF0aW9uUmV2aWV3U3RhdGU9dC5Bbm5vdGF0aW9uUmVwbHlUeXBlPXQuQW5ub3RhdGlvbk1vZGU9dC5Bbm5vdGF0aW9uTWFya2VkU3RhdGU9dC5Bbm5vdGF0aW9uRmxhZz10LkFubm90YXRpb25GaWVsZEZsYWc9dC5Bbm5vdGF0aW9uRWRpdG9yVHlwZT10LkFubm90YXRpb25FZGl0b3JQcmVmaXg9dC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZT10LkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGU9dC5Bbm5vdGF0aW9uQWN0aW9uRXZlbnRUeXBlPXQuQWJvcnRFeGNlcHRpb249dm9pZCAwO3QuYXJyYXlCeXRlTGVuZ3RoPWFycmF5Qnl0ZUxlbmd0aDt0LmFycmF5c1RvQnl0ZXM9ZnVuY3Rpb24gYXJyYXlzVG9CeXRlcyhlKXtjb25zdCB0PWUubGVuZ3RoO2lmKDE9PT10JiZlWzBdaW5zdGFuY2VvZiBVaW50OEFycmF5KXJldHVybiBlWzBdO2xldCBhPTA7Zm9yKGxldCByPTA7cjx0O3IrKylhKz1hcnJheUJ5dGVMZW5ndGgoZVtyXSk7bGV0IHI9MDtjb25zdCBuPW5ldyBVaW50OEFycmF5KGEpO2ZvcihsZXQgYT0wO2E8dDthKyspe2xldCB0PWVbYV07dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fCh0PSJzdHJpbmciPT10eXBlb2YgdD9zdHJpbmdUb0J5dGVzKHQpOm5ldyBVaW50OEFycmF5KHQpKTtjb25zdCBpPXQuYnl0ZUxlbmd0aDtuLnNldCh0LHIpO3IrPWl9cmV0dXJuIG59O3QuYXNzZXJ0PWZ1bmN0aW9uIGFzc2VydChlLHQpe2V8fHVucmVhY2hhYmxlKHQpfTt0LmJ5dGVzVG9TdHJpbmc9ZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhlKXsib2JqZWN0Ij09dHlwZW9mIGUmJm51bGwhPT1lJiZ2b2lkIDAhPT1lLmxlbmd0aHx8dW5yZWFjaGFibGUoIkludmFsaWQgYXJndW1lbnQgZm9yIGJ5dGVzVG9TdHJpbmciKTtjb25zdCB0PWUubGVuZ3RoLGE9ODE5MjtpZih0PGEpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxlKTtjb25zdCByPVtdO2ZvcihsZXQgbj0wO248dDtuKz1hKXtjb25zdCBpPU1hdGgubWluKG4rYSx0KSxzPWUuc3ViYXJyYXkobixpKTtyLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLHMpKX1yZXR1cm4gci5qb2luKCIiKX07dC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eT1mdW5jdGlvbiBjcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSgpe2NvbnN0IGU9T2JqZWN0LmNyZWF0ZShudWxsKTtsZXQgdD0hMTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwic2V0dGxlZCIse2dldDooKT0+dH0pO2UucHJvbWlzZT1uZXcgUHJvbWlzZSgoZnVuY3Rpb24oYSxyKXtlLnJlc29sdmU9ZnVuY3Rpb24oZSl7dD0hMDthKGUpfTtlLnJlamVjdD1mdW5jdGlvbihlKXt0PSEwO3IoZSl9fSkpO3JldHVybiBlfTt0LmNyZWF0ZVZhbGlkQWJzb2x1dGVVcmw9ZnVuY3Rpb24gY3JlYXRlVmFsaWRBYnNvbHV0ZVVybChlLHQ9bnVsbCxhPW51bGwpe2lmKCFlKXJldHVybiBudWxsO3RyeXtpZihhJiYic3RyaW5nIj09dHlwZW9mIGUpe2lmKGEuYWRkRGVmYXVsdFByb3RvY29sJiZlLnN0YXJ0c1dpdGgoInd3dy4iKSl7Y29uc3QgdD1lLm1hdGNoKC9cLi9nKTt0JiZ0Lmxlbmd0aD49MiYmKGU9YGh0dHA6Ly8ke2V9YCl9aWYoYS50cnlDb252ZXJ0RW5jb2RpbmcpdHJ5e2U9c3RyaW5nVG9VVEY4U3RyaW5nKGUpfWNhdGNoKGUpe319Y29uc3Qgcj10P25ldyBVUkwoZSx0KTpuZXcgVVJMKGUpO2lmKGZ1bmN0aW9uIF9pc1ZhbGlkUHJvdG9jb2woZSl7aWYoIWUpcmV0dXJuITE7c3dpdGNoKGUucHJvdG9jb2wpe2Nhc2UiaHR0cDoiOmNhc2UiaHR0cHM6IjpjYXNlImZ0cDoiOmNhc2UibWFpbHRvOiI6Y2FzZSJ0ZWw6IjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX0ocikpcmV0dXJuIHJ9Y2F0Y2goZSl7fXJldHVybiBudWxsfTt0LmVzY2FwZVN0cmluZz1mdW5jdGlvbiBlc2NhcGVTdHJpbmcoZSl7cmV0dXJuIGUucmVwbGFjZSgvKFsoKVxcXG5ccl0pL2csKGU9PiJcbiI9PT1lPyJcXG4iOiJcciI9PT1lPyJcXHIiOmBcXCR7ZX1gKSl9O3QuZ2V0TW9kaWZpY2F0aW9uRGF0ZT1mdW5jdGlvbiBnZXRNb2RpZmljYXRpb25EYXRlKGU9bmV3IERhdGUpe3JldHVybltlLmdldFVUQ0Z1bGxZZWFyKCkudG9TdHJpbmcoKSwoZS5nZXRVVENNb250aCgpKzEpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwiMCIpLGUuZ2V0VVRDRGF0ZSgpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwiMCIpLGUuZ2V0VVRDSG91cnMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIjAiKSxlLmdldFVUQ01pbnV0ZXMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIjAiKSxlLmdldFVUQ1NlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIjAiKV0uam9pbigiIil9O3QuZ2V0VmVyYm9zaXR5TGV2ZWw9ZnVuY3Rpb24gZ2V0VmVyYm9zaXR5TGV2ZWwoKXtyZXR1cm4gbn07dC5pbmZvPWZ1bmN0aW9uIGluZm8oZSl7bj49ci5JTkZPUyYmY29uc29sZS5sb2coYEluZm86ICR7ZX1gKX07dC5pc0FycmF5QnVmZmVyPWZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIoZSl7cmV0dXJuIm9iamVjdCI9PXR5cGVvZiBlJiZudWxsIT09ZSYmdm9pZCAwIT09ZS5ieXRlTGVuZ3RofTt0LmlzQXJyYXlFcXVhbD1mdW5jdGlvbiBpc0FycmF5RXF1YWwoZSx0KXtpZihlLmxlbmd0aCE9PXQubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgYT0wLHI9ZS5sZW5ndGg7YTxyO2ErKylpZihlW2FdIT09dFthXSlyZXR1cm4hMTtyZXR1cm4hMH07dC5pc0FzY2lpPWZ1bmN0aW9uIGlzQXNjaWkoZSl7cmV0dXJuL15bXHgwMC1ceDdGXSokLy50ZXN0KGUpfTt0Lm9iamVjdEZyb21NYXA9ZnVuY3Rpb24gb2JqZWN0RnJvbU1hcChlKXtjb25zdCB0PU9iamVjdC5jcmVhdGUobnVsbCk7Zm9yKGNvbnN0W2Escl1vZiBlKXRbYV09cjtyZXR1cm4gdH07dC5vYmplY3RTaXplPWZ1bmN0aW9uIG9iamVjdFNpemUoZSl7cmV0dXJuIE9iamVjdC5rZXlzKGUpLmxlbmd0aH07dC5zZXRWZXJib3NpdHlMZXZlbD1mdW5jdGlvbiBzZXRWZXJib3NpdHlMZXZlbChlKXtOdW1iZXIuaXNJbnRlZ2VyKGUpJiYobj1lKX07dC5zaGFkb3c9c2hhZG93O3Quc3RyaW5nMzI9ZnVuY3Rpb24gc3RyaW5nMzIoZSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZT4+MjQmMjU1LGU+PjE2JjI1NSxlPj44JjI1NSwyNTUmZSl9O3Quc3RyaW5nVG9CeXRlcz1zdHJpbmdUb0J5dGVzO3Quc3RyaW5nVG9QREZTdHJpbmc9ZnVuY3Rpb24gc3RyaW5nVG9QREZTdHJpbmcoZSl7aWYoZVswXT49IsOvIil7bGV0IHQ7IsO+Ij09PWVbMF0mJiLDvyI9PT1lWzFdP3Q9InV0Zi0xNmJlIjoiw78iPT09ZVswXSYmIsO+Ij09PWVbMV0/dD0idXRmLTE2bGUiOiLDryI9PT1lWzBdJiYiwrsiPT09ZVsxXSYmIsK/Ij09PWVbMl0mJih0PSJ1dGYtOCIpO2lmKHQpdHJ5e2NvbnN0IGE9bmV3IFRleHREZWNvZGVyKHQse2ZhdGFsOiEwfSkscj1zdHJpbmdUb0J5dGVzKGUpO3JldHVybiBhLmRlY29kZShyKX1jYXRjaChlKXt3YXJuKGBzdHJpbmdUb1BERlN0cmluZzogIiR7ZX0iLmApfX1jb25zdCB0PVtdO2ZvcihsZXQgYT0wLHI9ZS5sZW5ndGg7YTxyO2ErKyl7Y29uc3Qgcj1vW2UuY2hhckNvZGVBdChhKV07dC5wdXNoKHI/U3RyaW5nLmZyb21DaGFyQ29kZShyKTplLmNoYXJBdChhKSl9cmV0dXJuIHQuam9pbigiIil9O3Quc3RyaW5nVG9VVEYxNkJFU3RyaW5nPWZ1bmN0aW9uIHN0cmluZ1RvVVRGMTZCRVN0cmluZyhlKXtjb25zdCB0PVsiw77DvyJdO2ZvcihsZXQgYT0wLHI9ZS5sZW5ndGg7YTxyO2ErKyl7Y29uc3Qgcj1lLmNoYXJDb2RlQXQoYSk7dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUocj4+OCYyNTUpLFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1JnIpKX1yZXR1cm4gdC5qb2luKCIiKX07dC5zdHJpbmdUb1VURjhTdHJpbmc9c3RyaW5nVG9VVEY4U3RyaW5nO3QudW5yZWFjaGFibGU9dW5yZWFjaGFibGU7dC51dGY4U3RyaW5nVG9TdHJpbmc9ZnVuY3Rpb24gdXRmOFN0cmluZ1RvU3RyaW5nKGUpe3JldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoZSkpfTt0Lndhcm49d2FybjthKDMpO3QuSURFTlRJVFlfTUFUUklYPVsxLDAsMCwxLDAsMF07dC5GT05UX0lERU5USVRZX01BVFJJWD1bLjAwMSwwLDAsLjAwMSwwLDBdO3QuTElORV9GQUNUT1I9MS4zNTt0LkxJTkVfREVTQ0VOVF9GQUNUT1I9LjM1O3QuUmVuZGVyaW5nSW50ZW50RmxhZz17QU5ZOjEsRElTUExBWToyLFBSSU5UOjQsQU5OT1RBVElPTlNfRk9STVM6MTYsQU5OT1RBVElPTlNfU1RPUkFHRTozMixBTk5PVEFUSU9OU19ESVNBQkxFOjY0LE9QTElTVDoyNTZ9O3QuQW5ub3RhdGlvbk1vZGU9e0RJU0FCTEU6MCxFTkFCTEU6MSxFTkFCTEVfRk9STVM6MixFTkFCTEVfU1RPUkFHRTozfTt0LkFubm90YXRpb25FZGl0b3JQcmVmaXg9InBkZmpzX2ludGVybmFsX2VkaXRvcl8iO3QuQW5ub3RhdGlvbkVkaXRvclR5cGU9e0RJU0FCTEU6LTEsTk9ORTowLEZSRUVURVhUOjMsSU5LOjE1fTt0LkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlPXtGUkVFVEVYVF9TSVpFOjEsRlJFRVRFWFRfQ09MT1I6MixGUkVFVEVYVF9PUEFDSVRZOjMsSU5LX0NPTE9SOjExLElOS19USElDS05FU1M6MTIsSU5LX09QQUNJVFk6MTN9O3QuUGVybWlzc2lvbkZsYWc9e1BSSU5UOjQsTU9ESUZZX0NPTlRFTlRTOjgsQ09QWToxNixNT0RJRllfQU5OT1RBVElPTlM6MzIsRklMTF9JTlRFUkFDVElWRV9GT1JNUzoyNTYsQ09QWV9GT1JfQUNDRVNTSUJJTElUWTo1MTIsQVNTRU1CTEU6MTAyNCxQUklOVF9ISUdIX1FVQUxJVFk6MjA0OH07dC5UZXh0UmVuZGVyaW5nTW9kZT17RklMTDowLFNUUk9LRToxLEZJTExfU1RST0tFOjIsSU5WSVNJQkxFOjMsRklMTF9BRERfVE9fUEFUSDo0LFNUUk9LRV9BRERfVE9fUEFUSDo1LEZJTExfU1RST0tFX0FERF9UT19QQVRIOjYsQUREX1RPX1BBVEg6NyxGSUxMX1NUUk9LRV9NQVNLOjMsQUREX1RPX1BBVEhfRkxBRzo0fTt0LkltYWdlS2luZD17R1JBWVNDQUxFXzFCUFA6MSxSR0JfMjRCUFA6MixSR0JBXzMyQlBQOjN9O3QuQW5ub3RhdGlvblR5cGU9e1RFWFQ6MSxMSU5LOjIsRlJFRVRFWFQ6MyxMSU5FOjQsU1FVQVJFOjUsQ0lSQ0xFOjYsUE9MWUdPTjo3LFBPTFlMSU5FOjgsSElHSExJR0hUOjksVU5ERVJMSU5FOjEwLFNRVUlHR0xZOjExLFNUUklLRU9VVDoxMixTVEFNUDoxMyxDQVJFVDoxNCxJTks6MTUsUE9QVVA6MTYsRklMRUFUVEFDSE1FTlQ6MTcsU09VTkQ6MTgsTU9WSUU6MTksV0lER0VUOjIwLFNDUkVFTjoyMSxQUklOVEVSTUFSSzoyMixUUkFQTkVUOjIzLFdBVEVSTUFSSzoyNCxUSFJFRUQ6MjUsUkVEQUNUOjI2fTt0LkFubm90YXRpb25TdGF0ZU1vZGVsVHlwZT17TUFSS0VEOiJNYXJrZWQiLFJFVklFVzoiUmV2aWV3In07dC5Bbm5vdGF0aW9uTWFya2VkU3RhdGU9e01BUktFRDoiTWFya2VkIixVTk1BUktFRDoiVW5tYXJrZWQifTt0LkFubm90YXRpb25SZXZpZXdTdGF0ZT17QUNDRVBURUQ6IkFjY2VwdGVkIixSRUpFQ1RFRDoiUmVqZWN0ZWQiLENBTkNFTExFRDoiQ2FuY2VsbGVkIixDT01QTEVURUQ6IkNvbXBsZXRlZCIsTk9ORToiTm9uZSJ9O3QuQW5ub3RhdGlvblJlcGx5VHlwZT17R1JPVVA6Ikdyb3VwIixSRVBMWToiUiJ9O3QuQW5ub3RhdGlvbkZsYWc9e0lOVklTSUJMRToxLEhJRERFTjoyLFBSSU5UOjQsTk9aT09NOjgsTk9ST1RBVEU6MTYsTk9WSUVXOjMyLFJFQURPTkxZOjY0LExPQ0tFRDoxMjgsVE9HR0xFTk9WSUVXOjI1NixMT0NLRURDT05URU5UUzo1MTJ9O3QuQW5ub3RhdGlvbkZpZWxkRmxhZz17UkVBRE9OTFk6MSxSRVFVSVJFRDoyLE5PRVhQT1JUOjQsTVVMVElMSU5FOjQwOTYsUEFTU1dPUkQ6ODE5MixOT1RPR0dMRVRPT0ZGOjE2Mzg0LFJBRElPOjMyNzY4LFBVU0hCVVRUT046NjU1MzYsQ09NQk86MTMxMDcyLEVESVQ6MjYyMTQ0LFNPUlQ6NTI0Mjg4LEZJTEVTRUxFQ1Q6MTA0ODU3NixNVUxUSVNFTEVDVDoyMDk3MTUyLERPTk9UU1BFTExDSEVDSzo0MTk0MzA0LERPTk9UU0NST0xMOjgzODg2MDgsQ09NQjoxNjc3NzIxNixSSUNIVEVYVDozMzU1NDQzMixSQURJT1NJTlVOSVNPTjozMzU1NDQzMixDT01NSVRPTlNFTENIQU5HRTo2NzEwODg2NH07dC5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlPXtTT0xJRDoxLERBU0hFRDoyLEJFVkVMRUQ6MyxJTlNFVDo0LFVOREVSTElORTo1fTt0LkFubm90YXRpb25BY3Rpb25FdmVudFR5cGU9e0U6Ik1vdXNlIEVudGVyIixYOiJNb3VzZSBFeGl0IixEOiJNb3VzZSBEb3duIixVOiJNb3VzZSBVcCIsRm86IkZvY3VzIixCbDoiQmx1ciIsUE86IlBhZ2VPcGVuIixQQzoiUGFnZUNsb3NlIixQVjoiUGFnZVZpc2libGUiLFBJOiJQYWdlSW52aXNpYmxlIixLOiJLZXlzdHJva2UiLEY6IkZvcm1hdCIsVjoiVmFsaWRhdGUiLEM6IkNhbGN1bGF0ZSJ9O3QuRG9jdW1lbnRBY3Rpb25FdmVudFR5cGU9e1dDOiJXaWxsQ2xvc2UiLFdTOiJXaWxsU2F2ZSIsRFM6IkRpZFNhdmUiLFdQOiJXaWxsUHJpbnQiLERQOiJEaWRQcmludCJ9O3QuUGFnZUFjdGlvbkV2ZW50VHlwZT17TzoiUGFnZU9wZW4iLEM6IlBhZ2VDbG9zZSJ9O3QuU3RyZWFtVHlwZT17VU5LTk9XTjoiVU5LTk9XTiIsRkxBVEU6IkZMQVRFIixMWlc6IkxaVyIsRENUOiJEQ1QiLEpQWDoiSlBYIixKQklHOiJKQklHIixBODU6IkE4NSIsQUhYOiJBSFgiLENDRjoiQ0NGIixSTFg6IlJMWCJ9O3QuRm9udFR5cGU9e1VOS05PV046IlVOS05PV04iLFRZUEUxOiJUWVBFMSIsVFlQRTFTVEFOREFSRDoiVFlQRTFTVEFOREFSRCIsVFlQRTFDOiJUWVBFMUMiLENJREZPTlRUWVBFMDoiQ0lERk9OVFRZUEUwIixDSURGT05UVFlQRTBDOiJDSURGT05UVFlQRTBDIixUUlVFVFlQRToiVFJVRVRZUEUiLENJREZPTlRUWVBFMjoiQ0lERk9OVFRZUEUyIixUWVBFMzoiVFlQRTMiLE9QRU5UWVBFOiJPUEVOVFlQRSIsVFlQRTA6IlRZUEUwIixNTVRZUEUxOiJNTVRZUEUxIn07Y29uc3Qgcj17RVJST1JTOjAsV0FSTklOR1M6MSxJTkZPUzo1fTt0LlZlcmJvc2l0eUxldmVsPXI7dC5DTWFwQ29tcHJlc3Npb25UeXBlPXtOT05FOjAsQklOQVJZOjEsU1RSRUFNOjJ9O3QuT1BTPXtkZXBlbmRlbmN5OjEsc2V0TGluZVdpZHRoOjIsc2V0TGluZUNhcDozLHNldExpbmVKb2luOjQsc2V0TWl0ZXJMaW1pdDo1LHNldERhc2g6NixzZXRSZW5kZXJpbmdJbnRlbnQ6NyxzZXRGbGF0bmVzczo4LHNldEdTdGF0ZTo5LHNhdmU6MTAscmVzdG9yZToxMSx0cmFuc2Zvcm06MTIsbW92ZVRvOjEzLGxpbmVUbzoxNCxjdXJ2ZVRvOjE1LGN1cnZlVG8yOjE2LGN1cnZlVG8zOjE3LGNsb3NlUGF0aDoxOCxyZWN0YW5nbGU6MTksc3Ryb2tlOjIwLGNsb3NlU3Ryb2tlOjIxLGZpbGw6MjIsZW9GaWxsOjIzLGZpbGxTdHJva2U6MjQsZW9GaWxsU3Ryb2tlOjI1LGNsb3NlRmlsbFN0cm9rZToyNixjbG9zZUVPRmlsbFN0cm9rZToyNyxlbmRQYXRoOjI4LGNsaXA6MjksZW9DbGlwOjMwLGJlZ2luVGV4dDozMSxlbmRUZXh0OjMyLHNldENoYXJTcGFjaW5nOjMzLHNldFdvcmRTcGFjaW5nOjM0LHNldEhTY2FsZTozNSxzZXRMZWFkaW5nOjM2LHNldEZvbnQ6Mzcsc2V0VGV4dFJlbmRlcmluZ01vZGU6Mzgsc2V0VGV4dFJpc2U6MzksbW92ZVRleHQ6NDAsc2V0TGVhZGluZ01vdmVUZXh0OjQxLHNldFRleHRNYXRyaXg6NDIsbmV4dExpbmU6NDMsc2hvd1RleHQ6NDQsc2hvd1NwYWNlZFRleHQ6NDUsbmV4dExpbmVTaG93VGV4dDo0NixuZXh0TGluZVNldFNwYWNpbmdTaG93VGV4dDo0NyxzZXRDaGFyV2lkdGg6NDgsc2V0Q2hhcldpZHRoQW5kQm91bmRzOjQ5LHNldFN0cm9rZUNvbG9yU3BhY2U6NTAsc2V0RmlsbENvbG9yU3BhY2U6NTEsc2V0U3Ryb2tlQ29sb3I6NTIsc2V0U3Ryb2tlQ29sb3JOOjUzLHNldEZpbGxDb2xvcjo1NCxzZXRGaWxsQ29sb3JOOjU1LHNldFN0cm9rZUdyYXk6NTYsc2V0RmlsbEdyYXk6NTcsc2V0U3Ryb2tlUkdCQ29sb3I6NTgsc2V0RmlsbFJHQkNvbG9yOjU5LHNldFN0cm9rZUNNWUtDb2xvcjo2MCxzZXRGaWxsQ01ZS0NvbG9yOjYxLHNoYWRpbmdGaWxsOjYyLGJlZ2luSW5saW5lSW1hZ2U6NjMsYmVnaW5JbWFnZURhdGE6NjQsZW5kSW5saW5lSW1hZ2U6NjUscGFpbnRYT2JqZWN0OjY2LG1hcmtQb2ludDo2NyxtYXJrUG9pbnRQcm9wczo2OCxiZWdpbk1hcmtlZENvbnRlbnQ6NjksYmVnaW5NYXJrZWRDb250ZW50UHJvcHM6NzAsZW5kTWFya2VkQ29udGVudDo3MSxiZWdpbkNvbXBhdDo3MixlbmRDb21wYXQ6NzMscGFpbnRGb3JtWE9iamVjdEJlZ2luOjc0LHBhaW50Rm9ybVhPYmplY3RFbmQ6NzUsYmVnaW5Hcm91cDo3NixlbmRHcm91cDo3NyxiZWdpbkFubm90YXRpb25zOjc4LGVuZEFubm90YXRpb25zOjc5LGJlZ2luQW5ub3RhdGlvbjo4MCxlbmRBbm5vdGF0aW9uOjgxLHBhaW50SnBlZ1hPYmplY3Q6ODIscGFpbnRJbWFnZU1hc2tYT2JqZWN0OjgzLHBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwOjg0LHBhaW50SW1hZ2VYT2JqZWN0Ojg1LHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0Ojg2LHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXA6ODcscGFpbnRJbWFnZVhPYmplY3RSZXBlYXQ6ODgscGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0Ojg5LHBhaW50U29saWRDb2xvckltYWdlTWFzazo5MCxjb25zdHJ1Y3RQYXRoOjkxfTt0LlVOU1VQUE9SVEVEX0ZFQVRVUkVTPXt1bmtub3duOiJ1bmtub3duIixmb3JtczoiZm9ybXMiLGphdmFTY3JpcHQ6ImphdmFTY3JpcHQiLHNpZ25hdHVyZXM6InNpZ25hdHVyZXMiLHNtYXNrOiJzbWFzayIsc2hhZGluZ1BhdHRlcm46InNoYWRpbmdQYXR0ZXJuIixmb250OiJmb250IixlcnJvclRpbGluZ1BhdHRlcm46ImVycm9yVGlsaW5nUGF0dGVybiIsZXJyb3JFeHRHU3RhdGU6ImVycm9yRXh0R1N0YXRlIixlcnJvclhPYmplY3Q6ImVycm9yWE9iamVjdCIsZXJyb3JGb250TG9hZFR5cGUzOiJlcnJvckZvbnRMb2FkVHlwZTMiLGVycm9yRm9udFN0YXRlOiJlcnJvckZvbnRTdGF0ZSIsZXJyb3JGb250TWlzc2luZzoiZXJyb3JGb250TWlzc2luZyIsZXJyb3JGb250VHJhbnNsYXRlOiJlcnJvckZvbnRUcmFuc2xhdGUiLGVycm9yQ29sb3JTcGFjZToiZXJyb3JDb2xvclNwYWNlIixlcnJvck9wZXJhdG9yTGlzdDoiZXJyb3JPcGVyYXRvckxpc3QiLGVycm9yRm9udFRvVW5pY29kZToiZXJyb3JGb250VG9Vbmljb2RlIixlcnJvckZvbnRMb2FkTmF0aXZlOiJlcnJvckZvbnRMb2FkTmF0aXZlIixlcnJvckZvbnRCdWlsZFBhdGg6ImVycm9yRm9udEJ1aWxkUGF0aCIsZXJyb3JGb250R2V0UGF0aDoiZXJyb3JGb250R2V0UGF0aCIsZXJyb3JNYXJrZWRDb250ZW50OiJlcnJvck1hcmtlZENvbnRlbnQiLGVycm9yQ29udGVudFN1YlN0cmVhbToiZXJyb3JDb250ZW50U3ViU3RyZWFtIn07dC5QYXNzd29yZFJlc3BvbnNlcz17TkVFRF9QQVNTV09SRDoxLElOQ09SUkVDVF9QQVNTV09SRDoyfTtsZXQgbj1yLldBUk5JTkdTO2Z1bmN0aW9uIHdhcm4oZSl7bj49ci5XQVJOSU5HUyYmY29uc29sZS5sb2coYFdhcm5pbmc6ICR7ZX1gKX1mdW5jdGlvbiB1bnJlYWNoYWJsZShlKXt0aHJvdyBuZXcgRXJyb3IoZSl9ZnVuY3Rpb24gc2hhZG93KGUsdCxhKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTphLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiExfSk7cmV0dXJuIGF9Y29uc3QgaT1mdW5jdGlvbiBCYXNlRXhjZXB0aW9uQ2xvc3VyZSgpe2Z1bmN0aW9uIEJhc2VFeGNlcHRpb24oZSx0KXt0aGlzLmNvbnN0cnVjdG9yPT09QmFzZUV4Y2VwdGlvbiYmdW5yZWFjaGFibGUoIkNhbm5vdCBpbml0aWFsaXplIEJhc2VFeGNlcHRpb24uIik7dGhpcy5tZXNzYWdlPWU7dGhpcy5uYW1lPXR9QmFzZUV4Y2VwdGlvbi5wcm90b3R5cGU9bmV3IEVycm9yO0Jhc2VFeGNlcHRpb24uY29uc3RydWN0b3I9QmFzZUV4Y2VwdGlvbjtyZXR1cm4gQmFzZUV4Y2VwdGlvbn0oKTt0LkJhc2VFeGNlcHRpb249aTt0LlBhc3N3b3JkRXhjZXB0aW9uPWNsYXNzIFBhc3N3b3JkRXhjZXB0aW9uIGV4dGVuZHMgaXtjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKGUsIlBhc3N3b3JkRXhjZXB0aW9uIik7dGhpcy5jb2RlPXR9fTt0LlVua25vd25FcnJvckV4Y2VwdGlvbj1jbGFzcyBVbmtub3duRXJyb3JFeGNlcHRpb24gZXh0ZW5kcyBpe2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoZSwiVW5rbm93bkVycm9yRXhjZXB0aW9uIik7dGhpcy5kZXRhaWxzPXR9fTt0LkludmFsaWRQREZFeGNlcHRpb249Y2xhc3MgSW52YWxpZFBERkV4Y2VwdGlvbiBleHRlbmRzIGl7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwiSW52YWxpZFBERkV4Y2VwdGlvbiIpfX07dC5NaXNzaW5nUERGRXhjZXB0aW9uPWNsYXNzIE1pc3NpbmdQREZFeGNlcHRpb24gZXh0ZW5kcyBpe2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsIk1pc3NpbmdQREZFeGNlcHRpb24iKX19O3QuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uPWNsYXNzIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiBleHRlbmRzIGl7Y29uc3RydWN0b3IoZSx0KXtzdXBlcihlLCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24iKTt0aGlzLnN0YXR1cz10fX07dC5Gb3JtYXRFcnJvcj1jbGFzcyBGb3JtYXRFcnJvciBleHRlbmRzIGl7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwiRm9ybWF0RXJyb3IiKX19O3QuQWJvcnRFeGNlcHRpb249Y2xhc3MgQWJvcnRFeGNlcHRpb24gZXh0ZW5kcyBpe2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsIkFib3J0RXhjZXB0aW9uIil9fTtmdW5jdGlvbiBzdHJpbmdUb0J5dGVzKGUpeyJzdHJpbmciIT10eXBlb2YgZSYmdW5yZWFjaGFibGUoIkludmFsaWQgYXJndW1lbnQgZm9yIHN0cmluZ1RvQnl0ZXMiKTtjb25zdCB0PWUubGVuZ3RoLGE9bmV3IFVpbnQ4QXJyYXkodCk7Zm9yKGxldCByPTA7cjx0OysrcilhW3JdPTI1NSZlLmNoYXJDb2RlQXQocik7cmV0dXJuIGF9ZnVuY3Rpb24gYXJyYXlCeXRlTGVuZ3RoKGUpe2lmKHZvaWQgMCE9PWUubGVuZ3RoKXJldHVybiBlLmxlbmd0aDtpZih2b2lkIDAhPT1lLmJ5dGVMZW5ndGgpcmV0dXJuIGUuYnl0ZUxlbmd0aDt1bnJlYWNoYWJsZSgiSW52YWxpZCBhcmd1bWVudCBmb3IgYXJyYXlCeXRlTGVuZ3RoIil9dC5GZWF0dXJlVGVzdD1jbGFzcyBGZWF0dXJlVGVzdHtzdGF0aWMgZ2V0IGlzTGl0dGxlRW5kaWFuKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJpc0xpdHRsZUVuZGlhbiIsZnVuY3Rpb24gaXNMaXR0bGVFbmRpYW4oKXtjb25zdCBlPW5ldyBVaW50OEFycmF5KDQpO2VbMF09MTtyZXR1cm4gMT09PW5ldyBVaW50MzJBcnJheShlLmJ1ZmZlciwwLDEpWzBdfSgpKX1zdGF0aWMgZ2V0IGlzRXZhbFN1cHBvcnRlZCgpe3JldHVybiBzaGFkb3codGhpcywiaXNFdmFsU3VwcG9ydGVkIixmdW5jdGlvbiBpc0V2YWxTdXBwb3J0ZWQoKXt0cnl7bmV3IEZ1bmN0aW9uKCIiKTtyZXR1cm4hMH1jYXRjaChlKXtyZXR1cm4hMX19KCkpfXN0YXRpYyBnZXQgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQoKXtyZXR1cm4gc2hhZG93KHRoaXMsImlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkIiwidW5kZWZpbmVkIiE9dHlwZW9mIE9mZnNjcmVlbkNhbnZhcyl9fTtjb25zdCBzPVsuLi5BcnJheSgyNTYpLmtleXMoKV0ubWFwKChlPT5lLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCIwIikpKTtjbGFzcyBVdGlse3N0YXRpYyBtYWtlSGV4Q29sb3IoZSx0LGEpe3JldHVybmAjJHtzW2VdfSR7c1t0XX0ke3NbYV19YH1zdGF0aWMgc2NhbGVNaW5NYXgoZSx0KXtsZXQgYTtpZihlWzBdKXtpZihlWzBdPDApe2E9dFswXTt0WzBdPXRbMV07dFsxXT1hfXRbMF0qPWVbMF07dFsxXSo9ZVswXTtpZihlWzNdPDApe2E9dFsyXTt0WzJdPXRbM107dFszXT1hfXRbMl0qPWVbM107dFszXSo9ZVszXX1lbHNle2E9dFswXTt0WzBdPXRbMl07dFsyXT1hO2E9dFsxXTt0WzFdPXRbM107dFszXT1hO2lmKGVbMV08MCl7YT10WzJdO3RbMl09dFszXTt0WzNdPWF9dFsyXSo9ZVsxXTt0WzNdKj1lWzFdO2lmKGVbMl08MCl7YT10WzBdO3RbMF09dFsxXTt0WzFdPWF9dFswXSo9ZVsyXTt0WzFdKj1lWzJdfXRbMF0rPWVbNF07dFsxXSs9ZVs0XTt0WzJdKz1lWzVdO3RbM10rPWVbNV19c3RhdGljIHRyYW5zZm9ybShlLHQpe3JldHVybltlWzBdKnRbMF0rZVsyXSp0WzFdLGVbMV0qdFswXStlWzNdKnRbMV0sZVswXSp0WzJdK2VbMl0qdFszXSxlWzFdKnRbMl0rZVszXSp0WzNdLGVbMF0qdFs0XStlWzJdKnRbNV0rZVs0XSxlWzFdKnRbNF0rZVszXSp0WzVdK2VbNV1dfXN0YXRpYyBhcHBseVRyYW5zZm9ybShlLHQpe3JldHVybltlWzBdKnRbMF0rZVsxXSp0WzJdK3RbNF0sZVswXSp0WzFdK2VbMV0qdFszXSt0WzVdXX1zdGF0aWMgYXBwbHlJbnZlcnNlVHJhbnNmb3JtKGUsdCl7Y29uc3QgYT10WzBdKnRbM10tdFsxXSp0WzJdO3JldHVyblsoZVswXSp0WzNdLWVbMV0qdFsyXSt0WzJdKnRbNV0tdFs0XSp0WzNdKS9hLCgtZVswXSp0WzFdK2VbMV0qdFswXSt0WzRdKnRbMV0tdFs1XSp0WzBdKS9hXX1zdGF0aWMgZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3goZSx0KXtjb25zdCBhPVV0aWwuYXBwbHlUcmFuc2Zvcm0oZSx0KSxyPVV0aWwuYXBwbHlUcmFuc2Zvcm0oZS5zbGljZSgyLDQpLHQpLG49VXRpbC5hcHBseVRyYW5zZm9ybShbZVswXSxlWzNdXSx0KSxpPVV0aWwuYXBwbHlUcmFuc2Zvcm0oW2VbMl0sZVsxXV0sdCk7cmV0dXJuW01hdGgubWluKGFbMF0sclswXSxuWzBdLGlbMF0pLE1hdGgubWluKGFbMV0sclsxXSxuWzFdLGlbMV0pLE1hdGgubWF4KGFbMF0sclswXSxuWzBdLGlbMF0pLE1hdGgubWF4KGFbMV0sclsxXSxuWzFdLGlbMV0pXX1zdGF0aWMgaW52ZXJzZVRyYW5zZm9ybShlKXtjb25zdCB0PWVbMF0qZVszXS1lWzFdKmVbMl07cmV0dXJuW2VbM10vdCwtZVsxXS90LC1lWzJdL3QsZVswXS90LChlWzJdKmVbNV0tZVs0XSplWzNdKS90LChlWzRdKmVbMV0tZVs1XSplWzBdKS90XX1zdGF0aWMgYXBwbHkzZFRyYW5zZm9ybShlLHQpe3JldHVybltlWzBdKnRbMF0rZVsxXSp0WzFdK2VbMl0qdFsyXSxlWzNdKnRbMF0rZVs0XSp0WzFdK2VbNV0qdFsyXSxlWzZdKnRbMF0rZVs3XSp0WzFdK2VbOF0qdFsyXV19c3RhdGljIHNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKGUpe2NvbnN0IHQ9W2VbMF0sZVsyXSxlWzFdLGVbM11dLGE9ZVswXSp0WzBdK2VbMV0qdFsyXSxyPWVbMF0qdFsxXStlWzFdKnRbM10sbj1lWzJdKnRbMF0rZVszXSp0WzJdLGk9ZVsyXSp0WzFdK2VbM10qdFszXSxzPShhK2kpLzIsbz1NYXRoLnNxcnQoKGEraSkqKjItNCooYSppLW4qcikpLzIsYz1zK298fDEsbD1zLW98fDE7cmV0dXJuW01hdGguc3FydChjKSxNYXRoLnNxcnQobCldfXN0YXRpYyBub3JtYWxpemVSZWN0KGUpe2NvbnN0IHQ9ZS5zbGljZSgwKTtpZihlWzBdPmVbMl0pe3RbMF09ZVsyXTt0WzJdPWVbMF19aWYoZVsxXT5lWzNdKXt0WzFdPWVbM107dFszXT1lWzFdfXJldHVybiB0fXN0YXRpYyBpbnRlcnNlY3QoZSx0KXtjb25zdCBhPU1hdGgubWF4KE1hdGgubWluKGVbMF0sZVsyXSksTWF0aC5taW4odFswXSx0WzJdKSkscj1NYXRoLm1pbihNYXRoLm1heChlWzBdLGVbMl0pLE1hdGgubWF4KHRbMF0sdFsyXSkpO2lmKGE+cilyZXR1cm4gbnVsbDtjb25zdCBuPU1hdGgubWF4KE1hdGgubWluKGVbMV0sZVszXSksTWF0aC5taW4odFsxXSx0WzNdKSksaT1NYXRoLm1pbihNYXRoLm1heChlWzFdLGVbM10pLE1hdGgubWF4KHRbMV0sdFszXSkpO3JldHVybiBuPmk/bnVsbDpbYSxuLHIsaV19c3RhdGljIGJlemllckJvdW5kaW5nQm94KGUsdCxhLHIsbixpLHMsbyl7Y29uc3QgYz1bXSxsPVtbXSxbXV07bGV0IGgsdSxkLGYsZyxwLG0sYjtmb3IobGV0IGw9MDtsPDI7KytsKXtpZigwPT09bCl7dT02KmUtMTIqYSs2Km47aD0tMyplKzkqYS05Km4rMypzO2Q9MyphLTMqZX1lbHNle3U9Nip0LTEyKnIrNippO2g9LTMqdCs5KnItOSppKzMqbztkPTMqci0zKnR9aWYoTWF0aC5hYnMoaCk8MWUtMTIpe2lmKE1hdGguYWJzKHUpPDFlLTEyKWNvbnRpbnVlO2Y9LWQvdTswPGYmJmY8MSYmYy5wdXNoKGYpfWVsc2V7bT11KnUtNCpkKmg7Yj1NYXRoLnNxcnQobSk7aWYoIShtPDApKXtnPSgtdStiKS8oMipoKTswPGcmJmc8MSYmYy5wdXNoKGcpO3A9KC11LWIpLygyKmgpOzA8cCYmcDwxJiZjLnB1c2gocCl9fX1sZXQgeSx3PWMubGVuZ3RoO2NvbnN0IFM9dztmb3IoO3ctLTspe2Y9Y1t3XTt5PTEtZjtsWzBdW3ddPXkqeSp5KmUrMyp5KnkqZiphKzMqeSpmKmYqbitmKmYqZipzO2xbMV1bd109eSp5KnkqdCszKnkqeSpmKnIrMyp5KmYqZippK2YqZipmKm99bFswXVtTXT1lO2xbMV1bU109dDtsWzBdW1MrMV09cztsWzFdW1MrMV09bztsWzBdLmxlbmd0aD1sWzFdLmxlbmd0aD1TKzI7cmV0dXJuW01hdGgubWluKC4uLmxbMF0pLE1hdGgubWluKC4uLmxbMV0pLE1hdGgubWF4KC4uLmxbMF0pLE1hdGgubWF4KC4uLmxbMV0pXX19dC5VdGlsPVV0aWw7Y29uc3Qgbz1bMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsNzI4LDcxMSw3MTAsNzI5LDczMyw3MzEsNzMwLDczMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCw4MjI2LDgyMjQsODIyNSw4MjMwLDgyMTIsODIxMSw0MDIsODI2MCw4MjQ5LDgyNTAsODcyMiw4MjQwLDgyMjIsODIyMCw4MjIxLDgyMTYsODIxNyw4MjE4LDg0ODIsNjQyNTcsNjQyNTgsMzIxLDMzOCwzNTIsMzc2LDM4MSwzMDUsMzIyLDMzOSwzNTMsMzgyLDAsODM2NF07ZnVuY3Rpb24gc3RyaW5nVG9VVEY4U3RyaW5nKGUpe3JldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKGUpKX19LChlLHQsYSk9PnthKDQpfSwoZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LmlzTm9kZUpTPXZvaWQgMDtjb25zdCBhPSEoIm9iamVjdCIhPXR5cGVvZiBwcm9jZXNzfHxwcm9jZXNzKyIiIT0iW29iamVjdCBwcm9jZXNzXSJ8fHByb2Nlc3MudmVyc2lvbnMubnd8fHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24mJnByb2Nlc3MudHlwZSYmImJyb3dzZXIiIT09cHJvY2Vzcy50eXBlKTt0LmlzTm9kZUpTPWF9LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5SZWZTZXRDYWNoZT10LlJlZlNldD10LlJlZj10Lk5hbWU9dC5FT0Y9dC5EaWN0PXQuQ21kPXQuQ0lSQ1VMQVJfUkVGPXZvaWQgMDt0LmNsZWFyUHJpbWl0aXZlQ2FjaGVzPWZ1bmN0aW9uIGNsZWFyUHJpbWl0aXZlQ2FjaGVzKCl7by5fY2xlYXJDYWNoZSgpO3MuX2NsZWFyQ2FjaGUoKTtsLl9jbGVhckNhY2hlKCl9O3QuaXNDbWQ9ZnVuY3Rpb24gaXNDbWQoZSx0KXtyZXR1cm4gZSBpbnN0YW5jZW9mIG8mJih2b2lkIDA9PT10fHxlLmNtZD09PXQpfTt0LmlzRGljdD1mdW5jdGlvbiBpc0RpY3QoZSx0KXtyZXR1cm4gZSBpbnN0YW5jZW9mIERpY3QmJih2b2lkIDA9PT10fHxpc05hbWUoZS5nZXQoIlR5cGUiKSx0KSl9O3QuaXNOYW1lPWlzTmFtZTt0LmlzUmVmc0VxdWFsPWZ1bmN0aW9uIGlzUmVmc0VxdWFsKGUsdCl7cmV0dXJuIGUubnVtPT09dC5udW0mJmUuZ2VuPT09dC5nZW59O3ZhciByPWEoMik7Y29uc3Qgbj1TeW1ib2woIkNJUkNVTEFSX1JFRiIpO3QuQ0lSQ1VMQVJfUkVGPW47Y29uc3QgaT1TeW1ib2woIkVPRiIpO3QuRU9GPWk7Y29uc3Qgcz1mdW5jdGlvbiBOYW1lQ2xvc3VyZSgpe2xldCBlPU9iamVjdC5jcmVhdGUobnVsbCk7Y2xhc3MgTmFtZXtjb25zdHJ1Y3RvcihlKXt0aGlzLm5hbWU9ZX1zdGF0aWMgZ2V0KHQpe3JldHVybiBlW3RdfHwoZVt0XT1uZXcgTmFtZSh0KSl9c3RhdGljIF9jbGVhckNhY2hlKCl7ZT1PYmplY3QuY3JlYXRlKG51bGwpfX1yZXR1cm4gTmFtZX0oKTt0Lk5hbWU9cztjb25zdCBvPWZ1bmN0aW9uIENtZENsb3N1cmUoKXtsZXQgZT1PYmplY3QuY3JlYXRlKG51bGwpO2NsYXNzIENtZHtjb25zdHJ1Y3RvcihlKXt0aGlzLmNtZD1lfXN0YXRpYyBnZXQodCl7cmV0dXJuIGVbdF18fChlW3RdPW5ldyBDbWQodCkpfXN0YXRpYyBfY2xlYXJDYWNoZSgpe2U9T2JqZWN0LmNyZWF0ZShudWxsKX19cmV0dXJuIENtZH0oKTt0LkNtZD1vO2NvbnN0IGM9ZnVuY3Rpb24gbm9uU2VyaWFsaXphYmxlQ2xvc3VyZSgpe3JldHVybiBjfTtjbGFzcyBEaWN0e2NvbnN0cnVjdG9yKGU9bnVsbCl7dGhpcy5fbWFwPU9iamVjdC5jcmVhdGUobnVsbCk7dGhpcy54cmVmPWU7dGhpcy5vYmpJZD1udWxsO3RoaXMuc3VwcHJlc3NFbmNyeXB0aW9uPSExO3RoaXMuX19ub25TZXJpYWxpemFibGVfXz1jfWFzc2lnblhyZWYoZSl7dGhpcy54cmVmPWV9Z2V0IHNpemUoKXtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5fbWFwKS5sZW5ndGh9Z2V0KGUsdCxhKXtsZXQgcj10aGlzLl9tYXBbZV07aWYodm9pZCAwPT09ciYmdm9pZCAwIT09dCl7cj10aGlzLl9tYXBbdF07dm9pZCAwPT09ciYmdm9pZCAwIT09YSYmKHI9dGhpcy5fbWFwW2FdKX1yZXR1cm4gciBpbnN0YW5jZW9mIGwmJnRoaXMueHJlZj90aGlzLnhyZWYuZmV0Y2gocix0aGlzLnN1cHByZXNzRW5jcnlwdGlvbik6cn1hc3luYyBnZXRBc3luYyhlLHQsYSl7bGV0IHI9dGhpcy5fbWFwW2VdO2lmKHZvaWQgMD09PXImJnZvaWQgMCE9PXQpe3I9dGhpcy5fbWFwW3RdO3ZvaWQgMD09PXImJnZvaWQgMCE9PWEmJihyPXRoaXMuX21hcFthXSl9cmV0dXJuIHIgaW5zdGFuY2VvZiBsJiZ0aGlzLnhyZWY/dGhpcy54cmVmLmZldGNoQXN5bmMocix0aGlzLnN1cHByZXNzRW5jcnlwdGlvbik6cn1nZXRBcnJheShlLHQsYSl7bGV0IHI9dGhpcy5fbWFwW2VdO2lmKHZvaWQgMD09PXImJnZvaWQgMCE9PXQpe3I9dGhpcy5fbWFwW3RdO3ZvaWQgMD09PXImJnZvaWQgMCE9PWEmJihyPXRoaXMuX21hcFthXSl9ciBpbnN0YW5jZW9mIGwmJnRoaXMueHJlZiYmKHI9dGhpcy54cmVmLmZldGNoKHIsdGhpcy5zdXBwcmVzc0VuY3J5cHRpb24pKTtpZihBcnJheS5pc0FycmF5KHIpKXtyPXIuc2xpY2UoKTtmb3IobGV0IGU9MCx0PXIubGVuZ3RoO2U8dDtlKyspcltlXWluc3RhbmNlb2YgbCYmdGhpcy54cmVmJiYocltlXT10aGlzLnhyZWYuZmV0Y2gocltlXSx0aGlzLnN1cHByZXNzRW5jcnlwdGlvbikpfXJldHVybiByfWdldFJhdyhlKXtyZXR1cm4gdGhpcy5fbWFwW2VdfWdldEtleXMoKXtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5fbWFwKX1nZXRSYXdWYWx1ZXMoKXtyZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLl9tYXApfXNldChlLHQpe3RoaXMuX21hcFtlXT10fWhhcyhlKXtyZXR1cm4gdm9pZCAwIT09dGhpcy5fbWFwW2VdfWZvckVhY2goZSl7Zm9yKGNvbnN0IHQgaW4gdGhpcy5fbWFwKWUodCx0aGlzLmdldCh0KSl9c3RhdGljIGdldCBlbXB0eSgpe2NvbnN0IGU9bmV3IERpY3QobnVsbCk7ZS5zZXQ9KGUsdCk9PnsoMCxyLnVucmVhY2hhYmxlKSgiU2hvdWxkIG5vdCBjYWxsIGBzZXRgIG9uIHRoZSBlbXB0eSBkaWN0aW9uYXJ5LiIpfTtyZXR1cm4oMCxyLnNoYWRvdykodGhpcywiZW1wdHkiLGUpfXN0YXRpYyBtZXJnZSh7eHJlZjplLGRpY3RBcnJheTp0LG1lcmdlU3ViRGljdHM6YT0hMX0pe2NvbnN0IHI9bmV3IERpY3QoZSksbj1uZXcgTWFwO2Zvcihjb25zdCBlIG9mIHQpaWYoZSBpbnN0YW5jZW9mIERpY3QpZm9yKGNvbnN0W3Qscl1vZiBPYmplY3QuZW50cmllcyhlLl9tYXApKXtsZXQgZT1uLmdldCh0KTtpZih2b2lkIDA9PT1lKXtlPVtdO24uc2V0KHQsZSl9ZWxzZSBpZighKGEmJnIgaW5zdGFuY2VvZiBEaWN0KSljb250aW51ZTtlLnB1c2gocil9Zm9yKGNvbnN0W3QsYV1vZiBuKXtpZigxPT09YS5sZW5ndGh8fCEoYVswXWluc3RhbmNlb2YgRGljdCkpe3IuX21hcFt0XT1hWzBdO2NvbnRpbnVlfWNvbnN0IG49bmV3IERpY3QoZSk7Zm9yKGNvbnN0IGUgb2YgYSlmb3IoY29uc3RbdCxhXW9mIE9iamVjdC5lbnRyaWVzKGUuX21hcCkpdm9pZCAwPT09bi5fbWFwW3RdJiYobi5fbWFwW3RdPWEpO24uc2l6ZT4wJiYoci5fbWFwW3RdPW4pfW4uY2xlYXIoKTtyZXR1cm4gci5zaXplPjA/cjpEaWN0LmVtcHR5fX10LkRpY3Q9RGljdDtjb25zdCBsPWZ1bmN0aW9uIFJlZkNsb3N1cmUoKXtsZXQgZT1PYmplY3QuY3JlYXRlKG51bGwpO2NsYXNzIFJlZntjb25zdHJ1Y3RvcihlLHQpe3RoaXMubnVtPWU7dGhpcy5nZW49dH10b1N0cmluZygpe3JldHVybiAwPT09dGhpcy5nZW4/YCR7dGhpcy5udW19UmA6YCR7dGhpcy5udW19UiR7dGhpcy5nZW59YH1zdGF0aWMgZ2V0KHQsYSl7Y29uc3Qgcj0wPT09YT9gJHt0fVJgOmAke3R9UiR7YX1gO3JldHVybiBlW3JdfHwoZVtyXT1uZXcgUmVmKHQsYSkpfXN0YXRpYyBfY2xlYXJDYWNoZSgpe2U9T2JqZWN0LmNyZWF0ZShudWxsKX19cmV0dXJuIFJlZn0oKTt0LlJlZj1sO2NsYXNzIFJlZlNldHtjb25zdHJ1Y3RvcihlPW51bGwpe3RoaXMuX3NldD1uZXcgU2V0KGUmJmUuX3NldCl9aGFzKGUpe3JldHVybiB0aGlzLl9zZXQuaGFzKGUudG9TdHJpbmcoKSl9cHV0KGUpe3RoaXMuX3NldC5hZGQoZS50b1N0cmluZygpKX1yZW1vdmUoZSl7dGhpcy5fc2V0LmRlbGV0ZShlLnRvU3RyaW5nKCkpfVtTeW1ib2wuaXRlcmF0b3JdKCl7cmV0dXJuIHRoaXMuX3NldC52YWx1ZXMoKX1jbGVhcigpe3RoaXMuX3NldC5jbGVhcigpfX10LlJlZlNldD1SZWZTZXQ7Y2xhc3MgUmVmU2V0Q2FjaGV7Y29uc3RydWN0b3IoKXt0aGlzLl9tYXA9bmV3IE1hcH1nZXQgc2l6ZSgpe3JldHVybiB0aGlzLl9tYXAuc2l6ZX1nZXQoZSl7cmV0dXJuIHRoaXMuX21hcC5nZXQoZS50b1N0cmluZygpKX1oYXMoZSl7cmV0dXJuIHRoaXMuX21hcC5oYXMoZS50b1N0cmluZygpKX1wdXQoZSx0KXt0aGlzLl9tYXAuc2V0KGUudG9TdHJpbmcoKSx0KX1wdXRBbGlhcyhlLHQpe3RoaXMuX21hcC5zZXQoZS50b1N0cmluZygpLHRoaXMuZ2V0KHQpKX1bU3ltYm9sLml0ZXJhdG9yXSgpe3JldHVybiB0aGlzLl9tYXAudmFsdWVzKCl9Y2xlYXIoKXt0aGlzLl9tYXAuY2xlYXIoKX19dC5SZWZTZXRDYWNoZT1SZWZTZXRDYWNoZTtmdW5jdGlvbiBpc05hbWUoZSx0KXtyZXR1cm4gZSBpbnN0YW5jZW9mIHMmJih2b2lkIDA9PT10fHxlLm5hbWU9PT10KX19LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5YUmVmUGFyc2VFeGNlcHRpb249dC5YUmVmRW50cnlFeGNlcHRpb249dC5QYXJzZXJFT0ZFeGNlcHRpb249dC5NaXNzaW5nRGF0YUV4Y2VwdGlvbj10LkRvY1N0YXRzPXZvaWQgMDt0LmNvbGxlY3RBY3Rpb25zPWZ1bmN0aW9uIGNvbGxlY3RBY3Rpb25zKGUsdCxhKXtjb25zdCBpPU9iamVjdC5jcmVhdGUobnVsbCkscz1nZXRJbmhlcml0YWJsZVByb3BlcnR5KHtkaWN0OnQsa2V5OiJBQSIsc3RvcFdoZW5Gb3VuZDohMX0pO2lmKHMpZm9yKGxldCB0PXMubGVuZ3RoLTE7dD49MDt0LS0pe2NvbnN0IHI9c1t0XTtpZihyIGluc3RhbmNlb2Ygbi5EaWN0KWZvcihjb25zdCB0IG9mIHIuZ2V0S2V5cygpKXtjb25zdCBzPWFbdF07aWYoIXMpY29udGludWU7Y29uc3Qgbz1yLmdldFJhdyh0KSxjPW5ldyBuLlJlZlNldCxsPVtdO19jb2xsZWN0SlMobyxlLGwsYyk7bC5sZW5ndGg+MCYmKGlbc109bCl9fWlmKHQuaGFzKCJBIikpe2NvbnN0IGE9dC5nZXQoIkEiKSxyPW5ldyBuLlJlZlNldCxzPVtdO19jb2xsZWN0SlMoYSxlLHMscik7cy5sZW5ndGg+MCYmKGkuQWN0aW9uPXMpfXJldHVybigwLHIub2JqZWN0U2l6ZSkoaSk+MD9pOm51bGx9O3QuZW5jb2RlVG9YbWxTdHJpbmc9ZnVuY3Rpb24gZW5jb2RlVG9YbWxTdHJpbmcoZSl7Y29uc3QgdD1bXTtsZXQgYT0wO2ZvcihsZXQgcj0wLG49ZS5sZW5ndGg7cjxuO3IrKyl7Y29uc3Qgbj1lLmNvZGVQb2ludEF0KHIpO2lmKDMyPD1uJiZuPD0xMjYpe2NvbnN0IGk9b1tuXTtpZihpKXthPHImJnQucHVzaChlLnN1YnN0cmluZyhhLHIpKTt0LnB1c2goaSk7YT1yKzF9fWVsc2V7YTxyJiZ0LnB1c2goZS5zdWJzdHJpbmcoYSxyKSk7dC5wdXNoKGAmI3gke24udG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCl9O2ApO24+NTUyOTUmJihuPDU3MzQ0fHxuPjY1NTMzKSYmcisrO2E9cisxfX1pZigwPT09dC5sZW5ndGgpcmV0dXJuIGU7YTxlLmxlbmd0aCYmdC5wdXNoKGUuc3Vic3RyaW5nKGEsZS5sZW5ndGgpKTtyZXR1cm4gdC5qb2luKCIiKX07dC5lc2NhcGVQREZOYW1lPWZ1bmN0aW9uIGVzY2FwZVBERk5hbWUoZSl7Y29uc3QgdD1bXTtsZXQgYT0wO2ZvcihsZXQgcj0wLG49ZS5sZW5ndGg7cjxuO3IrKyl7Y29uc3Qgbj1lLmNoYXJDb2RlQXQocik7aWYobjwzM3x8bj4xMjZ8fDM1PT09bnx8NDA9PT1ufHw0MT09PW58fDYwPT09bnx8NjI9PT1ufHw5MT09PW58fDkzPT09bnx8MTIzPT09bnx8MTI1PT09bnx8NDc9PT1ufHwzNz09PW4pe2E8ciYmdC5wdXNoKGUuc3Vic3RyaW5nKGEscikpO3QucHVzaChgIyR7bi50b1N0cmluZygxNil9YCk7YT1yKzF9fWlmKDA9PT10Lmxlbmd0aClyZXR1cm4gZTthPGUubGVuZ3RoJiZ0LnB1c2goZS5zdWJzdHJpbmcoYSxlLmxlbmd0aCkpO3JldHVybiB0LmpvaW4oIiIpfTt0LmdldEFycmF5TG9va3VwVGFibGVGYWN0b3J5PWZ1bmN0aW9uIGdldEFycmF5TG9va3VwVGFibGVGYWN0b3J5KGUpe2xldCB0O3JldHVybiBmdW5jdGlvbigpe2lmKGUpe2xldCBhPWUoKTtlPW51bGw7dD1PYmplY3QuY3JlYXRlKG51bGwpO2ZvcihsZXQgZT0wLHI9YS5sZW5ndGg7ZTxyO2UrPTIpdFthW2VdXT1hW2UrMV07YT1udWxsfXJldHVybiB0fX07dC5nZXRJbmhlcml0YWJsZVByb3BlcnR5PWdldEluaGVyaXRhYmxlUHJvcGVydHk7dC5nZXRMb29rdXBUYWJsZUZhY3Rvcnk9ZnVuY3Rpb24gZ2V0TG9va3VwVGFibGVGYWN0b3J5KGUpe2xldCB0O3JldHVybiBmdW5jdGlvbigpe2lmKGUpe3Q9T2JqZWN0LmNyZWF0ZShudWxsKTtlKHQpO2U9bnVsbH1yZXR1cm4gdH19O3QuZ2V0TmV3QW5ub3RhdGlvbnNNYXA9ZnVuY3Rpb24gZ2V0TmV3QW5ub3RhdGlvbnNNYXAoZSl7aWYoIWUpcmV0dXJuIG51bGw7Y29uc3QgdD1uZXcgTWFwO2Zvcihjb25zdFthLG5db2YgZSl7aWYoIWEuc3RhcnRzV2l0aChyLkFubm90YXRpb25FZGl0b3JQcmVmaXgpKWNvbnRpbnVlO2xldCBlPXQuZ2V0KG4ucGFnZUluZGV4KTtpZighZSl7ZT1bXTt0LnNldChuLnBhZ2VJbmRleCxlKX1lLnB1c2gobil9cmV0dXJuIHQuc2l6ZT4wP3Q6bnVsbH07dC5pc1doaXRlU3BhY2U9ZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGUpe3JldHVybiAzMj09PWV8fDk9PT1lfHwxMz09PWV8fDEwPT09ZX07dC5sb2cyPWZ1bmN0aW9uIGxvZzIoZSl7aWYoZTw9MClyZXR1cm4gMDtyZXR1cm4gTWF0aC5jZWlsKE1hdGgubG9nMihlKSl9O3QubnVtYmVyVG9TdHJpbmc9ZnVuY3Rpb24gbnVtYmVyVG9TdHJpbmcoZSl7aWYoTnVtYmVyLmlzSW50ZWdlcihlKSlyZXR1cm4gZS50b1N0cmluZygpO2NvbnN0IHQ9TWF0aC5yb3VuZCgxMDAqZSk7aWYodCUxMDA9PTApcmV0dXJuKHQvMTAwKS50b1N0cmluZygpO2lmKHQlMTA9PTApcmV0dXJuIGUudG9GaXhlZCgxKTtyZXR1cm4gZS50b0ZpeGVkKDIpfTt0LnBhcnNlWEZBUGF0aD1mdW5jdGlvbiBwYXJzZVhGQVBhdGgoZSl7Y29uc3QgdD0vKC4rKVxbKFxkKylcXSQvO3JldHVybiBlLnNwbGl0KCIuIikubWFwKChlPT57Y29uc3QgYT1lLm1hdGNoKHQpO3JldHVybiBhP3tuYW1lOmFbMV0scG9zOnBhcnNlSW50KGFbMl0sMTApfTp7bmFtZTplLHBvczowfX0pKX07dC5yZWFkSW50OD1mdW5jdGlvbiByZWFkSW50OChlLHQpe3JldHVybiBlW3RdPDwyND4+MjR9O3QucmVhZFVpbnQxNj1mdW5jdGlvbiByZWFkVWludDE2KGUsdCl7cmV0dXJuIGVbdF08PDh8ZVt0KzFdfTt0LnJlYWRVaW50MzI9ZnVuY3Rpb24gcmVhZFVpbnQzMihlLHQpe3JldHVybihlW3RdPDwyNHxlW3QrMV08PDE2fGVbdCsyXTw8OHxlW3QrM10pPj4+MH07dC5yZWNvdmVySnNVUkw9ZnVuY3Rpb24gcmVjb3ZlckpzVVJMKGUpe2NvbnN0IHQ9bmV3IFJlZ0V4cCgiXlxccyooIitbImFwcC5sYXVuY2hVUkwiLCJ3aW5kb3cub3BlbiIsInhmYS5ob3N0LmdvdG9VUkwiXS5qb2luKCJ8Iikuc3BsaXQoIi4iKS5qb2luKCJcXC4iKSsiKVxcKCg/Oid8XCIpKFteJ1wiXSopKD86J3xcIikoPzosXFxzKihcXHcrKVxcKXxcXCkpIiwiaSIpLmV4ZWMoZSk7aWYodCYmdFsyXSl7Y29uc3QgZT10WzJdO2xldCBhPSExOyJ0cnVlIj09PXRbM10mJiJhcHAubGF1bmNoVVJMIj09PXRbMV0mJihhPSEwKTtyZXR1cm57dXJsOmUsbmV3V2luZG93OmF9fXJldHVybiBudWxsfTt0LnRvUm9tYW5OdW1lcmFscz1mdW5jdGlvbiB0b1JvbWFuTnVtZXJhbHMoZSx0PSExKXsoMCxyLmFzc2VydCkoTnVtYmVyLmlzSW50ZWdlcihlKSYmZT4wLCJUaGUgbnVtYmVyIHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIuIik7Y29uc3QgYT1bXTtsZXQgbjtmb3IoO2U+PTFlMzspe2UtPTFlMzthLnB1c2goIk0iKX1uPWUvMTAwfDA7ZSU9MTAwO2EucHVzaChzW25dKTtuPWUvMTB8MDtlJT0xMDthLnB1c2goc1sxMCtuXSk7YS5wdXNoKHNbMjArZV0pO2NvbnN0IGk9YS5qb2luKCIiKTtyZXR1cm4gdD9pLnRvTG93ZXJDYXNlKCk6aX07dC52YWxpZGF0ZUNTU0ZvbnQ9ZnVuY3Rpb24gdmFsaWRhdGVDU1NGb250KGUpe2NvbnN0IHQ9bmV3IFNldChbIjEwMCIsIjIwMCIsIjMwMCIsIjQwMCIsIjUwMCIsIjYwMCIsIjcwMCIsIjgwMCIsIjkwMCIsIjEwMDAiLCJub3JtYWwiLCJib2xkIiwiYm9sZGVyIiwibGlnaHRlciJdKSx7Zm9udEZhbWlseTphLGZvbnRXZWlnaHQ6bixpdGFsaWNBbmdsZTppfT1lO2lmKC9eIi4qIiQvLnRlc3QoYSkpe2lmKC9bXlxcXSIvLnRlc3QoYS5zbGljZSgxLGEubGVuZ3RoLTEpKSl7KDAsci53YXJuKShgWEZBIC0gRm9udEZhbWlseSBjb250YWlucyBzb21lIHVuZXNjYXBlZCAiOiAke2F9LmApO3JldHVybiExfX1lbHNlIGlmKC9eJy4qJyQvLnRlc3QoYSkpe2lmKC9bXlxcXScvLnRlc3QoYS5zbGljZSgxLGEubGVuZ3RoLTEpKSl7KDAsci53YXJuKShgWEZBIC0gRm9udEZhbWlseSBjb250YWlucyBzb21lIHVuZXNjYXBlZCAnOiAke2F9LmApO3JldHVybiExfX1lbHNlIGZvcihjb25zdCBlIG9mIGEuc3BsaXQoL1sgXHRdKy8pKWlmKC9eKFxkfCgtKFxkfC0pKSkvLnRlc3QoZSl8fCEvXltcdy1cXF0rJC8udGVzdChlKSl7KDAsci53YXJuKShgWEZBIC0gRm9udEZhbWlseSBjb250YWlucyBzb21lIGludmFsaWQgPGN1c3RvbS1pZGVudD46ICR7YX0uYCk7cmV0dXJuITF9Y29uc3Qgcz1uP24udG9TdHJpbmcoKToiIjtlLmZvbnRXZWlnaHQ9dC5oYXMocyk/czoiNDAwIjtjb25zdCBvPXBhcnNlRmxvYXQoaSk7ZS5pdGFsaWNBbmdsZT1pc05hTihvKXx8bzwtOTB8fG8+OTA/IjE0IjppLnRvU3RyaW5nKCk7cmV0dXJuITB9O3ZhciByPWEoMiksbj1hKDUpLGk9YSg3KTtjbGFzcyBNaXNzaW5nRGF0YUV4Y2VwdGlvbiBleHRlbmRzIHIuQmFzZUV4Y2VwdGlvbntjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKGBNaXNzaW5nIGRhdGEgWyR7ZX0sICR7dH0pYCwiTWlzc2luZ0RhdGFFeGNlcHRpb24iKTt0aGlzLmJlZ2luPWU7dGhpcy5lbmQ9dH19dC5NaXNzaW5nRGF0YUV4Y2VwdGlvbj1NaXNzaW5nRGF0YUV4Y2VwdGlvbjtjbGFzcyBQYXJzZXJFT0ZFeGNlcHRpb24gZXh0ZW5kcyByLkJhc2VFeGNlcHRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwiUGFyc2VyRU9GRXhjZXB0aW9uIil9fXQuUGFyc2VyRU9GRXhjZXB0aW9uPVBhcnNlckVPRkV4Y2VwdGlvbjtjbGFzcyBYUmVmRW50cnlFeGNlcHRpb24gZXh0ZW5kcyByLkJhc2VFeGNlcHRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwiWFJlZkVudHJ5RXhjZXB0aW9uIil9fXQuWFJlZkVudHJ5RXhjZXB0aW9uPVhSZWZFbnRyeUV4Y2VwdGlvbjtjbGFzcyBYUmVmUGFyc2VFeGNlcHRpb24gZXh0ZW5kcyByLkJhc2VFeGNlcHRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwiWFJlZlBhcnNlRXhjZXB0aW9uIil9fXQuWFJlZlBhcnNlRXhjZXB0aW9uPVhSZWZQYXJzZUV4Y2VwdGlvbjt0LkRvY1N0YXRzPWNsYXNzIERvY1N0YXRze2NvbnN0cnVjdG9yKGUpe3RoaXMuX2hhbmRsZXI9ZTt0aGlzLl9zdHJlYW1UeXBlcz1uZXcgU2V0O3RoaXMuX2ZvbnRUeXBlcz1uZXcgU2V0fV9zZW5kKCl7Y29uc3QgZT1PYmplY3QuY3JlYXRlKG51bGwpLHQ9T2JqZWN0LmNyZWF0ZShudWxsKTtmb3IoY29uc3QgdCBvZiB0aGlzLl9zdHJlYW1UeXBlcyllW3RdPSEwO2Zvcihjb25zdCBlIG9mIHRoaXMuX2ZvbnRUeXBlcyl0W2VdPSEwO3RoaXMuX2hhbmRsZXIuc2VuZCgiRG9jU3RhdHMiLHtzdHJlYW1UeXBlczplLGZvbnRUeXBlczp0fSl9YWRkU3RyZWFtVHlwZShlKXtpZighdGhpcy5fc3RyZWFtVHlwZXMuaGFzKGUpKXt0aGlzLl9zdHJlYW1UeXBlcy5hZGQoZSk7dGhpcy5fc2VuZCgpfX1hZGRGb250VHlwZShlKXtpZighdGhpcy5fZm9udFR5cGVzLmhhcyhlKSl7dGhpcy5fZm9udFR5cGVzLmFkZChlKTt0aGlzLl9zZW5kKCl9fX07ZnVuY3Rpb24gZ2V0SW5oZXJpdGFibGVQcm9wZXJ0eSh7ZGljdDplLGtleTp0LGdldEFycmF5OmE9ITEsc3RvcFdoZW5Gb3VuZDpyPSEwfSl7bGV0IGk7Y29uc3Qgcz1uZXcgbi5SZWZTZXQ7Zm9yKDtlIGluc3RhbmNlb2Ygbi5EaWN0JiYoIWUub2JqSWR8fCFzLmhhcyhlLm9iaklkKSk7KXtlLm9iaklkJiZzLnB1dChlLm9iaklkKTtjb25zdCBuPWE/ZS5nZXRBcnJheSh0KTplLmdldCh0KTtpZih2b2lkIDAhPT1uKXtpZihyKXJldHVybiBuO2l8fChpPVtdKTtpLnB1c2gobil9ZT1lLmdldCgiUGFyZW50Iil9cmV0dXJuIGl9Y29uc3Qgcz1bIiIsIkMiLCJDQyIsIkNDQyIsIkNEIiwiRCIsIkRDIiwiRENDIiwiRENDQyIsIkNNIiwiIiwiWCIsIlhYIiwiWFhYIiwiWEwiLCJMIiwiTFgiLCJMWFgiLCJMWFhYIiwiWEMiLCIiLCJJIiwiSUkiLCJJSUkiLCJJViIsIlYiLCJWSSIsIlZJSSIsIlZJSUkiLCJJWCJdO2Z1bmN0aW9uIF9jb2xsZWN0SlMoZSx0LGEscyl7aWYoIWUpcmV0dXJuO2xldCBvPW51bGw7aWYoZSBpbnN0YW5jZW9mIG4uUmVmKXtpZihzLmhhcyhlKSlyZXR1cm47bz1lO3MucHV0KG8pO2U9dC5mZXRjaChlKX1pZihBcnJheS5pc0FycmF5KGUpKWZvcihjb25zdCByIG9mIGUpX2NvbGxlY3RKUyhyLHQsYSxzKTtlbHNlIGlmKGUgaW5zdGFuY2VvZiBuLkRpY3Qpe2lmKCgwLG4uaXNOYW1lKShlLmdldCgiUyIpLCJKYXZhU2NyaXB0Iikpe2NvbnN0IHQ9ZS5nZXQoIkpTIik7bGV0IG47dCBpbnN0YW5jZW9mIGkuQmFzZVN0cmVhbT9uPXQuZ2V0U3RyaW5nKCk6InN0cmluZyI9PXR5cGVvZiB0JiYobj10KTtuPW4mJigwLHIuc3RyaW5nVG9QREZTdHJpbmcpKG4pLnJlcGxhY2UoL1x1MDAwMC9nLCIiKTtuJiZhLnB1c2gobil9X2NvbGxlY3RKUyhlLmdldFJhdygiTmV4dCIpLHQsYSxzKX1vJiZzLnJlbW92ZShvKX1jb25zdCBvPXs2MDoiJmx0OyIsNjI6IiZndDsiLDM4OiImYW1wOyIsMzQ6IiZxdW90OyIsMzk6IiZhcG9zOyJ9fSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuQmFzZVN0cmVhbT12b2lkIDA7dmFyIHI9YSgyKTtjbGFzcyBCYXNlU3RyZWFte2NvbnN0cnVjdG9yKCl7dGhpcy5jb25zdHJ1Y3Rvcj09PUJhc2VTdHJlYW0mJigwLHIudW5yZWFjaGFibGUpKCJDYW5ub3QgaW5pdGlhbGl6ZSBCYXNlU3RyZWFtLiIpfWdldCBsZW5ndGgoKXsoMCxyLnVucmVhY2hhYmxlKSgiQWJzdHJhY3QgZ2V0dGVyIGBsZW5ndGhgIGFjY2Vzc2VkIil9Z2V0IGlzRW1wdHkoKXsoMCxyLnVucmVhY2hhYmxlKSgiQWJzdHJhY3QgZ2V0dGVyIGBpc0VtcHR5YCBhY2Nlc3NlZCIpfWdldCBpc0RhdGFMb2FkZWQoKXtyZXR1cm4oMCxyLnNoYWRvdykodGhpcywiaXNEYXRhTG9hZGVkIiwhMCl9Z2V0Qnl0ZSgpeygwLHIudW5yZWFjaGFibGUpKCJBYnN0cmFjdCBtZXRob2QgYGdldEJ5dGVgIGNhbGxlZCIpfWdldEJ5dGVzKGUpeygwLHIudW5yZWFjaGFibGUpKCJBYnN0cmFjdCBtZXRob2QgYGdldEJ5dGVzYCBjYWxsZWQiKX1wZWVrQnl0ZSgpe2NvbnN0IGU9dGhpcy5nZXRCeXRlKCk7LTEhPT1lJiZ0aGlzLnBvcy0tO3JldHVybiBlfXBlZWtCeXRlcyhlKXtjb25zdCB0PXRoaXMuZ2V0Qnl0ZXMoZSk7dGhpcy5wb3MtPXQubGVuZ3RoO3JldHVybiB0fWdldFVpbnQxNigpe2NvbnN0IGU9dGhpcy5nZXRCeXRlKCksdD10aGlzLmdldEJ5dGUoKTtyZXR1cm4tMT09PWV8fC0xPT09dD8tMTooZTw8OCkrdH1nZXRJbnQzMigpe3JldHVybih0aGlzLmdldEJ5dGUoKTw8MjQpKyh0aGlzLmdldEJ5dGUoKTw8MTYpKyh0aGlzLmdldEJ5dGUoKTw8OCkrdGhpcy5nZXRCeXRlKCl9Z2V0Qnl0ZVJhbmdlKGUsdCl7KDAsci51bnJlYWNoYWJsZSkoIkFic3RyYWN0IG1ldGhvZCBgZ2V0Qnl0ZVJhbmdlYCBjYWxsZWQiKX1nZXRTdHJpbmcoZSl7cmV0dXJuKDAsci5ieXRlc1RvU3RyaW5nKSh0aGlzLmdldEJ5dGVzKGUpKX1za2lwKGUpe3RoaXMucG9zKz1lfHwxfXJlc2V0KCl7KDAsci51bnJlYWNoYWJsZSkoIkFic3RyYWN0IG1ldGhvZCBgcmVzZXRgIGNhbGxlZCIpfW1vdmVTdGFydCgpeygwLHIudW5yZWFjaGFibGUpKCJBYnN0cmFjdCBtZXRob2QgYG1vdmVTdGFydGAgY2FsbGVkIil9bWFrZVN1YlN0cmVhbShlLHQsYT1udWxsKXsoMCxyLnVucmVhY2hhYmxlKSgiQWJzdHJhY3QgbWV0aG9kIGBtYWtlU3ViU3RyZWFtYCBjYWxsZWQiKX1nZXRCYXNlU3RyZWFtcygpe3JldHVybiBudWxsfX10LkJhc2VTdHJlYW09QmFzZVN0cmVhbX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0Lk5ldHdvcmtQZGZNYW5hZ2VyPXQuTG9jYWxQZGZNYW5hZ2VyPXZvaWQgMDt2YXIgcj1hKDIpLG49YSg5KSxpPWEoNikscz1hKDExKSxvPWEoMTApO2Z1bmN0aW9uIHBhcnNlRG9jQmFzZVVybChlKXtpZihlKXtjb25zdCB0PSgwLHIuY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCkoZSk7aWYodClyZXR1cm4gdC5ocmVmOygwLHIud2FybikoYEludmFsaWQgYWJzb2x1dGUgZG9jQmFzZVVybDogIiR7ZX0iLmApfXJldHVybiBudWxsfWNsYXNzIEJhc2VQZGZNYW5hZ2Vye2NvbnN0cnVjdG9yKCl7dGhpcy5jb25zdHJ1Y3Rvcj09PUJhc2VQZGZNYW5hZ2VyJiYoMCxyLnVucmVhY2hhYmxlKSgiQ2Fubm90IGluaXRpYWxpemUgQmFzZVBkZk1hbmFnZXIuIil9Z2V0IGRvY0lkKCl7cmV0dXJuIHRoaXMuX2RvY0lkfWdldCBwYXNzd29yZCgpe3JldHVybiB0aGlzLl9wYXNzd29yZH1nZXQgZG9jQmFzZVVybCgpe2NvbnN0IGU9dGhpcy5wZGZEb2N1bWVudC5jYXRhbG9nO3JldHVybigwLHIuc2hhZG93KSh0aGlzLCJkb2NCYXNlVXJsIixlLmJhc2VVcmx8fHRoaXMuX2RvY0Jhc2VVcmwpfW9uTG9hZGVkU3RyZWFtKCl7KDAsci51bnJlYWNoYWJsZSkoIkFic3RyYWN0IG1ldGhvZCBgb25Mb2FkZWRTdHJlYW1gIGNhbGxlZCIpfWVuc3VyZURvYyhlLHQpe3JldHVybiB0aGlzLmVuc3VyZSh0aGlzLnBkZkRvY3VtZW50LGUsdCl9ZW5zdXJlWFJlZihlLHQpe3JldHVybiB0aGlzLmVuc3VyZSh0aGlzLnBkZkRvY3VtZW50LnhyZWYsZSx0KX1lbnN1cmVDYXRhbG9nKGUsdCl7cmV0dXJuIHRoaXMuZW5zdXJlKHRoaXMucGRmRG9jdW1lbnQuY2F0YWxvZyxlLHQpfWdldFBhZ2UoZSl7cmV0dXJuIHRoaXMucGRmRG9jdW1lbnQuZ2V0UGFnZShlKX1mb250RmFsbGJhY2soZSx0KXtyZXR1cm4gdGhpcy5wZGZEb2N1bWVudC5mb250RmFsbGJhY2soZSx0KX1sb2FkWGZhRm9udHMoZSx0KXtyZXR1cm4gdGhpcy5wZGZEb2N1bWVudC5sb2FkWGZhRm9udHMoZSx0KX1sb2FkWGZhSW1hZ2VzKCl7cmV0dXJuIHRoaXMucGRmRG9jdW1lbnQubG9hZFhmYUltYWdlcygpfXNlcmlhbGl6ZVhmYURhdGEoZSl7cmV0dXJuIHRoaXMucGRmRG9jdW1lbnQuc2VyaWFsaXplWGZhRGF0YShlKX1jbGVhbnVwKGU9ITEpe3JldHVybiB0aGlzLnBkZkRvY3VtZW50LmNsZWFudXAoZSl9YXN5bmMgZW5zdXJlKGUsdCxhKXsoMCxyLnVucmVhY2hhYmxlKSgiQWJzdHJhY3QgbWV0aG9kIGBlbnN1cmVgIGNhbGxlZCIpfXJlcXVlc3RSYW5nZShlLHQpeygwLHIudW5yZWFjaGFibGUpKCJBYnN0cmFjdCBtZXRob2QgYHJlcXVlc3RSYW5nZWAgY2FsbGVkIil9cmVxdWVzdExvYWRlZFN0cmVhbSgpeygwLHIudW5yZWFjaGFibGUpKCJBYnN0cmFjdCBtZXRob2QgYHJlcXVlc3RMb2FkZWRTdHJlYW1gIGNhbGxlZCIpfXNlbmRQcm9ncmVzc2l2ZURhdGEoZSl7KDAsci51bnJlYWNoYWJsZSkoIkFic3RyYWN0IG1ldGhvZCBgc2VuZFByb2dyZXNzaXZlRGF0YWAgY2FsbGVkIil9dXBkYXRlUGFzc3dvcmQoZSl7dGhpcy5fcGFzc3dvcmQ9ZX10ZXJtaW5hdGUoZSl7KDAsci51bnJlYWNoYWJsZSkoIkFic3RyYWN0IG1ldGhvZCBgdGVybWluYXRlYCBjYWxsZWQiKX19dC5Mb2NhbFBkZk1hbmFnZXI9Y2xhc3MgTG9jYWxQZGZNYW5hZ2VyIGV4dGVuZHMgQmFzZVBkZk1hbmFnZXJ7Y29uc3RydWN0b3IoZSx0LGEscixuLGksYyl7c3VwZXIoKTt0aGlzLl9kb2NJZD1lO3RoaXMuX3Bhc3N3b3JkPWE7dGhpcy5fZG9jQmFzZVVybD1wYXJzZURvY0Jhc2VVcmwoYyk7dGhpcy5tc2dIYW5kbGVyPXI7dGhpcy5ldmFsdWF0b3JPcHRpb25zPW47dGhpcy5lbmFibGVYZmE9aTtjb25zdCBsPW5ldyBvLlN0cmVhbSh0KTt0aGlzLnBkZkRvY3VtZW50PW5ldyBzLlBERkRvY3VtZW50KHRoaXMsbCk7dGhpcy5fbG9hZGVkU3RyZWFtUHJvbWlzZT1Qcm9taXNlLnJlc29sdmUobCl9YXN5bmMgZW5zdXJlKGUsdCxhKXtjb25zdCByPWVbdF07cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIHI/ci5hcHBseShlLGEpOnJ9cmVxdWVzdFJhbmdlKGUsdCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpfXJlcXVlc3RMb2FkZWRTdHJlYW0oKXt9b25Mb2FkZWRTdHJlYW0oKXtyZXR1cm4gdGhpcy5fbG9hZGVkU3RyZWFtUHJvbWlzZX10ZXJtaW5hdGUoZSl7fX07dC5OZXR3b3JrUGRmTWFuYWdlcj1jbGFzcyBOZXR3b3JrUGRmTWFuYWdlciBleHRlbmRzIEJhc2VQZGZNYW5hZ2Vye2NvbnN0cnVjdG9yKGUsdCxhLHIsaSxvKXtzdXBlcigpO3RoaXMuX2RvY0lkPWU7dGhpcy5fcGFzc3dvcmQ9YS5wYXNzd29yZDt0aGlzLl9kb2NCYXNlVXJsPXBhcnNlRG9jQmFzZVVybChvKTt0aGlzLm1zZ0hhbmRsZXI9YS5tc2dIYW5kbGVyO3RoaXMuZXZhbHVhdG9yT3B0aW9ucz1yO3RoaXMuZW5hYmxlWGZhPWk7dGhpcy5zdHJlYW1NYW5hZ2VyPW5ldyBuLkNodW5rZWRTdHJlYW1NYW5hZ2VyKHQse21zZ0hhbmRsZXI6YS5tc2dIYW5kbGVyLGxlbmd0aDphLmxlbmd0aCxkaXNhYmxlQXV0b0ZldGNoOmEuZGlzYWJsZUF1dG9GZXRjaCxyYW5nZUNodW5rU2l6ZTphLnJhbmdlQ2h1bmtTaXplfSk7dGhpcy5wZGZEb2N1bWVudD1uZXcgcy5QREZEb2N1bWVudCh0aGlzLHRoaXMuc3RyZWFtTWFuYWdlci5nZXRTdHJlYW0oKSl9YXN5bmMgZW5zdXJlKGUsdCxhKXt0cnl7Y29uc3Qgcj1lW3RdO3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiByP3IuYXBwbHkoZSxhKTpyfWNhdGNoKHIpe2lmKCEociBpbnN0YW5jZW9mIGkuTWlzc2luZ0RhdGFFeGNlcHRpb24pKXRocm93IHI7YXdhaXQgdGhpcy5yZXF1ZXN0UmFuZ2Uoci5iZWdpbixyLmVuZCk7cmV0dXJuIHRoaXMuZW5zdXJlKGUsdCxhKX19cmVxdWVzdFJhbmdlKGUsdCl7cmV0dXJuIHRoaXMuc3RyZWFtTWFuYWdlci5yZXF1ZXN0UmFuZ2UoZSx0KX1yZXF1ZXN0TG9hZGVkU3RyZWFtKCl7dGhpcy5zdHJlYW1NYW5hZ2VyLnJlcXVlc3RBbGxDaHVua3MoKX1zZW5kUHJvZ3Jlc3NpdmVEYXRhKGUpe3RoaXMuc3RyZWFtTWFuYWdlci5vblJlY2VpdmVEYXRhKHtjaHVuazplfSl9b25Mb2FkZWRTdHJlYW0oKXtyZXR1cm4gdGhpcy5zdHJlYW1NYW5hZ2VyLm9uTG9hZGVkU3RyZWFtKCl9dGVybWluYXRlKGUpe3RoaXMuc3RyZWFtTWFuYWdlci5hYm9ydChlKX19fSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuQ2h1bmtlZFN0cmVhbU1hbmFnZXI9dC5DaHVua2VkU3RyZWFtPXZvaWQgMDt2YXIgcj1hKDIpLG49YSg2KSxpPWEoMTApO2NsYXNzIENodW5rZWRTdHJlYW0gZXh0ZW5kcyBpLlN0cmVhbXtjb25zdHJ1Y3RvcihlLHQsYSl7c3VwZXIobmV3IFVpbnQ4QXJyYXkoZSksMCxlLG51bGwpO3RoaXMuY2h1bmtTaXplPXQ7dGhpcy5fbG9hZGVkQ2h1bmtzPW5ldyBTZXQ7dGhpcy5udW1DaHVua3M9TWF0aC5jZWlsKGUvdCk7dGhpcy5tYW5hZ2VyPWE7dGhpcy5wcm9ncmVzc2l2ZURhdGFMZW5ndGg9MDt0aGlzLmxhc3RTdWNjZXNzZnVsRW5zdXJlQnl0ZUNodW5rPS0xfWdldE1pc3NpbmdDaHVua3MoKXtjb25zdCBlPVtdO2ZvcihsZXQgdD0wLGE9dGhpcy5udW1DaHVua3M7dDxhOysrdCl0aGlzLl9sb2FkZWRDaHVua3MuaGFzKHQpfHxlLnB1c2godCk7cmV0dXJuIGV9Z2V0IG51bUNodW5rc0xvYWRlZCgpe3JldHVybiB0aGlzLl9sb2FkZWRDaHVua3Muc2l6ZX1nZXQgaXNEYXRhTG9hZGVkKCl7cmV0dXJuIHRoaXMubnVtQ2h1bmtzTG9hZGVkPT09dGhpcy5udW1DaHVua3N9b25SZWNlaXZlRGF0YShlLHQpe2NvbnN0IGE9dGhpcy5jaHVua1NpemU7aWYoZSVhIT0wKXRocm93IG5ldyBFcnJvcihgQmFkIGJlZ2luIG9mZnNldDogJHtlfWApO2NvbnN0IHI9ZSt0LmJ5dGVMZW5ndGg7aWYociVhIT0wJiZyIT09dGhpcy5ieXRlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBCYWQgZW5kIG9mZnNldDogJHtyfWApO3RoaXMuYnl0ZXMuc2V0KG5ldyBVaW50OEFycmF5KHQpLGUpO2NvbnN0IG49TWF0aC5mbG9vcihlL2EpLGk9TWF0aC5mbG9vcigoci0xKS9hKSsxO2ZvcihsZXQgZT1uO2U8aTsrK2UpdGhpcy5fbG9hZGVkQ2h1bmtzLmFkZChlKX1vblJlY2VpdmVQcm9ncmVzc2l2ZURhdGEoZSl7bGV0IHQ9dGhpcy5wcm9ncmVzc2l2ZURhdGFMZW5ndGg7Y29uc3QgYT1NYXRoLmZsb29yKHQvdGhpcy5jaHVua1NpemUpO3RoaXMuYnl0ZXMuc2V0KG5ldyBVaW50OEFycmF5KGUpLHQpO3QrPWUuYnl0ZUxlbmd0aDt0aGlzLnByb2dyZXNzaXZlRGF0YUxlbmd0aD10O2NvbnN0IHI9dD49dGhpcy5lbmQ/dGhpcy5udW1DaHVua3M6TWF0aC5mbG9vcih0L3RoaXMuY2h1bmtTaXplKTtmb3IobGV0IGU9YTtlPHI7KytlKXRoaXMuX2xvYWRlZENodW5rcy5hZGQoZSl9ZW5zdXJlQnl0ZShlKXtpZihlPHRoaXMucHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKXJldHVybjtjb25zdCB0PU1hdGguZmxvb3IoZS90aGlzLmNodW5rU2l6ZSk7aWYoISh0PnRoaXMubnVtQ2h1bmtzKSYmdCE9PXRoaXMubGFzdFN1Y2Nlc3NmdWxFbnN1cmVCeXRlQ2h1bmspe2lmKCF0aGlzLl9sb2FkZWRDaHVua3MuaGFzKHQpKXRocm93IG5ldyBuLk1pc3NpbmdEYXRhRXhjZXB0aW9uKGUsZSsxKTt0aGlzLmxhc3RTdWNjZXNzZnVsRW5zdXJlQnl0ZUNodW5rPXR9fWVuc3VyZVJhbmdlKGUsdCl7aWYoZT49dClyZXR1cm47aWYodDw9dGhpcy5wcm9ncmVzc2l2ZURhdGFMZW5ndGgpcmV0dXJuO2NvbnN0IGE9TWF0aC5mbG9vcihlL3RoaXMuY2h1bmtTaXplKTtpZihhPnRoaXMubnVtQ2h1bmtzKXJldHVybjtjb25zdCByPU1hdGgubWluKE1hdGguZmxvb3IoKHQtMSkvdGhpcy5jaHVua1NpemUpKzEsdGhpcy5udW1DaHVua3MpO2ZvcihsZXQgaT1hO2k8cjsrK2kpaWYoIXRoaXMuX2xvYWRlZENodW5rcy5oYXMoaSkpdGhyb3cgbmV3IG4uTWlzc2luZ0RhdGFFeGNlcHRpb24oZSx0KX1uZXh0RW1wdHlDaHVuayhlKXtjb25zdCB0PXRoaXMubnVtQ2h1bmtzO2ZvcihsZXQgYT0wO2E8dDsrK2Epe2NvbnN0IHI9KGUrYSkldDtpZighdGhpcy5fbG9hZGVkQ2h1bmtzLmhhcyhyKSlyZXR1cm4gcn1yZXR1cm4gbnVsbH1oYXNDaHVuayhlKXtyZXR1cm4gdGhpcy5fbG9hZGVkQ2h1bmtzLmhhcyhlKX1nZXRCeXRlKCl7Y29uc3QgZT10aGlzLnBvcztpZihlPj10aGlzLmVuZClyZXR1cm4tMTtlPj10aGlzLnByb2dyZXNzaXZlRGF0YUxlbmd0aCYmdGhpcy5lbnN1cmVCeXRlKGUpO3JldHVybiB0aGlzLmJ5dGVzW3RoaXMucG9zKytdfWdldEJ5dGVzKGUpe2NvbnN0IHQ9dGhpcy5ieXRlcyxhPXRoaXMucG9zLHI9dGhpcy5lbmQ7aWYoIWUpe3I+dGhpcy5wcm9ncmVzc2l2ZURhdGFMZW5ndGgmJnRoaXMuZW5zdXJlUmFuZ2UoYSxyKTtyZXR1cm4gdC5zdWJhcnJheShhLHIpfWxldCBuPWErZTtuPnImJihuPXIpO24+dGhpcy5wcm9ncmVzc2l2ZURhdGFMZW5ndGgmJnRoaXMuZW5zdXJlUmFuZ2UoYSxuKTt0aGlzLnBvcz1uO3JldHVybiB0LnN1YmFycmF5KGEsbil9Z2V0Qnl0ZVJhbmdlKGUsdCl7ZTwwJiYoZT0wKTt0PnRoaXMuZW5kJiYodD10aGlzLmVuZCk7dD50aGlzLnByb2dyZXNzaXZlRGF0YUxlbmd0aCYmdGhpcy5lbnN1cmVSYW5nZShlLHQpO3JldHVybiB0aGlzLmJ5dGVzLnN1YmFycmF5KGUsdCl9bWFrZVN1YlN0cmVhbShlLHQsYT1udWxsKXt0P2UrdD50aGlzLnByb2dyZXNzaXZlRGF0YUxlbmd0aCYmdGhpcy5lbnN1cmVSYW5nZShlLGUrdCk6ZT49dGhpcy5wcm9ncmVzc2l2ZURhdGFMZW5ndGgmJnRoaXMuZW5zdXJlQnl0ZShlKTtmdW5jdGlvbiBDaHVua2VkU3RyZWFtU3Vic3RyZWFtKCl7fUNodW5rZWRTdHJlYW1TdWJzdHJlYW0ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodGhpcyk7Q2h1bmtlZFN0cmVhbVN1YnN0cmVhbS5wcm90b3R5cGUuZ2V0TWlzc2luZ0NodW5rcz1mdW5jdGlvbigpe2NvbnN0IGU9dGhpcy5jaHVua1NpemUsdD1NYXRoLmZsb29yKHRoaXMuc3RhcnQvZSksYT1NYXRoLmZsb29yKCh0aGlzLmVuZC0xKS9lKSsxLHI9W107Zm9yKGxldCBlPXQ7ZTxhOysrZSl0aGlzLl9sb2FkZWRDaHVua3MuaGFzKGUpfHxyLnB1c2goZSk7cmV0dXJuIHJ9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShDaHVua2VkU3RyZWFtU3Vic3RyZWFtLnByb3RvdHlwZSwiaXNEYXRhTG9hZGVkIix7Z2V0KCl7cmV0dXJuIHRoaXMubnVtQ2h1bmtzTG9hZGVkPT09dGhpcy5udW1DaHVua3N8fDA9PT10aGlzLmdldE1pc3NpbmdDaHVua3MoKS5sZW5ndGh9LGNvbmZpZ3VyYWJsZTohMH0pO2NvbnN0IHI9bmV3IENodW5rZWRTdHJlYW1TdWJzdHJlYW07ci5wb3M9ci5zdGFydD1lO3IuZW5kPWUrdHx8dGhpcy5lbmQ7ci5kaWN0PWE7cmV0dXJuIHJ9Z2V0QmFzZVN0cmVhbXMoKXtyZXR1cm5bdGhpc119fXQuQ2h1bmtlZFN0cmVhbT1DaHVua2VkU3RyZWFtO3QuQ2h1bmtlZFN0cmVhbU1hbmFnZXI9Y2xhc3MgQ2h1bmtlZFN0cmVhbU1hbmFnZXJ7Y29uc3RydWN0b3IoZSx0KXt0aGlzLmxlbmd0aD10Lmxlbmd0aDt0aGlzLmNodW5rU2l6ZT10LnJhbmdlQ2h1bmtTaXplO3RoaXMuc3RyZWFtPW5ldyBDaHVua2VkU3RyZWFtKHRoaXMubGVuZ3RoLHRoaXMuY2h1bmtTaXplLHRoaXMpO3RoaXMucGRmTmV0d29ya1N0cmVhbT1lO3RoaXMuZGlzYWJsZUF1dG9GZXRjaD10LmRpc2FibGVBdXRvRmV0Y2g7dGhpcy5tc2dIYW5kbGVyPXQubXNnSGFuZGxlcjt0aGlzLmN1cnJSZXF1ZXN0SWQ9MDt0aGlzLl9jaHVua3NOZWVkZWRCeVJlcXVlc3Q9bmV3IE1hcDt0aGlzLl9yZXF1ZXN0c0J5Q2h1bms9bmV3IE1hcDt0aGlzLl9wcm9taXNlc0J5UmVxdWVzdD1uZXcgTWFwO3RoaXMucHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoPTA7dGhpcy5hYm9ydGVkPSExO3RoaXMuX2xvYWRlZFN0cmVhbUNhcGFiaWxpdHk9KDAsci5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKX1vbkxvYWRlZFN0cmVhbSgpe3JldHVybiB0aGlzLl9sb2FkZWRTdHJlYW1DYXBhYmlsaXR5LnByb21pc2V9c2VuZFJlcXVlc3QoZSx0KXtjb25zdCBhPXRoaXMucGRmTmV0d29ya1N0cmVhbS5nZXRSYW5nZVJlYWRlcihlLHQpO2EuaXNTdHJlYW1pbmdTdXBwb3J0ZWR8fChhLm9uUHJvZ3Jlc3M9dGhpcy5vblByb2dyZXNzLmJpbmQodGhpcykpO2xldCBuPVtdLGk9MDtyZXR1cm4gbmV3IFByb21pc2UoKChlLHQpPT57Y29uc3QgcmVhZENodW5rPXM9Pnt0cnl7aWYoIXMuZG9uZSl7Y29uc3QgZT1zLnZhbHVlO24ucHVzaChlKTtpKz0oMCxyLmFycmF5Qnl0ZUxlbmd0aCkoZSk7YS5pc1N0cmVhbWluZ1N1cHBvcnRlZCYmdGhpcy5vblByb2dyZXNzKHtsb2FkZWQ6aX0pO2EucmVhZCgpLnRoZW4ocmVhZENodW5rLHQpO3JldHVybn1jb25zdCBvPSgwLHIuYXJyYXlzVG9CeXRlcykobik7bj1udWxsO2Uobyl9Y2F0Y2goZSl7dChlKX19O2EucmVhZCgpLnRoZW4ocmVhZENodW5rLHQpfSkpLnRoZW4oKHQ9Pnt0aGlzLmFib3J0ZWR8fHRoaXMub25SZWNlaXZlRGF0YSh7Y2h1bms6dCxiZWdpbjplfSl9KSl9cmVxdWVzdEFsbENodW5rcygpe2NvbnN0IGU9dGhpcy5zdHJlYW0uZ2V0TWlzc2luZ0NodW5rcygpO3RoaXMuX3JlcXVlc3RDaHVua3MoZSk7cmV0dXJuIHRoaXMuX2xvYWRlZFN0cmVhbUNhcGFiaWxpdHkucHJvbWlzZX1fcmVxdWVzdENodW5rcyhlKXtjb25zdCB0PXRoaXMuY3VyclJlcXVlc3RJZCsrLGE9bmV3IFNldDt0aGlzLl9jaHVua3NOZWVkZWRCeVJlcXVlc3Quc2V0KHQsYSk7Zm9yKGNvbnN0IHQgb2YgZSl0aGlzLnN0cmVhbS5oYXNDaHVuayh0KXx8YS5hZGQodCk7aWYoMD09PWEuc2l6ZSlyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7Y29uc3Qgbj0oMCxyLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO3RoaXMuX3Byb21pc2VzQnlSZXF1ZXN0LnNldCh0LG4pO2NvbnN0IGk9W107Zm9yKGNvbnN0IGUgb2YgYSl7bGV0IGE9dGhpcy5fcmVxdWVzdHNCeUNodW5rLmdldChlKTtpZighYSl7YT1bXTt0aGlzLl9yZXF1ZXN0c0J5Q2h1bmsuc2V0KGUsYSk7aS5wdXNoKGUpfWEucHVzaCh0KX1pZihpLmxlbmd0aD4wKXtjb25zdCBlPXRoaXMuZ3JvdXBDaHVua3MoaSk7Zm9yKGNvbnN0IHQgb2YgZSl7Y29uc3QgZT10LmJlZ2luQ2h1bmsqdGhpcy5jaHVua1NpemUsYT1NYXRoLm1pbih0LmVuZENodW5rKnRoaXMuY2h1bmtTaXplLHRoaXMubGVuZ3RoKTt0aGlzLnNlbmRSZXF1ZXN0KGUsYSkuY2F0Y2gobi5yZWplY3QpfX1yZXR1cm4gbi5wcm9taXNlLmNhdGNoKChlPT57aWYoIXRoaXMuYWJvcnRlZCl0aHJvdyBlfSkpfWdldFN0cmVhbSgpe3JldHVybiB0aGlzLnN0cmVhbX1yZXF1ZXN0UmFuZ2UoZSx0KXt0PU1hdGgubWluKHQsdGhpcy5sZW5ndGgpO2NvbnN0IGE9dGhpcy5nZXRCZWdpbkNodW5rKGUpLHI9dGhpcy5nZXRFbmRDaHVuayh0KSxuPVtdO2ZvcihsZXQgZT1hO2U8cjsrK2Upbi5wdXNoKGUpO3JldHVybiB0aGlzLl9yZXF1ZXN0Q2h1bmtzKG4pfXJlcXVlc3RSYW5nZXMoZT1bXSl7Y29uc3QgdD1bXTtmb3IoY29uc3QgYSBvZiBlKXtjb25zdCBlPXRoaXMuZ2V0QmVnaW5DaHVuayhhLmJlZ2luKSxyPXRoaXMuZ2V0RW5kQ2h1bmsoYS5lbmQpO2ZvcihsZXQgYT1lO2E8cjsrK2EpdC5pbmNsdWRlcyhhKXx8dC5wdXNoKGEpfXQuc29ydCgoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS10fSkpO3JldHVybiB0aGlzLl9yZXF1ZXN0Q2h1bmtzKHQpfWdyb3VwQ2h1bmtzKGUpe2NvbnN0IHQ9W107bGV0IGE9LTEscj0tMTtmb3IobGV0IG49MCxpPWUubGVuZ3RoO248aTsrK24pe2NvbnN0IGk9ZVtuXTthPDAmJihhPWkpO2lmKHI+PTAmJnIrMSE9PWkpe3QucHVzaCh7YmVnaW5DaHVuazphLGVuZENodW5rOnIrMX0pO2E9aX1uKzE9PT1lLmxlbmd0aCYmdC5wdXNoKHtiZWdpbkNodW5rOmEsZW5kQ2h1bms6aSsxfSk7cj1pfXJldHVybiB0fW9uUHJvZ3Jlc3MoZSl7dGhpcy5tc2dIYW5kbGVyLnNlbmQoIkRvY1Byb2dyZXNzIix7bG9hZGVkOnRoaXMuc3RyZWFtLm51bUNodW5rc0xvYWRlZCp0aGlzLmNodW5rU2l6ZStlLmxvYWRlZCx0b3RhbDp0aGlzLmxlbmd0aH0pfW9uUmVjZWl2ZURhdGEoZSl7Y29uc3QgdD1lLmNodW5rLGE9dm9pZCAwPT09ZS5iZWdpbixyPWE/dGhpcy5wcm9ncmVzc2l2ZURhdGFMZW5ndGg6ZS5iZWdpbixuPXIrdC5ieXRlTGVuZ3RoLGk9TWF0aC5mbG9vcihyL3RoaXMuY2h1bmtTaXplKSxzPW48dGhpcy5sZW5ndGg/TWF0aC5mbG9vcihuL3RoaXMuY2h1bmtTaXplKTpNYXRoLmNlaWwobi90aGlzLmNodW5rU2l6ZSk7aWYoYSl7dGhpcy5zdHJlYW0ub25SZWNlaXZlUHJvZ3Jlc3NpdmVEYXRhKHQpO3RoaXMucHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoPW59ZWxzZSB0aGlzLnN0cmVhbS5vblJlY2VpdmVEYXRhKHIsdCk7dGhpcy5zdHJlYW0uaXNEYXRhTG9hZGVkJiZ0aGlzLl9sb2FkZWRTdHJlYW1DYXBhYmlsaXR5LnJlc29sdmUodGhpcy5zdHJlYW0pO2NvbnN0IG89W107Zm9yKGxldCBlPWk7ZTxzOysrZSl7Y29uc3QgdD10aGlzLl9yZXF1ZXN0c0J5Q2h1bmsuZ2V0KGUpO2lmKHQpe3RoaXMuX3JlcXVlc3RzQnlDaHVuay5kZWxldGUoZSk7Zm9yKGNvbnN0IGEgb2YgdCl7Y29uc3QgdD10aGlzLl9jaHVua3NOZWVkZWRCeVJlcXVlc3QuZ2V0KGEpO3QuaGFzKGUpJiZ0LmRlbGV0ZShlKTt0LnNpemU+MHx8by5wdXNoKGEpfX19aWYoIXRoaXMuZGlzYWJsZUF1dG9GZXRjaCYmMD09PXRoaXMuX3JlcXVlc3RzQnlDaHVuay5zaXplKXtsZXQgZTtpZigxPT09dGhpcy5zdHJlYW0ubnVtQ2h1bmtzTG9hZGVkKXtjb25zdCB0PXRoaXMuc3RyZWFtLm51bUNodW5rcy0xO3RoaXMuc3RyZWFtLmhhc0NodW5rKHQpfHwoZT10KX1lbHNlIGU9dGhpcy5zdHJlYW0ubmV4dEVtcHR5Q2h1bmsocyk7TnVtYmVyLmlzSW50ZWdlcihlKSYmdGhpcy5fcmVxdWVzdENodW5rcyhbZV0pfWZvcihjb25zdCBlIG9mIG8pe2NvbnN0IHQ9dGhpcy5fcHJvbWlzZXNCeVJlcXVlc3QuZ2V0KGUpO3RoaXMuX3Byb21pc2VzQnlSZXF1ZXN0LmRlbGV0ZShlKTt0LnJlc29sdmUoKX10aGlzLm1zZ0hhbmRsZXIuc2VuZCgiRG9jUHJvZ3Jlc3MiLHtsb2FkZWQ6dGhpcy5zdHJlYW0ubnVtQ2h1bmtzTG9hZGVkKnRoaXMuY2h1bmtTaXplLHRvdGFsOnRoaXMubGVuZ3RofSl9b25FcnJvcihlKXt0aGlzLl9sb2FkZWRTdHJlYW1DYXBhYmlsaXR5LnJlamVjdChlKX1nZXRCZWdpbkNodW5rKGUpe3JldHVybiBNYXRoLmZsb29yKGUvdGhpcy5jaHVua1NpemUpfWdldEVuZENodW5rKGUpe3JldHVybiBNYXRoLmZsb29yKChlLTEpL3RoaXMuY2h1bmtTaXplKSsxfWFib3J0KGUpe3RoaXMuYWJvcnRlZD0hMDt0aGlzLnBkZk5ldHdvcmtTdHJlYW0mJnRoaXMucGRmTmV0d29ya1N0cmVhbS5jYW5jZWxBbGxSZXF1ZXN0cyhlKTtmb3IoY29uc3QgdCBvZiB0aGlzLl9wcm9taXNlc0J5UmVxdWVzdC52YWx1ZXMoKSl0LnJlamVjdChlKX19fSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuU3RyaW5nU3RyZWFtPXQuU3RyZWFtPXQuTnVsbFN0cmVhbT12b2lkIDA7dmFyIHI9YSg3KSxuPWEoMik7Y2xhc3MgU3RyZWFtIGV4dGVuZHMgci5CYXNlU3RyZWFte2NvbnN0cnVjdG9yKGUsdCxhLHIpe3N1cGVyKCk7dGhpcy5ieXRlcz1lIGluc3RhbmNlb2YgVWludDhBcnJheT9lOm5ldyBVaW50OEFycmF5KGUpO3RoaXMuc3RhcnQ9dHx8MDt0aGlzLnBvcz10aGlzLnN0YXJ0O3RoaXMuZW5kPXQrYXx8dGhpcy5ieXRlcy5sZW5ndGg7dGhpcy5kaWN0PXJ9Z2V0IGxlbmd0aCgpe3JldHVybiB0aGlzLmVuZC10aGlzLnN0YXJ0fWdldCBpc0VtcHR5KCl7cmV0dXJuIDA9PT10aGlzLmxlbmd0aH1nZXRCeXRlKCl7cmV0dXJuIHRoaXMucG9zPj10aGlzLmVuZD8tMTp0aGlzLmJ5dGVzW3RoaXMucG9zKytdfWdldEJ5dGVzKGUpe2NvbnN0IHQ9dGhpcy5ieXRlcyxhPXRoaXMucG9zLHI9dGhpcy5lbmQ7aWYoIWUpcmV0dXJuIHQuc3ViYXJyYXkoYSxyKTtsZXQgbj1hK2U7bj5yJiYobj1yKTt0aGlzLnBvcz1uO3JldHVybiB0LnN1YmFycmF5KGEsbil9Z2V0Qnl0ZVJhbmdlKGUsdCl7ZTwwJiYoZT0wKTt0PnRoaXMuZW5kJiYodD10aGlzLmVuZCk7cmV0dXJuIHRoaXMuYnl0ZXMuc3ViYXJyYXkoZSx0KX1yZXNldCgpe3RoaXMucG9zPXRoaXMuc3RhcnR9bW92ZVN0YXJ0KCl7dGhpcy5zdGFydD10aGlzLnBvc31tYWtlU3ViU3RyZWFtKGUsdCxhPW51bGwpe3JldHVybiBuZXcgU3RyZWFtKHRoaXMuYnl0ZXMuYnVmZmVyLGUsdCxhKX19dC5TdHJlYW09U3RyZWFtO3QuU3RyaW5nU3RyZWFtPWNsYXNzIFN0cmluZ1N0cmVhbSBleHRlbmRzIFN0cmVhbXtjb25zdHJ1Y3RvcihlKXtzdXBlcigoMCxuLnN0cmluZ1RvQnl0ZXMpKGUpKX19O3QuTnVsbFN0cmVhbT1jbGFzcyBOdWxsU3RyZWFtIGV4dGVuZHMgU3RyZWFte2NvbnN0cnVjdG9yKCl7c3VwZXIobmV3IFVpbnQ4QXJyYXkoMCkpfX19LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5QYWdlPXQuUERGRG9jdW1lbnQ9dm9pZCAwO3ZhciByPWEoMTIpLG49YSgyKSxpPWEoNikscz1hKDUpLG89YSg1MSksYz1hKDcpLGw9YSg2NyksaD1hKDY5KSx1PWEoNzEpLGQ9YSgxMDApLGY9YSgxNyksZz1hKDEwKSxwPWEoNzUpLG09YSg2MiksYj1hKDE1KSx5PWEoMTkpLHc9YSg3NCksUz1hKDY1KSx4PWEoNzYpLGs9YSgxMDEpO2NvbnN0IEM9WzAsMCw2MTIsNzkyXTtjbGFzcyBQYWdle2NvbnN0cnVjdG9yKHtwZGZNYW5hZ2VyOmUseHJlZjp0LHBhZ2VJbmRleDphLHBhZ2VEaWN0OnIscmVmOm4sZ2xvYmFsSWRGYWN0b3J5OmksZm9udENhY2hlOnMsYnVpbHRJbkNNYXBDYWNoZTpvLHN0YW5kYXJkRm9udERhdGFDYWNoZTpjLGdsb2JhbEltYWdlQ2FjaGU6bCxub25CbGVuZE1vZGVzU2V0OmgseGZhRmFjdG9yeTp1fSl7dGhpcy5wZGZNYW5hZ2VyPWU7dGhpcy5wYWdlSW5kZXg9YTt0aGlzLnBhZ2VEaWN0PXI7dGhpcy54cmVmPXQ7dGhpcy5yZWY9bjt0aGlzLmZvbnRDYWNoZT1zO3RoaXMuYnVpbHRJbkNNYXBDYWNoZT1vO3RoaXMuc3RhbmRhcmRGb250RGF0YUNhY2hlPWM7dGhpcy5nbG9iYWxJbWFnZUNhY2hlPWw7dGhpcy5ub25CbGVuZE1vZGVzU2V0PWg7dGhpcy5ldmFsdWF0b3JPcHRpb25zPWUuZXZhbHVhdG9yT3B0aW9uczt0aGlzLnJlc291cmNlc1Byb21pc2U9bnVsbDt0aGlzLnhmYUZhY3Rvcnk9dTtjb25zdCBkPXtvYmo6MH07dGhpcy5fbG9jYWxJZEZhY3Rvcnk9Y2xhc3MgZXh0ZW5kcyBpe3N0YXRpYyBjcmVhdGVPYmpJZCgpe3JldHVybmBwJHthfV8keysrZC5vYmp9YH1zdGF0aWMgZ2V0UGFnZU9iaklkKCl7cmV0dXJuYHBhZ2Uke24udG9TdHJpbmcoKX1gfX19X2dldEluaGVyaXRhYmxlUHJvcGVydHkoZSx0PSExKXtjb25zdCBhPSgwLGkuZ2V0SW5oZXJpdGFibGVQcm9wZXJ0eSkoe2RpY3Q6dGhpcy5wYWdlRGljdCxrZXk6ZSxnZXRBcnJheTp0LHN0b3BXaGVuRm91bmQ6ITF9KTtyZXR1cm4gQXJyYXkuaXNBcnJheShhKT8xIT09YS5sZW5ndGgmJmFbMF1pbnN0YW5jZW9mIHMuRGljdD9zLkRpY3QubWVyZ2Uoe3hyZWY6dGhpcy54cmVmLGRpY3RBcnJheTphfSk6YVswXTphfWdldCBjb250ZW50KCl7cmV0dXJuIHRoaXMucGFnZURpY3QuZ2V0QXJyYXkoIkNvbnRlbnRzIil9Z2V0IHJlc291cmNlcygpe2NvbnN0IGU9dGhpcy5fZ2V0SW5oZXJpdGFibGVQcm9wZXJ0eSgiUmVzb3VyY2VzIik7cmV0dXJuKDAsbi5zaGFkb3cpKHRoaXMsInJlc291cmNlcyIsZSBpbnN0YW5jZW9mIHMuRGljdD9lOnMuRGljdC5lbXB0eSl9X2dldEJvdW5kaW5nQm94KGUpe2lmKHRoaXMueGZhRGF0YSlyZXR1cm4gdGhpcy54ZmFEYXRhLmJib3g7Y29uc3QgdD10aGlzLl9nZXRJbmhlcml0YWJsZVByb3BlcnR5KGUsITApO2lmKEFycmF5LmlzQXJyYXkodCkmJjQ9PT10Lmxlbmd0aCl7aWYodFsyXS10WzBdIT0wJiZ0WzNdLXRbMV0hPTApcmV0dXJuIHQ7KDAsbi53YXJuKShgRW1wdHkgLyR7ZX0gZW50cnkuYCl9cmV0dXJuIG51bGx9Z2V0IG1lZGlhQm94KCl7cmV0dXJuKDAsbi5zaGFkb3cpKHRoaXMsIm1lZGlhQm94Iix0aGlzLl9nZXRCb3VuZGluZ0JveCgiTWVkaWFCb3giKXx8Qyl9Z2V0IGNyb3BCb3goKXtyZXR1cm4oMCxuLnNoYWRvdykodGhpcywiY3JvcEJveCIsdGhpcy5fZ2V0Qm91bmRpbmdCb3goIkNyb3BCb3giKXx8dGhpcy5tZWRpYUJveCl9Z2V0IHVzZXJVbml0KCl7bGV0IGU9dGhpcy5wYWdlRGljdC5nZXQoIlVzZXJVbml0Iik7KCJudW1iZXIiIT10eXBlb2YgZXx8ZTw9MCkmJihlPTEpO3JldHVybigwLG4uc2hhZG93KSh0aGlzLCJ1c2VyVW5pdCIsZSl9Z2V0IHZpZXcoKXtjb25zdHtjcm9wQm94OmUsbWVkaWFCb3g6dH09dGhpcztsZXQgYTtpZihlPT09dHx8KDAsbi5pc0FycmF5RXF1YWwpKGUsdCkpYT10O2Vsc2V7Y29uc3Qgcj1uLlV0aWwuaW50ZXJzZWN0KGUsdCk7ciYmclsyXS1yWzBdIT0wJiZyWzNdLXJbMV0hPTA/YT1yOigwLG4ud2FybikoIkVtcHR5IC9Dcm9wQm94IGFuZCAvTWVkaWFCb3ggaW50ZXJzZWN0aW9uLiIpfXJldHVybigwLG4uc2hhZG93KSh0aGlzLCJ2aWV3IixhfHx0KX1nZXQgcm90YXRlKCl7bGV0IGU9dGhpcy5fZ2V0SW5oZXJpdGFibGVQcm9wZXJ0eSgiUm90YXRlIil8fDA7ZSU5MCE9MD9lPTA6ZT49MzYwP2UlPTM2MDplPDAmJihlPShlJTM2MCszNjApJTM2MCk7cmV0dXJuKDAsbi5zaGFkb3cpKHRoaXMsInJvdGF0ZSIsZSl9X29uU3ViU3RyZWFtRXJyb3IoZSx0LGEpe2lmKCF0aGlzLmV2YWx1YXRvck9wdGlvbnMuaWdub3JlRXJyb3JzKXRocm93IHQ7ZS5zZW5kKCJVbnN1cHBvcnRlZEZlYXR1cmUiLHtmZWF0dXJlSWQ6bi5VTlNVUFBPUlRFRF9GRUFUVVJFUy5lcnJvckNvbnRlbnRTdWJTdHJlYW19KTsoMCxuLndhcm4pKGBnZXRDb250ZW50U3RyZWFtIC0gaWdub3Jpbmcgc3ViLXN0cmVhbSAoJHthfSk6ICIke3R9Ii5gKX1nZXRDb250ZW50U3RyZWFtKGUpe3JldHVybiB0aGlzLnBkZk1hbmFnZXIuZW5zdXJlKHRoaXMsImNvbnRlbnQiKS50aGVuKCh0PT50IGluc3RhbmNlb2YgYy5CYXNlU3RyZWFtP3Q6QXJyYXkuaXNBcnJheSh0KT9uZXcgeS5TdHJlYW1zU2VxdWVuY2VTdHJlYW0odCx0aGlzLl9vblN1YlN0cmVhbUVycm9yLmJpbmQodGhpcyxlKSk6bmV3IGcuTnVsbFN0cmVhbSkpfWdldCB4ZmFEYXRhKCl7cmV0dXJuKDAsbi5zaGFkb3cpKHRoaXMsInhmYURhdGEiLHRoaXMueGZhRmFjdG9yeT97YmJveDp0aGlzLnhmYUZhY3RvcnkuZ2V0Qm91bmRpbmdCb3godGhpcy5wYWdlSW5kZXgpfTpudWxsKX1hc3luYyBzYXZlTmV3QW5ub3RhdGlvbnMoZSx0LGEpe2lmKHRoaXMueGZhRmFjdG9yeSl0aHJvdyBuZXcgRXJyb3IoIlhGQTogQ2Fubm90IHNhdmUgbmV3IGFubm90YXRpb25zLiIpO2NvbnN0IG49bmV3IGIuUGFydGlhbEV2YWx1YXRvcih7eHJlZjp0aGlzLnhyZWYsaGFuZGxlcjplLHBhZ2VJbmRleDp0aGlzLnBhZ2VJbmRleCxpZEZhY3Rvcnk6dGhpcy5fbG9jYWxJZEZhY3RvcnksZm9udENhY2hlOnRoaXMuZm9udENhY2hlLGJ1aWx0SW5DTWFwQ2FjaGU6dGhpcy5idWlsdEluQ01hcENhY2hlLHN0YW5kYXJkRm9udERhdGFDYWNoZTp0aGlzLnN0YW5kYXJkRm9udERhdGFDYWNoZSxnbG9iYWxJbWFnZUNhY2hlOnRoaXMuZ2xvYmFsSW1hZ2VDYWNoZSxvcHRpb25zOnRoaXMuZXZhbHVhdG9yT3B0aW9uc30pLGk9dGhpcy5wYWdlRGljdCxzPXRoaXMuYW5ub3RhdGlvbnMuc2xpY2UoKSxvPWF3YWl0IHIuQW5ub3RhdGlvbkZhY3Rvcnkuc2F2ZU5ld0Fubm90YXRpb25zKG4sdCxhKTtmb3IoY29uc3R7cmVmOmV9b2Ygby5hbm5vdGF0aW9ucylzLnB1c2goZSk7Y29uc3QgYz1pLmdldCgiQW5ub3RzIik7aS5zZXQoIkFubm90cyIscyk7Y29uc3QgbD1bXTtsZXQgaD1udWxsO3RoaXMueHJlZi5lbmNyeXB0JiYoaD10aGlzLnhyZWYuZW5jcnlwdC5jcmVhdGVDaXBoZXJUcmFuc2Zvcm0odGhpcy5yZWYubnVtLHRoaXMucmVmLmdlbikpOygwLFMud3JpdGVPYmplY3QpKHRoaXMucmVmLGksbCxoKTtjJiZpLnNldCgiQW5ub3RzIixjKTtjb25zdCB1PW8uZGVwZW5kZW5jaWVzO3UucHVzaCh7cmVmOnRoaXMucmVmLGRhdGE6bC5qb2luKCIiKX0sLi4uby5hbm5vdGF0aW9ucyk7cmV0dXJuIHV9c2F2ZShlLHQsYSl7Y29uc3Qgcj1uZXcgYi5QYXJ0aWFsRXZhbHVhdG9yKHt4cmVmOnRoaXMueHJlZixoYW5kbGVyOmUscGFnZUluZGV4OnRoaXMucGFnZUluZGV4LGlkRmFjdG9yeTp0aGlzLl9sb2NhbElkRmFjdG9yeSxmb250Q2FjaGU6dGhpcy5mb250Q2FjaGUsYnVpbHRJbkNNYXBDYWNoZTp0aGlzLmJ1aWx0SW5DTWFwQ2FjaGUsc3RhbmRhcmRGb250RGF0YUNhY2hlOnRoaXMuc3RhbmRhcmRGb250RGF0YUNhY2hlLGdsb2JhbEltYWdlQ2FjaGU6dGhpcy5nbG9iYWxJbWFnZUNhY2hlLG9wdGlvbnM6dGhpcy5ldmFsdWF0b3JPcHRpb25zfSk7cmV0dXJuIHRoaXMuX3BhcnNlZEFubm90YXRpb25zLnRoZW4oKGZ1bmN0aW9uKGUpe2NvbnN0IGk9W107Zm9yKGNvbnN0IHMgb2YgZSlzLm11c3RCZVByaW50ZWQoYSkmJmkucHVzaChzLnNhdmUocix0LGEpLmNhdGNoKChmdW5jdGlvbihlKXsoMCxuLndhcm4pKGBzYXZlIC0gaWdub3JpbmcgYW5ub3RhdGlvbiBkYXRhIGR1cmluZyAiJHt0Lm5hbWV9IiB0YXNrOiAiJHtlfSIuYCk7cmV0dXJuIG51bGx9KSkpO3JldHVybiBQcm9taXNlLmFsbChpKS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gZS5maWx0ZXIoKGU9PiEhZSkpfSkpfSkpfWxvYWRSZXNvdXJjZXMoZSl7dGhpcy5yZXNvdXJjZXNQcm9taXNlfHwodGhpcy5yZXNvdXJjZXNQcm9taXNlPXRoaXMucGRmTWFuYWdlci5lbnN1cmUodGhpcywicmVzb3VyY2VzIikpO3JldHVybiB0aGlzLnJlc291cmNlc1Byb21pc2UudGhlbigoKCk9Pm5ldyBwLk9iamVjdExvYWRlcih0aGlzLnJlc291cmNlcyxlLHRoaXMueHJlZikubG9hZCgpKSl9Z2V0T3BlcmF0b3JMaXN0KHtoYW5kbGVyOmUsc2luazp0LHRhc2s6YSxpbnRlbnQ6cyxjYWNoZUtleTpvLGFubm90YXRpb25TdG9yYWdlOmM9bnVsbH0pe2NvbnN0IGw9dGhpcy5nZXRDb250ZW50U3RyZWFtKGUpLGg9dGhpcy5sb2FkUmVzb3VyY2VzKFsiQ29sb3JTcGFjZSIsIkV4dEdTdGF0ZSIsIkZvbnQiLCJQYXR0ZXJuIiwiUHJvcGVydGllcyIsIlNoYWRpbmciLCJYT2JqZWN0Il0pLHU9bmV3IGIuUGFydGlhbEV2YWx1YXRvcih7eHJlZjp0aGlzLnhyZWYsaGFuZGxlcjplLHBhZ2VJbmRleDp0aGlzLnBhZ2VJbmRleCxpZEZhY3Rvcnk6dGhpcy5fbG9jYWxJZEZhY3RvcnksZm9udENhY2hlOnRoaXMuZm9udENhY2hlLGJ1aWx0SW5DTWFwQ2FjaGU6dGhpcy5idWlsdEluQ01hcENhY2hlLHN0YW5kYXJkRm9udERhdGFDYWNoZTp0aGlzLnN0YW5kYXJkRm9udERhdGFDYWNoZSxnbG9iYWxJbWFnZUNhY2hlOnRoaXMuZ2xvYmFsSW1hZ2VDYWNoZSxvcHRpb25zOnRoaXMuZXZhbHVhdG9yT3B0aW9uc30pLGQ9dGhpcy54ZmFGYWN0b3J5P251bGw6KDAsaS5nZXROZXdBbm5vdGF0aW9uc01hcCkoYyk7bGV0IGY9UHJvbWlzZS5yZXNvbHZlKG51bGwpO2lmKGQpe2NvbnN0IGU9ZC5nZXQodGhpcy5wYWdlSW5kZXgpO2UmJihmPXIuQW5ub3RhdGlvbkZhY3RvcnkucHJpbnROZXdBbm5vdGF0aW9ucyh1LGEsZSkpfWNvbnN0IGc9UHJvbWlzZS5hbGwoW2wsaF0pLnRoZW4oKChbcl0pPT57Y29uc3Qgbj1uZXcgbS5PcGVyYXRvckxpc3Qocyx0KTtlLnNlbmQoIlN0YXJ0UmVuZGVyUGFnZSIse3RyYW5zcGFyZW5jeTp1Lmhhc0JsZW5kTW9kZXModGhpcy5yZXNvdXJjZXMsdGhpcy5ub25CbGVuZE1vZGVzU2V0KSxwYWdlSW5kZXg6dGhpcy5wYWdlSW5kZXgsY2FjaGVLZXk6b30pO3JldHVybiB1LmdldE9wZXJhdG9yTGlzdCh7c3RyZWFtOnIsdGFzazphLHJlc291cmNlczp0aGlzLnJlc291cmNlcyxvcGVyYXRvckxpc3Q6bn0pLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIG59KSl9KSk7cmV0dXJuIFByb21pc2UuYWxsKFtnLHRoaXMuX3BhcnNlZEFubm90YXRpb25zLGZdKS50aGVuKChmdW5jdGlvbihbZSx0LHJdKXtyJiYodD10LmNvbmNhdChyKSk7aWYoMD09PXQubGVuZ3RofHxzJm4uUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19ESVNBQkxFKXtlLmZsdXNoKCEwKTtyZXR1cm57bGVuZ3RoOmUudG90YWxMZW5ndGh9fWNvbnN0IGk9ISEocyZuLlJlbmRlcmluZ0ludGVudEZsYWcuQU5OT1RBVElPTlNfRk9STVMpLG89ISEocyZuLlJlbmRlcmluZ0ludGVudEZsYWcuQU5ZKSxsPSEhKHMmbi5SZW5kZXJpbmdJbnRlbnRGbGFnLkRJU1BMQVkpLGg9ISEocyZuLlJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQpLGQ9W107Zm9yKGNvbnN0IGUgb2YgdCkob3x8bCYmZS5tdXN0QmVWaWV3ZWQoYyl8fGgmJmUubXVzdEJlUHJpbnRlZChjKSkmJmQucHVzaChlLmdldE9wZXJhdG9yTGlzdCh1LGEscyxpLGMpLmNhdGNoKChmdW5jdGlvbihlKXsoMCxuLndhcm4pKGBnZXRPcGVyYXRvckxpc3QgLSBpZ25vcmluZyBhbm5vdGF0aW9uIGRhdGEgZHVyaW5nICIke2EubmFtZX0iIHRhc2s6ICIke2V9Ii5gKTtyZXR1cm4gbnVsbH0pKSk7cmV0dXJuIFByb21pc2UuYWxsKGQpLnRoZW4oKGZ1bmN0aW9uKHQpe2xldCBhPSExLHI9ITE7Zm9yKGNvbnN0e29wTGlzdDpuLHNlcGFyYXRlRm9ybTppLHNlcGFyYXRlQ2FudmFzOnN9b2YgdCl7ZS5hZGRPcExpc3Qobik7aSYmKGE9aSk7cyYmKHI9cyl9ZS5mbHVzaCghMCx7Zm9ybTphLGNhbnZhczpyfSk7cmV0dXJue2xlbmd0aDplLnRvdGFsTGVuZ3RofX0pKX0pKX1leHRyYWN0VGV4dENvbnRlbnQoe2hhbmRsZXI6ZSx0YXNrOnQsaW5jbHVkZU1hcmtlZENvbnRlbnQ6YSxzaW5rOnIsY29tYmluZVRleHRJdGVtczpufSl7Y29uc3QgaT10aGlzLmdldENvbnRlbnRTdHJlYW0oZSkscz10aGlzLmxvYWRSZXNvdXJjZXMoWyJFeHRHU3RhdGUiLCJGb250IiwiUHJvcGVydGllcyIsIlhPYmplY3QiXSk7cmV0dXJuIFByb21pc2UuYWxsKFtpLHNdKS50aGVuKCgoW2ldKT0+bmV3IGIuUGFydGlhbEV2YWx1YXRvcih7eHJlZjp0aGlzLnhyZWYsaGFuZGxlcjplLHBhZ2VJbmRleDp0aGlzLnBhZ2VJbmRleCxpZEZhY3Rvcnk6dGhpcy5fbG9jYWxJZEZhY3RvcnksZm9udENhY2hlOnRoaXMuZm9udENhY2hlLGJ1aWx0SW5DTWFwQ2FjaGU6dGhpcy5idWlsdEluQ01hcENhY2hlLHN0YW5kYXJkRm9udERhdGFDYWNoZTp0aGlzLnN0YW5kYXJkRm9udERhdGFDYWNoZSxnbG9iYWxJbWFnZUNhY2hlOnRoaXMuZ2xvYmFsSW1hZ2VDYWNoZSxvcHRpb25zOnRoaXMuZXZhbHVhdG9yT3B0aW9uc30pLmdldFRleHRDb250ZW50KHtzdHJlYW06aSx0YXNrOnQscmVzb3VyY2VzOnRoaXMucmVzb3VyY2VzLGluY2x1ZGVNYXJrZWRDb250ZW50OmEsY29tYmluZVRleHRJdGVtczpuLHNpbms6cix2aWV3Qm94OnRoaXMudmlld30pKSl9YXN5bmMgZ2V0U3RydWN0VHJlZSgpe2NvbnN0IGU9YXdhaXQgdGhpcy5wZGZNYW5hZ2VyLmVuc3VyZUNhdGFsb2coInN0cnVjdFRyZWVSb290Iik7aWYoIWUpcmV0dXJuIG51bGw7cmV0dXJuKGF3YWl0IHRoaXMucGRmTWFuYWdlci5lbnN1cmUodGhpcywiX3BhcnNlU3RydWN0VHJlZSIsW2VdKSkuc2VyaWFsaXphYmxlfV9wYXJzZVN0cnVjdFRyZWUoZSl7Y29uc3QgdD1uZXcgdy5TdHJ1Y3RUcmVlUGFnZShlLHRoaXMucGFnZURpY3QpO3QucGFyc2UoKTtyZXR1cm4gdH1hc3luYyBnZXRBbm5vdGF0aW9uc0RhdGEoZSx0LGEpe2NvbnN0IHI9YXdhaXQgdGhpcy5fcGFyc2VkQW5ub3RhdGlvbnM7aWYoMD09PXIubGVuZ3RoKXJldHVybltdO2NvbnN0IGk9W10scz1bXTtsZXQgbztjb25zdCBjPSEhKGEmbi5SZW5kZXJpbmdJbnRlbnRGbGFnLkFOWSksbD0hIShhJm4uUmVuZGVyaW5nSW50ZW50RmxhZy5ESVNQTEFZKSxoPSEhKGEmbi5SZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UKTtmb3IoY29uc3QgYSBvZiByKXtjb25zdCByPWN8fGwmJmEudmlld2FibGU7KHJ8fGgmJmEucHJpbnRhYmxlKSYmcy5wdXNoKGEuZGF0YSk7aWYoYS5oYXNUZXh0Q29udGVudCYmcil7b3x8KG89bmV3IGIuUGFydGlhbEV2YWx1YXRvcih7eHJlZjp0aGlzLnhyZWYsaGFuZGxlcjplLHBhZ2VJbmRleDp0aGlzLnBhZ2VJbmRleCxpZEZhY3Rvcnk6dGhpcy5fbG9jYWxJZEZhY3RvcnksZm9udENhY2hlOnRoaXMuZm9udENhY2hlLGJ1aWx0SW5DTWFwQ2FjaGU6dGhpcy5idWlsdEluQ01hcENhY2hlLHN0YW5kYXJkRm9udERhdGFDYWNoZTp0aGlzLnN0YW5kYXJkRm9udERhdGFDYWNoZSxnbG9iYWxJbWFnZUNhY2hlOnRoaXMuZ2xvYmFsSW1hZ2VDYWNoZSxvcHRpb25zOnRoaXMuZXZhbHVhdG9yT3B0aW9uc30pKTtpLnB1c2goYS5leHRyYWN0VGV4dENvbnRlbnQobyx0LHRoaXMudmlldykuY2F0Y2goKGZ1bmN0aW9uKGUpeygwLG4ud2FybikoYGdldEFubm90YXRpb25zRGF0YSAtIGlnbm9yaW5nIHRleHRDb250ZW50IGR1cmluZyAiJHt0Lm5hbWV9IiB0YXNrOiAiJHtlfSIuYCl9KSkpfX1hd2FpdCBQcm9taXNlLmFsbChpKTtyZXR1cm4gc31nZXQgYW5ub3RhdGlvbnMoKXtjb25zdCBlPXRoaXMuX2dldEluaGVyaXRhYmxlUHJvcGVydHkoIkFubm90cyIpO3JldHVybigwLG4uc2hhZG93KSh0aGlzLCJhbm5vdGF0aW9ucyIsQXJyYXkuaXNBcnJheShlKT9lOltdKX1nZXQgX3BhcnNlZEFubm90YXRpb25zKCl7Y29uc3QgZT10aGlzLnBkZk1hbmFnZXIuZW5zdXJlKHRoaXMsImFubm90YXRpb25zIikudGhlbigoKCk9Pntjb25zdCBlPVtdO2Zvcihjb25zdCB0IG9mIHRoaXMuYW5ub3RhdGlvbnMpZS5wdXNoKHIuQW5ub3RhdGlvbkZhY3RvcnkuY3JlYXRlKHRoaXMueHJlZix0LHRoaXMucGRmTWFuYWdlcix0aGlzLl9sb2NhbElkRmFjdG9yeSwhMSkuY2F0Y2goKGZ1bmN0aW9uKGUpeygwLG4ud2FybikoYF9wYXJzZWRBbm5vdGF0aW9uczogIiR7ZX0iLmApO3JldHVybiBudWxsfSkpKTtyZXR1cm4gUHJvbWlzZS5hbGwoZSkudGhlbigoZnVuY3Rpb24oZSl7aWYoMD09PWUubGVuZ3RoKXJldHVybiBlO2NvbnN0IHQ9W107bGV0IGE7Zm9yKGNvbnN0IG4gb2YgZSlpZihuKWlmKG4gaW5zdGFuY2VvZiByLlBvcHVwQW5ub3RhdGlvbil7YXx8KGE9W10pO2EucHVzaChuKX1lbHNlIHQucHVzaChuKTthJiZ0LnB1c2goLi4uYSk7cmV0dXJuIHR9KSl9KSk7cmV0dXJuKDAsbi5zaGFkb3cpKHRoaXMsIl9wYXJzZWRBbm5vdGF0aW9ucyIsZSl9Z2V0IGpzQWN0aW9ucygpe2NvbnN0IGU9KDAsaS5jb2xsZWN0QWN0aW9ucykodGhpcy54cmVmLHRoaXMucGFnZURpY3Qsbi5QYWdlQWN0aW9uRXZlbnRUeXBlKTtyZXR1cm4oMCxuLnNoYWRvdykodGhpcywianNBY3Rpb25zIixlKX19dC5QYWdlPVBhZ2U7Y29uc3Qgdj1uZXcgVWludDhBcnJheShbMzcsODAsNjgsNzAsNDVdKSxGPW5ldyBVaW50OEFycmF5KFsxMTUsMTE2LDk3LDExNCwxMTYsMTIwLDExNCwxMDEsMTAyXSksTz1uZXcgVWludDhBcnJheShbMTAxLDExMCwxMDAsMTExLDk4LDEwNl0pLFQ9L15bMS05XVwuXGQkLztmdW5jdGlvbiBmaW5kKGUsdCxhPTEwMjQscj0hMSl7Y29uc3Qgbj10Lmxlbmd0aCxpPWUucGVla0J5dGVzKGEpLHM9aS5sZW5ndGgtbjtpZihzPD0wKXJldHVybiExO2lmKHIpe2NvbnN0IGE9bi0xO2xldCByPWkubGVuZ3RoLTE7Zm9yKDtyPj1hOyl7bGV0IHM9MDtmb3IoO3M8biYmaVtyLXNdPT09dFthLXNdOylzKys7aWYocz49bil7ZS5wb3MrPXItYTtyZXR1cm4hMH1yLS19fWVsc2V7bGV0IGE9MDtmb3IoO2E8PXM7KXtsZXQgcj0wO2Zvcig7cjxuJiZpW2Ercl09PT10W3JdOylyKys7aWYocj49bil7ZS5wb3MrPWE7cmV0dXJuITB9YSsrfX1yZXR1cm4hMX10LlBERkRvY3VtZW50PWNsYXNzIFBERkRvY3VtZW50e2NvbnN0cnVjdG9yKGUsdCl7aWYodC5sZW5ndGg8PTApdGhyb3cgbmV3IG4uSW52YWxpZFBERkV4Y2VwdGlvbigiVGhlIFBERiBmaWxlIGlzIGVtcHR5LCBpLmUuIGl0cyBzaXplIGlzIHplcm8gYnl0ZXMuIik7dGhpcy5wZGZNYW5hZ2VyPWU7dGhpcy5zdHJlYW09dDt0aGlzLnhyZWY9bmV3IGsuWFJlZih0LGUpO3RoaXMuX3BhZ2VQcm9taXNlcz1uZXcgTWFwO3RoaXMuX3ZlcnNpb249bnVsbDtjb25zdCBhPXtmb250OjB9O3RoaXMuX2dsb2JhbElkRmFjdG9yeT1jbGFzc3tzdGF0aWMgZ2V0RG9jSWQoKXtyZXR1cm5gZ18ke2UuZG9jSWR9YH1zdGF0aWMgY3JlYXRlRm9udElkKCl7cmV0dXJuImYiKyArK2EuZm9udH1zdGF0aWMgY3JlYXRlT2JqSWQoKXsoMCxuLnVucmVhY2hhYmxlKSgiQWJzdHJhY3QgbWV0aG9kIGBjcmVhdGVPYmpJZGAgY2FsbGVkLiIpfXN0YXRpYyBnZXRQYWdlT2JqSWQoKXsoMCxuLnVucmVhY2hhYmxlKSgiQWJzdHJhY3QgbWV0aG9kIGBnZXRQYWdlT2JqSWRgIGNhbGxlZC4iKX19fXBhcnNlKGUpe3RoaXMueHJlZi5wYXJzZShlKTt0aGlzLmNhdGFsb2c9bmV3IGguQ2F0YWxvZyh0aGlzLnBkZk1hbmFnZXIsdGhpcy54cmVmKTt0aGlzLmNhdGFsb2cudmVyc2lvbiYmKHRoaXMuX3ZlcnNpb249dGhpcy5jYXRhbG9nLnZlcnNpb24pfWdldCBsaW5lYXJpemF0aW9uKCl7bGV0IGU9bnVsbDt0cnl7ZT1mLkxpbmVhcml6YXRpb24uY3JlYXRlKHRoaXMuc3RyZWFtKX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgaS5NaXNzaW5nRGF0YUV4Y2VwdGlvbil0aHJvdyBlOygwLG4uaW5mbykoZSl9cmV0dXJuKDAsbi5zaGFkb3cpKHRoaXMsImxpbmVhcml6YXRpb24iLGUpfWdldCBzdGFydFhSZWYoKXtjb25zdCBlPXRoaXMuc3RyZWFtO2xldCB0PTA7aWYodGhpcy5saW5lYXJpemF0aW9uKXtlLnJlc2V0KCk7ZmluZChlLE8pJiYodD1lLnBvcys2LWUuc3RhcnQpfWVsc2V7Y29uc3QgYT0xMDI0LHI9Ri5sZW5ndGg7bGV0IG49ITEscz1lLmVuZDtmb3IoOyFuJiZzPjA7KXtzLT1hLXI7czwwJiYocz0wKTtlLnBvcz1zO249ZmluZChlLEYsYSwhMCl9aWYobil7ZS5za2lwKDkpO2xldCBhO2Rve2E9ZS5nZXRCeXRlKCl9d2hpbGUoKDAsaS5pc1doaXRlU3BhY2UpKGEpKTtsZXQgcj0iIjtmb3IoO2E+PTMyJiZhPD01Nzspe3IrPVN0cmluZy5mcm9tQ2hhckNvZGUoYSk7YT1lLmdldEJ5dGUoKX10PXBhcnNlSW50KHIsMTApO2lzTmFOKHQpJiYodD0wKX19cmV0dXJuKDAsbi5zaGFkb3cpKHRoaXMsInN0YXJ0WFJlZiIsdCl9Y2hlY2tIZWFkZXIoKXtjb25zdCBlPXRoaXMuc3RyZWFtO2UucmVzZXQoKTtpZighZmluZChlLHYpKXJldHVybjtlLm1vdmVTdGFydCgpO2xldCB0LGE9IiI7Zm9yKDsodD1lLmdldEJ5dGUoKSk+MzImJiEoYS5sZW5ndGg+PTEyKTspYSs9U3RyaW5nLmZyb21DaGFyQ29kZSh0KTt0aGlzLl92ZXJzaW9ufHwodGhpcy5fdmVyc2lvbj1hLnN1YnN0cmluZyg1KSl9cGFyc2VTdGFydFhSZWYoKXt0aGlzLnhyZWYuc2V0U3RhcnRYUmVmKHRoaXMuc3RhcnRYUmVmKX1nZXQgbnVtUGFnZXMoKXtsZXQgZT0wO2U9dGhpcy5jYXRhbG9nLmhhc0FjdHVhbE51bVBhZ2VzP3RoaXMuY2F0YWxvZy5udW1QYWdlczp0aGlzLnhmYUZhY3Rvcnk/dGhpcy54ZmFGYWN0b3J5LmdldE51bVBhZ2VzKCk6dGhpcy5saW5lYXJpemF0aW9uP3RoaXMubGluZWFyaXphdGlvbi5udW1QYWdlczp0aGlzLmNhdGFsb2cubnVtUGFnZXM7cmV0dXJuKDAsbi5zaGFkb3cpKHRoaXMsIm51bVBhZ2VzIixlKX1faGFzT25seURvY3VtZW50U2lnbmF0dXJlcyhlLHQ9MCl7cmV0dXJuISFBcnJheS5pc0FycmF5KGUpJiZlLmV2ZXJ5KChlPT57aWYoISgoZT10aGlzLnhyZWYuZmV0Y2hJZlJlZihlKSlpbnN0YW5jZW9mIHMuRGljdCkpcmV0dXJuITE7aWYoZS5oYXMoIktpZHMiKSl7aWYoKyt0PjEwKXsoMCxuLndhcm4pKCJfaGFzT25seURvY3VtZW50U2lnbmF0dXJlczogbWF4aW11bSByZWN1cnNpb24gZGVwdGggcmVhY2hlZCIpO3JldHVybiExfXJldHVybiB0aGlzLl9oYXNPbmx5RG9jdW1lbnRTaWduYXR1cmVzKGUuZ2V0KCJLaWRzIiksdCl9Y29uc3QgYT0oMCxzLmlzTmFtZSkoZS5nZXQoIkZUIiksIlNpZyIpLHI9ZS5nZXQoIlJlY3QiKSxpPUFycmF5LmlzQXJyYXkocikmJnIuZXZlcnkoKGU9PjA9PT1lKSk7cmV0dXJuIGEmJml9KSl9Z2V0IF94ZmFTdHJlYW1zKCl7Y29uc3QgZT10aGlzLmNhdGFsb2cuYWNyb0Zvcm07aWYoIWUpcmV0dXJuIG51bGw7Y29uc3QgdD1lLmdldCgiWEZBIiksYT17InhkcDp4ZHAiOiIiLHRlbXBsYXRlOiIiLGRhdGFzZXRzOiIiLGNvbmZpZzoiIixjb25uZWN0aW9uU2V0OiIiLGxvY2FsZVNldDoiIixzdHlsZXNoZWV0OiIiLCIveGRwOnhkcCI6IiJ9O2lmKHQgaW5zdGFuY2VvZiBjLkJhc2VTdHJlYW0mJiF0LmlzRW1wdHkpe2FbInhkcDp4ZHAiXT10O3JldHVybiBhfWlmKCFBcnJheS5pc0FycmF5KHQpfHwwPT09dC5sZW5ndGgpcmV0dXJuIG51bGw7Zm9yKGxldCBlPTAscj10Lmxlbmd0aDtlPHI7ZSs9Mil7bGV0IG47bj0wPT09ZT8ieGRwOnhkcCI6ZT09PXItMj8iL3hkcDp4ZHAiOnRbZV07aWYoIWEuaGFzT3duUHJvcGVydHkobikpY29udGludWU7Y29uc3QgaT10aGlzLnhyZWYuZmV0Y2hJZlJlZih0W2UrMV0pO2kgaW5zdGFuY2VvZiBjLkJhc2VTdHJlYW0mJiFpLmlzRW1wdHkmJihhW25dPWkpfXJldHVybiBhfWdldCB4ZmFEYXRhc2V0cygpe2NvbnN0IGU9dGhpcy5feGZhU3RyZWFtcztpZighZSlyZXR1cm4oMCxuLnNoYWRvdykodGhpcywieGZhRGF0YXNldHMiLG51bGwpO2Zvcihjb25zdCB0IG9mWyJkYXRhc2V0cyIsInhkcDp4ZHAiXSl7Y29uc3QgYT1lW3RdO2lmKGEpdHJ5e2NvbnN0IGU9e1t0XTooMCxuLnN0cmluZ1RvVVRGOFN0cmluZykoYS5nZXRTdHJpbmcoKSl9O3JldHVybigwLG4uc2hhZG93KSh0aGlzLCJ4ZmFEYXRhc2V0cyIsbmV3IGQuRGF0YXNldFJlYWRlcihlKSl9Y2F0Y2goZSl7KDAsbi53YXJuKSgiWEZBIC0gSW52YWxpZCB1dGYtOCBzdHJpbmcuIik7YnJlYWt9fXJldHVybigwLG4uc2hhZG93KSh0aGlzLCJ4ZmFEYXRhc2V0cyIsbnVsbCl9Z2V0IHhmYURhdGEoKXtjb25zdCBlPXRoaXMuX3hmYVN0cmVhbXM7aWYoIWUpcmV0dXJuIG51bGw7Y29uc3QgdD1PYmplY3QuY3JlYXRlKG51bGwpO2Zvcihjb25zdFthLHJdb2YgT2JqZWN0LmVudHJpZXMoZSkpaWYocil0cnl7dFthXT0oMCxuLnN0cmluZ1RvVVRGOFN0cmluZykoci5nZXRTdHJpbmcoKSl9Y2F0Y2goZSl7KDAsbi53YXJuKSgiWEZBIC0gSW52YWxpZCB1dGYtOCBzdHJpbmcuIik7cmV0dXJuIG51bGx9cmV0dXJuIHR9Z2V0IHhmYUZhY3RvcnkoKXtsZXQgZTt0aGlzLnBkZk1hbmFnZXIuZW5hYmxlWGZhJiZ0aGlzLmNhdGFsb2cubmVlZHNSZW5kZXJpbmcmJnRoaXMuZm9ybUluZm8uaGFzWGZhJiYhdGhpcy5mb3JtSW5mby5oYXNBY3JvRm9ybSYmKGU9dGhpcy54ZmFEYXRhKTtyZXR1cm4oMCxuLnNoYWRvdykodGhpcywieGZhRmFjdG9yeSIsZT9uZXcgeC5YRkFGYWN0b3J5KGUpOm51bGwpfWdldCBpc1B1cmVYZmEoKXtyZXR1cm4hIXRoaXMueGZhRmFjdG9yeSYmdGhpcy54ZmFGYWN0b3J5LmlzVmFsaWQoKX1nZXQgaHRtbEZvclhmYSgpe3JldHVybiB0aGlzLnhmYUZhY3Rvcnk/dGhpcy54ZmFGYWN0b3J5LmdldFBhZ2VzKCk6bnVsbH1hc3luYyBsb2FkWGZhSW1hZ2VzKCl7Y29uc3QgZT1hd2FpdCB0aGlzLnBkZk1hbmFnZXIuZW5zdXJlQ2F0YWxvZygieGZhSW1hZ2VzIik7aWYoIWUpcmV0dXJuO2NvbnN0IHQ9ZS5nZXRLZXlzKCksYT1uZXcgcC5PYmplY3RMb2FkZXIoZSx0LHRoaXMueHJlZik7YXdhaXQgYS5sb2FkKCk7Y29uc3Qgcj1uZXcgTWFwO2Zvcihjb25zdCBhIG9mIHQpe2NvbnN0IHQ9ZS5nZXQoYSk7dCBpbnN0YW5jZW9mIGMuQmFzZVN0cmVhbSYmci5zZXQoYSx0LmdldEJ5dGVzKCkpfXRoaXMueGZhRmFjdG9yeS5zZXRJbWFnZXMocil9YXN5bmMgbG9hZFhmYUZvbnRzKGUsdCl7Y29uc3QgYT1hd2FpdCB0aGlzLnBkZk1hbmFnZXIuZW5zdXJlQ2F0YWxvZygiYWNyb0Zvcm0iKTtpZighYSlyZXR1cm47Y29uc3Qgcj1hd2FpdCBhLmdldEFzeW5jKCJEUiIpO2lmKCEociBpbnN0YW5jZW9mIHMuRGljdCkpcmV0dXJuO2NvbnN0IGM9bmV3IHAuT2JqZWN0TG9hZGVyKHIsWyJGb250Il0sdGhpcy54cmVmKTthd2FpdCBjLmxvYWQoKTtjb25zdCBsPXIuZ2V0KCJGb250Iik7aWYoIShsIGluc3RhbmNlb2Ygcy5EaWN0KSlyZXR1cm47Y29uc3QgaD1PYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5wZGZNYW5hZ2VyLmV2YWx1YXRvck9wdGlvbnMpO2gudXNlU3lzdGVtRm9udHM9ITE7Y29uc3QgdT1uZXcgYi5QYXJ0aWFsRXZhbHVhdG9yKHt4cmVmOnRoaXMueHJlZixoYW5kbGVyOmUscGFnZUluZGV4Oi0xLGlkRmFjdG9yeTp0aGlzLl9nbG9iYWxJZEZhY3RvcnksZm9udENhY2hlOnRoaXMuY2F0YWxvZy5mb250Q2FjaGUsYnVpbHRJbkNNYXBDYWNoZTp0aGlzLmNhdGFsb2cuYnVpbHRJbkNNYXBDYWNoZSxzdGFuZGFyZEZvbnREYXRhQ2FjaGU6dGhpcy5jYXRhbG9nLnN0YW5kYXJkRm9udERhdGFDYWNoZSxvcHRpb25zOmh9KSxkPW5ldyBtLk9wZXJhdG9yTGlzdCxmPVtdLGc9e2dldCBmb250KCl7cmV0dXJuIGYuYXQoLTEpfSxzZXQgZm9udChlKXtmLnB1c2goZSl9LGNsb25lKCl7cmV0dXJuIHRoaXN9fSx5PW5ldyBNYXA7bC5mb3JFYWNoKCgoZSx0KT0+e3kuc2V0KGUsdCl9KSk7Y29uc3Qgdz1bXTtmb3IoY29uc3RbZSxhXW9mIHkpe2NvbnN0IG89YS5nZXQoIkZvbnREZXNjcmlwdG9yIik7aWYoIShvIGluc3RhbmNlb2Ygcy5EaWN0KSljb250aW51ZTtsZXQgYz1vLmdldCgiRm9udEZhbWlseSIpO2M9Yy5yZXBsYWNlKC9bIF0rKFxkKS9nLCIkMSIpO2NvbnN0IGw9e2ZvbnRGYW1pbHk6Yyxmb250V2VpZ2h0Om8uZ2V0KCJGb250V2VpZ2h0IiksaXRhbGljQW5nbGU6LW8uZ2V0KCJJdGFsaWNBbmdsZSIpfTsoMCxpLnZhbGlkYXRlQ1NTRm9udCkobCkmJncucHVzaCh1LmhhbmRsZVNldEZvbnQocixbcy5OYW1lLmdldChlKSwxXSxudWxsLGQsdCxnLG51bGwsbCkuY2F0Y2goKGZ1bmN0aW9uKGUpeygwLG4ud2FybikoYGxvYWRYZmFGb250czogIiR7ZX0iLmApO3JldHVybiBudWxsfSkpKX1hd2FpdCBQcm9taXNlLmFsbCh3KTtjb25zdCBTPXRoaXMueGZhRmFjdG9yeS5zZXRGb250cyhmKTtpZighUylyZXR1cm47aC5pZ25vcmVFcnJvcnM9ITA7dy5sZW5ndGg9MDtmLmxlbmd0aD0wO2NvbnN0IHg9bmV3IFNldDtmb3IoY29uc3QgZSBvZiBTKSgwLG8uZ2V0WGZhRm9udE5hbWUpKGAke2V9LVJlZ3VsYXJgKXx8eC5hZGQoZSk7eC5zaXplJiZTLnB1c2goIlBkZkpTLUZhbGxiYWNrIik7Zm9yKGNvbnN0IGUgb2YgUylpZigheC5oYXMoZSkpZm9yKGNvbnN0IGEgb2Zbe25hbWU6IlJlZ3VsYXIiLGZvbnRXZWlnaHQ6NDAwLGl0YWxpY0FuZ2xlOjB9LHtuYW1lOiJCb2xkIixmb250V2VpZ2h0OjcwMCxpdGFsaWNBbmdsZTowfSx7bmFtZToiSXRhbGljIixmb250V2VpZ2h0OjQwMCxpdGFsaWNBbmdsZToxMn0se25hbWU6IkJvbGRJdGFsaWMiLGZvbnRXZWlnaHQ6NzAwLGl0YWxpY0FuZ2xlOjEyfV0pe2NvbnN0IGk9YCR7ZX0tJHthLm5hbWV9YCxjPSgwLG8uZ2V0WGZhRm9udERpY3QpKGkpO3cucHVzaCh1LmhhbmRsZVNldEZvbnQocixbcy5OYW1lLmdldChpKSwxXSxudWxsLGQsdCxnLGMse2ZvbnRGYW1pbHk6ZSxmb250V2VpZ2h0OmEuZm9udFdlaWdodCxpdGFsaWNBbmdsZTphLml0YWxpY0FuZ2xlfSkuY2F0Y2goKGZ1bmN0aW9uKGUpeygwLG4ud2FybikoYGxvYWRYZmFGb250czogIiR7ZX0iLmApO3JldHVybiBudWxsfSkpKX1hd2FpdCBQcm9taXNlLmFsbCh3KTt0aGlzLnhmYUZhY3RvcnkuYXBwZW5kRm9udHMoZix4KX1hc3luYyBzZXJpYWxpemVYZmFEYXRhKGUpe3JldHVybiB0aGlzLnhmYUZhY3Rvcnk/dGhpcy54ZmFGYWN0b3J5LnNlcmlhbGl6ZURhdGEoZSk6bnVsbH1nZXQgZm9ybUluZm8oKXtjb25zdCBlPXtoYXNGaWVsZHM6ITEsaGFzQWNyb0Zvcm06ITEsaGFzWGZhOiExLGhhc1NpZ25hdHVyZXM6ITF9LHQ9dGhpcy5jYXRhbG9nLmFjcm9Gb3JtO2lmKCF0KXJldHVybigwLG4uc2hhZG93KSh0aGlzLCJmb3JtSW5mbyIsZSk7dHJ5e2NvbnN0IGE9dC5nZXQoIkZpZWxkcyIpLHI9QXJyYXkuaXNBcnJheShhKSYmYS5sZW5ndGg+MDtlLmhhc0ZpZWxkcz1yO2NvbnN0IG49dC5nZXQoIlhGQSIpO2UuaGFzWGZhPUFycmF5LmlzQXJyYXkobikmJm4ubGVuZ3RoPjB8fG4gaW5zdGFuY2VvZiBjLkJhc2VTdHJlYW0mJiFuLmlzRW1wdHk7Y29uc3QgaT0hISgxJnQuZ2V0KCJTaWdGbGFncyIpKSxzPWkmJnRoaXMuX2hhc09ubHlEb2N1bWVudFNpZ25hdHVyZXMoYSk7ZS5oYXNBY3JvRm9ybT1yJiYhcztlLmhhc1NpZ25hdHVyZXM9aX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgaS5NaXNzaW5nRGF0YUV4Y2VwdGlvbil0aHJvdyBlOygwLG4ud2FybikoYENhbm5vdCBmZXRjaCBmb3JtIGluZm9ybWF0aW9uOiAiJHtlfSIuYCl9cmV0dXJuKDAsbi5zaGFkb3cpKHRoaXMsImZvcm1JbmZvIixlKX1nZXQgZG9jdW1lbnRJbmZvKCl7bGV0IGU9dGhpcy5fdmVyc2lvbjtpZigic3RyaW5nIiE9dHlwZW9mIGV8fCFULnRlc3QoZSkpeygwLG4ud2FybikoYEludmFsaWQgUERGIGhlYWRlciB2ZXJzaW9uIG51bWJlcjogJHtlfWApO2U9bnVsbH1jb25zdCB0PXtQREZGb3JtYXRWZXJzaW9uOmUsTGFuZ3VhZ2U6dGhpcy5jYXRhbG9nLmxhbmcsRW5jcnlwdEZpbHRlck5hbWU6dGhpcy54cmVmLmVuY3J5cHQ/dGhpcy54cmVmLmVuY3J5cHQuZmlsdGVyTmFtZTpudWxsLElzTGluZWFyaXplZDohIXRoaXMubGluZWFyaXphdGlvbixJc0Fjcm9Gb3JtUHJlc2VudDp0aGlzLmZvcm1JbmZvLmhhc0Fjcm9Gb3JtLElzWEZBUHJlc2VudDp0aGlzLmZvcm1JbmZvLmhhc1hmYSxJc0NvbGxlY3Rpb25QcmVzZW50OiEhdGhpcy5jYXRhbG9nLmNvbGxlY3Rpb24sSXNTaWduYXR1cmVzUHJlc2VudDp0aGlzLmZvcm1JbmZvLmhhc1NpZ25hdHVyZXN9O2xldCBhO3RyeXthPXRoaXMueHJlZi50cmFpbGVyLmdldCgiSW5mbyIpfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBpLk1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7KDAsbi5pbmZvKSgiVGhlIGRvY3VtZW50IGluZm9ybWF0aW9uIGRpY3Rpb25hcnkgaXMgaW52YWxpZC4iKX1pZighKGEgaW5zdGFuY2VvZiBzLkRpY3QpKXJldHVybigwLG4uc2hhZG93KSh0aGlzLCJkb2N1bWVudEluZm8iLHQpO2Zvcihjb25zdCBlIG9mIGEuZ2V0S2V5cygpKXtjb25zdCByPWEuZ2V0KGUpO3N3aXRjaChlKXtjYXNlIlRpdGxlIjpjYXNlIkF1dGhvciI6Y2FzZSJTdWJqZWN0IjpjYXNlIktleXdvcmRzIjpjYXNlIkNyZWF0b3IiOmNhc2UiUHJvZHVjZXIiOmNhc2UiQ3JlYXRpb25EYXRlIjpjYXNlIk1vZERhdGUiOmlmKCJzdHJpbmciPT10eXBlb2Ygcil7dFtlXT0oMCxuLnN0cmluZ1RvUERGU3RyaW5nKShyKTtjb250aW51ZX1icmVhaztjYXNlIlRyYXBwZWQiOmlmKHIgaW5zdGFuY2VvZiBzLk5hbWUpe3RbZV09cjtjb250aW51ZX1icmVhaztkZWZhdWx0OmxldCBhO3N3aXRjaCh0eXBlb2Ygcil7Y2FzZSJzdHJpbmciOmE9KDAsbi5zdHJpbmdUb1BERlN0cmluZykocik7YnJlYWs7Y2FzZSJudW1iZXIiOmNhc2UiYm9vbGVhbiI6YT1yO2JyZWFrO2RlZmF1bHQ6ciBpbnN0YW5jZW9mIHMuTmFtZSYmKGE9cil9aWYodm9pZCAwPT09YSl7KDAsbi53YXJuKShgQmFkIHZhbHVlLCBmb3IgY3VzdG9tIGtleSAiJHtlfSIsIGluIEluZm86ICR7cn0uYCk7Y29udGludWV9dC5DdXN0b218fCh0LkN1c3RvbT1PYmplY3QuY3JlYXRlKG51bGwpKTt0LkN1c3RvbVtlXT1hO2NvbnRpbnVlfSgwLG4ud2FybikoYEJhZCB2YWx1ZSwgZm9yIGtleSAiJHtlfSIsIGluIEluZm86ICR7cn0uYCl9cmV0dXJuKDAsbi5zaGFkb3cpKHRoaXMsImRvY3VtZW50SW5mbyIsdCl9Z2V0IGZpbmdlcnByaW50cygpe2Z1bmN0aW9uIHZhbGlkYXRlKGUpe3JldHVybiJzdHJpbmciPT10eXBlb2YgZSYmZS5sZW5ndGg+MCYmIlwwXDBcMFwwXDBcMFwwXDBcMFwwXDBcMFwwXDBcMFwwIiE9PWV9ZnVuY3Rpb24gaGV4U3RyaW5nKGUpe2NvbnN0IHQ9W107Zm9yKGxldCBhPTAscj1lLmxlbmd0aDthPHI7YSsrKXtjb25zdCByPWVbYV0udG9TdHJpbmcoMTYpO3QucHVzaChyLnBhZFN0YXJ0KDIsIjAiKSl9cmV0dXJuIHQuam9pbigiIil9Y29uc3QgZT10aGlzLnhyZWYudHJhaWxlci5nZXQoIklEIik7bGV0IHQsYTtpZihBcnJheS5pc0FycmF5KGUpJiZ2YWxpZGF0ZShlWzBdKSl7dD0oMCxuLnN0cmluZ1RvQnl0ZXMpKGVbMF0pO2VbMV0hPT1lWzBdJiZ2YWxpZGF0ZShlWzFdKSYmKGE9KDAsbi5zdHJpbmdUb0J5dGVzKShlWzFdKSl9ZWxzZSB0PSgwLGwuY2FsY3VsYXRlTUQ1KSh0aGlzLnN0cmVhbS5nZXRCeXRlUmFuZ2UoMCwxMDI0KSwwLDEwMjQpO3JldHVybigwLG4uc2hhZG93KSh0aGlzLCJmaW5nZXJwcmludHMiLFtoZXhTdHJpbmcodCksYT9oZXhTdHJpbmcoYSk6bnVsbF0pfWFzeW5jIF9nZXRMaW5lYXJpemF0aW9uUGFnZShlKXtjb25zdHtjYXRhbG9nOnQsbGluZWFyaXphdGlvbjphLHhyZWY6cn09dGhpcyxpPXMuUmVmLmdldChhLm9iamVjdE51bWJlckZpcnN0LDApO3RyeXtjb25zdCBlPWF3YWl0IHIuZmV0Y2hBc3luYyhpKTtpZihlIGluc3RhbmNlb2Ygcy5EaWN0KXtsZXQgYT1lLmdldFJhdygiVHlwZSIpO2EgaW5zdGFuY2VvZiBzLlJlZiYmKGE9YXdhaXQgci5mZXRjaEFzeW5jKGEpKTtpZigoMCxzLmlzTmFtZSkoYSwiUGFnZSIpfHwhZS5oYXMoIlR5cGUiKSYmIWUuaGFzKCJLaWRzIikpe3QucGFnZUtpZHNDb3VudENhY2hlLmhhcyhpKXx8dC5wYWdlS2lkc0NvdW50Q2FjaGUucHV0KGksMSk7dC5wYWdlSW5kZXhDYWNoZS5oYXMoaSl8fHQucGFnZUluZGV4Q2FjaGUucHV0KGksMCk7cmV0dXJuW2UsaV19fXRocm93IG5ldyBuLkZvcm1hdEVycm9yKCJUaGUgTGluZWFyaXphdGlvbiBkaWN0aW9uYXJ5IGRvZXNuJ3QgcG9pbnQgdG8gYSB2YWxpZCBQYWdlIGRpY3Rpb25hcnkuIil9Y2F0Y2goYSl7KDAsbi53YXJuKShgX2dldExpbmVhcml6YXRpb25QYWdlOiAiJHthLm1lc3NhZ2V9Ii5gKTtyZXR1cm4gdC5nZXRQYWdlRGljdChlKX19Z2V0UGFnZShlKXtjb25zdCB0PXRoaXMuX3BhZ2VQcm9taXNlcy5nZXQoZSk7aWYodClyZXR1cm4gdDtjb25zdHtjYXRhbG9nOmEsbGluZWFyaXphdGlvbjpyLHhmYUZhY3Rvcnk6bn09dGhpcztsZXQgaTtpPW4/UHJvbWlzZS5yZXNvbHZlKFtzLkRpY3QuZW1wdHksbnVsbF0pOnImJnIucGFnZUZpcnN0PT09ZT90aGlzLl9nZXRMaW5lYXJpemF0aW9uUGFnZShlKTphLmdldFBhZ2VEaWN0KGUpO2k9aS50aGVuKCgoW3Qscl0pPT5uZXcgUGFnZSh7cGRmTWFuYWdlcjp0aGlzLnBkZk1hbmFnZXIseHJlZjp0aGlzLnhyZWYscGFnZUluZGV4OmUscGFnZURpY3Q6dCxyZWY6cixnbG9iYWxJZEZhY3Rvcnk6dGhpcy5fZ2xvYmFsSWRGYWN0b3J5LGZvbnRDYWNoZTphLmZvbnRDYWNoZSxidWlsdEluQ01hcENhY2hlOmEuYnVpbHRJbkNNYXBDYWNoZSxzdGFuZGFyZEZvbnREYXRhQ2FjaGU6YS5zdGFuZGFyZEZvbnREYXRhQ2FjaGUsZ2xvYmFsSW1hZ2VDYWNoZTphLmdsb2JhbEltYWdlQ2FjaGUsbm9uQmxlbmRNb2Rlc1NldDphLm5vbkJsZW5kTW9kZXNTZXQseGZhRmFjdG9yeTpufSkpKTt0aGlzLl9wYWdlUHJvbWlzZXMuc2V0KGUsaSk7cmV0dXJuIGl9YXN5bmMgY2hlY2tGaXJzdFBhZ2UoZT0hMSl7aWYoIWUpdHJ5e2F3YWl0IHRoaXMuZ2V0UGFnZSgwKX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgaS5YUmVmRW50cnlFeGNlcHRpb24pe3RoaXMuX3BhZ2VQcm9taXNlcy5kZWxldGUoMCk7YXdhaXQgdGhpcy5jbGVhbnVwKCk7dGhyb3cgbmV3IGkuWFJlZlBhcnNlRXhjZXB0aW9ufX19YXN5bmMgY2hlY2tMYXN0UGFnZShlPSExKXtjb25zdHtjYXRhbG9nOnQscGRmTWFuYWdlcjphfT10aGlzO3Quc2V0QWN0dWFsTnVtUGFnZXMoKTtsZXQgcjt0cnl7YXdhaXQgUHJvbWlzZS5hbGwoW2EuZW5zdXJlRG9jKCJ4ZmFGYWN0b3J5IiksYS5lbnN1cmVEb2MoImxpbmVhcml6YXRpb24iKSxhLmVuc3VyZUNhdGFsb2coIm51bVBhZ2VzIildKTtpZih0aGlzLnhmYUZhY3RvcnkpcmV0dXJuO3I9dGhpcy5saW5lYXJpemF0aW9uP3RoaXMubGluZWFyaXphdGlvbi5udW1QYWdlczp0Lm51bVBhZ2VzO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHIpKXRocm93IG5ldyBuLkZvcm1hdEVycm9yKCJQYWdlIGNvdW50IGlzIG5vdCBhbiBpbnRlZ2VyLiIpO2lmKHI8PTEpcmV0dXJuO2F3YWl0IHRoaXMuZ2V0UGFnZShyLTEpfWNhdGNoKHMpe3RoaXMuX3BhZ2VQcm9taXNlcy5kZWxldGUoci0xKTthd2FpdCB0aGlzLmNsZWFudXAoKTtpZihzIGluc3RhbmNlb2YgaS5YUmVmRW50cnlFeGNlcHRpb24mJiFlKXRocm93IG5ldyBpLlhSZWZQYXJzZUV4Y2VwdGlvbjsoMCxuLndhcm4pKGBjaGVja0xhc3RQYWdlIC0gaW52YWxpZCAvUGFnZXMgdHJlZSAvQ291bnQ6ICR7cn0uYCk7bGV0IG87dHJ5e289YXdhaXQgdC5nZXRBbGxQYWdlRGljdHMoZSl9Y2F0Y2goYSl7aWYoYSBpbnN0YW5jZW9mIGkuWFJlZkVudHJ5RXhjZXB0aW9uJiYhZSl0aHJvdyBuZXcgaS5YUmVmUGFyc2VFeGNlcHRpb247dC5zZXRBY3R1YWxOdW1QYWdlcygxKTtyZXR1cm59Zm9yKGNvbnN0W2UsW3Isbl1db2Ygbyl7bGV0IGk7aWYociBpbnN0YW5jZW9mIEVycm9yKXtpPVByb21pc2UucmVqZWN0KHIpO2kuY2F0Y2goKCgpPT57fSkpfWVsc2UgaT1Qcm9taXNlLnJlc29sdmUobmV3IFBhZ2Uoe3BkZk1hbmFnZXI6YSx4cmVmOnRoaXMueHJlZixwYWdlSW5kZXg6ZSxwYWdlRGljdDpyLHJlZjpuLGdsb2JhbElkRmFjdG9yeTp0aGlzLl9nbG9iYWxJZEZhY3RvcnksZm9udENhY2hlOnQuZm9udENhY2hlLGJ1aWx0SW5DTWFwQ2FjaGU6dC5idWlsdEluQ01hcENhY2hlLHN0YW5kYXJkRm9udERhdGFDYWNoZTp0LnN0YW5kYXJkRm9udERhdGFDYWNoZSxnbG9iYWxJbWFnZUNhY2hlOnQuZ2xvYmFsSW1hZ2VDYWNoZSxub25CbGVuZE1vZGVzU2V0OnQubm9uQmxlbmRNb2Rlc1NldCx4ZmFGYWN0b3J5Om51bGx9KSk7dGhpcy5fcGFnZVByb21pc2VzLnNldChlLGkpfXQuc2V0QWN0dWFsTnVtUGFnZXMoby5zaXplKX19Zm9udEZhbGxiYWNrKGUsdCl7cmV0dXJuIHRoaXMuY2F0YWxvZy5mb250RmFsbGJhY2soZSx0KX1hc3luYyBjbGVhbnVwKGU9ITEpe3JldHVybiB0aGlzLmNhdGFsb2c/dGhpcy5jYXRhbG9nLmNsZWFudXAoZSk6KDAsdS5jbGVhckdsb2JhbENhY2hlcykoKX1fY29sbGVjdEZpZWxkT2JqZWN0cyhlLHQsYSl7Y29uc3QgaT10aGlzLnhyZWYuZmV0Y2hJZlJlZih0KTtpZihpLmhhcygiVCIpKXtjb25zdCB0PSgwLG4uc3RyaW5nVG9QREZTdHJpbmcpKGkuZ2V0KCJUIikpO2U9IiI9PT1lP3Q6YCR7ZX0uJHt0fWB9YS5oYXMoZSl8fGEuc2V0KGUsW10pO2EuZ2V0KGUpLnB1c2goci5Bbm5vdGF0aW9uRmFjdG9yeS5jcmVhdGUodGhpcy54cmVmLHQsdGhpcy5wZGZNYW5hZ2VyLHRoaXMuX2xvY2FsSWRGYWN0b3J5LCEwKS50aGVuKChlPT5lJiZlLmdldEZpZWxkT2JqZWN0KCkpKS5jYXRjaCgoZnVuY3Rpb24oZSl7KDAsbi53YXJuKShgX2NvbGxlY3RGaWVsZE9iamVjdHM6ICIke2V9Ii5gKTtyZXR1cm4gbnVsbH0pKSk7aWYoaS5oYXMoIktpZHMiKSl7Y29uc3QgdD1pLmdldCgiS2lkcyIpO2Zvcihjb25zdCByIG9mIHQpdGhpcy5fY29sbGVjdEZpZWxkT2JqZWN0cyhlLHIsYSl9fWdldCBmaWVsZE9iamVjdHMoKXtpZighdGhpcy5mb3JtSW5mby5oYXNGaWVsZHMpcmV0dXJuKDAsbi5zaGFkb3cpKHRoaXMsImZpZWxkT2JqZWN0cyIsUHJvbWlzZS5yZXNvbHZlKG51bGwpKTtjb25zdCBlPU9iamVjdC5jcmVhdGUobnVsbCksdD1uZXcgTWFwO2Zvcihjb25zdCBlIG9mIHRoaXMuY2F0YWxvZy5hY3JvRm9ybS5nZXQoIkZpZWxkcyIpKXRoaXMuX2NvbGxlY3RGaWVsZE9iamVjdHMoIiIsZSx0KTtjb25zdCBhPVtdO2Zvcihjb25zdFtyLG5db2YgdClhLnB1c2goUHJvbWlzZS5hbGwobikudGhlbigodD0+eyh0PXQuZmlsdGVyKChlPT4hIWUpKSkubGVuZ3RoPjAmJihlW3JdPXQpfSkpKTtyZXR1cm4oMCxuLnNoYWRvdykodGhpcywiZmllbGRPYmplY3RzIixQcm9taXNlLmFsbChhKS50aGVuKCgoKT0+ZSkpKX1nZXQgaGFzSlNBY3Rpb25zKCl7Y29uc3QgZT10aGlzLnBkZk1hbmFnZXIuZW5zdXJlRG9jKCJfcGFyc2VIYXNKU0FjdGlvbnMiKTtyZXR1cm4oMCxuLnNoYWRvdykodGhpcywiaGFzSlNBY3Rpb25zIixlKX1hc3luYyBfcGFyc2VIYXNKU0FjdGlvbnMoKXtjb25zdFtlLHRdPWF3YWl0IFByb21pc2UuYWxsKFt0aGlzLnBkZk1hbmFnZXIuZW5zdXJlQ2F0YWxvZygianNBY3Rpb25zIiksdGhpcy5wZGZNYW5hZ2VyLmVuc3VyZURvYygiZmllbGRPYmplY3RzIildKTtyZXR1cm4hIWV8fCEhdCYmT2JqZWN0LnZhbHVlcyh0KS5zb21lKChlPT5lLnNvbWUoKGU9Pm51bGwhPT1lLmFjdGlvbnMpKSkpfWdldCBjYWxjdWxhdGlvbk9yZGVySWRzKCl7Y29uc3QgZT10aGlzLmNhdGFsb2cuYWNyb0Zvcm07aWYoIWV8fCFlLmhhcygiQ08iKSlyZXR1cm4oMCxuLnNoYWRvdykodGhpcywiY2FsY3VsYXRpb25PcmRlcklkcyIsbnVsbCk7Y29uc3QgdD1lLmdldCgiQ08iKTtpZighQXJyYXkuaXNBcnJheSh0KXx8MD09PXQubGVuZ3RoKXJldHVybigwLG4uc2hhZG93KSh0aGlzLCJjYWxjdWxhdGlvbk9yZGVySWRzIixudWxsKTtjb25zdCBhPVtdO2Zvcihjb25zdCBlIG9mIHQpZSBpbnN0YW5jZW9mIHMuUmVmJiZhLnB1c2goZS50b1N0cmluZygpKTtyZXR1cm4gMD09PWEubGVuZ3RoPygwLG4uc2hhZG93KSh0aGlzLCJjYWxjdWxhdGlvbk9yZGVySWRzIixudWxsKTooMCxuLnNoYWRvdykodGhpcywiY2FsY3VsYXRpb25PcmRlcklkcyIsYSl9fX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LlBvcHVwQW5ub3RhdGlvbj10Lk1hcmt1cEFubm90YXRpb249dC5Bbm5vdGF0aW9uRmFjdG9yeT10LkFubm90YXRpb25Cb3JkZXJTdHlsZT10LkFubm90YXRpb249dm9pZCAwO3QuZ2V0UXVhZFBvaW50cz1nZXRRdWFkUG9pbnRzO3ZhciByPWEoMiksbj1hKDYpLGk9YSgxMykscz1hKDUpLG89YSg2NSksYz1hKDcpLGw9YSg2MCksaD1hKDY5KSx1PWEoMTQpLGQ9YSg3MiksZj1hKDc1KSxnPWEoNjIpLHA9YSgxMCksbT1hKDc2KTt0LkFubm90YXRpb25GYWN0b3J5PWNsYXNzIEFubm90YXRpb25GYWN0b3J5e3N0YXRpYyBjcmVhdGUoZSx0LGEscixuKXtyZXR1cm4gUHJvbWlzZS5hbGwoW2EuZW5zdXJlQ2F0YWxvZygiYWNyb0Zvcm0iKSxhLmVuc3VyZUNhdGFsb2coImJhc2VVcmwiKSxhLmVuc3VyZURvYygieGZhRGF0YXNldHMiKSxuP3RoaXMuX2dldFBhZ2VJbmRleChlLHQsYSk6LTFdKS50aGVuKCgoW2kscyxvLGNdKT0+YS5lbnN1cmUodGhpcywiX2NyZWF0ZSIsW2UsdCxhLHIsaSxvLG4sY10pKSl9c3RhdGljIF9jcmVhdGUoZSx0LGEsaSxvLGMsbCxoPS0xKXtjb25zdCB1PWUuZmV0Y2hJZlJlZih0KTtpZighKHUgaW5zdGFuY2VvZiBzLkRpY3QpKXJldHVybjtjb25zdCBkPXQgaW5zdGFuY2VvZiBzLlJlZj90LnRvU3RyaW5nKCk6YGFubm90XyR7aS5jcmVhdGVPYmpJZCgpfWA7bGV0IGY9dS5nZXQoIlN1YnR5cGUiKTtmPWYgaW5zdGFuY2VvZiBzLk5hbWU/Zi5uYW1lOm51bGw7Y29uc3QgZz17eHJlZjplLHJlZjp0LGRpY3Q6dSxzdWJ0eXBlOmYsaWQ6ZCxwZGZNYW5hZ2VyOmEsYWNyb0Zvcm06byBpbnN0YW5jZW9mIHMuRGljdD9vOnMuRGljdC5lbXB0eSx4ZmFEYXRhc2V0czpjLGNvbGxlY3RGaWVsZHM6bCxwYWdlSW5kZXg6aH07c3dpdGNoKGYpe2Nhc2UiTGluayI6cmV0dXJuIG5ldyBMaW5rQW5ub3RhdGlvbihnKTtjYXNlIlRleHQiOnJldHVybiBuZXcgVGV4dEFubm90YXRpb24oZyk7Y2FzZSJXaWRnZXQiOmxldCBlPSgwLG4uZ2V0SW5oZXJpdGFibGVQcm9wZXJ0eSkoe2RpY3Q6dSxrZXk6IkZUIn0pO2U9ZSBpbnN0YW5jZW9mIHMuTmFtZT9lLm5hbWU6bnVsbDtzd2l0Y2goZSl7Y2FzZSJUeCI6cmV0dXJuIG5ldyBUZXh0V2lkZ2V0QW5ub3RhdGlvbihnKTtjYXNlIkJ0biI6cmV0dXJuIG5ldyBCdXR0b25XaWRnZXRBbm5vdGF0aW9uKGcpO2Nhc2UiQ2giOnJldHVybiBuZXcgQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbihnKTtjYXNlIlNpZyI6cmV0dXJuIG5ldyBTaWduYXR1cmVXaWRnZXRBbm5vdGF0aW9uKGcpfSgwLHIud2FybikoYFVuaW1wbGVtZW50ZWQgd2lkZ2V0IGZpZWxkIHR5cGUgIiR7ZX0iLCBmYWxsaW5nIGJhY2sgdG8gYmFzZSBmaWVsZCB0eXBlLmApO3JldHVybiBuZXcgV2lkZ2V0QW5ub3RhdGlvbihnKTtjYXNlIlBvcHVwIjpyZXR1cm4gbmV3IFBvcHVwQW5ub3RhdGlvbihnKTtjYXNlIkZyZWVUZXh0IjpyZXR1cm4gbmV3IEZyZWVUZXh0QW5ub3RhdGlvbihnKTtjYXNlIkxpbmUiOnJldHVybiBuZXcgTGluZUFubm90YXRpb24oZyk7Y2FzZSJTcXVhcmUiOnJldHVybiBuZXcgU3F1YXJlQW5ub3RhdGlvbihnKTtjYXNlIkNpcmNsZSI6cmV0dXJuIG5ldyBDaXJjbGVBbm5vdGF0aW9uKGcpO2Nhc2UiUG9seUxpbmUiOnJldHVybiBuZXcgUG9seWxpbmVBbm5vdGF0aW9uKGcpO2Nhc2UiUG9seWdvbiI6cmV0dXJuIG5ldyBQb2x5Z29uQW5ub3RhdGlvbihnKTtjYXNlIkNhcmV0IjpyZXR1cm4gbmV3IENhcmV0QW5ub3RhdGlvbihnKTtjYXNlIkluayI6cmV0dXJuIG5ldyBJbmtBbm5vdGF0aW9uKGcpO2Nhc2UiSGlnaGxpZ2h0IjpyZXR1cm4gbmV3IEhpZ2hsaWdodEFubm90YXRpb24oZyk7Y2FzZSJVbmRlcmxpbmUiOnJldHVybiBuZXcgVW5kZXJsaW5lQW5ub3RhdGlvbihnKTtjYXNlIlNxdWlnZ2x5IjpyZXR1cm4gbmV3IFNxdWlnZ2x5QW5ub3RhdGlvbihnKTtjYXNlIlN0cmlrZU91dCI6cmV0dXJuIG5ldyBTdHJpa2VPdXRBbm5vdGF0aW9uKGcpO2Nhc2UiU3RhbXAiOnJldHVybiBuZXcgU3RhbXBBbm5vdGF0aW9uKGcpO2Nhc2UiRmlsZUF0dGFjaG1lbnQiOnJldHVybiBuZXcgRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uKGcpO2RlZmF1bHQ6bHx8KGY/KDAsci53YXJuKShgVW5pbXBsZW1lbnRlZCBhbm5vdGF0aW9uIHR5cGUgIiR7Zn0iLCBmYWxsaW5nIGJhY2sgdG8gYmFzZSBhbm5vdGF0aW9uLmApOigwLHIud2FybikoIkFubm90YXRpb24gaXMgbWlzc2luZyB0aGUgcmVxdWlyZWQgL1N1YnR5cGUuIikpO3JldHVybiBuZXcgQW5ub3RhdGlvbihnKX19c3RhdGljIGFzeW5jIF9nZXRQYWdlSW5kZXgoZSx0LGEpe3RyeXtjb25zdCByPWF3YWl0IGUuZmV0Y2hJZlJlZkFzeW5jKHQpO2lmKCEociBpbnN0YW5jZW9mIHMuRGljdCkpcmV0dXJuLTE7Y29uc3Qgbj1yLmdldFJhdygiUCIpO2lmKCEobiBpbnN0YW5jZW9mIHMuUmVmKSlyZXR1cm4tMTtyZXR1cm4gYXdhaXQgYS5lbnN1cmVDYXRhbG9nKCJnZXRQYWdlSW5kZXgiLFtuXSl9Y2F0Y2goZSl7KDAsci53YXJuKShgX2dldFBhZ2VJbmRleDogIiR7ZX0iLmApO3JldHVybi0xfX1zdGF0aWMgYXN5bmMgc2F2ZU5ld0Fubm90YXRpb25zKGUsdCxhKXtjb25zdCBuPWUueHJlZjtsZXQgaTtjb25zdCBjPVtdLGw9W107Zm9yKGNvbnN0IGggb2YgYSlzd2l0Y2goaC5hbm5vdGF0aW9uVHlwZSl7Y2FzZSByLkFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhUOmlmKCFpKXtjb25zdCBlPW5ldyBzLkRpY3Qobik7ZS5zZXQoIkJhc2VGb250IixzLk5hbWUuZ2V0KCJIZWx2ZXRpY2EiKSk7ZS5zZXQoIlR5cGUiLHMuTmFtZS5nZXQoIkZvbnQiKSk7ZS5zZXQoIlN1YnR5cGUiLHMuTmFtZS5nZXQoIlR5cGUxIikpO2Uuc2V0KCJFbmNvZGluZyIscy5OYW1lLmdldCgiV2luQW5zaUVuY29kaW5nIikpO2NvbnN0IHQ9W107aT1uLmdldE5ld1JlZigpOygwLG8ud3JpdGVPYmplY3QpKGksZSx0LG51bGwpO2MucHVzaCh7cmVmOmksZGF0YTp0LmpvaW4oIiIpfSl9bC5wdXNoKEZyZWVUZXh0QW5ub3RhdGlvbi5jcmVhdGVOZXdBbm5vdGF0aW9uKG4saCxjLHtldmFsdWF0b3I6ZSx0YXNrOnQsYmFzZUZvbnRSZWY6aX0pKTticmVhaztjYXNlIHIuQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LOmwucHVzaChJbmtBbm5vdGF0aW9uLmNyZWF0ZU5ld0Fubm90YXRpb24obixoLGMpKX1yZXR1cm57YW5ub3RhdGlvbnM6YXdhaXQgUHJvbWlzZS5hbGwobCksZGVwZW5kZW5jaWVzOmN9fXN0YXRpYyBhc3luYyBwcmludE5ld0Fubm90YXRpb25zKGUsdCxhKXtpZighYSlyZXR1cm4gbnVsbDtjb25zdCBuPWUueHJlZixpPVtdO2Zvcihjb25zdCBzIG9mIGEpc3dpdGNoKHMuYW5ub3RhdGlvblR5cGUpe2Nhc2Ugci5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVDppLnB1c2goRnJlZVRleHRBbm5vdGF0aW9uLmNyZWF0ZU5ld1ByaW50QW5ub3RhdGlvbihuLHMse2V2YWx1YXRvcjplLHRhc2s6dH0pKTticmVhaztjYXNlIHIuQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LOmkucHVzaChJbmtBbm5vdGF0aW9uLmNyZWF0ZU5ld1ByaW50QW5ub3RhdGlvbihuLHMpKX1yZXR1cm4gUHJvbWlzZS5hbGwoaSl9fTtmdW5jdGlvbiBnZXRSZ2JDb2xvcihlLHQ9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDMpKXtpZighQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gdDtjb25zdCBhPXR8fG5ldyBVaW50OENsYW1wZWRBcnJheSgzKTtzd2l0Y2goZS5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gbnVsbDtjYXNlIDE6dS5Db2xvclNwYWNlLnNpbmdsZXRvbnMuZ3JheS5nZXRSZ2JJdGVtKGUsMCxhLDApO3JldHVybiBhO2Nhc2UgMzp1LkNvbG9yU3BhY2Uuc2luZ2xldG9ucy5yZ2IuZ2V0UmdiSXRlbShlLDAsYSwwKTtyZXR1cm4gYTtjYXNlIDQ6dS5Db2xvclNwYWNlLnNpbmdsZXRvbnMuY215ay5nZXRSZ2JJdGVtKGUsMCxhLDApO3JldHVybiBhO2RlZmF1bHQ6cmV0dXJuIHR9fWZ1bmN0aW9uIGdldFF1YWRQb2ludHMoZSx0KXtpZighZS5oYXMoIlF1YWRQb2ludHMiKSlyZXR1cm4gbnVsbDtjb25zdCBhPWUuZ2V0QXJyYXkoIlF1YWRQb2ludHMiKTtpZighQXJyYXkuaXNBcnJheShhKXx8MD09PWEubGVuZ3RofHxhLmxlbmd0aCU4PjApcmV0dXJuIG51bGw7Y29uc3Qgcj1bXTtmb3IobGV0IGU9MCxuPWEubGVuZ3RoLzg7ZTxuO2UrKyl7ci5wdXNoKFtdKTtmb3IobGV0IG49OCplLGk9OCplKzg7bjxpO24rPTIpe2NvbnN0IGk9YVtuXSxzPWFbbisxXTtpZihudWxsIT09dCYmKGk8dFswXXx8aT50WzJdfHxzPHRbMV18fHM+dFszXSkpcmV0dXJuIG51bGw7cltlXS5wdXNoKHt4OmkseTpzfSl9fXJldHVybiByLm1hcCgoZT0+e2NvbnN0W3QsYSxyLG5dPWUucmVkdWNlKCgoW2UsdCxhLHJdLG4pPT5bTWF0aC5taW4oZSxuLngpLE1hdGgubWF4KHQsbi54KSxNYXRoLm1pbihhLG4ueSksTWF0aC5tYXgocixuLnkpXSksW051bWJlci5NQVhfVkFMVUUsTnVtYmVyLk1JTl9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NSU5fVkFMVUVdKTtyZXR1cm5be3g6dCx5Om59LHt4OmEseTpufSx7eDp0LHk6cn0se3g6YSx5OnJ9XX0pKX1mdW5jdGlvbiBnZXRUcmFuc2Zvcm1NYXRyaXgoZSx0LGEpe2NvbnN0W24saSxzLG9dPXIuVXRpbC5nZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveCh0LGEpO2lmKG49PT1zfHxpPT09bylyZXR1cm5bMSwwLDAsMSxlWzBdLGVbMV1dO2NvbnN0IGM9KGVbMl0tZVswXSkvKHMtbiksbD0oZVszXS1lWzFdKS8oby1pKTtyZXR1cm5bYywwLDAsbCxlWzBdLW4qYyxlWzFdLWkqbF19Y2xhc3MgQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtjb25zdCB0PWUuZGljdDt0aGlzLnNldFRpdGxlKHQuZ2V0KCJUIikpO3RoaXMuc2V0Q29udGVudHModC5nZXQoIkNvbnRlbnRzIikpO3RoaXMuc2V0TW9kaWZpY2F0aW9uRGF0ZSh0LmdldCgiTSIpKTt0aGlzLnNldEZsYWdzKHQuZ2V0KCJGIikpO3RoaXMuc2V0UmVjdGFuZ2xlKHQuZ2V0QXJyYXkoIlJlY3QiKSk7dGhpcy5zZXRDb2xvcih0LmdldEFycmF5KCJDIikpO3RoaXMuc2V0Qm9yZGVyU3R5bGUodCk7dGhpcy5zZXRBcHBlYXJhbmNlKHQpO3RoaXMuc2V0T3B0aW9uYWxDb250ZW50KHQpO2NvbnN0IGE9dC5nZXQoIk1LIik7dGhpcy5zZXRCb3JkZXJBbmRCYWNrZ3JvdW5kQ29sb3JzKGEpO3RoaXMuc2V0Um90YXRpb24oYSk7dGhpcy5fc3RyZWFtcz1bXTt0aGlzLmFwcGVhcmFuY2UmJnRoaXMuX3N0cmVhbXMucHVzaCh0aGlzLmFwcGVhcmFuY2UpO3RoaXMuZGF0YT17YW5ub3RhdGlvbkZsYWdzOnRoaXMuZmxhZ3MsYm9yZGVyU3R5bGU6dGhpcy5ib3JkZXJTdHlsZSxjb2xvcjp0aGlzLmNvbG9yLGJhY2tncm91bmRDb2xvcjp0aGlzLmJhY2tncm91bmRDb2xvcixib3JkZXJDb2xvcjp0aGlzLmJvcmRlckNvbG9yLHJvdGF0aW9uOnRoaXMucm90YXRpb24sY29udGVudHNPYmo6dGhpcy5fY29udGVudHMsaGFzQXBwZWFyYW5jZTohIXRoaXMuYXBwZWFyYW5jZSxpZDplLmlkLG1vZGlmaWNhdGlvbkRhdGU6dGhpcy5tb2RpZmljYXRpb25EYXRlLHJlY3Q6dGhpcy5yZWN0YW5nbGUsc3VidHlwZTplLnN1YnR5cGUsaGFzT3duQ2FudmFzOiExfTtpZihlLmNvbGxlY3RGaWVsZHMpe2NvbnN0IGE9dC5nZXQoIktpZHMiKTtpZihBcnJheS5pc0FycmF5KGEpKXtjb25zdCBlPVtdO2Zvcihjb25zdCB0IG9mIGEpdCBpbnN0YW5jZW9mIHMuUmVmJiZlLnB1c2godC50b1N0cmluZygpKTswIT09ZS5sZW5ndGgmJih0aGlzLmRhdGEua2lkSWRzPWUpfXRoaXMuZGF0YS5hY3Rpb25zPSgwLG4uY29sbGVjdEFjdGlvbnMpKGUueHJlZix0LHIuQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSk7dGhpcy5kYXRhLmZpZWxkTmFtZT10aGlzLl9jb25zdHJ1Y3RGaWVsZE5hbWUodCk7dGhpcy5kYXRhLnBhZ2VJbmRleD1lLnBhZ2VJbmRleH10aGlzLl9mYWxsYmFja0ZvbnREaWN0PW51bGx9X2hhc0ZsYWcoZSx0KXtyZXR1cm4hIShlJnQpfV9pc1ZpZXdhYmxlKGUpe3JldHVybiF0aGlzLl9oYXNGbGFnKGUsci5Bbm5vdGF0aW9uRmxhZy5JTlZJU0lCTEUpJiYhdGhpcy5faGFzRmxhZyhlLHIuQW5ub3RhdGlvbkZsYWcuTk9WSUVXKX1faXNQcmludGFibGUoZSl7cmV0dXJuIHRoaXMuX2hhc0ZsYWcoZSxyLkFubm90YXRpb25GbGFnLlBSSU5UKSYmIXRoaXMuX2hhc0ZsYWcoZSxyLkFubm90YXRpb25GbGFnLklOVklTSUJMRSl9bXVzdEJlVmlld2VkKGUpe2NvbnN0IHQ9ZSYmZS5nZXQodGhpcy5kYXRhLmlkKTtyZXR1cm4gdCYmdm9pZCAwIT09dC5oaWRkZW4/IXQuaGlkZGVuOnRoaXMudmlld2FibGUmJiF0aGlzLl9oYXNGbGFnKHRoaXMuZmxhZ3Msci5Bbm5vdGF0aW9uRmxhZy5ISURERU4pfW11c3RCZVByaW50ZWQoZSl7Y29uc3QgdD1lJiZlLmdldCh0aGlzLmRhdGEuaWQpO3JldHVybiB0JiZ2b2lkIDAhPT10LnByaW50P3QucHJpbnQ6dGhpcy5wcmludGFibGV9Z2V0IHZpZXdhYmxlKCl7cmV0dXJuIG51bGwhPT10aGlzLmRhdGEucXVhZFBvaW50cyYmKDA9PT10aGlzLmZsYWdzfHx0aGlzLl9pc1ZpZXdhYmxlKHRoaXMuZmxhZ3MpKX1nZXQgcHJpbnRhYmxlKCl7cmV0dXJuIG51bGwhPT10aGlzLmRhdGEucXVhZFBvaW50cyYmKDAhPT10aGlzLmZsYWdzJiZ0aGlzLl9pc1ByaW50YWJsZSh0aGlzLmZsYWdzKSl9X3BhcnNlU3RyaW5nSGVscGVyKGUpe2NvbnN0IHQ9InN0cmluZyI9PXR5cGVvZiBlPygwLHIuc3RyaW5nVG9QREZTdHJpbmcpKGUpOiIiO3JldHVybntzdHI6dCxkaXI6dCYmInJ0bCI9PT0oMCxsLmJpZGkpKHQpLmRpcj8icnRsIjoibHRyIn19c2V0VGl0bGUoZSl7dGhpcy5fdGl0bGU9dGhpcy5fcGFyc2VTdHJpbmdIZWxwZXIoZSl9c2V0Q29udGVudHMoZSl7dGhpcy5fY29udGVudHM9dGhpcy5fcGFyc2VTdHJpbmdIZWxwZXIoZSl9c2V0TW9kaWZpY2F0aW9uRGF0ZShlKXt0aGlzLm1vZGlmaWNhdGlvbkRhdGU9InN0cmluZyI9PXR5cGVvZiBlP2U6bnVsbH1zZXRGbGFncyhlKXt0aGlzLmZsYWdzPU51bWJlci5pc0ludGVnZXIoZSkmJmU+MD9lOjB9aGFzRmxhZyhlKXtyZXR1cm4gdGhpcy5faGFzRmxhZyh0aGlzLmZsYWdzLGUpfXNldFJlY3RhbmdsZShlKXtBcnJheS5pc0FycmF5KGUpJiY0PT09ZS5sZW5ndGg/dGhpcy5yZWN0YW5nbGU9ci5VdGlsLm5vcm1hbGl6ZVJlY3QoZSk6dGhpcy5yZWN0YW5nbGU9WzAsMCwwLDBdfXNldENvbG9yKGUpe3RoaXMuY29sb3I9Z2V0UmdiQ29sb3IoZSl9c2V0TGluZUVuZGluZ3MoZSl7dGhpcy5saW5lRW5kaW5ncz1bIk5vbmUiLCJOb25lIl07aWYoQXJyYXkuaXNBcnJheShlKSYmMj09PWUubGVuZ3RoKWZvcihsZXQgdD0wO3Q8Mjt0Kyspe2NvbnN0IGE9ZVt0XTtpZihhIGluc3RhbmNlb2Ygcy5OYW1lKXN3aXRjaChhLm5hbWUpe2Nhc2UiTm9uZSI6Y29udGludWU7Y2FzZSJTcXVhcmUiOmNhc2UiQ2lyY2xlIjpjYXNlIkRpYW1vbmQiOmNhc2UiT3BlbkFycm93IjpjYXNlIkNsb3NlZEFycm93IjpjYXNlIkJ1dHQiOmNhc2UiUk9wZW5BcnJvdyI6Y2FzZSJSQ2xvc2VkQXJyb3ciOmNhc2UiU2xhc2giOnRoaXMubGluZUVuZGluZ3NbdF09YS5uYW1lO2NvbnRpbnVlfSgwLHIud2FybikoYElnbm9yaW5nIGludmFsaWQgbGluZUVuZGluZzogJHthfWApfX1zZXRSb3RhdGlvbihlKXt0aGlzLnJvdGF0aW9uPTA7aWYoZSBpbnN0YW5jZW9mIHMuRGljdCl7bGV0IHQ9ZS5nZXQoIlIiKXx8MDtpZihOdW1iZXIuaXNJbnRlZ2VyKHQpJiYwIT09dCl7dCU9MzYwO3Q8MCYmKHQrPTM2MCk7dCU5MD09MCYmKHRoaXMucm90YXRpb249dCl9fX1zZXRCb3JkZXJBbmRCYWNrZ3JvdW5kQ29sb3JzKGUpe2lmKGUgaW5zdGFuY2VvZiBzLkRpY3Qpe3RoaXMuYm9yZGVyQ29sb3I9Z2V0UmdiQ29sb3IoZS5nZXRBcnJheSgiQkMiKSxudWxsKTt0aGlzLmJhY2tncm91bmRDb2xvcj1nZXRSZ2JDb2xvcihlLmdldEFycmF5KCJCRyIpLG51bGwpfWVsc2UgdGhpcy5ib3JkZXJDb2xvcj10aGlzLmJhY2tncm91bmRDb2xvcj1udWxsfXNldEJvcmRlclN0eWxlKGUpe3RoaXMuYm9yZGVyU3R5bGU9bmV3IEFubm90YXRpb25Cb3JkZXJTdHlsZTtpZihlIGluc3RhbmNlb2Ygcy5EaWN0KWlmKGUuaGFzKCJCUyIpKXtjb25zdCB0PWUuZ2V0KCJCUyIpLGE9dC5nZXQoIlR5cGUiKTtpZighYXx8KDAscy5pc05hbWUpKGEsIkJvcmRlciIpKXt0aGlzLmJvcmRlclN0eWxlLnNldFdpZHRoKHQuZ2V0KCJXIiksdGhpcy5yZWN0YW5nbGUpO3RoaXMuYm9yZGVyU3R5bGUuc2V0U3R5bGUodC5nZXQoIlMiKSk7dGhpcy5ib3JkZXJTdHlsZS5zZXREYXNoQXJyYXkodC5nZXRBcnJheSgiRCIpKX19ZWxzZSBpZihlLmhhcygiQm9yZGVyIikpe2NvbnN0IHQ9ZS5nZXRBcnJheSgiQm9yZGVyIik7aWYoQXJyYXkuaXNBcnJheSh0KSYmdC5sZW5ndGg+PTMpe3RoaXMuYm9yZGVyU3R5bGUuc2V0SG9yaXpvbnRhbENvcm5lclJhZGl1cyh0WzBdKTt0aGlzLmJvcmRlclN0eWxlLnNldFZlcnRpY2FsQ29ybmVyUmFkaXVzKHRbMV0pO3RoaXMuYm9yZGVyU3R5bGUuc2V0V2lkdGgodFsyXSx0aGlzLnJlY3RhbmdsZSk7ND09PXQubGVuZ3RoJiZ0aGlzLmJvcmRlclN0eWxlLnNldERhc2hBcnJheSh0WzNdLCEwKX19ZWxzZSB0aGlzLmJvcmRlclN0eWxlLnNldFdpZHRoKDApfXNldEFwcGVhcmFuY2UoZSl7dGhpcy5hcHBlYXJhbmNlPW51bGw7Y29uc3QgdD1lLmdldCgiQVAiKTtpZighKHQgaW5zdGFuY2VvZiBzLkRpY3QpKXJldHVybjtjb25zdCBhPXQuZ2V0KCJOIik7aWYoYSBpbnN0YW5jZW9mIGMuQmFzZVN0cmVhbSl7dGhpcy5hcHBlYXJhbmNlPWE7cmV0dXJufWlmKCEoYSBpbnN0YW5jZW9mIHMuRGljdCkpcmV0dXJuO2NvbnN0IHI9ZS5nZXQoIkFTIik7ciBpbnN0YW5jZW9mIHMuTmFtZSYmYS5oYXMoci5uYW1lKSYmKHRoaXMuYXBwZWFyYW5jZT1hLmdldChyLm5hbWUpKX1zZXRPcHRpb25hbENvbnRlbnQoZSl7dGhpcy5vYz1udWxsO2NvbnN0IHQ9ZS5nZXQoIk9DIik7dCBpbnN0YW5jZW9mIHMuTmFtZT8oMCxyLndhcm4pKCJzZXRPcHRpb25hbENvbnRlbnQ6IFN1cHBvcnQgZm9yIC9OYW1lLWVudHJ5IGlzIG5vdCBpbXBsZW1lbnRlZC4iKTp0IGluc3RhbmNlb2Ygcy5EaWN0JiYodGhpcy5vYz10KX1sb2FkUmVzb3VyY2VzKGUsdCl7cmV0dXJuIHQuZGljdC5nZXRBc3luYygiUmVzb3VyY2VzIikudGhlbigodD0+e2lmKCF0KXJldHVybjtyZXR1cm4gbmV3IGYuT2JqZWN0TG9hZGVyKHQsZSx0LnhyZWYpLmxvYWQoKS50aGVuKChmdW5jdGlvbigpe3JldHVybiB0fSkpfSkpfWFzeW5jIGdldE9wZXJhdG9yTGlzdChlLHQsYSxuLGkpe2NvbnN0IG89dGhpcy5kYXRhO2xldCBjPXRoaXMuYXBwZWFyYW5jZTtjb25zdCBsPSEhKHRoaXMuZGF0YS5oYXNPd25DYW52YXMmJmEmci5SZW5kZXJpbmdJbnRlbnRGbGFnLkRJU1BMQVkpO2lmKCFjKXtpZighbClyZXR1cm57b3BMaXN0Om5ldyBnLk9wZXJhdG9yTGlzdCxzZXBhcmF0ZUZvcm06ITEsc2VwYXJhdGVDYW52YXM6ITF9O2M9bmV3IHAuU3RyaW5nU3RyZWFtKCIiKTtjLmRpY3Q9bmV3IHMuRGljdH1jb25zdCBoPWMuZGljdCx1PWF3YWl0IHRoaXMubG9hZFJlc291cmNlcyhbIkV4dEdTdGF0ZSIsIkNvbG9yU3BhY2UiLCJQYXR0ZXJuIiwiU2hhZGluZyIsIlhPYmplY3QiLCJGb250Il0sYyksZD1oLmdldEFycmF5KCJCQm94Iil8fFswLDAsMSwxXSxmPWguZ2V0QXJyYXkoIk1hdHJpeCIpfHxbMSwwLDAsMSwwLDBdLG09Z2V0VHJhbnNmb3JtTWF0cml4KG8ucmVjdCxkLGYpLGI9bmV3IGcuT3BlcmF0b3JMaXN0O2xldCB5O3RoaXMub2MmJih5PWF3YWl0IGUucGFyc2VNYXJrZWRDb250ZW50UHJvcHModGhpcy5vYyxudWxsKSk7dm9pZCAwIT09eSYmYi5hZGRPcChyLk9QUy5iZWdpbk1hcmtlZENvbnRlbnRQcm9wcyxbIk9DIix5XSk7Yi5hZGRPcChyLk9QUy5iZWdpbkFubm90YXRpb24sW28uaWQsby5yZWN0LG0sZixsXSk7YXdhaXQgZS5nZXRPcGVyYXRvckxpc3Qoe3N0cmVhbTpjLHRhc2s6dCxyZXNvdXJjZXM6dSxvcGVyYXRvckxpc3Q6YixmYWxsYmFja0ZvbnREaWN0OnRoaXMuX2ZhbGxiYWNrRm9udERpY3R9KTtiLmFkZE9wKHIuT1BTLmVuZEFubm90YXRpb24sW10pO3ZvaWQgMCE9PXkmJmIuYWRkT3Aoci5PUFMuZW5kTWFya2VkQ29udGVudCxbXSk7dGhpcy5yZXNldCgpO3JldHVybntvcExpc3Q6YixzZXBhcmF0ZUZvcm06ITEsc2VwYXJhdGVDYW52YXM6bH19YXN5bmMgc2F2ZShlLHQsYSl7cmV0dXJuIG51bGx9Z2V0IGhhc1RleHRDb250ZW50KCl7cmV0dXJuITF9YXN5bmMgZXh0cmFjdFRleHRDb250ZW50KGUsdCxhKXtpZighdGhpcy5hcHBlYXJhbmNlKXJldHVybjtjb25zdCByPWF3YWl0IHRoaXMubG9hZFJlc291cmNlcyhbIkV4dEdTdGF0ZSIsIkZvbnQiLCJQcm9wZXJ0aWVzIiwiWE9iamVjdCJdLHRoaXMuYXBwZWFyYW5jZSksbj1bXSxpPVtdLHM9e2Rlc2lyZWRTaXplOk1hdGguSW5maW5pdHkscmVhZHk6ITAsZW5xdWV1ZShlLHQpe2Zvcihjb25zdCB0IG9mIGUuaXRlbXMpe2kucHVzaCh0LnN0cik7aWYodC5oYXNFT0wpe24ucHVzaChpLmpvaW4oIiIpKTtpLmxlbmd0aD0wfX19fTthd2FpdCBlLmdldFRleHRDb250ZW50KHtzdHJlYW06dGhpcy5hcHBlYXJhbmNlLHRhc2s6dCxyZXNvdXJjZXM6cixpbmNsdWRlTWFya2VkQ29udGVudDohMCxjb21iaW5lVGV4dEl0ZW1zOiEwLHNpbms6cyx2aWV3Qm94OmF9KTt0aGlzLnJlc2V0KCk7aS5sZW5ndGgmJm4ucHVzaChpLmpvaW4oIiIpKTtuLmxlbmd0aD4wJiYodGhpcy5kYXRhLnRleHRDb250ZW50PW4pfWdldEZpZWxkT2JqZWN0KCl7cmV0dXJuIHRoaXMuZGF0YS5raWRJZHM/e2lkOnRoaXMuZGF0YS5pZCxhY3Rpb25zOnRoaXMuZGF0YS5hY3Rpb25zLG5hbWU6dGhpcy5kYXRhLmZpZWxkTmFtZSxzdHJva2VDb2xvcjp0aGlzLmRhdGEuYm9yZGVyQ29sb3IsZmlsbENvbG9yOnRoaXMuZGF0YS5iYWNrZ3JvdW5kQ29sb3IsdHlwZToiIixraWRJZHM6dGhpcy5kYXRhLmtpZElkcyxwYWdlOnRoaXMuZGF0YS5wYWdlSW5kZXgscm90YXRpb246dGhpcy5yb3RhdGlvbn06bnVsbH1yZXNldCgpe2Zvcihjb25zdCBlIG9mIHRoaXMuX3N0cmVhbXMpZS5yZXNldCgpfV9jb25zdHJ1Y3RGaWVsZE5hbWUoZSl7aWYoIWUuaGFzKCJUIikmJiFlLmhhcygiUGFyZW50IikpeygwLHIud2FybikoIlVua25vd24gZmllbGQgbmFtZSwgZmFsbGluZyBiYWNrIHRvIGVtcHR5IGZpZWxkIG5hbWUuIik7cmV0dXJuIiJ9aWYoIWUuaGFzKCJQYXJlbnQiKSlyZXR1cm4oMCxyLnN0cmluZ1RvUERGU3RyaW5nKShlLmdldCgiVCIpKTtjb25zdCB0PVtdO2UuaGFzKCJUIikmJnQudW5zaGlmdCgoMCxyLnN0cmluZ1RvUERGU3RyaW5nKShlLmdldCgiVCIpKSk7bGV0IGE9ZTtjb25zdCBuPW5ldyBzLlJlZlNldDtlLm9iaklkJiZuLnB1dChlLm9iaklkKTtmb3IoO2EuaGFzKCJQYXJlbnQiKTspe2E9YS5nZXQoIlBhcmVudCIpO2lmKCEoYSBpbnN0YW5jZW9mIHMuRGljdCl8fGEub2JqSWQmJm4uaGFzKGEub2JqSWQpKWJyZWFrO2Eub2JqSWQmJm4ucHV0KGEub2JqSWQpO2EuaGFzKCJUIikmJnQudW5zaGlmdCgoMCxyLnN0cmluZ1RvUERGU3RyaW5nKShhLmdldCgiVCIpKSl9cmV0dXJuIHQuam9pbigiLiIpfX10LkFubm90YXRpb249QW5ub3RhdGlvbjtjbGFzcyBBbm5vdGF0aW9uQm9yZGVyU3R5bGV7Y29uc3RydWN0b3IoKXt0aGlzLndpZHRoPTE7dGhpcy5zdHlsZT1yLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuU09MSUQ7dGhpcy5kYXNoQXJyYXk9WzNdO3RoaXMuaG9yaXpvbnRhbENvcm5lclJhZGl1cz0wO3RoaXMudmVydGljYWxDb3JuZXJSYWRpdXM9MH1zZXRXaWR0aChlLHQ9WzAsMCwwLDBdKXtpZihlIGluc3RhbmNlb2Ygcy5OYW1lKXRoaXMud2lkdGg9MDtlbHNlIGlmKCJudW1iZXIiPT10eXBlb2YgZSl7aWYoZT4wKXtjb25zdCBhPSh0WzJdLXRbMF0pLzIsbj0odFszXS10WzFdKS8yO2lmKGE+MCYmbj4wJiYoZT5hfHxlPm4pKXsoMCxyLndhcm4pKGBBbm5vdGF0aW9uQm9yZGVyU3R5bGUuc2V0V2lkdGggLSBpZ25vcmluZyB3aWR0aDogJHtlfWApO2U9MX19dGhpcy53aWR0aD1lfX1zZXRTdHlsZShlKXtpZihlIGluc3RhbmNlb2Ygcy5OYW1lKXN3aXRjaChlLm5hbWUpe2Nhc2UiUyI6dGhpcy5zdHlsZT1yLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuU09MSUQ7YnJlYWs7Y2FzZSJEIjp0aGlzLnN0eWxlPXIuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5EQVNIRUQ7YnJlYWs7Y2FzZSJCIjp0aGlzLnN0eWxlPXIuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5CRVZFTEVEO2JyZWFrO2Nhc2UiSSI6dGhpcy5zdHlsZT1yLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuSU5TRVQ7YnJlYWs7Y2FzZSJVIjp0aGlzLnN0eWxlPXIuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5VTkRFUkxJTkV9fXNldERhc2hBcnJheShlLHQ9ITEpe2lmKEFycmF5LmlzQXJyYXkoZSkmJmUubGVuZ3RoPjApe2xldCBhPSEwLHI9ITA7Zm9yKGNvbnN0IHQgb2YgZSl7aWYoISgrdD49MCkpe2E9ITE7YnJlYWt9dD4wJiYocj0hMSl9aWYoYSYmIXIpe3RoaXMuZGFzaEFycmF5PWU7dCYmdGhpcy5zZXRTdHlsZShzLk5hbWUuZ2V0KCJEIikpfWVsc2UgdGhpcy53aWR0aD0wfWVsc2UgZSYmKHRoaXMud2lkdGg9MCl9c2V0SG9yaXpvbnRhbENvcm5lclJhZGl1cyhlKXtOdW1iZXIuaXNJbnRlZ2VyKGUpJiYodGhpcy5ob3Jpem9udGFsQ29ybmVyUmFkaXVzPWUpfXNldFZlcnRpY2FsQ29ybmVyUmFkaXVzKGUpe051bWJlci5pc0ludGVnZXIoZSkmJih0aGlzLnZlcnRpY2FsQ29ybmVyUmFkaXVzPWUpfX10LkFubm90YXRpb25Cb3JkZXJTdHlsZT1Bbm5vdGF0aW9uQm9yZGVyU3R5bGU7Y2xhc3MgTWFya3VwQW5ub3RhdGlvbiBleHRlbmRzIEFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7Y29uc3QgdD1lLmRpY3Q7aWYodC5oYXMoIklSVCIpKXtjb25zdCBlPXQuZ2V0UmF3KCJJUlQiKTt0aGlzLmRhdGEuaW5SZXBseVRvPWUgaW5zdGFuY2VvZiBzLlJlZj9lLnRvU3RyaW5nKCk6bnVsbDtjb25zdCBhPXQuZ2V0KCJSVCIpO3RoaXMuZGF0YS5yZXBseVR5cGU9YSBpbnN0YW5jZW9mIHMuTmFtZT9hLm5hbWU6ci5Bbm5vdGF0aW9uUmVwbHlUeXBlLlJFUExZfWlmKHRoaXMuZGF0YS5yZXBseVR5cGU9PT1yLkFubm90YXRpb25SZXBseVR5cGUuR1JPVVApe2NvbnN0IGU9dC5nZXQoIklSVCIpO3RoaXMuc2V0VGl0bGUoZS5nZXQoIlQiKSk7dGhpcy5kYXRhLnRpdGxlT2JqPXRoaXMuX3RpdGxlO3RoaXMuc2V0Q29udGVudHMoZS5nZXQoIkNvbnRlbnRzIikpO3RoaXMuZGF0YS5jb250ZW50c09iaj10aGlzLl9jb250ZW50cztpZihlLmhhcygiQ3JlYXRpb25EYXRlIikpe3RoaXMuc2V0Q3JlYXRpb25EYXRlKGUuZ2V0KCJDcmVhdGlvbkRhdGUiKSk7dGhpcy5kYXRhLmNyZWF0aW9uRGF0ZT10aGlzLmNyZWF0aW9uRGF0ZX1lbHNlIHRoaXMuZGF0YS5jcmVhdGlvbkRhdGU9bnVsbDtpZihlLmhhcygiTSIpKXt0aGlzLnNldE1vZGlmaWNhdGlvbkRhdGUoZS5nZXQoIk0iKSk7dGhpcy5kYXRhLm1vZGlmaWNhdGlvbkRhdGU9dGhpcy5tb2RpZmljYXRpb25EYXRlfWVsc2UgdGhpcy5kYXRhLm1vZGlmaWNhdGlvbkRhdGU9bnVsbDt0aGlzLmRhdGEuaGFzUG9wdXA9ZS5oYXMoIlBvcHVwIik7aWYoZS5oYXMoIkMiKSl7dGhpcy5zZXRDb2xvcihlLmdldEFycmF5KCJDIikpO3RoaXMuZGF0YS5jb2xvcj10aGlzLmNvbG9yfWVsc2UgdGhpcy5kYXRhLmNvbG9yPW51bGx9ZWxzZXt0aGlzLmRhdGEudGl0bGVPYmo9dGhpcy5fdGl0bGU7dGhpcy5zZXRDcmVhdGlvbkRhdGUodC5nZXQoIkNyZWF0aW9uRGF0ZSIpKTt0aGlzLmRhdGEuY3JlYXRpb25EYXRlPXRoaXMuY3JlYXRpb25EYXRlO3RoaXMuZGF0YS5oYXNQb3B1cD10LmhhcygiUG9wdXAiKTt0LmhhcygiQyIpfHwodGhpcy5kYXRhLmNvbG9yPW51bGwpfXQuaGFzKCJSQyIpJiYodGhpcy5kYXRhLnJpY2hUZXh0PW0uWEZBRmFjdG9yeS5nZXRSaWNoVGV4dEFzSHRtbCh0LmdldCgiUkMiKSkpfXNldENyZWF0aW9uRGF0ZShlKXt0aGlzLmNyZWF0aW9uRGF0ZT0ic3RyaW5nIj09dHlwZW9mIGU/ZTpudWxsfV9zZXREZWZhdWx0QXBwZWFyYW5jZSh7eHJlZjplLGV4dHJhOnQsc3Ryb2tlQ29sb3I6YSxmaWxsQ29sb3I6cixibGVuZE1vZGU6bixzdHJva2VBbHBoYTppLGZpbGxBbHBoYTpvLHBvaW50c0NhbGxiYWNrOmN9KXtsZXQgbD1OdW1iZXIuTUFYX1ZBTFVFLGg9TnVtYmVyLk1BWF9WQUxVRSx1PU51bWJlci5NSU5fVkFMVUUsZD1OdW1iZXIuTUlOX1ZBTFVFO2NvbnN0IGY9WyJxIl07dCYmZi5wdXNoKHQpO2EmJmYucHVzaChgJHthWzBdfSAke2FbMV19ICR7YVsyXX0gUkdgKTtyJiZmLnB1c2goYCR7clswXX0gJHtyWzFdfSAke3JbMl19IHJnYCk7bGV0IGc9dGhpcy5kYXRhLnF1YWRQb2ludHM7Z3x8KGc9W1t7eDp0aGlzLnJlY3RhbmdsZVswXSx5OnRoaXMucmVjdGFuZ2xlWzNdfSx7eDp0aGlzLnJlY3RhbmdsZVsyXSx5OnRoaXMucmVjdGFuZ2xlWzNdfSx7eDp0aGlzLnJlY3RhbmdsZVswXSx5OnRoaXMucmVjdGFuZ2xlWzFdfSx7eDp0aGlzLnJlY3RhbmdsZVsyXSx5OnRoaXMucmVjdGFuZ2xlWzFdfV1dKTtmb3IoY29uc3QgZSBvZiBnKXtjb25zdFt0LGEscixuXT1jKGYsZSk7bD1NYXRoLm1pbihsLHQpO3U9TWF0aC5tYXgodSxhKTtoPU1hdGgubWluKGgscik7ZD1NYXRoLm1heChkLG4pfWYucHVzaCgiUSIpO2NvbnN0IG09bmV3IHMuRGljdChlKSxiPW5ldyBzLkRpY3QoZSk7Yi5zZXQoIlN1YnR5cGUiLHMuTmFtZS5nZXQoIkZvcm0iKSk7Y29uc3QgeT1uZXcgcC5TdHJpbmdTdHJlYW0oZi5qb2luKCIgIikpO3kuZGljdD1iO20uc2V0KCJGbTAiLHkpO2NvbnN0IHc9bmV3IHMuRGljdChlKTtuJiZ3LnNldCgiQk0iLHMuTmFtZS5nZXQobikpOyJudW1iZXIiPT10eXBlb2YgaSYmdy5zZXQoIkNBIixpKTsibnVtYmVyIj09dHlwZW9mIG8mJncuc2V0KCJjYSIsbyk7Y29uc3QgUz1uZXcgcy5EaWN0KGUpO1Muc2V0KCJHUzAiLHcpO2NvbnN0IHg9bmV3IHMuRGljdChlKTt4LnNldCgiRXh0R1N0YXRlIixTKTt4LnNldCgiWE9iamVjdCIsbSk7Y29uc3Qgaz1uZXcgcy5EaWN0KGUpO2suc2V0KCJSZXNvdXJjZXMiLHgpO2NvbnN0IEM9dGhpcy5kYXRhLnJlY3Q9W2wsaCx1LGRdO2suc2V0KCJCQm94IixDKTt0aGlzLmFwcGVhcmFuY2U9bmV3IHAuU3RyaW5nU3RyZWFtKCIvR1MwIGdzIC9GbTAgRG8iKTt0aGlzLmFwcGVhcmFuY2UuZGljdD1rO3RoaXMuX3N0cmVhbXMucHVzaCh0aGlzLmFwcGVhcmFuY2UseSl9c3RhdGljIGFzeW5jIGNyZWF0ZU5ld0Fubm90YXRpb24oZSx0LGEscil7Y29uc3Qgbj1lLmdldE5ld1JlZigpLGk9ZS5nZXROZXdSZWYoKSxzPXRoaXMuY3JlYXRlTmV3RGljdCh0LGUse2FwUmVmOml9KSxjPWF3YWl0IHRoaXMuY3JlYXRlTmV3QXBwZWFyYW5jZVN0cmVhbSh0LGUsciksbD1bXTtsZXQgaD1lLmVuY3J5cHQ/ZS5lbmNyeXB0LmNyZWF0ZUNpcGhlclRyYW5zZm9ybShpLm51bSxpLmdlbik6bnVsbDsoMCxvLndyaXRlT2JqZWN0KShpLGMsbCxoKTthLnB1c2goe3JlZjppLGRhdGE6bC5qb2luKCIiKX0pO2wubGVuZ3RoPTA7aD1lLmVuY3J5cHQ/ZS5lbmNyeXB0LmNyZWF0ZUNpcGhlclRyYW5zZm9ybShuLm51bSxuLmdlbik6bnVsbDsoMCxvLndyaXRlT2JqZWN0KShuLHMsbCxoKTtyZXR1cm57cmVmOm4sZGF0YTpsLmpvaW4oIiIpfX1zdGF0aWMgYXN5bmMgY3JlYXRlTmV3UHJpbnRBbm5vdGF0aW9uKGUsdCxhKXtjb25zdCByPWF3YWl0IHRoaXMuY3JlYXRlTmV3QXBwZWFyYW5jZVN0cmVhbSh0LGUsYSksbj10aGlzLmNyZWF0ZU5ld0RpY3QodCxlLHthcDpyfSk7cmV0dXJuIG5ldyB0aGlzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcih7ZGljdDpuLHhyZWY6ZX0pfX10Lk1hcmt1cEFubm90YXRpb249TWFya3VwQW5ub3RhdGlvbjtjbGFzcyBXaWRnZXRBbm5vdGF0aW9uIGV4dGVuZHMgQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTtjb25zdCB0PWUuZGljdCxhPXRoaXMuZGF0YTt0aGlzLnJlZj1lLnJlZjthLmFubm90YXRpb25UeXBlPXIuQW5ub3RhdGlvblR5cGUuV0lER0VUO3ZvaWQgMD09PWEuZmllbGROYW1lJiYoYS5maWVsZE5hbWU9dGhpcy5fY29uc3RydWN0RmllbGROYW1lKHQpKTt2b2lkIDA9PT1hLmFjdGlvbnMmJihhLmFjdGlvbnM9KDAsbi5jb2xsZWN0QWN0aW9ucykoZS54cmVmLHQsci5Bbm5vdGF0aW9uQWN0aW9uRXZlbnRUeXBlKSk7bGV0IG89KDAsbi5nZXRJbmhlcml0YWJsZVByb3BlcnR5KSh7ZGljdDp0LGtleToiViIsZ2V0QXJyYXk6ITB9KTthLmZpZWxkVmFsdWU9dGhpcy5fZGVjb2RlRm9ybVZhbHVlKG8pO2NvbnN0IGM9KDAsbi5nZXRJbmhlcml0YWJsZVByb3BlcnR5KSh7ZGljdDp0LGtleToiRFYiLGdldEFycmF5OiEwfSk7YS5kZWZhdWx0RmllbGRWYWx1ZT10aGlzLl9kZWNvZGVGb3JtVmFsdWUoYyk7aWYodm9pZCAwPT09byYmZS54ZmFEYXRhc2V0cyl7Y29uc3QgdD10aGlzLl90aXRsZS5zdHI7aWYodCl7dGhpcy5faGFzVmFsdWVGcm9tWEZBPSEwO2EuZmllbGRWYWx1ZT1vPWUueGZhRGF0YXNldHMuZ2V0VmFsdWUodCl9fXZvaWQgMD09PW8mJm51bGwhPT1hLmRlZmF1bHRGaWVsZFZhbHVlJiYoYS5maWVsZFZhbHVlPWEuZGVmYXVsdEZpZWxkVmFsdWUpO2EuYWx0ZXJuYXRpdmVUZXh0PSgwLHIuc3RyaW5nVG9QREZTdHJpbmcpKHQuZ2V0KCJUVSIpfHwiIik7Y29uc3QgbD0oMCxuLmdldEluaGVyaXRhYmxlUHJvcGVydHkpKHtkaWN0OnQsa2V5OiJEQSJ9KXx8ZS5hY3JvRm9ybS5nZXQoIkRBIik7dGhpcy5fZGVmYXVsdEFwcGVhcmFuY2U9InN0cmluZyI9PXR5cGVvZiBsP2w6IiI7YS5kZWZhdWx0QXBwZWFyYW5jZURhdGE9KDAsaS5wYXJzZURlZmF1bHRBcHBlYXJhbmNlKSh0aGlzLl9kZWZhdWx0QXBwZWFyYW5jZSk7Y29uc3QgaD0oMCxuLmdldEluaGVyaXRhYmxlUHJvcGVydHkpKHtkaWN0OnQsa2V5OiJGVCJ9KTthLmZpZWxkVHlwZT1oIGluc3RhbmNlb2Ygcy5OYW1lP2gubmFtZTpudWxsO2NvbnN0IHU9KDAsbi5nZXRJbmhlcml0YWJsZVByb3BlcnR5KSh7ZGljdDp0LGtleToiRFIifSksZD1lLmFjcm9Gb3JtLmdldCgiRFIiKSxmPXRoaXMuYXBwZWFyYW5jZSYmdGhpcy5hcHBlYXJhbmNlLmRpY3QuZ2V0KCJSZXNvdXJjZXMiKTt0aGlzLl9maWVsZFJlc291cmNlcz17bG9jYWxSZXNvdXJjZXM6dSxhY3JvRm9ybVJlc291cmNlczpkLGFwcGVhcmFuY2VSZXNvdXJjZXM6ZixtZXJnZWRSZXNvdXJjZXM6cy5EaWN0Lm1lcmdlKHt4cmVmOmUueHJlZixkaWN0QXJyYXk6W3UsZixkXSxtZXJnZVN1YkRpY3RzOiEwfSl9O2EuZmllbGRGbGFncz0oMCxuLmdldEluaGVyaXRhYmxlUHJvcGVydHkpKHtkaWN0OnQsa2V5OiJGZiJ9KTsoIU51bWJlci5pc0ludGVnZXIoYS5maWVsZEZsYWdzKXx8YS5maWVsZEZsYWdzPDApJiYoYS5maWVsZEZsYWdzPTApO2EucmVhZE9ubHk9dGhpcy5oYXNGaWVsZEZsYWcoci5Bbm5vdGF0aW9uRmllbGRGbGFnLlJFQURPTkxZKTthLnJlcXVpcmVkPXRoaXMuaGFzRmllbGRGbGFnKHIuQW5ub3RhdGlvbkZpZWxkRmxhZy5SRVFVSVJFRCk7YS5oaWRkZW49dGhpcy5faGFzRmxhZyhhLmFubm90YXRpb25GbGFncyxyLkFubm90YXRpb25GbGFnLkhJRERFTil9X2RlY29kZUZvcm1WYWx1ZShlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKT9lLmZpbHRlcigoZT0+InN0cmluZyI9PXR5cGVvZiBlKSkubWFwKChlPT4oMCxyLnN0cmluZ1RvUERGU3RyaW5nKShlKSkpOmUgaW5zdGFuY2VvZiBzLk5hbWU/KDAsci5zdHJpbmdUb1BERlN0cmluZykoZS5uYW1lKToic3RyaW5nIj09dHlwZW9mIGU/KDAsci5zdHJpbmdUb1BERlN0cmluZykoZSk6bnVsbH1oYXNGaWVsZEZsYWcoZSl7cmV0dXJuISEodGhpcy5kYXRhLmZpZWxkRmxhZ3MmZSl9c3RhdGljIF9nZXRSb3RhdGlvbk1hdHJpeChlLHQsYSl7c3dpdGNoKGUpe2Nhc2UgOTA6cmV0dXJuWzAsMSwtMSwwLHQsMF07Y2FzZSAxODA6cmV0dXJuWy0xLDAsMCwtMSx0LGFdO2Nhc2UgMjcwOnJldHVyblswLC0xLDEsMCwwLGFdO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHJvdGF0aW9uIil9fWdldFJvdGF0aW9uTWF0cml4KGUpe2NvbnN0IHQ9ZT9lLmdldCh0aGlzLmRhdGEuaWQpOnZvaWQgMDtsZXQgYT10JiZ0LnJvdGF0aW9uO3ZvaWQgMD09PWEmJihhPXRoaXMucm90YXRpb24pO2lmKDA9PT1hKXJldHVybiByLklERU5USVRZX01BVFJJWDtjb25zdCBuPXRoaXMuZGF0YS5yZWN0WzJdLXRoaXMuZGF0YS5yZWN0WzBdLGk9dGhpcy5kYXRhLnJlY3RbM10tdGhpcy5kYXRhLnJlY3RbMV07cmV0dXJuIFdpZGdldEFubm90YXRpb24uX2dldFJvdGF0aW9uTWF0cml4KGEsbixpKX1nZXRCb3JkZXJBbmRCYWNrZ3JvdW5kQXBwZWFyYW5jZXMoZSl7Y29uc3QgdD1lP2UuZ2V0KHRoaXMuZGF0YS5pZCk6dm9pZCAwO2xldCBhPXQmJnQucm90YXRpb247dm9pZCAwPT09YSYmKGE9dGhpcy5yb3RhdGlvbik7aWYoIXRoaXMuYmFja2dyb3VuZENvbG9yJiYhdGhpcy5ib3JkZXJDb2xvcilyZXR1cm4iIjtjb25zdCByPXRoaXMuZGF0YS5yZWN0WzJdLXRoaXMuZGF0YS5yZWN0WzBdLG49dGhpcy5kYXRhLnJlY3RbM10tdGhpcy5kYXRhLnJlY3RbMV0scz0wPT09YXx8MTgwPT09YT9gMCAwICR7cn0gJHtufSByZWA6YDAgMCAke259ICR7cn0gcmVgO2xldCBvPSIiO3RoaXMuYmFja2dyb3VuZENvbG9yJiYobz1gJHsoMCxpLmdldFBkZkNvbG9yKSh0aGlzLmJhY2tncm91bmRDb2xvciwhMCl9ICR7c30gZiBgKTtpZih0aGlzLmJvcmRlckNvbG9yKXtvKz1gJHt0aGlzLmJvcmRlclN0eWxlLndpZHRofHwxfSB3ICR7KDAsaS5nZXRQZGZDb2xvcikodGhpcy5ib3JkZXJDb2xvciwhMSl9ICR7c30gUyBgfXJldHVybiBvfWFzeW5jIGdldE9wZXJhdG9yTGlzdChlLHQsYSxuLGkpe2lmKG4mJiEodGhpcyBpbnN0YW5jZW9mIFNpZ25hdHVyZVdpZGdldEFubm90YXRpb24pKXJldHVybntvcExpc3Q6bmV3IGcuT3BlcmF0b3JMaXN0LHNlcGFyYXRlRm9ybTohMCxzZXBhcmF0ZUNhbnZhczohMX07aWYoIXRoaXMuX2hhc1RleHQpcmV0dXJuIHN1cGVyLmdldE9wZXJhdG9yTGlzdChlLHQsYSxuLGkpO2NvbnN0IHM9YXdhaXQgdGhpcy5fZ2V0QXBwZWFyYW5jZShlLHQsaSk7aWYodGhpcy5hcHBlYXJhbmNlJiZudWxsPT09cylyZXR1cm4gc3VwZXIuZ2V0T3BlcmF0b3JMaXN0KGUsdCxhLG4saSk7Y29uc3Qgbz1uZXcgZy5PcGVyYXRvckxpc3Q7aWYoIXRoaXMuX2RlZmF1bHRBcHBlYXJhbmNlfHxudWxsPT09cylyZXR1cm57b3BMaXN0Om8sc2VwYXJhdGVGb3JtOiExLHNlcGFyYXRlQ2FudmFzOiExfTtjb25zdCBjPVswLDAsdGhpcy5kYXRhLnJlY3RbMl0tdGhpcy5kYXRhLnJlY3RbMF0sdGhpcy5kYXRhLnJlY3RbM10tdGhpcy5kYXRhLnJlY3RbMV1dLGw9Z2V0VHJhbnNmb3JtTWF0cml4KHRoaXMuZGF0YS5yZWN0LGMsWzEsMCwwLDEsMCwwXSk7bGV0IGg7dGhpcy5vYyYmKGg9YXdhaXQgZS5wYXJzZU1hcmtlZENvbnRlbnRQcm9wcyh0aGlzLm9jLG51bGwpKTt2b2lkIDAhPT1oJiZvLmFkZE9wKHIuT1BTLmJlZ2luTWFya2VkQ29udGVudFByb3BzLFsiT0MiLGhdKTtvLmFkZE9wKHIuT1BTLmJlZ2luQW5ub3RhdGlvbixbdGhpcy5kYXRhLmlkLHRoaXMuZGF0YS5yZWN0LGwsdGhpcy5nZXRSb3RhdGlvbk1hdHJpeChpKSwhMV0pO2NvbnN0IHU9bmV3IHAuU3RyaW5nU3RyZWFtKHMpO2F3YWl0IGUuZ2V0T3BlcmF0b3JMaXN0KHtzdHJlYW06dSx0YXNrOnQscmVzb3VyY2VzOnRoaXMuX2ZpZWxkUmVzb3VyY2VzLm1lcmdlZFJlc291cmNlcyxvcGVyYXRvckxpc3Q6b30pO28uYWRkT3Aoci5PUFMuZW5kQW5ub3RhdGlvbixbXSk7dm9pZCAwIT09aCYmby5hZGRPcChyLk9QUy5lbmRNYXJrZWRDb250ZW50LFtdKTtyZXR1cm57b3BMaXN0Om8sc2VwYXJhdGVGb3JtOiExLHNlcGFyYXRlQ2FudmFzOiExfX1fZ2V0TUtEaWN0KGUpe2NvbnN0IHQ9bmV3IHMuRGljdChudWxsKTtlJiZ0LnNldCgiUiIsZSk7dGhpcy5ib3JkZXJDb2xvciYmdC5zZXQoIkJDIixBcnJheS5mcm9tKHRoaXMuYm9yZGVyQ29sb3IpLm1hcCgoZT0+ZS8yNTUpKSk7dGhpcy5iYWNrZ3JvdW5kQ29sb3ImJnQuc2V0KCJCRyIsQXJyYXkuZnJvbSh0aGlzLmJhY2tncm91bmRDb2xvcikubWFwKChlPT5lLzI1NSkpKTtyZXR1cm4gdC5zaXplPjA/dDpudWxsfWFzeW5jIHNhdmUoZSx0LGEpe2NvbnN0IG49YT9hLmdldCh0aGlzLmRhdGEuaWQpOnZvaWQgMDtsZXQgaT1uJiZuLnZhbHVlLGM9biYmbi5yb3RhdGlvbjtpZihpPT09dGhpcy5kYXRhLmZpZWxkVmFsdWV8fHZvaWQgMD09PWkpe2lmKCF0aGlzLl9oYXNWYWx1ZUZyb21YRkEmJnZvaWQgMD09PWMpcmV0dXJuIG51bGw7aT1pfHx0aGlzLmRhdGEuZmllbGRWYWx1ZX1pZih2b2lkIDA9PT1jJiYhdGhpcy5faGFzVmFsdWVGcm9tWEZBJiZBcnJheS5pc0FycmF5KGkpJiZBcnJheS5pc0FycmF5KHRoaXMuZGF0YS5maWVsZFZhbHVlKSYmaS5sZW5ndGg9PT10aGlzLmRhdGEuZmllbGRWYWx1ZS5sZW5ndGgmJmkuZXZlcnkoKChlLHQpPT5lPT09dGhpcy5kYXRhLmZpZWxkVmFsdWVbdF0pKSlyZXR1cm4gbnVsbDt2b2lkIDA9PT1jJiYoYz10aGlzLnJvdGF0aW9uKTtsZXQgbD1hd2FpdCB0aGlzLl9nZXRBcHBlYXJhbmNlKGUsdCxhKTtpZihudWxsPT09bClyZXR1cm4gbnVsbDtjb25zdHt4cmVmOmh9PWUsdT1oLmZldGNoSWZSZWYodGhpcy5yZWYpO2lmKCEodSBpbnN0YW5jZW9mIHMuRGljdCkpcmV0dXJuIG51bGw7Y29uc3QgZD1bMCwwLHRoaXMuZGF0YS5yZWN0WzJdLXRoaXMuZGF0YS5yZWN0WzBdLHRoaXMuZGF0YS5yZWN0WzNdLXRoaXMuZGF0YS5yZWN0WzFdXSxmPXtwYXRoOigwLHIuc3RyaW5nVG9QREZTdHJpbmcpKHUuZ2V0KCJUIil8fCIiKSx2YWx1ZTppfSxnPWguZ2V0TmV3UmVmKCkscD1uZXcgcy5EaWN0KGgpO3Auc2V0KCJOIixnKTtjb25zdCBtPWguZW5jcnlwdDtsZXQgYj1udWxsLHk9bnVsbDtpZihtKXtiPW0uY3JlYXRlQ2lwaGVyVHJhbnNmb3JtKHRoaXMucmVmLm51bSx0aGlzLnJlZi5nZW4pO3k9bS5jcmVhdGVDaXBoZXJUcmFuc2Zvcm0oZy5udW0sZy5nZW4pO2w9eS5lbmNyeXB0U3RyaW5nKGwpfWNvbnN0IGVuY29kZXI9ZT0+KDAsci5pc0FzY2lpKShlKT9lOigwLHIuc3RyaW5nVG9VVEYxNkJFU3RyaW5nKShlKTt1LnNldCgiViIsQXJyYXkuaXNBcnJheShpKT9pLm1hcChlbmNvZGVyKTplbmNvZGVyKGkpKTt1LnNldCgiQVAiLHApO3Uuc2V0KCJNIixgRDokeygwLHIuZ2V0TW9kaWZpY2F0aW9uRGF0ZSkoKX1gKTtjb25zdCB3PXRoaXMuX2dldE1LRGljdChjKTt3JiZ1LnNldCgiTUsiLHcpO2NvbnN0IFM9bmV3IHMuRGljdChoKTtTLnNldCgiTGVuZ3RoIixsLmxlbmd0aCk7Uy5zZXQoIlN1YnR5cGUiLHMuTmFtZS5nZXQoIkZvcm0iKSk7Uy5zZXQoIlJlc291cmNlcyIsdGhpcy5fZ2V0U2F2ZUZpZWxkUmVzb3VyY2VzKGgpKTtTLnNldCgiQkJveCIsZCk7Y29uc3QgeD10aGlzLmdldFJvdGF0aW9uTWF0cml4KGEpO3ghPT1yLklERU5USVRZX01BVFJJWCYmUy5zZXQoIk1hdHJpeCIseCk7Y29uc3Qgaz1bYCR7dGhpcy5yZWYubnVtfSAke3RoaXMucmVmLmdlbn0gb2JqXG5gXTsoMCxvLndyaXRlRGljdCkodSxrLGIpO2sucHVzaCgiXG5lbmRvYmpcbiIpO2NvbnN0IEM9W2Ake2cubnVtfSAke2cuZ2VufSBvYmpcbmBdOygwLG8ud3JpdGVEaWN0KShTLEMseSk7Qy5wdXNoKCIgc3RyZWFtXG4iLGwsIlxuZW5kc3RyZWFtXG5lbmRvYmpcbiIpO3JldHVyblt7cmVmOnRoaXMucmVmLGRhdGE6ay5qb2luKCIiKSx4ZmE6Zn0se3JlZjpnLGRhdGE6Qy5qb2luKCIiKSx4ZmE6bnVsbH1dfWFzeW5jIF9nZXRBcHBlYXJhbmNlKGUsdCxhKXtpZih0aGlzLmhhc0ZpZWxkRmxhZyhyLkFubm90YXRpb25GaWVsZEZsYWcuUEFTU1dPUkQpKXJldHVybiBudWxsO2NvbnN0IG49YT9hLmdldCh0aGlzLmRhdGEuaWQpOnZvaWQgMDtsZXQgcyxvO2lmKG4pe3M9bi5mb3JtYXR0ZWRWYWx1ZXx8bi52YWx1ZTtvPW4ucm90YXRpb259aWYodm9pZCAwPT09byYmdm9pZCAwPT09cyYmKCF0aGlzLl9oYXNWYWx1ZUZyb21YRkF8fHRoaXMuYXBwZWFyYW5jZSkpcmV0dXJuIG51bGw7aWYodm9pZCAwPT09cyl7cz10aGlzLmRhdGEuZmllbGRWYWx1ZTtpZighcylyZXR1cm4iIn1BcnJheS5pc0FycmF5KHMpJiYxPT09cy5sZW5ndGgmJihzPXNbMF0pOygwLHIuYXNzZXJ0KSgic3RyaW5nIj09dHlwZW9mIHMsIkV4cGVjdGVkIGB2YWx1ZWAgdG8gYmUgYSBzdHJpbmcuIik7cz1zLnRyaW0oKTtpZigiIj09PXMpcmV0dXJuIiI7dm9pZCAwPT09byYmKG89dGhpcy5yb3RhdGlvbik7bGV0IGM9LTE7dGhpcy5kYXRhLm11bHRpTGluZSYmKGM9cy5zcGxpdCgvXHJcbnxccnxcbi8pLmxlbmd0aCk7bGV0IGw9dGhpcy5kYXRhLnJlY3RbM10tdGhpcy5kYXRhLnJlY3RbMV0saD10aGlzLmRhdGEucmVjdFsyXS10aGlzLmRhdGEucmVjdFswXTs5MCE9PW8mJjI3MCE9PW98fChbaCxsXT1bbCxoXSk7dGhpcy5fZGVmYXVsdEFwcGVhcmFuY2V8fCh0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhPSgwLGkucGFyc2VEZWZhdWx0QXBwZWFyYW5jZSkodGhpcy5fZGVmYXVsdEFwcGVhcmFuY2U9Ii9IZWx2ZXRpY2EgMCBUZiAwIGciKSk7Y29uc3QgdT1hd2FpdCBXaWRnZXRBbm5vdGF0aW9uLl9nZXRGb250RGF0YShlLHQsdGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YSx0aGlzLl9maWVsZFJlc291cmNlcy5tZXJnZWRSZXNvdXJjZXMpLFtkLGZdPXRoaXMuX2NvbXB1dGVGb250U2l6ZShsLTIsaC00LHMsdSxjKTtsZXQgZz11LmRlc2NlbnQ7aXNOYU4oZykmJihnPTApO2NvbnN0IHA9TWF0aC5taW4oTWF0aC5mbG9vcigobC1mKS8yKSwyKStNYXRoLmFicyhnKSpmLG09dGhpcy5kYXRhLnRleHRBbGlnbm1lbnQ7aWYodGhpcy5kYXRhLm11bHRpTGluZSlyZXR1cm4gdGhpcy5fZ2V0TXVsdGlsaW5lQXBwZWFyYW5jZShkLHMsdSxmLGgsbCxtLDIscCxhKTtjb25zdCBiPXUuZW5jb2RlU3RyaW5nKHMpLmpvaW4oIiIpO2lmKHRoaXMuZGF0YS5jb21iKXJldHVybiB0aGlzLl9nZXRDb21iQXBwZWFyYW5jZShkLHUsYixoLDIscCxhKTtjb25zdCB5PXRoaXMuZ2V0Qm9yZGVyQW5kQmFja2dyb3VuZEFwcGVhcmFuY2VzKGEpO2lmKDA9PT1tfHxtPjIpcmV0dXJuYC9UeCBCTUMgcSAke3l9QlQgYCtkK2AgMSAwIDAgMSAyICR7cH0gVG0gKCR7KDAsci5lc2NhcGVTdHJpbmcpKGIpfSkgVGogRVQgUSBFTUNgO3JldHVybmAvVHggQk1DIHEgJHt5fUJUIGArZCtgIDEgMCAwIDEgMCAwIFRtICR7dGhpcy5fcmVuZGVyVGV4dChiLHUsZixoLG0sMixwKX0gRVQgUSBFTUNgfXN0YXRpYyBhc3luYyBfZ2V0Rm9udERhdGEoZSx0LGEscil7Y29uc3Qgbj1uZXcgZy5PcGVyYXRvckxpc3QsaT17Zm9udDpudWxsLGNsb25lKCl7cmV0dXJuIHRoaXN9fSx7Zm9udE5hbWU6byxmb250U2l6ZTpjfT1hO2F3YWl0IGUuaGFuZGxlU2V0Rm9udChyLFtvJiZzLk5hbWUuZ2V0KG8pLGNdLG51bGwsbix0LGksbnVsbCk7cmV0dXJuIGkuZm9udH1fZ2V0VGV4dFdpZHRoKGUsdCl7cmV0dXJuIHQuY2hhcnNUb0dseXBocyhlKS5yZWR1Y2UoKChlLHQpPT5lK3Qud2lkdGgpLDApLzFlM31fY29tcHV0ZUZvbnRTaXplKGUsdCxhLG4scyl7bGV0e2ZvbnRTaXplOm99PXRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGE7aWYoIW8pe2NvbnN0IHJvdW5kV2l0aFR3b0RpZ2l0cz1lPT5NYXRoLmZsb29yKDEwMCplKS8xMDA7aWYoLTE9PT1zKXtjb25zdCBpPXRoaXMuX2dldFRleHRXaWR0aChhLG4pO289cm91bmRXaXRoVHdvRGlnaXRzKE1hdGgubWluKGUvci5MSU5FX0ZBQ1RPUix0L2kpKX1lbHNle2NvbnN0IGk9YS5zcGxpdCgvXHJcbj98XG4vKSxjPVtdO2Zvcihjb25zdCBlIG9mIGkpe2NvbnN0IHQ9bi5lbmNvZGVTdHJpbmcoZSkuam9pbigiIiksYT1uLmNoYXJzVG9HbHlwaHModCkscj1uLmdldENoYXJQb3NpdGlvbnModCk7Yy5wdXNoKHtsaW5lOnQsZ2x5cGhzOmEscG9zaXRpb25zOnJ9KX1jb25zdCBpc1Rvb0JpZz1hPT57bGV0IHI9MDtmb3IoY29uc3QgaSBvZiBjKXtyKz10aGlzLl9zcGxpdExpbmUobnVsbCxuLGEsdCxpKS5sZW5ndGgqYTtpZihyPmUpcmV0dXJuITB9cmV0dXJuITF9O289MTI7bGV0IGw9bypyLkxJTkVfRkFDVE9SLGg9TWF0aC5yb3VuZChlL2wpO2g9TWF0aC5tYXgoaCxzKTtmb3IoOzspe2w9ZS9oO289cm91bmRXaXRoVHdvRGlnaXRzKGwvci5MSU5FX0ZBQ1RPUik7aWYoIWlzVG9vQmlnKG8pKWJyZWFrO2grK319Y29uc3R7Zm9udE5hbWU6Yyxmb250Q29sb3I6bH09dGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YTt0aGlzLl9kZWZhdWx0QXBwZWFyYW5jZT0oMCxpLmNyZWF0ZURlZmF1bHRBcHBlYXJhbmNlKSh7Zm9udFNpemU6byxmb250TmFtZTpjLGZvbnRDb2xvcjpsfSl9cmV0dXJuW3RoaXMuX2RlZmF1bHRBcHBlYXJhbmNlLG9dfV9yZW5kZXJUZXh0KGUsdCxhLGkscyxvLGMpe2xldCBsO2lmKDE9PT1zKXtsPShpLXRoaXMuX2dldFRleHRXaWR0aChlLHQpKmEpLzJ9ZWxzZSBpZigyPT09cyl7bD1pLXRoaXMuX2dldFRleHRXaWR0aChlLHQpKmEtb31lbHNlIGw9bztsPSgwLG4ubnVtYmVyVG9TdHJpbmcpKGwpO3JldHVybmAke2x9ICR7Yz0oMCxuLm51bWJlclRvU3RyaW5nKShjKX0gVGQgKCR7KDAsci5lc2NhcGVTdHJpbmcpKGUpfSkgVGpgfV9nZXRTYXZlRmllbGRSZXNvdXJjZXMoZSl7Y29uc3R7bG9jYWxSZXNvdXJjZXM6dCxhcHBlYXJhbmNlUmVzb3VyY2VzOmEsYWNyb0Zvcm1SZXNvdXJjZXM6cn09dGhpcy5fZmllbGRSZXNvdXJjZXMsbj10aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhJiZ0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhLmZvbnROYW1lO2lmKCFuKXJldHVybiB0fHxzLkRpY3QuZW1wdHk7Zm9yKGNvbnN0IGUgb2ZbdCxhXSlpZihlIGluc3RhbmNlb2Ygcy5EaWN0KXtjb25zdCB0PWUuZ2V0KCJGb250Iik7aWYodCBpbnN0YW5jZW9mIHMuRGljdCYmdC5oYXMobikpcmV0dXJuIGV9aWYociBpbnN0YW5jZW9mIHMuRGljdCl7Y29uc3QgYT1yLmdldCgiRm9udCIpO2lmKGEgaW5zdGFuY2VvZiBzLkRpY3QmJmEuaGFzKG4pKXtjb25zdCByPW5ldyBzLkRpY3QoZSk7ci5zZXQobixhLmdldFJhdyhuKSk7Y29uc3QgaT1uZXcgcy5EaWN0KGUpO2kuc2V0KCJGb250IixyKTtyZXR1cm4gcy5EaWN0Lm1lcmdlKHt4cmVmOmUsZGljdEFycmF5OltpLHRdLG1lcmdlU3ViRGljdHM6ITB9KX19cmV0dXJuIHR8fHMuRGljdC5lbXB0eX1nZXRGaWVsZE9iamVjdCgpe3JldHVybiBudWxsfX1jbGFzcyBUZXh0V2lkZ2V0QW5ub3RhdGlvbiBleHRlbmRzIFdpZGdldEFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7dGhpcy5faGFzVGV4dD0hMDtjb25zdCB0PWUuZGljdDsic3RyaW5nIiE9dHlwZW9mIHRoaXMuZGF0YS5maWVsZFZhbHVlJiYodGhpcy5kYXRhLmZpZWxkVmFsdWU9IiIpO2xldCBhPSgwLG4uZ2V0SW5oZXJpdGFibGVQcm9wZXJ0eSkoe2RpY3Q6dCxrZXk6IlEifSk7KCFOdW1iZXIuaXNJbnRlZ2VyKGEpfHxhPDB8fGE+MikmJihhPW51bGwpO3RoaXMuZGF0YS50ZXh0QWxpZ25tZW50PWE7bGV0IGk9KDAsbi5nZXRJbmhlcml0YWJsZVByb3BlcnR5KSh7ZGljdDp0LGtleToiTWF4TGVuIn0pOyghTnVtYmVyLmlzSW50ZWdlcihpKXx8aTwwKSYmKGk9MCk7dGhpcy5kYXRhLm1heExlbj1pO3RoaXMuZGF0YS5tdWx0aUxpbmU9dGhpcy5oYXNGaWVsZEZsYWcoci5Bbm5vdGF0aW9uRmllbGRGbGFnLk1VTFRJTElORSk7dGhpcy5kYXRhLmNvbWI9dGhpcy5oYXNGaWVsZEZsYWcoci5Bbm5vdGF0aW9uRmllbGRGbGFnLkNPTUIpJiYhdGhpcy5oYXNGaWVsZEZsYWcoci5Bbm5vdGF0aW9uRmllbGRGbGFnLk1VTFRJTElORSkmJiF0aGlzLmhhc0ZpZWxkRmxhZyhyLkFubm90YXRpb25GaWVsZEZsYWcuUEFTU1dPUkQpJiYhdGhpcy5oYXNGaWVsZEZsYWcoci5Bbm5vdGF0aW9uRmllbGRGbGFnLkZJTEVTRUxFQ1QpJiYwIT09dGhpcy5kYXRhLm1heExlbjt0aGlzLmRhdGEuZG9Ob3RTY3JvbGw9dGhpcy5oYXNGaWVsZEZsYWcoci5Bbm5vdGF0aW9uRmllbGRGbGFnLkRPTk9UU0NST0xMKX1fZ2V0Q29tYkFwcGVhcmFuY2UoZSx0LGEsaSxzLG8sYyl7Y29uc3QgbD0oMCxuLm51bWJlclRvU3RyaW5nKShpL3RoaXMuZGF0YS5tYXhMZW4pLGg9W10sdT10LmdldENoYXJQb3NpdGlvbnMoYSk7Zm9yKGNvbnN0W2UsdF1vZiB1KWgucHVzaChgKCR7KDAsci5lc2NhcGVTdHJpbmcpKGEuc3Vic3RyaW5nKGUsdCkpfSkgVGpgKTtyZXR1cm5gL1R4IEJNQyBxICR7dGhpcy5nZXRCb3JkZXJBbmRCYWNrZ3JvdW5kQXBwZWFyYW5jZXMoYyl9QlQgYCtlK2AgMSAwIDAgMSAke3N9ICR7b30gVG0gJHtoLmpvaW4oYCAke2x9IDAgVGQgYCl9IEVUIFEgRU1DYH1fZ2V0TXVsdGlsaW5lQXBwZWFyYW5jZShlLHQsYSxyLG4saSxzLG8sYyxsKXtjb25zdCBoPXQuc3BsaXQoL1xyXG4/fFxuLyksdT1bXSxkPW4tMipvO2Zvcihjb25zdCBlIG9mIGgpe2NvbnN0IHQ9dGhpcy5fc3BsaXRMaW5lKGUsYSxyLGQpO2Zvcihjb25zdCBlIG9mIHQpe2NvbnN0IHQ9MD09PXUubGVuZ3RoP286MDt1LnB1c2godGhpcy5fcmVuZGVyVGV4dChlLGEscixuLHMsdCwtcikpfX1jb25zdCBmPXUuam9pbigiXG4iKTtyZXR1cm5gL1R4IEJNQyBxICR7dGhpcy5nZXRCb3JkZXJBbmRCYWNrZ3JvdW5kQXBwZWFyYW5jZXMobCl9QlQgYCtlK2AgMSAwIDAgMSAwICR7aX0gVG0gJHtmfSBFVCBRIEVNQ2B9X3NwbGl0TGluZShlLHQsYSxyLG49e30pe2U9bi5saW5lfHx0LmVuY29kZVN0cmluZyhlKS5qb2luKCIiKTtjb25zdCBpPW4uZ2x5cGhzfHx0LmNoYXJzVG9HbHlwaHMoZSk7aWYoaS5sZW5ndGg8PTEpcmV0dXJuW2VdO2NvbnN0IHM9bi5wb3NpdGlvbnN8fHQuZ2V0Q2hhclBvc2l0aW9ucyhlKSxvPWEvMWUzLGM9W107bGV0IGw9LTEsaD0tMSx1PS0xLGQ9MCxmPTA7Zm9yKGxldCB0PTAsYT1pLmxlbmd0aDt0PGE7dCsrKXtjb25zdFthLG5dPXNbdF0sZz1pW3RdLHA9Zy53aWR0aCpvO2lmKCIgIj09PWcudW5pY29kZSlpZihmK3A+cil7Yy5wdXNoKGUuc3Vic3RyaW5nKGQsYSkpO2Q9YTtmPXA7bD0tMTt1PS0xfWVsc2V7Zis9cDtsPWE7aD1uO3U9dH1lbHNlIGlmKGYrcD5yKWlmKC0xIT09bCl7Yy5wdXNoKGUuc3Vic3RyaW5nKGQsaCkpO2Q9aDt0PXUrMTtsPS0xO2Y9MH1lbHNle2MucHVzaChlLnN1YnN0cmluZyhkLGEpKTtkPWE7Zj1wfWVsc2UgZis9cH1kPGUubGVuZ3RoJiZjLnB1c2goZS5zdWJzdHJpbmcoZCxlLmxlbmd0aCkpO3JldHVybiBjfWdldEZpZWxkT2JqZWN0KCl7cmV0dXJue2lkOnRoaXMuZGF0YS5pZCx2YWx1ZTp0aGlzLmRhdGEuZmllbGRWYWx1ZSxkZWZhdWx0VmFsdWU6dGhpcy5kYXRhLmRlZmF1bHRGaWVsZFZhbHVlfHwiIixtdWx0aWxpbmU6dGhpcy5kYXRhLm11bHRpTGluZSxwYXNzd29yZDp0aGlzLmhhc0ZpZWxkRmxhZyhyLkFubm90YXRpb25GaWVsZEZsYWcuUEFTU1dPUkQpLGNoYXJMaW1pdDp0aGlzLmRhdGEubWF4TGVuLGNvbWI6dGhpcy5kYXRhLmNvbWIsZWRpdGFibGU6IXRoaXMuZGF0YS5yZWFkT25seSxoaWRkZW46dGhpcy5kYXRhLmhpZGRlbixuYW1lOnRoaXMuZGF0YS5maWVsZE5hbWUscmVjdDp0aGlzLmRhdGEucmVjdCxhY3Rpb25zOnRoaXMuZGF0YS5hY3Rpb25zLHBhZ2U6dGhpcy5kYXRhLnBhZ2VJbmRleCxzdHJva2VDb2xvcjp0aGlzLmRhdGEuYm9yZGVyQ29sb3IsZmlsbENvbG9yOnRoaXMuZGF0YS5iYWNrZ3JvdW5kQ29sb3Iscm90YXRpb246dGhpcy5yb3RhdGlvbix0eXBlOiJ0ZXh0In19fWNsYXNzIEJ1dHRvbldpZGdldEFubm90YXRpb24gZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO3RoaXMuY2hlY2tlZEFwcGVhcmFuY2U9bnVsbDt0aGlzLnVuY2hlY2tlZEFwcGVhcmFuY2U9bnVsbDt0aGlzLmRhdGEuY2hlY2tCb3g9IXRoaXMuaGFzRmllbGRGbGFnKHIuQW5ub3RhdGlvbkZpZWxkRmxhZy5SQURJTykmJiF0aGlzLmhhc0ZpZWxkRmxhZyhyLkFubm90YXRpb25GaWVsZEZsYWcuUFVTSEJVVFRPTik7dGhpcy5kYXRhLnJhZGlvQnV0dG9uPXRoaXMuaGFzRmllbGRGbGFnKHIuQW5ub3RhdGlvbkZpZWxkRmxhZy5SQURJTykmJiF0aGlzLmhhc0ZpZWxkRmxhZyhyLkFubm90YXRpb25GaWVsZEZsYWcuUFVTSEJVVFRPTik7dGhpcy5kYXRhLnB1c2hCdXR0b249dGhpcy5oYXNGaWVsZEZsYWcoci5Bbm5vdGF0aW9uRmllbGRGbGFnLlBVU0hCVVRUT04pO3RoaXMuZGF0YS5pc1Rvb2x0aXBPbmx5PSExO2lmKHRoaXMuZGF0YS5jaGVja0JveCl0aGlzLl9wcm9jZXNzQ2hlY2tCb3goZSk7ZWxzZSBpZih0aGlzLmRhdGEucmFkaW9CdXR0b24pdGhpcy5fcHJvY2Vzc1JhZGlvQnV0dG9uKGUpO2Vsc2UgaWYodGhpcy5kYXRhLnB1c2hCdXR0b24pe3RoaXMuZGF0YS5oYXNPd25DYW52YXM9ITA7dGhpcy5fcHJvY2Vzc1B1c2hCdXR0b24oZSl9ZWxzZSgwLHIud2FybikoIkludmFsaWQgZmllbGQgZmxhZ3MgZm9yIGJ1dHRvbiB3aWRnZXQgYW5ub3RhdGlvbiIpfWFzeW5jIGdldE9wZXJhdG9yTGlzdChlLHQsYSxuLGkpe2lmKHRoaXMuZGF0YS5wdXNoQnV0dG9uKXJldHVybiBzdXBlci5nZXRPcGVyYXRvckxpc3QoZSx0LGEsITEsaSk7bGV0IHM9bnVsbCxvPW51bGw7aWYoaSl7Y29uc3QgZT1pLmdldCh0aGlzLmRhdGEuaWQpO3M9ZT9lLnZhbHVlOm51bGw7bz1lP2Uucm90YXRpb246bnVsbH1pZihudWxsPT09cyYmdGhpcy5hcHBlYXJhbmNlKXJldHVybiBzdXBlci5nZXRPcGVyYXRvckxpc3QoZSx0LGEsbixpKTtudWxsPT1zJiYocz10aGlzLmRhdGEuY2hlY2tCb3g/dGhpcy5kYXRhLmZpZWxkVmFsdWU9PT10aGlzLmRhdGEuZXhwb3J0VmFsdWU6dGhpcy5kYXRhLmZpZWxkVmFsdWU9PT10aGlzLmRhdGEuYnV0dG9uVmFsdWUpO2NvbnN0IGM9cz90aGlzLmNoZWNrZWRBcHBlYXJhbmNlOnRoaXMudW5jaGVja2VkQXBwZWFyYW5jZTtpZihjKXtjb25zdCBzPXRoaXMuYXBwZWFyYW5jZSxsPWMuZGljdC5nZXRBcnJheSgiTWF0cml4Iil8fHIuSURFTlRJVFlfTUFUUklYO28mJmMuZGljdC5zZXQoIk1hdHJpeCIsdGhpcy5nZXRSb3RhdGlvbk1hdHJpeChpKSk7dGhpcy5hcHBlYXJhbmNlPWM7Y29uc3QgaD1zdXBlci5nZXRPcGVyYXRvckxpc3QoZSx0LGEsbixpKTt0aGlzLmFwcGVhcmFuY2U9cztjLmRpY3Quc2V0KCJNYXRyaXgiLGwpO3JldHVybiBofXJldHVybntvcExpc3Q6bmV3IGcuT3BlcmF0b3JMaXN0LHNlcGFyYXRlRm9ybTohMSxzZXBhcmF0ZUNhbnZhczohMX19YXN5bmMgc2F2ZShlLHQsYSl7cmV0dXJuIHRoaXMuZGF0YS5jaGVja0JveD90aGlzLl9zYXZlQ2hlY2tib3goZSx0LGEpOnRoaXMuZGF0YS5yYWRpb0J1dHRvbj90aGlzLl9zYXZlUmFkaW9CdXR0b24oZSx0LGEpOm51bGx9YXN5bmMgX3NhdmVDaGVja2JveChlLHQsYSl7aWYoIWEpcmV0dXJuIG51bGw7Y29uc3Qgbj1hLmdldCh0aGlzLmRhdGEuaWQpO2xldCBpPW4mJm4ucm90YXRpb24sYz1uJiZuLnZhbHVlO2lmKHZvaWQgMD09PWkpe2lmKHZvaWQgMD09PWMpcmV0dXJuIG51bGw7aWYodGhpcy5kYXRhLmZpZWxkVmFsdWU9PT10aGlzLmRhdGEuZXhwb3J0VmFsdWU9PT1jKXJldHVybiBudWxsfWNvbnN0IGw9ZS54cmVmLmZldGNoSWZSZWYodGhpcy5yZWYpO2lmKCEobCBpbnN0YW5jZW9mIHMuRGljdCkpcmV0dXJuIG51bGw7dm9pZCAwPT09aSYmKGk9dGhpcy5yb3RhdGlvbik7dm9pZCAwPT09YyYmKGM9dGhpcy5kYXRhLmZpZWxkVmFsdWU9PT10aGlzLmRhdGEuZXhwb3J0VmFsdWUpO2NvbnN0IGg9e3BhdGg6KDAsci5zdHJpbmdUb1BERlN0cmluZykobC5nZXQoIlQiKXx8IiIpLHZhbHVlOmM/dGhpcy5kYXRhLmV4cG9ydFZhbHVlOiIifSx1PXMuTmFtZS5nZXQoYz90aGlzLmRhdGEuZXhwb3J0VmFsdWU6Ik9mZiIpO2wuc2V0KCJWIix1KTtsLnNldCgiQVMiLHUpO2wuc2V0KCJNIixgRDokeygwLHIuZ2V0TW9kaWZpY2F0aW9uRGF0ZSkoKX1gKTtjb25zdCBkPXRoaXMuX2dldE1LRGljdChpKTtkJiZsLnNldCgiTUsiLGQpO2NvbnN0IGY9ZS54cmVmLmVuY3J5cHQ7bGV0IGc9bnVsbDtmJiYoZz1mLmNyZWF0ZUNpcGhlclRyYW5zZm9ybSh0aGlzLnJlZi5udW0sdGhpcy5yZWYuZ2VuKSk7Y29uc3QgcD1bYCR7dGhpcy5yZWYubnVtfSAke3RoaXMucmVmLmdlbn0gb2JqXG5gXTsoMCxvLndyaXRlRGljdCkobCxwLGcpO3AucHVzaCgiXG5lbmRvYmpcbiIpO3JldHVyblt7cmVmOnRoaXMucmVmLGRhdGE6cC5qb2luKCIiKSx4ZmE6aH1dfWFzeW5jIF9zYXZlUmFkaW9CdXR0b24oZSx0LGEpe2lmKCFhKXJldHVybiBudWxsO2NvbnN0IG49YS5nZXQodGhpcy5kYXRhLmlkKTtsZXQgaT1uJiZuLnJvdGF0aW9uLGM9biYmbi52YWx1ZTtpZih2b2lkIDA9PT1pKXtpZih2b2lkIDA9PT1jKXJldHVybiBudWxsO2lmKHRoaXMuZGF0YS5maWVsZFZhbHVlPT09dGhpcy5kYXRhLmJ1dHRvblZhbHVlPT09YylyZXR1cm4gbnVsbH1jb25zdCBsPWUueHJlZi5mZXRjaElmUmVmKHRoaXMucmVmKTtpZighKGwgaW5zdGFuY2VvZiBzLkRpY3QpKXJldHVybiBudWxsO3ZvaWQgMD09PWMmJihjPXRoaXMuZGF0YS5maWVsZFZhbHVlPT09dGhpcy5kYXRhLmJ1dHRvblZhbHVlKTt2b2lkIDA9PT1pJiYoaT10aGlzLnJvdGF0aW9uKTtjb25zdCBoPXtwYXRoOigwLHIuc3RyaW5nVG9QREZTdHJpbmcpKGwuZ2V0KCJUIil8fCIiKSx2YWx1ZTpjP3RoaXMuZGF0YS5idXR0b25WYWx1ZToiIn0sdT1zLk5hbWUuZ2V0KGM/dGhpcy5kYXRhLmJ1dHRvblZhbHVlOiJPZmYiKTtsZXQgZD1udWxsO2NvbnN0IGY9ZS54cmVmLmVuY3J5cHQ7aWYoYylpZih0aGlzLnBhcmVudCBpbnN0YW5jZW9mIHMuUmVmKXtjb25zdCB0PWUueHJlZi5mZXRjaCh0aGlzLnBhcmVudCk7bGV0IGE9bnVsbDtmJiYoYT1mLmNyZWF0ZUNpcGhlclRyYW5zZm9ybSh0aGlzLnBhcmVudC5udW0sdGhpcy5wYXJlbnQuZ2VuKSk7dC5zZXQoIlYiLHUpO2Q9W2Ake3RoaXMucGFyZW50Lm51bX0gJHt0aGlzLnBhcmVudC5nZW59IG9ialxuYF07KDAsby53cml0ZURpY3QpKHQsZCxhKTtkLnB1c2goIlxuZW5kb2JqXG4iKX1lbHNlIHRoaXMucGFyZW50IGluc3RhbmNlb2Ygcy5EaWN0JiZ0aGlzLnBhcmVudC5zZXQoIlYiLHUpO2wuc2V0KCJBUyIsdSk7bC5zZXQoIk0iLGBEOiR7KDAsci5nZXRNb2RpZmljYXRpb25EYXRlKSgpfWApO2NvbnN0IGc9dGhpcy5fZ2V0TUtEaWN0KGkpO2cmJmwuc2V0KCJNSyIsZyk7bGV0IHA9bnVsbDtmJiYocD1mLmNyZWF0ZUNpcGhlclRyYW5zZm9ybSh0aGlzLnJlZi5udW0sdGhpcy5yZWYuZ2VuKSk7Y29uc3QgbT1bYCR7dGhpcy5yZWYubnVtfSAke3RoaXMucmVmLmdlbn0gb2JqXG5gXTsoMCxvLndyaXRlRGljdCkobCxtLHApO20ucHVzaCgiXG5lbmRvYmpcbiIpO2NvbnN0IGI9W3tyZWY6dGhpcy5yZWYsZGF0YTptLmpvaW4oIiIpLHhmYTpofV07bnVsbCE9PWQmJmIucHVzaCh7cmVmOnRoaXMucGFyZW50LGRhdGE6ZC5qb2luKCIiKSx4ZmE6bnVsbH0pO3JldHVybiBifV9nZXREZWZhdWx0Q2hlY2tlZEFwcGVhcmFuY2UoZSx0KXtjb25zdCBhPXRoaXMuZGF0YS5yZWN0WzJdLXRoaXMuZGF0YS5yZWN0WzBdLGk9dGhpcy5kYXRhLnJlY3RbM10tdGhpcy5kYXRhLnJlY3RbMV0sbz1bMCwwLGEsaV0sYz0uOCpNYXRoLm1pbihhLGkpO2xldCBsLGg7aWYoImNoZWNrIj09PXQpe2w9e3dpZHRoOi43NTUqYyxoZWlnaHQ6LjcwNSpjfTtoPSIzIn1lbHNlIGlmKCJkaXNjIj09PXQpe2w9e3dpZHRoOi43OTEqYyxoZWlnaHQ6LjcwNSpjfTtoPSJsIn1lbHNlKDAsci51bnJlYWNoYWJsZSkoYF9nZXREZWZhdWx0Q2hlY2tlZEFwcGVhcmFuY2UgLSB1bnN1cHBvcnRlZCB0eXBlOiAke3R9YCk7Y29uc3QgdT1gcSBCVCAvUGRmSnNaYURiICR7Y30gVGYgMCBnICR7KDAsbi5udW1iZXJUb1N0cmluZykoKGEtbC53aWR0aCkvMil9ICR7KDAsbi5udW1iZXJUb1N0cmluZykoKGktbC5oZWlnaHQpLzIpfSBUZCAoJHtofSkgVGogRVQgUWAsZD1uZXcgcy5EaWN0KGUueHJlZik7ZC5zZXQoIkZvcm1UeXBlIiwxKTtkLnNldCgiU3VidHlwZSIscy5OYW1lLmdldCgiRm9ybSIpKTtkLnNldCgiVHlwZSIscy5OYW1lLmdldCgiWE9iamVjdCIpKTtkLnNldCgiQkJveCIsbyk7ZC5zZXQoIk1hdHJpeCIsWzEsMCwwLDEsMCwwXSk7ZC5zZXQoIkxlbmd0aCIsdS5sZW5ndGgpO2NvbnN0IGY9bmV3IHMuRGljdChlLnhyZWYpLGc9bmV3IHMuRGljdChlLnhyZWYpO2cuc2V0KCJQZGZKc1phRGIiLHRoaXMuZmFsbGJhY2tGb250RGljdCk7Zi5zZXQoIkZvbnQiLGcpO2Quc2V0KCJSZXNvdXJjZXMiLGYpO3RoaXMuY2hlY2tlZEFwcGVhcmFuY2U9bmV3IHAuU3RyaW5nU3RyZWFtKHUpO3RoaXMuY2hlY2tlZEFwcGVhcmFuY2UuZGljdD1kO3RoaXMuX3N0cmVhbXMucHVzaCh0aGlzLmNoZWNrZWRBcHBlYXJhbmNlKX1fcHJvY2Vzc0NoZWNrQm94KGUpe2NvbnN0IHQ9ZS5kaWN0LmdldCgiQVAiKTtpZighKHQgaW5zdGFuY2VvZiBzLkRpY3QpKXJldHVybjtjb25zdCBhPXQuZ2V0KCJOIik7aWYoIShhIGluc3RhbmNlb2Ygcy5EaWN0KSlyZXR1cm47Y29uc3Qgcj10aGlzLl9kZWNvZGVGb3JtVmFsdWUoZS5kaWN0LmdldCgiQVMiKSk7InN0cmluZyI9PXR5cGVvZiByJiYodGhpcy5kYXRhLmZpZWxkVmFsdWU9cik7Y29uc3Qgbj1udWxsIT09dGhpcy5kYXRhLmZpZWxkVmFsdWUmJiJPZmYiIT09dGhpcy5kYXRhLmZpZWxkVmFsdWU/dGhpcy5kYXRhLmZpZWxkVmFsdWU6IlllcyIsaT1hLmdldEtleXMoKTtpZigwPT09aS5sZW5ndGgpaS5wdXNoKCJPZmYiLG4pO2Vsc2UgaWYoMT09PWkubGVuZ3RoKSJPZmYiPT09aVswXT9pLnB1c2gobik6aS51bnNoaWZ0KCJPZmYiKTtlbHNlIGlmKGkuaW5jbHVkZXMobikpe2kubGVuZ3RoPTA7aS5wdXNoKCJPZmYiLG4pfWVsc2V7Y29uc3QgZT1pLmZpbmQoKGU9PiJPZmYiIT09ZSkpO2kubGVuZ3RoPTA7aS5wdXNoKCJPZmYiLGUpfWkuaW5jbHVkZXModGhpcy5kYXRhLmZpZWxkVmFsdWUpfHwodGhpcy5kYXRhLmZpZWxkVmFsdWU9Ik9mZiIpO3RoaXMuZGF0YS5leHBvcnRWYWx1ZT1pWzFdO3RoaXMuY2hlY2tlZEFwcGVhcmFuY2U9YS5nZXQodGhpcy5kYXRhLmV4cG9ydFZhbHVlKXx8bnVsbDt0aGlzLnVuY2hlY2tlZEFwcGVhcmFuY2U9YS5nZXQoIk9mZiIpfHxudWxsO3RoaXMuY2hlY2tlZEFwcGVhcmFuY2U/dGhpcy5fc3RyZWFtcy5wdXNoKHRoaXMuY2hlY2tlZEFwcGVhcmFuY2UpOnRoaXMuX2dldERlZmF1bHRDaGVja2VkQXBwZWFyYW5jZShlLCJjaGVjayIpO3RoaXMudW5jaGVja2VkQXBwZWFyYW5jZSYmdGhpcy5fc3RyZWFtcy5wdXNoKHRoaXMudW5jaGVja2VkQXBwZWFyYW5jZSk7dGhpcy5fZmFsbGJhY2tGb250RGljdD10aGlzLmZhbGxiYWNrRm9udERpY3R9X3Byb2Nlc3NSYWRpb0J1dHRvbihlKXt0aGlzLmRhdGEuZmllbGRWYWx1ZT10aGlzLmRhdGEuYnV0dG9uVmFsdWU9bnVsbDtjb25zdCB0PWUuZGljdC5nZXQoIlBhcmVudCIpO2lmKHQgaW5zdGFuY2VvZiBzLkRpY3Qpe3RoaXMucGFyZW50PWUuZGljdC5nZXRSYXcoIlBhcmVudCIpO2NvbnN0IGE9dC5nZXQoIlYiKTthIGluc3RhbmNlb2Ygcy5OYW1lJiYodGhpcy5kYXRhLmZpZWxkVmFsdWU9dGhpcy5fZGVjb2RlRm9ybVZhbHVlKGEpKX1jb25zdCBhPWUuZGljdC5nZXQoIkFQIik7aWYoIShhIGluc3RhbmNlb2Ygcy5EaWN0KSlyZXR1cm47Y29uc3Qgcj1hLmdldCgiTiIpO2lmKHIgaW5zdGFuY2VvZiBzLkRpY3Qpe2Zvcihjb25zdCBlIG9mIHIuZ2V0S2V5cygpKWlmKCJPZmYiIT09ZSl7dGhpcy5kYXRhLmJ1dHRvblZhbHVlPXRoaXMuX2RlY29kZUZvcm1WYWx1ZShlKTticmVha310aGlzLmNoZWNrZWRBcHBlYXJhbmNlPXIuZ2V0KHRoaXMuZGF0YS5idXR0b25WYWx1ZSl8fG51bGw7dGhpcy51bmNoZWNrZWRBcHBlYXJhbmNlPXIuZ2V0KCJPZmYiKXx8bnVsbDt0aGlzLmNoZWNrZWRBcHBlYXJhbmNlP3RoaXMuX3N0cmVhbXMucHVzaCh0aGlzLmNoZWNrZWRBcHBlYXJhbmNlKTp0aGlzLl9nZXREZWZhdWx0Q2hlY2tlZEFwcGVhcmFuY2UoZSwiZGlzYyIpO3RoaXMudW5jaGVja2VkQXBwZWFyYW5jZSYmdGhpcy5fc3RyZWFtcy5wdXNoKHRoaXMudW5jaGVja2VkQXBwZWFyYW5jZSk7dGhpcy5fZmFsbGJhY2tGb250RGljdD10aGlzLmZhbGxiYWNrRm9udERpY3R9fV9wcm9jZXNzUHVzaEJ1dHRvbihlKXtpZihlLmRpY3QuaGFzKCJBIil8fGUuZGljdC5oYXMoIkFBIil8fHRoaXMuZGF0YS5hbHRlcm5hdGl2ZVRleHQpe3RoaXMuZGF0YS5pc1Rvb2x0aXBPbmx5PSFlLmRpY3QuaGFzKCJBIikmJiFlLmRpY3QuaGFzKCJBQSIpO2guQ2F0YWxvZy5wYXJzZURlc3REaWN0aW9uYXJ5KHtkZXN0RGljdDplLmRpY3QscmVzdWx0T2JqOnRoaXMuZGF0YSxkb2NCYXNlVXJsOmUucGRmTWFuYWdlci5kb2NCYXNlVXJsfSl9ZWxzZSgwLHIud2FybikoIlB1c2ggYnV0dG9ucyB3aXRob3V0IGFjdGlvbiBkaWN0aW9uYXJpZXMgYXJlIG5vdCBzdXBwb3J0ZWQiKX1nZXRGaWVsZE9iamVjdCgpe2xldCBlLHQ9ImJ1dHRvbiI7aWYodGhpcy5kYXRhLmNoZWNrQm94KXt0PSJjaGVja2JveCI7ZT10aGlzLmRhdGEuZXhwb3J0VmFsdWV9ZWxzZSBpZih0aGlzLmRhdGEucmFkaW9CdXR0b24pe3Q9InJhZGlvYnV0dG9uIjtlPXRoaXMuZGF0YS5idXR0b25WYWx1ZX1yZXR1cm57aWQ6dGhpcy5kYXRhLmlkLHZhbHVlOnRoaXMuZGF0YS5maWVsZFZhbHVlfHwiT2ZmIixkZWZhdWx0VmFsdWU6dGhpcy5kYXRhLmRlZmF1bHRGaWVsZFZhbHVlLGV4cG9ydFZhbHVlczplLGVkaXRhYmxlOiF0aGlzLmRhdGEucmVhZE9ubHksbmFtZTp0aGlzLmRhdGEuZmllbGROYW1lLHJlY3Q6dGhpcy5kYXRhLnJlY3QsaGlkZGVuOnRoaXMuZGF0YS5oaWRkZW4sYWN0aW9uczp0aGlzLmRhdGEuYWN0aW9ucyxwYWdlOnRoaXMuZGF0YS5wYWdlSW5kZXgsc3Ryb2tlQ29sb3I6dGhpcy5kYXRhLmJvcmRlckNvbG9yLGZpbGxDb2xvcjp0aGlzLmRhdGEuYmFja2dyb3VuZENvbG9yLHJvdGF0aW9uOnRoaXMucm90YXRpb24sdHlwZTp0fX1nZXQgZmFsbGJhY2tGb250RGljdCgpe2NvbnN0IGU9bmV3IHMuRGljdDtlLnNldCgiQmFzZUZvbnQiLHMuTmFtZS5nZXQoIlphcGZEaW5nYmF0cyIpKTtlLnNldCgiVHlwZSIscy5OYW1lLmdldCgiRmFsbGJhY2tUeXBlIikpO2Uuc2V0KCJTdWJ0eXBlIixzLk5hbWUuZ2V0KCJGYWxsYmFja1R5cGUiKSk7ZS5zZXQoIkVuY29kaW5nIixzLk5hbWUuZ2V0KCJaYXBmRGluZ2JhdHNFbmNvZGluZyIpKTtyZXR1cm4oMCxyLnNoYWRvdykodGhpcywiZmFsbGJhY2tGb250RGljdCIsZSl9fWNsYXNzIENob2ljZVdpZGdldEFubm90YXRpb24gZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO3RoaXMuZGF0YS5vcHRpb25zPVtdO2NvbnN0IHQ9KDAsbi5nZXRJbmhlcml0YWJsZVByb3BlcnR5KSh7ZGljdDplLmRpY3Qsa2V5OiJPcHQifSk7aWYoQXJyYXkuaXNBcnJheSh0KSl7Y29uc3QgYT1lLnhyZWY7Zm9yKGxldCBlPTAscj10Lmxlbmd0aDtlPHI7ZSsrKXtjb25zdCByPWEuZmV0Y2hJZlJlZih0W2VdKSxuPUFycmF5LmlzQXJyYXkocik7dGhpcy5kYXRhLm9wdGlvbnNbZV09e2V4cG9ydFZhbHVlOnRoaXMuX2RlY29kZUZvcm1WYWx1ZShuP2EuZmV0Y2hJZlJlZihyWzBdKTpyKSxkaXNwbGF5VmFsdWU6dGhpcy5fZGVjb2RlRm9ybVZhbHVlKG4/YS5mZXRjaElmUmVmKHJbMV0pOnIpfX19InN0cmluZyI9PXR5cGVvZiB0aGlzLmRhdGEuZmllbGRWYWx1ZT90aGlzLmRhdGEuZmllbGRWYWx1ZT1bdGhpcy5kYXRhLmZpZWxkVmFsdWVdOnRoaXMuZGF0YS5maWVsZFZhbHVlfHwodGhpcy5kYXRhLmZpZWxkVmFsdWU9W10pO3RoaXMuZGF0YS5jb21ibz10aGlzLmhhc0ZpZWxkRmxhZyhyLkFubm90YXRpb25GaWVsZEZsYWcuQ09NQk8pO3RoaXMuZGF0YS5tdWx0aVNlbGVjdD10aGlzLmhhc0ZpZWxkRmxhZyhyLkFubm90YXRpb25GaWVsZEZsYWcuTVVMVElTRUxFQ1QpO3RoaXMuX2hhc1RleHQ9ITB9Z2V0RmllbGRPYmplY3QoKXtjb25zdCBlPXRoaXMuZGF0YS5jb21ibz8iY29tYm9ib3giOiJsaXN0Ym94Iix0PXRoaXMuZGF0YS5maWVsZFZhbHVlLmxlbmd0aD4wP3RoaXMuZGF0YS5maWVsZFZhbHVlWzBdOm51bGw7cmV0dXJue2lkOnRoaXMuZGF0YS5pZCx2YWx1ZTp0LGRlZmF1bHRWYWx1ZTp0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWUsZWRpdGFibGU6IXRoaXMuZGF0YS5yZWFkT25seSxuYW1lOnRoaXMuZGF0YS5maWVsZE5hbWUscmVjdDp0aGlzLmRhdGEucmVjdCxudW1JdGVtczp0aGlzLmRhdGEuZmllbGRWYWx1ZS5sZW5ndGgsbXVsdGlwbGVTZWxlY3Rpb246dGhpcy5kYXRhLm11bHRpU2VsZWN0LGhpZGRlbjp0aGlzLmRhdGEuaGlkZGVuLGFjdGlvbnM6dGhpcy5kYXRhLmFjdGlvbnMsaXRlbXM6dGhpcy5kYXRhLm9wdGlvbnMscGFnZTp0aGlzLmRhdGEucGFnZUluZGV4LHN0cm9rZUNvbG9yOnRoaXMuZGF0YS5ib3JkZXJDb2xvcixmaWxsQ29sb3I6dGhpcy5kYXRhLmJhY2tncm91bmRDb2xvcixyb3RhdGlvbjp0aGlzLnJvdGF0aW9uLHR5cGU6ZX19YXN5bmMgX2dldEFwcGVhcmFuY2UoZSx0LGEpe2lmKHRoaXMuZGF0YS5jb21ibylyZXR1cm4gc3VwZXIuX2dldEFwcGVhcmFuY2UoZSx0LGEpO2lmKCFhKXJldHVybiBudWxsO2NvbnN0IG49YS5nZXQodGhpcy5kYXRhLmlkKTtpZighbilyZXR1cm4gbnVsbDtjb25zdCBzPW4ucm90YXRpb247bGV0IG89bi52YWx1ZTtpZih2b2lkIDA9PT1zJiZ2b2lkIDA9PT1vKXJldHVybiBudWxsO3ZvaWQgMD09PW8/bz10aGlzLmRhdGEuZmllbGRWYWx1ZTpBcnJheS5pc0FycmF5KG8pfHwobz1bb10pO2xldCBjPXRoaXMuZGF0YS5yZWN0WzNdLXRoaXMuZGF0YS5yZWN0WzFdLGw9dGhpcy5kYXRhLnJlY3RbMl0tdGhpcy5kYXRhLnJlY3RbMF07OTAhPT1zJiYyNzAhPT1zfHwoW2wsY109W2MsbF0pO2NvbnN0IGg9dGhpcy5kYXRhLm9wdGlvbnMubGVuZ3RoLHU9W107Zm9yKGxldCBlPTA7ZTxoO2UrKyl7Y29uc3R7ZXhwb3J0VmFsdWU6dH09dGhpcy5kYXRhLm9wdGlvbnNbZV07by5pbmNsdWRlcyh0KSYmdS5wdXNoKGUpfXRoaXMuX2RlZmF1bHRBcHBlYXJhbmNlfHwodGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YT0oMCxpLnBhcnNlRGVmYXVsdEFwcGVhcmFuY2UpKHRoaXMuX2RlZmF1bHRBcHBlYXJhbmNlPSIvSGVsdmV0aWNhIDAgVGYgMCBnIikpO2NvbnN0IGQ9YXdhaXQgV2lkZ2V0QW5ub3RhdGlvbi5fZ2V0Rm9udERhdGEoZSx0LHRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGEsdGhpcy5fZmllbGRSZXNvdXJjZXMubWVyZ2VkUmVzb3VyY2VzKTtsZXQgZix7Zm9udFNpemU6Z309dGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YTtpZihnKWY9dGhpcy5fZGVmYXVsdEFwcGVhcmFuY2U7ZWxzZXtjb25zdCBlPShjLTIpL2g7bGV0IHQsYT0tMTtmb3IoY29uc3R7ZGlzcGxheVZhbHVlOmV9b2YgdGhpcy5kYXRhLm9wdGlvbnMpe2NvbnN0IHI9dGhpcy5fZ2V0VGV4dFdpZHRoKGUsZCk7aWYocj5hKXthPXI7dD1lfX1bZixnXT10aGlzLl9jb21wdXRlRm9udFNpemUoZSxsLTQsdCxkLC0xKX1jb25zdCBwPWcqci5MSU5FX0ZBQ1RPUixtPShwLWcpLzIsYj1NYXRoLmZsb29yKGMvcCk7bGV0IHk7aWYoMT09PXUubGVuZ3RoKXtjb25zdCBlPXVbMF07eT1lLWUlYn1lbHNlIHk9dS5sZW5ndGg/dVswXTowO2NvbnN0IHc9TWF0aC5taW4oeStiKzEsaCksUz1bIi9UeCBCTUMgcSIsYDEgMSAke2x9ICR7Y30gcmUgVyBuYF07aWYodS5sZW5ndGgpe1MucHVzaCgiMC42MDAwMDYgMC43NTY4NjYgMC44NTQ5MDQgcmciKTtmb3IoY29uc3QgZSBvZiB1KXk8PWUmJmU8dyYmUy5wdXNoKGAxICR7Yy0oZS15KzEpKnB9ICR7bH0gJHtwfSByZSBmYCl9Uy5wdXNoKCJCVCIsZixgMSAwIDAgMSAwICR7Y30gVG1gKTtmb3IobGV0IGU9eTtlPHc7ZSsrKXtjb25zdHtkaXNwbGF5VmFsdWU6dH09dGhpcy5kYXRhLm9wdGlvbnNbZV0sYT1lPT09eT8yOjAscj1lPT09eT9tOjA7Uy5wdXNoKHRoaXMuX3JlbmRlclRleHQodCxkLGcsbCwwLGEsLXArcikpfVMucHVzaCgiRVQgUSBFTUMiKTtyZXR1cm4gUy5qb2luKCJcbiIpfX1jbGFzcyBTaWduYXR1cmVXaWRnZXRBbm5vdGF0aW9uIGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTt0aGlzLmRhdGEuZmllbGRWYWx1ZT1udWxsfWdldEZpZWxkT2JqZWN0KCl7cmV0dXJue2lkOnRoaXMuZGF0YS5pZCx2YWx1ZTpudWxsLHBhZ2U6dGhpcy5kYXRhLnBhZ2VJbmRleCx0eXBlOiJzaWduYXR1cmUifX19Y2xhc3MgVGV4dEFubm90YXRpb24gZXh0ZW5kcyBNYXJrdXBBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO2NvbnN0IHQ9ZS5kaWN0O3RoaXMuZGF0YS5hbm5vdGF0aW9uVHlwZT1yLkFubm90YXRpb25UeXBlLlRFWFQ7aWYodGhpcy5kYXRhLmhhc0FwcGVhcmFuY2UpdGhpcy5kYXRhLm5hbWU9Ik5vSWNvbiI7ZWxzZXt0aGlzLmRhdGEucmVjdFsxXT10aGlzLmRhdGEucmVjdFszXS0yMjt0aGlzLmRhdGEucmVjdFsyXT10aGlzLmRhdGEucmVjdFswXSsyMjt0aGlzLmRhdGEubmFtZT10LmhhcygiTmFtZSIpP3QuZ2V0KCJOYW1lIikubmFtZToiTm90ZSJ9aWYodC5oYXMoIlN0YXRlIikpe3RoaXMuZGF0YS5zdGF0ZT10LmdldCgiU3RhdGUiKXx8bnVsbDt0aGlzLmRhdGEuc3RhdGVNb2RlbD10LmdldCgiU3RhdGVNb2RlbCIpfHxudWxsfWVsc2V7dGhpcy5kYXRhLnN0YXRlPW51bGw7dGhpcy5kYXRhLnN0YXRlTW9kZWw9bnVsbH19fWNsYXNzIExpbmtBbm5vdGF0aW9uIGV4dGVuZHMgQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTt0aGlzLmRhdGEuYW5ub3RhdGlvblR5cGU9ci5Bbm5vdGF0aW9uVHlwZS5MSU5LO2NvbnN0IHQ9Z2V0UXVhZFBvaW50cyhlLmRpY3QsdGhpcy5yZWN0YW5nbGUpO3QmJih0aGlzLmRhdGEucXVhZFBvaW50cz10KTt0aGlzLmRhdGEuYm9yZGVyQ29sb3I9dGhpcy5kYXRhLmJvcmRlckNvbG9yfHx0aGlzLmRhdGEuY29sb3I7aC5DYXRhbG9nLnBhcnNlRGVzdERpY3Rpb25hcnkoe2Rlc3REaWN0OmUuZGljdCxyZXN1bHRPYmo6dGhpcy5kYXRhLGRvY0Jhc2VVcmw6ZS5wZGZNYW5hZ2VyLmRvY0Jhc2VVcmx9KX19Y2xhc3MgUG9wdXBBbm5vdGF0aW9uIGV4dGVuZHMgQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTt0aGlzLmRhdGEuYW5ub3RhdGlvblR5cGU9ci5Bbm5vdGF0aW9uVHlwZS5QT1BVUDtsZXQgdD1lLmRpY3QuZ2V0KCJQYXJlbnQiKTtpZighdCl7KDAsci53YXJuKSgiUG9wdXAgYW5ub3RhdGlvbiBoYXMgYSBtaXNzaW5nIG9yIGludmFsaWQgcGFyZW50IGFubm90YXRpb24uIik7cmV0dXJufWNvbnN0IGE9dC5nZXQoIlN1YnR5cGUiKTt0aGlzLmRhdGEucGFyZW50VHlwZT1hIGluc3RhbmNlb2Ygcy5OYW1lP2EubmFtZTpudWxsO2NvbnN0IG49ZS5kaWN0LmdldFJhdygiUGFyZW50Iik7dGhpcy5kYXRhLnBhcmVudElkPW4gaW5zdGFuY2VvZiBzLlJlZj9uLnRvU3RyaW5nKCk6bnVsbDtjb25zdCBpPXQuZ2V0QXJyYXkoIlJlY3QiKTtBcnJheS5pc0FycmF5KGkpJiY0PT09aS5sZW5ndGg/dGhpcy5kYXRhLnBhcmVudFJlY3Q9ci5VdGlsLm5vcm1hbGl6ZVJlY3QoaSk6dGhpcy5kYXRhLnBhcmVudFJlY3Q9WzAsMCwwLDBdO2NvbnN0IG89dC5nZXQoIlJUIik7KDAscy5pc05hbWUpKG8sci5Bbm5vdGF0aW9uUmVwbHlUeXBlLkdST1VQKSYmKHQ9dC5nZXQoIklSVCIpKTtpZih0LmhhcygiTSIpKXt0aGlzLnNldE1vZGlmaWNhdGlvbkRhdGUodC5nZXQoIk0iKSk7dGhpcy5kYXRhLm1vZGlmaWNhdGlvbkRhdGU9dGhpcy5tb2RpZmljYXRpb25EYXRlfWVsc2UgdGhpcy5kYXRhLm1vZGlmaWNhdGlvbkRhdGU9bnVsbDtpZih0LmhhcygiQyIpKXt0aGlzLnNldENvbG9yKHQuZ2V0QXJyYXkoIkMiKSk7dGhpcy5kYXRhLmNvbG9yPXRoaXMuY29sb3J9ZWxzZSB0aGlzLmRhdGEuY29sb3I9bnVsbDtpZighdGhpcy52aWV3YWJsZSl7Y29uc3QgZT10LmdldCgiRiIpO3RoaXMuX2lzVmlld2FibGUoZSkmJnRoaXMuc2V0RmxhZ3MoZSl9dGhpcy5zZXRUaXRsZSh0LmdldCgiVCIpKTt0aGlzLmRhdGEudGl0bGVPYmo9dGhpcy5fdGl0bGU7dGhpcy5zZXRDb250ZW50cyh0LmdldCgiQ29udGVudHMiKSk7dGhpcy5kYXRhLmNvbnRlbnRzT2JqPXRoaXMuX2NvbnRlbnRzO3QuaGFzKCJSQyIpJiYodGhpcy5kYXRhLnJpY2hUZXh0PW0uWEZBRmFjdG9yeS5nZXRSaWNoVGV4dEFzSHRtbCh0LmdldCgiUkMiKSkpfX10LlBvcHVwQW5ub3RhdGlvbj1Qb3B1cEFubm90YXRpb247Y2xhc3MgRnJlZVRleHRBbm5vdGF0aW9uIGV4dGVuZHMgTWFya3VwQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTt0aGlzLmRhdGEuYW5ub3RhdGlvblR5cGU9ci5Bbm5vdGF0aW9uVHlwZS5GUkVFVEVYVH1nZXQgaGFzVGV4dENvbnRlbnQoKXtyZXR1cm4hIXRoaXMuYXBwZWFyYW5jZX1zdGF0aWMgY3JlYXRlTmV3RGljdChlLHQse2FwUmVmOmEsYXA6bn0pe2NvbnN0e2NvbG9yOm8sZm9udFNpemU6YyxyZWN0Omwscm90YXRpb246aCx1c2VyOnUsdmFsdWU6ZH09ZSxmPW5ldyBzLkRpY3QodCk7Zi5zZXQoIlR5cGUiLHMuTmFtZS5nZXQoIkFubm90IikpO2Yuc2V0KCJTdWJ0eXBlIixzLk5hbWUuZ2V0KCJGcmVlVGV4dCIpKTtmLnNldCgiQ3JlYXRpb25EYXRlIixgRDokeygwLHIuZ2V0TW9kaWZpY2F0aW9uRGF0ZSkoKX1gKTtmLnNldCgiUmVjdCIsbCk7Y29uc3QgZz1gL0hlbHYgJHtjfSBUZiAkeygwLGkuZ2V0UGRmQ29sb3IpKG8sITApfWA7Zi5zZXQoIkRBIixnKTtmLnNldCgiQ29udGVudHMiLGQpO2Yuc2V0KCJGIiw0KTtmLnNldCgiQm9yZGVyIixbMCwwLDBdKTtmLnNldCgiUm90YXRlIixoKTt1JiZmLnNldCgiVCIsKDAsci5zdHJpbmdUb1VURjhTdHJpbmcpKHUpKTtjb25zdCBwPW5ldyBzLkRpY3QodCk7Zi5zZXQoIkFQIixwKTthP3Auc2V0KCJOIixhKTpwLnNldCgiTiIsbik7cmV0dXJuIGZ9c3RhdGljIGFzeW5jIGNyZWF0ZU5ld0FwcGVhcmFuY2VTdHJlYW0oZSx0LGEpe2NvbnN0e2Jhc2VGb250UmVmOm8sZXZhbHVhdG9yOmMsdGFzazpsfT1hLHtjb2xvcjpoLGZvbnRTaXplOnUscmVjdDpkLHJvdGF0aW9uOmYsdmFsdWU6Z309ZSxtPW5ldyBzLkRpY3QodCksYj1uZXcgcy5EaWN0KHQpO2lmKG8pYi5zZXQoIkhlbHYiLG8pO2Vsc2V7Y29uc3QgZT1uZXcgcy5EaWN0KHQpO2Uuc2V0KCJCYXNlRm9udCIscy5OYW1lLmdldCgiSGVsdmV0aWNhIikpO2Uuc2V0KCJUeXBlIixzLk5hbWUuZ2V0KCJGb250IikpO2Uuc2V0KCJTdWJ0eXBlIixzLk5hbWUuZ2V0KCJUeXBlMSIpKTtlLnNldCgiRW5jb2RpbmciLHMuTmFtZS5nZXQoIldpbkFuc2lFbmNvZGluZyIpKTtiLnNldCgiSGVsdiIsZSl9bS5zZXQoIkZvbnQiLGIpO2NvbnN0IHk9YXdhaXQgV2lkZ2V0QW5ub3RhdGlvbi5fZ2V0Rm9udERhdGEoYyxsLHtmb250TmFtZToiSGVsdmV0aWNhIixmb250U2l6ZTp1fSxtKSxbdyxTLHgsa109ZDtsZXQgQz14LXcsdj1rLVM7ZiUxODAhPTAmJihbQyx2XT1bdixDXSk7Y29uc3QgRj1nLnNwbGl0KCJcbiIpLE89dS8xZTM7bGV0IFQ9LTEvMDtjb25zdCBNPVtdO2ZvcihsZXQgZSBvZiBGKXtlPXkuZW5jb2RlU3RyaW5nKGUpLmpvaW4oIiIpO00ucHVzaChlKTtsZXQgdD0wO2NvbnN0IGE9eS5jaGFyc1RvR2x5cGhzKGUpO2Zvcihjb25zdCBlIG9mIGEpdCs9ZS53aWR0aCpPO1Q9TWF0aC5tYXgoVCx0KX1sZXQgRT0xO1Q+QyYmKEU9Qy9UKTtsZXQgRD0xO2NvbnN0IE49ci5MSU5FX0ZBQ1RPUip1LFI9ci5MSU5FX0RFU0NFTlRfRkFDVE9SKnUsTD1OKkYubGVuZ3RoO0w+diYmKEQ9di9MKTtjb25zdCBqPXUqTWF0aC5taW4oRSxEKSwkPVsicSIsYDAgMCAkeygwLG4ubnVtYmVyVG9TdHJpbmcpKEMpfSAkeygwLG4ubnVtYmVyVG9TdHJpbmcpKHYpfSByZSBXIG5gLCJCVCIsYDEgMCAwIDEgMCAkeygwLG4ubnVtYmVyVG9TdHJpbmcpKHYrUil9IFRtIDAgVGMgJHsoMCxpLmdldFBkZkNvbG9yKShoLCEwKX1gLGAvSGVsdiAkeygwLG4ubnVtYmVyVG9TdHJpbmcpKGopfSBUZmBdLF89KDAsbi5udW1iZXJUb1N0cmluZykoTik7Zm9yKGNvbnN0IGUgb2YgTSkkLnB1c2goYDAgLSR7X30gVGQgKCR7KDAsci5lc2NhcGVTdHJpbmcpKGUpfSkgVGpgKTskLnB1c2goIkVUIiwiUSIpO2NvbnN0IFU9JC5qb2luKCJcbiIpLFg9bmV3IHMuRGljdCh0KTtYLnNldCgiRm9ybVR5cGUiLDEpO1guc2V0KCJTdWJ0eXBlIixzLk5hbWUuZ2V0KCJGb3JtIikpO1guc2V0KCJUeXBlIixzLk5hbWUuZ2V0KCJYT2JqZWN0IikpO1guc2V0KCJCQm94IixbMCwwLEMsdl0pO1guc2V0KCJMZW5ndGgiLFUubGVuZ3RoKTtYLnNldCgiUmVzb3VyY2VzIixtKTtpZihmKXtjb25zdCBlPVdpZGdldEFubm90YXRpb24uX2dldFJvdGF0aW9uTWF0cml4KGYsQyx2KTtYLnNldCgiTWF0cml4IixlKX1jb25zdCBIPW5ldyBwLlN0cmluZ1N0cmVhbShVKTtILmRpY3Q9WDtyZXR1cm4gSH19Y2xhc3MgTGluZUFubm90YXRpb24gZXh0ZW5kcyBNYXJrdXBBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO2NvbnN0e2RpY3Q6dH09ZTt0aGlzLmRhdGEuYW5ub3RhdGlvblR5cGU9ci5Bbm5vdGF0aW9uVHlwZS5MSU5FO2NvbnN0IGE9dC5nZXRBcnJheSgiTCIpO3RoaXMuZGF0YS5saW5lQ29vcmRpbmF0ZXM9ci5VdGlsLm5vcm1hbGl6ZVJlY3QoYSk7dGhpcy5zZXRMaW5lRW5kaW5ncyh0LmdldEFycmF5KCJMRSIpKTt0aGlzLmRhdGEubGluZUVuZGluZ3M9dGhpcy5saW5lRW5kaW5ncztpZighdGhpcy5hcHBlYXJhbmNlKXtjb25zdCBuPXRoaXMuY29sb3I/QXJyYXkuZnJvbSh0aGlzLmNvbG9yKS5tYXAoKGU9PmUvMjU1KSk6WzAsMCwwXSxpPXQuZ2V0KCJDQSIpO2xldCBzPW51bGwsbz10LmdldEFycmF5KCJJQyIpO2lmKG8pe289Z2V0UmdiQ29sb3IobyxudWxsKTtzPW8/QXJyYXkuZnJvbShvKS5tYXAoKGU9PmUvMjU1KSk6bnVsbH1jb25zdCBjPXM/aTpudWxsLGw9dGhpcy5ib3JkZXJTdHlsZS53aWR0aHx8MSxoPTIqbCx1PVt0aGlzLmRhdGEubGluZUNvb3JkaW5hdGVzWzBdLWgsdGhpcy5kYXRhLmxpbmVDb29yZGluYXRlc1sxXS1oLHRoaXMuZGF0YS5saW5lQ29vcmRpbmF0ZXNbMl0raCx0aGlzLmRhdGEubGluZUNvb3JkaW5hdGVzWzNdK2hdO3IuVXRpbC5pbnRlcnNlY3QodGhpcy5yZWN0YW5nbGUsdSl8fCh0aGlzLnJlY3RhbmdsZT11KTt0aGlzLl9zZXREZWZhdWx0QXBwZWFyYW5jZSh7eHJlZjplLnhyZWYsZXh0cmE6YCR7bH0gd2Asc3Ryb2tlQ29sb3I6bixmaWxsQ29sb3I6cyxzdHJva2VBbHBoYTppLGZpbGxBbHBoYTpjLHBvaW50c0NhbGxiYWNrOihlLHQpPT57ZS5wdXNoKGAke2FbMF19ICR7YVsxXX0gbWAsYCR7YVsyXX0gJHthWzNdfSBsYCwiUyIpO3JldHVyblt0WzBdLngtbCx0WzFdLngrbCx0WzNdLnktbCx0WzFdLnkrbF19fSl9fX1jbGFzcyBTcXVhcmVBbm5vdGF0aW9uIGV4dGVuZHMgTWFya3VwQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTt0aGlzLmRhdGEuYW5ub3RhdGlvblR5cGU9ci5Bbm5vdGF0aW9uVHlwZS5TUVVBUkU7aWYoIXRoaXMuYXBwZWFyYW5jZSl7Y29uc3QgdD10aGlzLmNvbG9yP0FycmF5LmZyb20odGhpcy5jb2xvcikubWFwKChlPT5lLzI1NSkpOlswLDAsMF0sYT1lLmRpY3QuZ2V0KCJDQSIpO2xldCByPW51bGwsbj1lLmRpY3QuZ2V0QXJyYXkoIklDIik7aWYobil7bj1nZXRSZ2JDb2xvcihuLG51bGwpO3I9bj9BcnJheS5mcm9tKG4pLm1hcCgoZT0+ZS8yNTUpKTpudWxsfWNvbnN0IGk9cj9hOm51bGw7aWYoMD09PXRoaXMuYm9yZGVyU3R5bGUud2lkdGgmJiFyKXJldHVybjt0aGlzLl9zZXREZWZhdWx0QXBwZWFyYW5jZSh7eHJlZjplLnhyZWYsZXh0cmE6YCR7dGhpcy5ib3JkZXJTdHlsZS53aWR0aH0gd2Asc3Ryb2tlQ29sb3I6dCxmaWxsQ29sb3I6cixzdHJva2VBbHBoYTphLGZpbGxBbHBoYTppLHBvaW50c0NhbGxiYWNrOihlLHQpPT57Y29uc3QgYT10WzJdLngrdGhpcy5ib3JkZXJTdHlsZS53aWR0aC8yLG49dFsyXS55K3RoaXMuYm9yZGVyU3R5bGUud2lkdGgvMixpPXRbM10ueC10WzJdLngtdGhpcy5ib3JkZXJTdHlsZS53aWR0aCxzPXRbMV0ueS10WzNdLnktdGhpcy5ib3JkZXJTdHlsZS53aWR0aDtlLnB1c2goYCR7YX0gJHtufSAke2l9ICR7c30gcmVgKTtyP2UucHVzaCgiQiIpOmUucHVzaCgiUyIpO3JldHVyblt0WzBdLngsdFsxXS54LHRbM10ueSx0WzFdLnldfX0pfX19Y2xhc3MgQ2lyY2xlQW5ub3RhdGlvbiBleHRlbmRzIE1hcmt1cEFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7dGhpcy5kYXRhLmFubm90YXRpb25UeXBlPXIuQW5ub3RhdGlvblR5cGUuQ0lSQ0xFO2lmKCF0aGlzLmFwcGVhcmFuY2Upe2NvbnN0IHQ9dGhpcy5jb2xvcj9BcnJheS5mcm9tKHRoaXMuY29sb3IpLm1hcCgoZT0+ZS8yNTUpKTpbMCwwLDBdLGE9ZS5kaWN0LmdldCgiQ0EiKTtsZXQgcj1udWxsLG49ZS5kaWN0LmdldEFycmF5KCJJQyIpO2lmKG4pe249Z2V0UmdiQ29sb3IobixudWxsKTtyPW4/QXJyYXkuZnJvbShuKS5tYXAoKGU9PmUvMjU1KSk6bnVsbH1jb25zdCBpPXI/YTpudWxsO2lmKDA9PT10aGlzLmJvcmRlclN0eWxlLndpZHRoJiYhcilyZXR1cm47Y29uc3Qgcz00LzMqTWF0aC50YW4oTWF0aC5QSS84KTt0aGlzLl9zZXREZWZhdWx0QXBwZWFyYW5jZSh7eHJlZjplLnhyZWYsZXh0cmE6YCR7dGhpcy5ib3JkZXJTdHlsZS53aWR0aH0gd2Asc3Ryb2tlQ29sb3I6dCxmaWxsQ29sb3I6cixzdHJva2VBbHBoYTphLGZpbGxBbHBoYTppLHBvaW50c0NhbGxiYWNrOihlLHQpPT57Y29uc3QgYT10WzBdLngrdGhpcy5ib3JkZXJTdHlsZS53aWR0aC8yLG49dFswXS55LXRoaXMuYm9yZGVyU3R5bGUud2lkdGgvMixpPXRbM10ueC10aGlzLmJvcmRlclN0eWxlLndpZHRoLzIsbz10WzNdLnkrdGhpcy5ib3JkZXJTdHlsZS53aWR0aC8yLGM9YSsoaS1hKS8yLGw9bisoby1uKS8yLGg9KGktYSkvMipzLHU9KG8tbikvMipzO2UucHVzaChgJHtjfSAke299IG1gLGAke2MraH0gJHtvfSAke2l9ICR7bCt1fSAke2l9ICR7bH0gY2AsYCR7aX0gJHtsLXV9ICR7YytofSAke259ICR7Y30gJHtufSBjYCxgJHtjLWh9ICR7bn0gJHthfSAke2wtdX0gJHthfSAke2x9IGNgLGAke2F9ICR7bCt1fSAke2MtaH0gJHtvfSAke2N9ICR7b30gY2AsImgiKTtyP2UucHVzaCgiQiIpOmUucHVzaCgiUyIpO3JldHVyblt0WzBdLngsdFsxXS54LHRbM10ueSx0WzFdLnldfX0pfX19Y2xhc3MgUG9seWxpbmVBbm5vdGF0aW9uIGV4dGVuZHMgTWFya3VwQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTtjb25zdHtkaWN0OnR9PWU7dGhpcy5kYXRhLmFubm90YXRpb25UeXBlPXIuQW5ub3RhdGlvblR5cGUuUE9MWUxJTkU7dGhpcy5kYXRhLnZlcnRpY2VzPVtdO2lmKCEodGhpcyBpbnN0YW5jZW9mIFBvbHlnb25Bbm5vdGF0aW9uKSl7dGhpcy5zZXRMaW5lRW5kaW5ncyh0LmdldEFycmF5KCJMRSIpKTt0aGlzLmRhdGEubGluZUVuZGluZ3M9dGhpcy5saW5lRW5kaW5nc31jb25zdCBhPXQuZ2V0QXJyYXkoIlZlcnRpY2VzIik7aWYoQXJyYXkuaXNBcnJheShhKSl7Zm9yKGxldCBlPTAsdD1hLmxlbmd0aDtlPHQ7ZSs9Mil0aGlzLmRhdGEudmVydGljZXMucHVzaCh7eDphW2VdLHk6YVtlKzFdfSk7aWYoIXRoaXMuYXBwZWFyYW5jZSl7Y29uc3QgYT10aGlzLmNvbG9yP0FycmF5LmZyb20odGhpcy5jb2xvcikubWFwKChlPT5lLzI1NSkpOlswLDAsMF0sbj10LmdldCgiQ0EiKSxpPXRoaXMuYm9yZGVyU3R5bGUud2lkdGh8fDEscz0yKmksbz1bMS8wLDEvMCwtMS8wLC0xLzBdO2Zvcihjb25zdCBlIG9mIHRoaXMuZGF0YS52ZXJ0aWNlcyl7b1swXT1NYXRoLm1pbihvWzBdLGUueC1zKTtvWzFdPU1hdGgubWluKG9bMV0sZS55LXMpO29bMl09TWF0aC5tYXgob1syXSxlLngrcyk7b1szXT1NYXRoLm1heChvWzNdLGUueStzKX1yLlV0aWwuaW50ZXJzZWN0KHRoaXMucmVjdGFuZ2xlLG8pfHwodGhpcy5yZWN0YW5nbGU9byk7dGhpcy5fc2V0RGVmYXVsdEFwcGVhcmFuY2Uoe3hyZWY6ZS54cmVmLGV4dHJhOmAke2l9IHdgLHN0cm9rZUNvbG9yOmEsc3Ryb2tlQWxwaGE6bixwb2ludHNDYWxsYmFjazooZSx0KT0+e2NvbnN0IGE9dGhpcy5kYXRhLnZlcnRpY2VzO2ZvcihsZXQgdD0wLHI9YS5sZW5ndGg7dDxyO3QrKyllLnB1c2goYCR7YVt0XS54fSAke2FbdF0ueX0gJHswPT09dD8ibSI6ImwifWApO2UucHVzaCgiUyIpO3JldHVyblt0WzBdLngsdFsxXS54LHRbM10ueSx0WzFdLnldfX0pfX19fWNsYXNzIFBvbHlnb25Bbm5vdGF0aW9uIGV4dGVuZHMgUG9seWxpbmVBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO3RoaXMuZGF0YS5hbm5vdGF0aW9uVHlwZT1yLkFubm90YXRpb25UeXBlLlBPTFlHT059fWNsYXNzIENhcmV0QW5ub3RhdGlvbiBleHRlbmRzIE1hcmt1cEFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7dGhpcy5kYXRhLmFubm90YXRpb25UeXBlPXIuQW5ub3RhdGlvblR5cGUuQ0FSRVR9fWNsYXNzIElua0Fubm90YXRpb24gZXh0ZW5kcyBNYXJrdXBBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO3RoaXMuZGF0YS5hbm5vdGF0aW9uVHlwZT1yLkFubm90YXRpb25UeXBlLklOSzt0aGlzLmRhdGEuaW5rTGlzdHM9W107Y29uc3QgdD1lLmRpY3QuZ2V0QXJyYXkoIklua0xpc3QiKTtpZighQXJyYXkuaXNBcnJheSh0KSlyZXR1cm47Y29uc3QgYT1lLnhyZWY7Zm9yKGxldCBlPTAscj10Lmxlbmd0aDtlPHI7KytlKXt0aGlzLmRhdGEuaW5rTGlzdHMucHVzaChbXSk7Zm9yKGxldCByPTAsbj10W2VdLmxlbmd0aDtyPG47cis9Mil0aGlzLmRhdGEuaW5rTGlzdHNbZV0ucHVzaCh7eDphLmZldGNoSWZSZWYodFtlXVtyXSkseTphLmZldGNoSWZSZWYodFtlXVtyKzFdKX0pfWlmKCF0aGlzLmFwcGVhcmFuY2Upe2NvbnN0IHQ9dGhpcy5jb2xvcj9BcnJheS5mcm9tKHRoaXMuY29sb3IpLm1hcCgoZT0+ZS8yNTUpKTpbMCwwLDBdLGE9ZS5kaWN0LmdldCgiQ0EiKSxuPXRoaXMuYm9yZGVyU3R5bGUud2lkdGh8fDEsaT0yKm4scz1bMS8wLDEvMCwtMS8wLC0xLzBdO2Zvcihjb25zdCBlIG9mIHRoaXMuZGF0YS5pbmtMaXN0cylmb3IoY29uc3QgdCBvZiBlKXtzWzBdPU1hdGgubWluKHNbMF0sdC54LWkpO3NbMV09TWF0aC5taW4oc1sxXSx0LnktaSk7c1syXT1NYXRoLm1heChzWzJdLHQueCtpKTtzWzNdPU1hdGgubWF4KHNbM10sdC55K2kpfXIuVXRpbC5pbnRlcnNlY3QodGhpcy5yZWN0YW5nbGUscyl8fCh0aGlzLnJlY3RhbmdsZT1zKTt0aGlzLl9zZXREZWZhdWx0QXBwZWFyYW5jZSh7eHJlZjplLnhyZWYsZXh0cmE6YCR7bn0gd2Asc3Ryb2tlQ29sb3I6dCxzdHJva2VBbHBoYTphLHBvaW50c0NhbGxiYWNrOihlLHQpPT57Zm9yKGNvbnN0IHQgb2YgdGhpcy5kYXRhLmlua0xpc3RzKXtmb3IobGV0IGE9MCxyPXQubGVuZ3RoO2E8cjthKyspZS5wdXNoKGAke3RbYV0ueH0gJHt0W2FdLnl9ICR7MD09PWE/Im0iOiJsIn1gKTtlLnB1c2goIlMiKX1yZXR1cm5bdFswXS54LHRbMV0ueCx0WzNdLnksdFsxXS55XX19KX19c3RhdGljIGNyZWF0ZU5ld0RpY3QoZSx0LHthcFJlZjphLGFwOm59KXtjb25zdHtwYXRoczppLHJlY3Q6byxyb3RhdGlvbjpjfT1lLGw9bmV3IHMuRGljdCh0KTtsLnNldCgiVHlwZSIscy5OYW1lLmdldCgiQW5ub3QiKSk7bC5zZXQoIlN1YnR5cGUiLHMuTmFtZS5nZXQoIkluayIpKTtsLnNldCgiQ3JlYXRpb25EYXRlIixgRDokeygwLHIuZ2V0TW9kaWZpY2F0aW9uRGF0ZSkoKX1gKTtsLnNldCgiUmVjdCIsbyk7bC5zZXQoIklua0xpc3QiLGkubWFwKChlPT5lLnBvaW50cykpKTtsLnNldCgiRiIsNCk7bC5zZXQoIkJvcmRlciIsWzAsMCwwXSk7bC5zZXQoIlJvdGF0ZSIsYyk7Y29uc3QgaD1uZXcgcy5EaWN0KHQpO2wuc2V0KCJBUCIsaCk7YT9oLnNldCgiTiIsYSk6aC5zZXQoIk4iLG4pO3JldHVybiBsfXN0YXRpYyBhc3luYyBjcmVhdGVOZXdBcHBlYXJhbmNlU3RyZWFtKGUsdCxhKXtjb25zdHtjb2xvcjpyLHJlY3Q6byxyb3RhdGlvbjpjLHBhdGhzOmwsdGhpY2tuZXNzOmgsb3BhY2l0eTp1fT1lLFtkLGYsZyxtXT1vO2xldCBiPWctZCx5PW0tZjtjJTE4MCE9MCYmKFtiLHldPVt5LGJdKTtjb25zdCB3PVtgJHtofSB3IDEgSiAxIGpgLGAkeygwLGkuZ2V0UGRmQ29sb3IpKHIsITEpfWBdOzEhPT11JiZ3LnB1c2goIi9SMCBncyIpO2NvbnN0IFM9W107Zm9yKGNvbnN0e2JlemllcjplfW9mIGwpe1MubGVuZ3RoPTA7Uy5wdXNoKGAkeygwLG4ubnVtYmVyVG9TdHJpbmcpKGVbMF0pfSAkeygwLG4ubnVtYmVyVG9TdHJpbmcpKGVbMV0pfSBtYCk7Zm9yKGxldCB0PTIsYT1lLmxlbmd0aDt0PGE7dCs9Nil7Y29uc3QgYT1lLnNsaWNlKHQsdCs2KS5tYXAobi5udW1iZXJUb1N0cmluZykuam9pbigiICIpO1MucHVzaChgJHthfSBjYCl9Uy5wdXNoKCJTIik7dy5wdXNoKFMuam9pbigiXG4iKSl9Y29uc3QgeD13LmpvaW4oIlxuIiksaz1uZXcgcy5EaWN0KHQpO2suc2V0KCJGb3JtVHlwZSIsMSk7ay5zZXQoIlN1YnR5cGUiLHMuTmFtZS5nZXQoIkZvcm0iKSk7ay5zZXQoIlR5cGUiLHMuTmFtZS5nZXQoIlhPYmplY3QiKSk7ay5zZXQoIkJCb3giLFswLDAsYix5XSk7ay5zZXQoIkxlbmd0aCIseC5sZW5ndGgpO2lmKGMpe2NvbnN0IGU9V2lkZ2V0QW5ub3RhdGlvbi5fZ2V0Um90YXRpb25NYXRyaXgoYyxiLHkpO2suc2V0KCJNYXRyaXgiLGUpfWlmKDEhPT11KXtjb25zdCBlPW5ldyBzLkRpY3QodCksYT1uZXcgcy5EaWN0KHQpLHI9bmV3IHMuRGljdCh0KTtyLnNldCgiQ0EiLHUpO3Iuc2V0KCJUeXBlIixzLk5hbWUuZ2V0KCJFeHRHU3RhdGUiKSk7YS5zZXQoIlIwIixyKTtlLnNldCgiRXh0R1N0YXRlIixhKTtrLnNldCgiUmVzb3VyY2VzIixlKX1jb25zdCBDPW5ldyBwLlN0cmluZ1N0cmVhbSh4KTtDLmRpY3Q9aztyZXR1cm4gQ319Y2xhc3MgSGlnaGxpZ2h0QW5ub3RhdGlvbiBleHRlbmRzIE1hcmt1cEFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7dGhpcy5kYXRhLmFubm90YXRpb25UeXBlPXIuQW5ub3RhdGlvblR5cGUuSElHSExJR0hUO2lmKHRoaXMuZGF0YS5xdWFkUG9pbnRzPWdldFF1YWRQb2ludHMoZS5kaWN0LG51bGwpKXtjb25zdCB0PXRoaXMuYXBwZWFyYW5jZSYmdGhpcy5hcHBlYXJhbmNlLmRpY3QuZ2V0KCJSZXNvdXJjZXMiKTtpZighdGhpcy5hcHBlYXJhbmNlfHwhdHx8IXQuaGFzKCJFeHRHU3RhdGUiKSl7dGhpcy5hcHBlYXJhbmNlJiYoMCxyLndhcm4pKCJIaWdobGlnaHRBbm5vdGF0aW9uIC0gaWdub3JpbmcgYnVpbHQtaW4gYXBwZWFyYW5jZSBzdHJlYW0uIik7Y29uc3QgdD10aGlzLmNvbG9yP0FycmF5LmZyb20odGhpcy5jb2xvcikubWFwKChlPT5lLzI1NSkpOlsxLDEsMF0sYT1lLmRpY3QuZ2V0KCJDQSIpO3RoaXMuX3NldERlZmF1bHRBcHBlYXJhbmNlKHt4cmVmOmUueHJlZixmaWxsQ29sb3I6dCxibGVuZE1vZGU6Ik11bHRpcGx5IixmaWxsQWxwaGE6YSxwb2ludHNDYWxsYmFjazooZSx0KT0+e2UucHVzaChgJHt0WzBdLnh9ICR7dFswXS55fSBtYCxgJHt0WzFdLnh9ICR7dFsxXS55fSBsYCxgJHt0WzNdLnh9ICR7dFszXS55fSBsYCxgJHt0WzJdLnh9ICR7dFsyXS55fSBsYCwiZiIpO3JldHVyblt0WzBdLngsdFsxXS54LHRbM10ueSx0WzFdLnldfX0pfX1lbHNlIHRoaXMuZGF0YS5oYXNQb3B1cD0hMX19Y2xhc3MgVW5kZXJsaW5lQW5ub3RhdGlvbiBleHRlbmRzIE1hcmt1cEFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7dGhpcy5kYXRhLmFubm90YXRpb25UeXBlPXIuQW5ub3RhdGlvblR5cGUuVU5ERVJMSU5FO2lmKHRoaXMuZGF0YS5xdWFkUG9pbnRzPWdldFF1YWRQb2ludHMoZS5kaWN0LG51bGwpKXtpZighdGhpcy5hcHBlYXJhbmNlKXtjb25zdCB0PXRoaXMuY29sb3I/QXJyYXkuZnJvbSh0aGlzLmNvbG9yKS5tYXAoKGU9PmUvMjU1KSk6WzAsMCwwXSxhPWUuZGljdC5nZXQoIkNBIik7dGhpcy5fc2V0RGVmYXVsdEFwcGVhcmFuY2Uoe3hyZWY6ZS54cmVmLGV4dHJhOiJbXSAwIGQgMSB3IixzdHJva2VDb2xvcjp0LHN0cm9rZUFscGhhOmEscG9pbnRzQ2FsbGJhY2s6KGUsdCk9PntlLnB1c2goYCR7dFsyXS54fSAke3RbMl0ueX0gbWAsYCR7dFszXS54fSAke3RbM10ueX0gbGAsIlMiKTtyZXR1cm5bdFswXS54LHRbMV0ueCx0WzNdLnksdFsxXS55XX19KX19ZWxzZSB0aGlzLmRhdGEuaGFzUG9wdXA9ITF9fWNsYXNzIFNxdWlnZ2x5QW5ub3RhdGlvbiBleHRlbmRzIE1hcmt1cEFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7dGhpcy5kYXRhLmFubm90YXRpb25UeXBlPXIuQW5ub3RhdGlvblR5cGUuU1FVSUdHTFk7aWYodGhpcy5kYXRhLnF1YWRQb2ludHM9Z2V0UXVhZFBvaW50cyhlLmRpY3QsbnVsbCkpe2lmKCF0aGlzLmFwcGVhcmFuY2Upe2NvbnN0IHQ9dGhpcy5jb2xvcj9BcnJheS5mcm9tKHRoaXMuY29sb3IpLm1hcCgoZT0+ZS8yNTUpKTpbMCwwLDBdLGE9ZS5kaWN0LmdldCgiQ0EiKTt0aGlzLl9zZXREZWZhdWx0QXBwZWFyYW5jZSh7eHJlZjplLnhyZWYsZXh0cmE6IltdIDAgZCAxIHciLHN0cm9rZUNvbG9yOnQsc3Ryb2tlQWxwaGE6YSxwb2ludHNDYWxsYmFjazooZSx0KT0+e2NvbnN0IGE9KHRbMF0ueS10WzJdLnkpLzY7bGV0IHI9YSxuPXRbMl0ueDtjb25zdCBpPXRbMl0ueSxzPXRbM10ueDtlLnB1c2goYCR7bn0gJHtpK3J9IG1gKTtkb3tuKz0yO3I9MD09PXI/YTowO2UucHVzaChgJHtufSAke2krcn0gbGApfXdoaWxlKG48cyk7ZS5wdXNoKCJTIik7cmV0dXJuW3RbMl0ueCxzLGktMiphLGkrMiphXX19KX19ZWxzZSB0aGlzLmRhdGEuaGFzUG9wdXA9ITF9fWNsYXNzIFN0cmlrZU91dEFubm90YXRpb24gZXh0ZW5kcyBNYXJrdXBBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO3RoaXMuZGF0YS5hbm5vdGF0aW9uVHlwZT1yLkFubm90YXRpb25UeXBlLlNUUklLRU9VVDtpZih0aGlzLmRhdGEucXVhZFBvaW50cz1nZXRRdWFkUG9pbnRzKGUuZGljdCxudWxsKSl7aWYoIXRoaXMuYXBwZWFyYW5jZSl7Y29uc3QgdD10aGlzLmNvbG9yP0FycmF5LmZyb20odGhpcy5jb2xvcikubWFwKChlPT5lLzI1NSkpOlswLDAsMF0sYT1lLmRpY3QuZ2V0KCJDQSIpO3RoaXMuX3NldERlZmF1bHRBcHBlYXJhbmNlKHt4cmVmOmUueHJlZixleHRyYToiW10gMCBkIDEgdyIsc3Ryb2tlQ29sb3I6dCxzdHJva2VBbHBoYTphLHBvaW50c0NhbGxiYWNrOihlLHQpPT57ZS5wdXNoKCh0WzBdLngrdFsyXS54KS8yKyIgIisodFswXS55K3RbMl0ueSkvMisiIG0iLCh0WzFdLngrdFszXS54KS8yKyIgIisodFsxXS55K3RbM10ueSkvMisiIGwiLCJTIik7cmV0dXJuW3RbMF0ueCx0WzFdLngsdFszXS55LHRbMV0ueV19fSl9fWVsc2UgdGhpcy5kYXRhLmhhc1BvcHVwPSExfX1jbGFzcyBTdGFtcEFubm90YXRpb24gZXh0ZW5kcyBNYXJrdXBBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO3RoaXMuZGF0YS5hbm5vdGF0aW9uVHlwZT1yLkFubm90YXRpb25UeXBlLlNUQU1QfX1jbGFzcyBGaWxlQXR0YWNobWVudEFubm90YXRpb24gZXh0ZW5kcyBNYXJrdXBBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO2NvbnN0IHQ9bmV3IGQuRmlsZVNwZWMoZS5kaWN0LmdldCgiRlMiKSxlLnhyZWYpO3RoaXMuZGF0YS5hbm5vdGF0aW9uVHlwZT1yLkFubm90YXRpb25UeXBlLkZJTEVBVFRBQ0hNRU5UO3RoaXMuZGF0YS5maWxlPXQuc2VyaWFsaXphYmxlfX19LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5jcmVhdGVEZWZhdWx0QXBwZWFyYW5jZT1mdW5jdGlvbiBjcmVhdGVEZWZhdWx0QXBwZWFyYW5jZSh7Zm9udFNpemU6ZSxmb250TmFtZTp0LGZvbnRDb2xvcjphfSl7cmV0dXJuYC8keygwLHIuZXNjYXBlUERGTmFtZSkodCl9ICR7ZX0gVGYgJHtnZXRQZGZDb2xvcihhLCEwKX1gfTt0LmdldFBkZkNvbG9yPWdldFBkZkNvbG9yO3QucGFyc2VEZWZhdWx0QXBwZWFyYW5jZT1mdW5jdGlvbiBwYXJzZURlZmF1bHRBcHBlYXJhbmNlKGUpe3JldHVybiBuZXcgRGVmYXVsdEFwcGVhcmFuY2VFdmFsdWF0b3IoZSkucGFyc2UoKX07dmFyIHI9YSg2KSxuPWEoMiksaT1hKDE0KSxzPWEoMTUpLG89YSg1KSxjPWEoMTApO2NsYXNzIERlZmF1bHRBcHBlYXJhbmNlRXZhbHVhdG9yIGV4dGVuZHMgcy5FdmFsdWF0b3JQcmVwcm9jZXNzb3J7Y29uc3RydWN0b3IoZSl7c3VwZXIobmV3IGMuU3RyaW5nU3RyZWFtKGUpKX1wYXJzZSgpe2NvbnN0IGU9e2ZuOjAsYXJnczpbXX0sdD17Zm9udFNpemU6MCxmb250TmFtZToiIixmb250Q29sb3I6bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDMpfTt0cnl7Zm9yKDs7KXtlLmFyZ3MubGVuZ3RoPTA7aWYoIXRoaXMucmVhZChlKSlicmVhaztpZigwIT09dGhpcy5zYXZlZFN0YXRlc0RlcHRoKWNvbnRpbnVlO2NvbnN0e2ZuOmEsYXJnczpyfT1lO3N3aXRjaCgwfGEpe2Nhc2Ugbi5PUFMuc2V0Rm9udDpjb25zdFtlLGFdPXI7ZSBpbnN0YW5jZW9mIG8uTmFtZSYmKHQuZm9udE5hbWU9ZS5uYW1lKTsibnVtYmVyIj09dHlwZW9mIGEmJmE+MCYmKHQuZm9udFNpemU9YSk7YnJlYWs7Y2FzZSBuLk9QUy5zZXRGaWxsUkdCQ29sb3I6aS5Db2xvclNwYWNlLnNpbmdsZXRvbnMucmdiLmdldFJnYkl0ZW0ociwwLHQuZm9udENvbG9yLDApO2JyZWFrO2Nhc2Ugbi5PUFMuc2V0RmlsbEdyYXk6aS5Db2xvclNwYWNlLnNpbmdsZXRvbnMuZ3JheS5nZXRSZ2JJdGVtKHIsMCx0LmZvbnRDb2xvciwwKTticmVhaztjYXNlIG4uT1BTLnNldEZpbGxDb2xvclNwYWNlOmkuQ29sb3JTcGFjZS5zaW5nbGV0b25zLmNteWsuZ2V0UmdiSXRlbShyLDAsdC5mb250Q29sb3IsMCl9fX1jYXRjaChlKXsoMCxuLndhcm4pKGBwYXJzZURlZmF1bHRBcHBlYXJhbmNlIC0gaWdub3JpbmcgZXJyb3JzOiAiJHtlfSIuYCl9cmV0dXJuIHR9fWZ1bmN0aW9uIGdldFBkZkNvbG9yKGUsdCl7aWYoZVswXT09PWVbMV0mJmVbMV09PT1lWzJdKXtjb25zdCBhPWVbMF0vMjU1O3JldHVybmAkeygwLHIubnVtYmVyVG9TdHJpbmcpKGEpfSAke3Q/ImciOiJHIn1gfXJldHVybiBBcnJheS5mcm9tKGUpLm1hcCgoZT0+KDAsci5udW1iZXJUb1N0cmluZykoZS8yNTUpKSkuam9pbigiICIpKyIgIisodD8icmciOiJSRyIpfX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LkNvbG9yU3BhY2U9dm9pZCAwO3ZhciByPWEoMiksbj1hKDUpLGk9YSg3KSxzPWEoNik7Y2xhc3MgQ29sb3JTcGFjZXtjb25zdHJ1Y3RvcihlLHQpe3RoaXMuY29uc3RydWN0b3I9PT1Db2xvclNwYWNlJiYoMCxyLnVucmVhY2hhYmxlKSgiQ2Fubm90IGluaXRpYWxpemUgQ29sb3JTcGFjZS4iKTt0aGlzLm5hbWU9ZTt0aGlzLm51bUNvbXBzPXR9Z2V0UmdiKGUsdCl7Y29uc3QgYT1uZXcgVWludDhDbGFtcGVkQXJyYXkoMyk7dGhpcy5nZXRSZ2JJdGVtKGUsdCxhLDApO3JldHVybiBhfWdldFJnYkl0ZW0oZSx0LGEsbil7KDAsci51bnJlYWNoYWJsZSkoIlNob3VsZCBub3QgY2FsbCBDb2xvclNwYWNlLmdldFJnYkl0ZW0iKX1nZXRSZ2JCdWZmZXIoZSx0LGEsbixpLHMsbyl7KDAsci51bnJlYWNoYWJsZSkoIlNob3VsZCBub3QgY2FsbCBDb2xvclNwYWNlLmdldFJnYkJ1ZmZlciIpfWdldE91dHB1dExlbmd0aChlLHQpeygwLHIudW5yZWFjaGFibGUpKCJTaG91bGQgbm90IGNhbGwgQ29sb3JTcGFjZS5nZXRPdXRwdXRMZW5ndGgiKX1pc1Bhc3N0aHJvdWdoKGUpe3JldHVybiExfWlzRGVmYXVsdERlY29kZShlLHQpe3JldHVybiBDb2xvclNwYWNlLmlzRGVmYXVsdERlY29kZShlLHRoaXMubnVtQ29tcHMpfWZpbGxSZ2IoZSx0LGEscixuLGkscyxvLGMpe2NvbnN0IGw9dCphO2xldCBoPW51bGw7Y29uc3QgdT0xPDxzLGQ9YSE9PW58fHQhPT1yO2lmKHRoaXMuaXNQYXNzdGhyb3VnaChzKSloPW87ZWxzZSBpZigxPT09dGhpcy5udW1Db21wcyYmbD51JiYiRGV2aWNlR3JheSIhPT10aGlzLm5hbWUmJiJEZXZpY2VSR0IiIT09dGhpcy5uYW1lKXtjb25zdCB0PXM8PTg/bmV3IFVpbnQ4QXJyYXkodSk6bmV3IFVpbnQxNkFycmF5KHUpO2ZvcihsZXQgZT0wO2U8dTtlKyspdFtlXT1lO2NvbnN0IGE9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDMqdSk7dGhpcy5nZXRSZ2JCdWZmZXIodCwwLHUsYSwwLHMsMCk7aWYoZCl7aD1uZXcgVWludDhBcnJheSgzKmwpO2xldCBlPTA7Zm9yKGxldCB0PTA7dDxsOysrdCl7Y29uc3Qgcj0zKm9bdF07aFtlKytdPWFbcl07aFtlKytdPWFbcisxXTtoW2UrK109YVtyKzJdfX1lbHNle2xldCB0PTA7Zm9yKGxldCByPTA7cjxsOysrcil7Y29uc3Qgbj0zKm9bcl07ZVt0KytdPWFbbl07ZVt0KytdPWFbbisxXTtlW3QrK109YVtuKzJdO3QrPWN9fX1lbHNlIGlmKGQpe2g9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDMqbCk7dGhpcy5nZXRSZ2JCdWZmZXIobywwLGwsaCwwLHMsMCl9ZWxzZSB0aGlzLmdldFJnYkJ1ZmZlcihvLDAscippLGUsMCxzLGMpO2lmKGgpaWYoZCkhZnVuY3Rpb24gcmVzaXplUmdiSW1hZ2UoZSx0LGEscixuLGkscyl7cz0xIT09cz8wOnM7Y29uc3Qgbz1hL24sYz1yL2k7bGV0IGwsaD0wO2NvbnN0IHU9bmV3IFVpbnQxNkFycmF5KG4pLGQ9MyphO2ZvcihsZXQgZT0wO2U8bjtlKyspdVtlXT0zKk1hdGguZmxvb3IoZSpvKTtmb3IobGV0IGE9MDthPGk7YSsrKXtjb25zdCByPU1hdGguZmxvb3IoYSpjKSpkO2ZvcihsZXQgYT0wO2E8bjthKyspe2w9cit1W2FdO3RbaCsrXT1lW2wrK107dFtoKytdPWVbbCsrXTt0W2grK109ZVtsKytdO2grPXN9fX0oaCxlLHQsYSxyLG4sYyk7ZWxzZXtsZXQgdD0wLGE9MDtmb3IobGV0IG49MCxzPXIqaTtuPHM7bisrKXtlW3QrK109aFthKytdO2VbdCsrXT1oW2ErK107ZVt0KytdPWhbYSsrXTt0Kz1jfX19Z2V0IHVzZXNaZXJvVG9PbmVSYW5nZSgpe3JldHVybigwLHIuc2hhZG93KSh0aGlzLCJ1c2VzWmVyb1RvT25lUmFuZ2UiLCEwKX1zdGF0aWMgX2NhY2hlKGUsdCxhLHIpe2lmKCFhKXRocm93IG5ldyBFcnJvcignQ29sb3JTcGFjZS5fY2FjaGUgLSBleHBlY3RlZCAibG9jYWxDb2xvclNwYWNlQ2FjaGUiIGFyZ3VtZW50LicpO2lmKCFyKXRocm93IG5ldyBFcnJvcignQ29sb3JTcGFjZS5fY2FjaGUgLSBleHBlY3RlZCAicGFyc2VkQ29sb3JTcGFjZSIgYXJndW1lbnQuJyk7bGV0IGkscztpZihlIGluc3RhbmNlb2Ygbi5SZWYpe3M9ZTtlPXQuZmV0Y2goZSl9ZSBpbnN0YW5jZW9mIG4uTmFtZSYmKGk9ZS5uYW1lKTsoaXx8cykmJmEuc2V0KGkscyxyKX1zdGF0aWMgZ2V0Q2FjaGVkKGUsdCxhKXtpZighYSl0aHJvdyBuZXcgRXJyb3IoJ0NvbG9yU3BhY2UuZ2V0Q2FjaGVkIC0gZXhwZWN0ZWQgImxvY2FsQ29sb3JTcGFjZUNhY2hlIiBhcmd1bWVudC4nKTtpZihlIGluc3RhbmNlb2Ygbi5SZWYpe2NvbnN0IHI9YS5nZXRCeVJlZihlKTtpZihyKXJldHVybiByO3RyeXtlPXQuZmV0Y2goZSl9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIHMuTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZX19aWYoZSBpbnN0YW5jZW9mIG4uTmFtZSl7Y29uc3QgdD1hLmdldEJ5TmFtZShlLm5hbWUpO2lmKHQpcmV0dXJuIHR9cmV0dXJuIG51bGx9c3RhdGljIGFzeW5jIHBhcnNlQXN5bmMoe2NzOmUseHJlZjp0LHJlc291cmNlczphPW51bGwscGRmRnVuY3Rpb25GYWN0b3J5OnIsbG9jYWxDb2xvclNwYWNlQ2FjaGU6bn0pe2NvbnN0IGk9dGhpcy5fcGFyc2UoZSx0LGEscik7dGhpcy5fY2FjaGUoZSx0LG4saSk7cmV0dXJuIGl9c3RhdGljIHBhcnNlKHtjczplLHhyZWY6dCxyZXNvdXJjZXM6YT1udWxsLHBkZkZ1bmN0aW9uRmFjdG9yeTpyLGxvY2FsQ29sb3JTcGFjZUNhY2hlOm59KXtjb25zdCBpPXRoaXMuZ2V0Q2FjaGVkKGUsdCxuKTtpZihpKXJldHVybiBpO2NvbnN0IHM9dGhpcy5fcGFyc2UoZSx0LGEscik7dGhpcy5fY2FjaGUoZSx0LG4scyk7cmV0dXJuIHN9c3RhdGljIF9wYXJzZShlLHQsYT1udWxsLGkpe2lmKChlPXQuZmV0Y2hJZlJlZihlKSlpbnN0YW5jZW9mIG4uTmFtZSlzd2l0Y2goZS5uYW1lKXtjYXNlIkciOmNhc2UiRGV2aWNlR3JheSI6cmV0dXJuIHRoaXMuc2luZ2xldG9ucy5ncmF5O2Nhc2UiUkdCIjpjYXNlIkRldmljZVJHQiI6cmV0dXJuIHRoaXMuc2luZ2xldG9ucy5yZ2I7Y2FzZSJDTVlLIjpjYXNlIkRldmljZUNNWUsiOnJldHVybiB0aGlzLnNpbmdsZXRvbnMuY215aztjYXNlIlBhdHRlcm4iOnJldHVybiBuZXcgUGF0dGVybkNTKG51bGwpO2RlZmF1bHQ6aWYoYSBpbnN0YW5jZW9mIG4uRGljdCl7Y29uc3Qgcj1hLmdldCgiQ29sb3JTcGFjZSIpO2lmKHIgaW5zdGFuY2VvZiBuLkRpY3Qpe2NvbnN0IHM9ci5nZXQoZS5uYW1lKTtpZihzKXtpZihzIGluc3RhbmNlb2Ygbi5OYW1lKXJldHVybiB0aGlzLl9wYXJzZShzLHQsYSxpKTtlPXM7YnJlYWt9fX10aHJvdyBuZXcgci5Gb3JtYXRFcnJvcihgVW5yZWNvZ25pemVkIENvbG9yU3BhY2U6ICR7ZS5uYW1lfWApfWlmKEFycmF5LmlzQXJyYXkoZSkpe2NvbnN0IG49dC5mZXRjaElmUmVmKGVbMF0pLm5hbWU7bGV0IHMsbyx1LGQsZixnO3N3aXRjaChuKXtjYXNlIkciOmNhc2UiRGV2aWNlR3JheSI6cmV0dXJuIHRoaXMuc2luZ2xldG9ucy5ncmF5O2Nhc2UiUkdCIjpjYXNlIkRldmljZVJHQiI6cmV0dXJuIHRoaXMuc2luZ2xldG9ucy5yZ2I7Y2FzZSJDTVlLIjpjYXNlIkRldmljZUNNWUsiOnJldHVybiB0aGlzLnNpbmdsZXRvbnMuY215aztjYXNlIkNhbEdyYXkiOnM9dC5mZXRjaElmUmVmKGVbMV0pO2Q9cy5nZXRBcnJheSgiV2hpdGVQb2ludCIpO2Y9cy5nZXRBcnJheSgiQmxhY2tQb2ludCIpO2c9cy5nZXQoIkdhbW1hIik7cmV0dXJuIG5ldyBjKGQsZixnKTtjYXNlIkNhbFJHQiI6cz10LmZldGNoSWZSZWYoZVsxXSk7ZD1zLmdldEFycmF5KCJXaGl0ZVBvaW50Iik7Zj1zLmdldEFycmF5KCJCbGFja1BvaW50Iik7Zz1zLmdldEFycmF5KCJHYW1tYSIpO2NvbnN0IHA9cy5nZXRBcnJheSgiTWF0cml4Iik7cmV0dXJuIG5ldyBsKGQsZixnLHApO2Nhc2UiSUNDQmFzZWQiOmNvbnN0IG09dC5mZXRjaElmUmVmKGVbMV0pLmRpY3Q7bz1tLmdldCgiTiIpO2NvbnN0IGI9bS5nZXQoIkFsdGVybmF0ZSIpO2lmKGIpe2NvbnN0IGU9dGhpcy5fcGFyc2UoYix0LGEsaSk7aWYoZS5udW1Db21wcz09PW8pcmV0dXJuIGU7KDAsci53YXJuKSgiSUNDQmFzZWQgY29sb3Igc3BhY2U6IElnbm9yaW5nIGluY29ycmVjdCAvQWx0ZXJuYXRlIGVudHJ5LiIpfWlmKDE9PT1vKXJldHVybiB0aGlzLnNpbmdsZXRvbnMuZ3JheTtpZigzPT09bylyZXR1cm4gdGhpcy5zaW5nbGV0b25zLnJnYjtpZig0PT09bylyZXR1cm4gdGhpcy5zaW5nbGV0b25zLmNteWs7YnJlYWs7Y2FzZSJQYXR0ZXJuIjp1PWVbMV18fG51bGw7dSYmKHU9dGhpcy5fcGFyc2UodSx0LGEsaSkpO3JldHVybiBuZXcgUGF0dGVybkNTKHUpO2Nhc2UiSSI6Y2FzZSJJbmRleGVkIjp1PXRoaXMuX3BhcnNlKGVbMV0sdCxhLGkpO2NvbnN0IHk9dC5mZXRjaElmUmVmKGVbMl0pKzEsdz10LmZldGNoSWZSZWYoZVszXSk7cmV0dXJuIG5ldyBJbmRleGVkQ1ModSx5LHcpO2Nhc2UiU2VwYXJhdGlvbiI6Y2FzZSJEZXZpY2VOIjpjb25zdCBTPXQuZmV0Y2hJZlJlZihlWzFdKTtvPUFycmF5LmlzQXJyYXkoUyk/Uy5sZW5ndGg6MTt1PXRoaXMuX3BhcnNlKGVbMl0sdCxhLGkpO2NvbnN0IHg9aS5jcmVhdGUoZVszXSk7cmV0dXJuIG5ldyBBbHRlcm5hdGVDUyhvLHUseCk7Y2FzZSJMYWIiOnM9dC5mZXRjaElmUmVmKGVbMV0pO2Q9cy5nZXRBcnJheSgiV2hpdGVQb2ludCIpO2Y9cy5nZXRBcnJheSgiQmxhY2tQb2ludCIpO2NvbnN0IGs9cy5nZXRBcnJheSgiUmFuZ2UiKTtyZXR1cm4gbmV3IGgoZCxmLGspO2RlZmF1bHQ6dGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoYFVuaW1wbGVtZW50ZWQgQ29sb3JTcGFjZSBvYmplY3Q6ICR7bn1gKX19dGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoYFVucmVjb2duaXplZCBDb2xvclNwYWNlIG9iamVjdDogJHtlfWApfXN0YXRpYyBpc0RlZmF1bHREZWNvZGUoZSx0KXtpZighQXJyYXkuaXNBcnJheShlKSlyZXR1cm4hMDtpZigyKnQhPT1lLmxlbmd0aCl7KDAsci53YXJuKSgiVGhlIGRlY29kZSBtYXAgaXMgbm90IHRoZSBjb3JyZWN0IGxlbmd0aCIpO3JldHVybiEwfWZvcihsZXQgdD0wLGE9ZS5sZW5ndGg7dDxhO3QrPTIpaWYoMCE9PWVbdF18fDEhPT1lW3QrMV0pcmV0dXJuITE7cmV0dXJuITB9c3RhdGljIGdldCBzaW5nbGV0b25zKCl7cmV0dXJuKDAsci5zaGFkb3cpKHRoaXMsInNpbmdsZXRvbnMiLHtnZXQgZ3JheSgpe3JldHVybigwLHIuc2hhZG93KSh0aGlzLCJncmF5IixuZXcgRGV2aWNlR3JheUNTKX0sZ2V0IHJnYigpe3JldHVybigwLHIuc2hhZG93KSh0aGlzLCJyZ2IiLG5ldyBEZXZpY2VSZ2JDUyl9LGdldCBjbXlrKCl7cmV0dXJuKDAsci5zaGFkb3cpKHRoaXMsImNteWsiLG5ldyBvKX19KX19dC5Db2xvclNwYWNlPUNvbG9yU3BhY2U7Y2xhc3MgQWx0ZXJuYXRlQ1MgZXh0ZW5kcyBDb2xvclNwYWNle2NvbnN0cnVjdG9yKGUsdCxhKXtzdXBlcigiQWx0ZXJuYXRlIixlKTt0aGlzLmJhc2U9dDt0aGlzLnRpbnRGbj1hO3RoaXMudG1wQnVmPW5ldyBGbG9hdDMyQXJyYXkodC5udW1Db21wcyl9Z2V0UmdiSXRlbShlLHQsYSxyKXtjb25zdCBuPXRoaXMudG1wQnVmO3RoaXMudGludEZuKGUsdCxuLDApO3RoaXMuYmFzZS5nZXRSZ2JJdGVtKG4sMCxhLHIpfWdldFJnYkJ1ZmZlcihlLHQsYSxyLG4saSxzKXtjb25zdCBvPXRoaXMudGludEZuLGM9dGhpcy5iYXNlLGw9MS8oKDE8PGkpLTEpLGg9Yy5udW1Db21wcyx1PWMudXNlc1plcm9Ub09uZVJhbmdlLGQ9KGMuaXNQYXNzdGhyb3VnaCg4KXx8IXUpJiYwPT09cztsZXQgZj1kP246MDtjb25zdCBnPWQ/cjpuZXcgVWludDhDbGFtcGVkQXJyYXkoaCphKSxwPXRoaXMubnVtQ29tcHMsbT1uZXcgRmxvYXQzMkFycmF5KHApLGI9bmV3IEZsb2F0MzJBcnJheShoKTtsZXQgeSx3O2Zvcih5PTA7eTxhO3krKyl7Zm9yKHc9MDt3PHA7dysrKW1bd109ZVt0KytdKmw7byhtLDAsYiwwKTtpZih1KWZvcih3PTA7dzxoO3crKylnW2YrK109MjU1KmJbd107ZWxzZXtjLmdldFJnYkl0ZW0oYiwwLGcsZik7Zis9aH19ZHx8Yy5nZXRSZ2JCdWZmZXIoZywwLGEscixuLDgscyl9Z2V0T3V0cHV0TGVuZ3RoKGUsdCl7cmV0dXJuIHRoaXMuYmFzZS5nZXRPdXRwdXRMZW5ndGgoZSp0aGlzLmJhc2UubnVtQ29tcHMvdGhpcy5udW1Db21wcyx0KX19Y2xhc3MgUGF0dGVybkNTIGV4dGVuZHMgQ29sb3JTcGFjZXtjb25zdHJ1Y3RvcihlKXtzdXBlcigiUGF0dGVybiIsbnVsbCk7dGhpcy5iYXNlPWV9aXNEZWZhdWx0RGVjb2RlKGUsdCl7KDAsci51bnJlYWNoYWJsZSkoIlNob3VsZCBub3QgY2FsbCBQYXR0ZXJuQ1MuaXNEZWZhdWx0RGVjb2RlIil9fWNsYXNzIEluZGV4ZWRDUyBleHRlbmRzIENvbG9yU3BhY2V7Y29uc3RydWN0b3IoZSx0LGEpe3N1cGVyKCJJbmRleGVkIiwxKTt0aGlzLmJhc2U9ZTt0aGlzLmhpZ2hWYWw9dDtjb25zdCBuPWUubnVtQ29tcHMqdDt0aGlzLmxvb2t1cD1uZXcgVWludDhBcnJheShuKTtpZihhIGluc3RhbmNlb2YgaS5CYXNlU3RyZWFtKXtjb25zdCBlPWEuZ2V0Qnl0ZXMobik7dGhpcy5sb29rdXAuc2V0KGUpfWVsc2V7aWYoInN0cmluZyIhPXR5cGVvZiBhKXRocm93IG5ldyByLkZvcm1hdEVycm9yKGBJbmRleGVkQ1MgLSB1bnJlY29nbml6ZWQgbG9va3VwIHRhYmxlOiAke2F9YCk7Zm9yKGxldCBlPTA7ZTxuOysrZSl0aGlzLmxvb2t1cFtlXT0yNTUmYS5jaGFyQ29kZUF0KGUpfX1nZXRSZ2JJdGVtKGUsdCxhLHIpe2NvbnN0IG49dGhpcy5iYXNlLm51bUNvbXBzLGk9ZVt0XSpuO3RoaXMuYmFzZS5nZXRSZ2JCdWZmZXIodGhpcy5sb29rdXAsaSwxLGEsciw4LDApfWdldFJnYkJ1ZmZlcihlLHQsYSxyLG4saSxzKXtjb25zdCBvPXRoaXMuYmFzZSxjPW8ubnVtQ29tcHMsbD1vLmdldE91dHB1dExlbmd0aChjLHMpLGg9dGhpcy5sb29rdXA7Zm9yKGxldCBpPTA7aTxhOysraSl7Y29uc3QgYT1lW3QrK10qYztvLmdldFJnYkJ1ZmZlcihoLGEsMSxyLG4sOCxzKTtuKz1sfX1nZXRPdXRwdXRMZW5ndGgoZSx0KXtyZXR1cm4gdGhpcy5iYXNlLmdldE91dHB1dExlbmd0aChlKnRoaXMuYmFzZS5udW1Db21wcyx0KX1pc0RlZmF1bHREZWNvZGUoZSx0KXtpZighQXJyYXkuaXNBcnJheShlKSlyZXR1cm4hMDtpZigyIT09ZS5sZW5ndGgpeygwLHIud2FybikoIkRlY29kZSBtYXAgbGVuZ3RoIGlzIG5vdCBjb3JyZWN0Iik7cmV0dXJuITB9aWYoIU51bWJlci5pc0ludGVnZXIodCl8fHQ8MSl7KDAsci53YXJuKSgiQml0cyBwZXIgY29tcG9uZW50IGlzIG5vdCBjb3JyZWN0Iik7cmV0dXJuITB9cmV0dXJuIDA9PT1lWzBdJiZlWzFdPT09KDE8PHQpLTF9fWNsYXNzIERldmljZUdyYXlDUyBleHRlbmRzIENvbG9yU3BhY2V7Y29uc3RydWN0b3IoKXtzdXBlcigiRGV2aWNlR3JheSIsMSl9Z2V0UmdiSXRlbShlLHQsYSxyKXtjb25zdCBuPTI1NSplW3RdO2Fbcl09YVtyKzFdPWFbcisyXT1ufWdldFJnYkJ1ZmZlcihlLHQsYSxyLG4saSxzKXtjb25zdCBvPTI1NS8oKDE8PGkpLTEpO2xldCBjPXQsbD1uO2ZvcihsZXQgdD0wO3Q8YTsrK3Qpe2NvbnN0IHQ9byplW2MrK107cltsKytdPXQ7cltsKytdPXQ7cltsKytdPXQ7bCs9c319Z2V0T3V0cHV0TGVuZ3RoKGUsdCl7cmV0dXJuIGUqKDMrdCl9fWNsYXNzIERldmljZVJnYkNTIGV4dGVuZHMgQ29sb3JTcGFjZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCJEZXZpY2VSR0IiLDMpfWdldFJnYkl0ZW0oZSx0LGEscil7YVtyXT0yNTUqZVt0XTthW3IrMV09MjU1KmVbdCsxXTthW3IrMl09MjU1KmVbdCsyXX1nZXRSZ2JCdWZmZXIoZSx0LGEscixuLGkscyl7aWYoOD09PWkmJjA9PT1zKXtyLnNldChlLnN1YmFycmF5KHQsdCszKmEpLG4pO3JldHVybn1jb25zdCBvPTI1NS8oKDE8PGkpLTEpO2xldCBjPXQsbD1uO2ZvcihsZXQgdD0wO3Q8YTsrK3Qpe3JbbCsrXT1vKmVbYysrXTtyW2wrK109byplW2MrK107cltsKytdPW8qZVtjKytdO2wrPXN9fWdldE91dHB1dExlbmd0aChlLHQpe3JldHVybiBlKigzK3QpLzN8MH1pc1Bhc3N0aHJvdWdoKGUpe3JldHVybiA4PT09ZX19Y29uc3Qgbz1mdW5jdGlvbiBEZXZpY2VDbXlrQ1NDbG9zdXJlKCl7ZnVuY3Rpb24gY29udmVydFRvUmdiKGUsdCxhLHIsbil7Y29uc3QgaT1lW3RdKmEscz1lW3QrMV0qYSxvPWVbdCsyXSphLGM9ZVt0KzNdKmE7cltuXT0yNTUraSooLTQuMzg3MzMyMzg0NjA5OTg4KmkrNTQuNDg2MTUxOTQxODkxNzYqcysxOC44MjI5MDUwMjE2NTMwMipvKzIxMi4yNTY2MjQ1MTYzOTU4NSpjLTI4NS4yMzMxMDI2MTM3MDA0KStzKigxLjcxNDk3NjM0NzczNjIxMzQqcy01LjYwOTY3MzY5MDQwNDczMTUqbystMTcuODczODcwODYxNDE1NDQ0KmMtNS40OTcwMDY0MjcxOTYzNjYpK28qKC0yLjUyMTczNDAxMzE2ODMwMzMqby0yMS4yNDg5MjMzMzczNTMwNzMqYysxNy41MTE5MjcwODQxODEzKStjKigtMjEuODYxMjIxNDc0NjM2MDUqYy0xODkuNDgxODA4MzU5MjI3NDcpO3JbbisxXT0yNTUraSooOC44NDEwNDE0MjIwMzYxNDkqaSs2MC4xMTgwMjcwNDU1OTczNjYqcys2Ljg3MTQyNTU5MjA0OTAwNypvKzMxLjE1OTEwMDEzMDA1NTkyMipjLTc5LjI5NzA4NDQ4MTY1NDgpK3MqKC0xNS4zMTAzNjEzMDY5Njc4MTcqcysxNy41NzUyNTEyNjExMDk0ODIqbysxMzEuMzUyNTA5MTI0OTM5NzYqYy0xOTAuOTQ1MzMwMjU4ODk1MSkrbyooNC40NDQzMzkxMDI4NTI3Mzkqbys5Ljg2MzI4NjE0OTM0MDUqYy0yNC44Njc0MTU4MjU1NTg3OCkrYyooLTIwLjczNzMyNTQ3MTE4MTAzNCpjLTE4Ny44MDQ1MzcwOTcxOTU3OCk7cltuKzJdPTI1NStpKiguODg0MjUyMjQzMDAwMzI5NippKzguMDc4Njc3NTAzMTEyOTI4KnMrMzAuODk5NzgzMDk3MDM3Mjkqby0uMjM4ODMyMzg2ODkxNzg5MzQqYy0xNC4xODM1NzY3OTk2NzMyODYpK3MqKDEwLjQ5NTkzMjczNDMyMDcyKnMrNjMuMDIzNzg0OTQ3NTQwNTIqbys1MC42MDY5NTc2NTYzNjA3MzQqYy0xMTIuMjM4ODQyNTM3MTkyNDgpK28qKC4wMzI5NjA0MTExNDg3MzIxNypvKzExNS42MDM4NDQ0OTY0NjY0MSpjLTE5My41ODIwOTM1Njg2MTUwNSkrYyooLTIyLjMzODE2ODA3MzA5ODg2KmMtMTgwLjEyNjEzOTc0NzA4MzY3KX1yZXR1cm4gY2xhc3MgRGV2aWNlQ215a0NTIGV4dGVuZHMgQ29sb3JTcGFjZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCJEZXZpY2VDTVlLIiw0KX1nZXRSZ2JJdGVtKGUsdCxhLHIpe2NvbnZlcnRUb1JnYihlLHQsMSxhLHIpfWdldFJnYkJ1ZmZlcihlLHQsYSxyLG4saSxzKXtjb25zdCBvPTEvKCgxPDxpKS0xKTtmb3IobGV0IGk9MDtpPGE7aSsrKXtjb252ZXJ0VG9SZ2IoZSx0LG8scixuKTt0Kz00O24rPTMrc319Z2V0T3V0cHV0TGVuZ3RoKGUsdCl7cmV0dXJuIGUvNCooMyt0KXwwfX19KCksYz1mdW5jdGlvbiBDYWxHcmF5Q1NDbG9zdXJlKCl7ZnVuY3Rpb24gY29udmVydFRvUmdiKGUsdCxhLHIsbixpKXtjb25zdCBzPSh0W2FdKmkpKiplLkcsbz1lLllXKnMsYz1NYXRoLm1heCgyOTUuOCpvKiouMzMzMzMzMzMzMzMzMzMzMy00MC44LDApO3Jbbl09YztyW24rMV09YztyW24rMl09Y31yZXR1cm4gY2xhc3MgQ2FsR3JheUNTIGV4dGVuZHMgQ29sb3JTcGFjZXtjb25zdHJ1Y3RvcihlLHQsYSl7c3VwZXIoIkNhbEdyYXkiLDEpO2lmKCFlKXRocm93IG5ldyByLkZvcm1hdEVycm9yKCJXaGl0ZVBvaW50IG1pc3NpbmcgLSByZXF1aXJlZCBmb3IgY29sb3Igc3BhY2UgQ2FsR3JheSIpO3Q9dHx8WzAsMCwwXTthPWF8fDE7dGhpcy5YVz1lWzBdO3RoaXMuWVc9ZVsxXTt0aGlzLlpXPWVbMl07dGhpcy5YQj10WzBdO3RoaXMuWUI9dFsxXTt0aGlzLlpCPXRbMl07dGhpcy5HPWE7aWYodGhpcy5YVzwwfHx0aGlzLlpXPDB8fDEhPT10aGlzLllXKXRocm93IG5ldyByLkZvcm1hdEVycm9yKGBJbnZhbGlkIFdoaXRlUG9pbnQgY29tcG9uZW50cyBmb3IgJHt0aGlzLm5hbWV9LCBubyBmYWxsYmFjayBhdmFpbGFibGVgKTtpZih0aGlzLlhCPDB8fHRoaXMuWUI8MHx8dGhpcy5aQjwwKXsoMCxyLmluZm8pKGBJbnZhbGlkIEJsYWNrUG9pbnQgZm9yICR7dGhpcy5uYW1lfSwgZmFsbGluZyBiYWNrIHRvIGRlZmF1bHQuYCk7dGhpcy5YQj10aGlzLllCPXRoaXMuWkI9MH0wPT09dGhpcy5YQiYmMD09PXRoaXMuWUImJjA9PT10aGlzLlpCfHwoMCxyLndhcm4pKGAke3RoaXMubmFtZX0sIEJsYWNrUG9pbnQ6IFhCOiAke3RoaXMuWEJ9LCBZQjogJHt0aGlzLllCfSwgWkI6ICR7dGhpcy5aQn0sIG9ubHkgZGVmYXVsdCB2YWx1ZXMgYXJlIHN1cHBvcnRlZC5gKTtpZih0aGlzLkc8MSl7KDAsci5pbmZvKShgSW52YWxpZCBHYW1tYTogJHt0aGlzLkd9IGZvciAke3RoaXMubmFtZX0sIGZhbGxpbmcgYmFjayB0byBkZWZhdWx0LmApO3RoaXMuRz0xfX1nZXRSZ2JJdGVtKGUsdCxhLHIpe2NvbnZlcnRUb1JnYih0aGlzLGUsdCxhLHIsMSl9Z2V0UmdiQnVmZmVyKGUsdCxhLHIsbixpLHMpe2NvbnN0IG89MS8oKDE8PGkpLTEpO2ZvcihsZXQgaT0wO2k8YTsrK2kpe2NvbnZlcnRUb1JnYih0aGlzLGUsdCxyLG4sbyk7dCs9MTtuKz0zK3N9fWdldE91dHB1dExlbmd0aChlLHQpe3JldHVybiBlKigzK3QpfX19KCksbD1mdW5jdGlvbiBDYWxSR0JDU0Nsb3N1cmUoKXtjb25zdCBlPW5ldyBGbG9hdDMyQXJyYXkoWy44OTUxLC4yNjY0LC0uMTYxNCwtLjc1MDIsMS43MTM1LC4wMzY3LC4wMzg5LC0uMDY4NSwxLjAyOTZdKSx0PW5ldyBGbG9hdDMyQXJyYXkoWy45ODY5OTI5LC0uMTQ3MDU0MywuMTU5OTYyNywuNDMyMzA1MywuNTE4MzYwMywuMDQ5MjkxMiwtLjAwODUyODcsLjA0MDA0MjgsLjk2ODQ4NjddKSxhPW5ldyBGbG9hdDMyQXJyYXkoWzMuMjQwNDU0MiwtMS41MzcxMzg1LC0uNDk4NTMxNCwtLjk2OTI2NiwxLjg3NjAxMDgsLjA0MTU1NiwuMDU1NjQzNCwtLjIwNDAyNTksMS4wNTcyMjUyXSksbj1uZXcgRmxvYXQzMkFycmF5KFsxLDEsMV0pLGk9bmV3IEZsb2F0MzJBcnJheSgzKSxzPW5ldyBGbG9hdDMyQXJyYXkoMyksbz1uZXcgRmxvYXQzMkFycmF5KDMpO2Z1bmN0aW9uIG1hdHJpeFByb2R1Y3QoZSx0LGEpe2FbMF09ZVswXSp0WzBdK2VbMV0qdFsxXStlWzJdKnRbMl07YVsxXT1lWzNdKnRbMF0rZVs0XSp0WzFdK2VbNV0qdFsyXTthWzJdPWVbNl0qdFswXStlWzddKnRbMV0rZVs4XSp0WzJdfWZ1bmN0aW9uIHNSR0JUcmFuc2ZlckZ1bmN0aW9uKGUpe3JldHVybiBlPD0uMDAzMTMwOD9hZGp1c3RUb1JhbmdlKDAsMSwxMi45MiplKTplPj0uOTk1NTQ1MjU/MTphZGp1c3RUb1JhbmdlKDAsMSwxLjA1NSplKiooMS8yLjQpLS4wNTUpfWZ1bmN0aW9uIGFkanVzdFRvUmFuZ2UoZSx0LGEpe3JldHVybiBNYXRoLm1heChlLE1hdGgubWluKHQsYSkpfWZ1bmN0aW9uIGRlY29kZUwoZSl7cmV0dXJuIGU8MD8tZGVjb2RlTCgtZSk6ZT44PygoZSsxNikvMTE2KSoqMzouMDAxMTA3MDU2NDU5ODc5NDUzOSplfWZ1bmN0aW9uIGNvbnZlcnRUb1JnYihyLGMsbCxoLHUsZCl7Y29uc3QgZj1hZGp1c3RUb1JhbmdlKDAsMSxjW2xdKmQpLGc9YWRqdXN0VG9SYW5nZSgwLDEsY1tsKzFdKmQpLHA9YWRqdXN0VG9SYW5nZSgwLDEsY1tsKzJdKmQpLG09MT09PWY/MTpmKipyLkdSLGI9MT09PWc/MTpnKipyLkdHLHk9MT09PXA/MTpwKipyLkdCLHc9ci5NWEEqbStyLk1YQipiK3IuTVhDKnksUz1yLk1ZQSptK3IuTVlCKmIrci5NWUMqeSx4PXIuTVpBKm0rci5NWkIqYityLk1aQyp5LGs9cztrWzBdPXc7a1sxXT1TO2tbMl09eDtjb25zdCBDPW87IWZ1bmN0aW9uIG5vcm1hbGl6ZVdoaXRlUG9pbnRUb0ZsYXQoYSxyLG4pe2lmKDE9PT1hWzBdJiYxPT09YVsyXSl7blswXT1yWzBdO25bMV09clsxXTtuWzJdPXJbMl07cmV0dXJufWNvbnN0IHM9bjttYXRyaXhQcm9kdWN0KGUscixzKTtjb25zdCBvPWk7IWZ1bmN0aW9uIGNvbnZlcnRUb0ZsYXQoZSx0LGEpe2FbMF09MSp0WzBdL2VbMF07YVsxXT0xKnRbMV0vZVsxXTthWzJdPTEqdFsyXS9lWzJdfShhLHMsbyk7bWF0cml4UHJvZHVjdCh0LG8sbil9KHIud2hpdGVQb2ludCxrLEMpO2NvbnN0IHY9czshZnVuY3Rpb24gY29tcGVuc2F0ZUJsYWNrUG9pbnQoZSx0LGEpe2lmKDA9PT1lWzBdJiYwPT09ZVsxXSYmMD09PWVbMl0pe2FbMF09dFswXTthWzFdPXRbMV07YVsyXT10WzJdO3JldHVybn1jb25zdCByPWRlY29kZUwoMCksbj0oMS1yKS8oMS1kZWNvZGVMKGVbMF0pKSxpPTEtbixzPSgxLXIpLygxLWRlY29kZUwoZVsxXSkpLG89MS1zLGM9KDEtcikvKDEtZGVjb2RlTChlWzJdKSksbD0xLWM7YVswXT10WzBdKm4raTthWzFdPXRbMV0qcytvO2FbMl09dFsyXSpjK2x9KHIuYmxhY2tQb2ludCxDLHYpO2NvbnN0IEY9bzshZnVuY3Rpb24gbm9ybWFsaXplV2hpdGVQb2ludFRvRDY1KGEscixuKXtjb25zdCBzPW47bWF0cml4UHJvZHVjdChlLHIscyk7Y29uc3Qgbz1pOyFmdW5jdGlvbiBjb252ZXJ0VG9ENjUoZSx0LGEpe2FbMF09Ljk1MDQ3KnRbMF0vZVswXTthWzFdPTEqdFsxXS9lWzFdO2FbMl09MS4wODg4Myp0WzJdL2VbMl19KGEscyxvKTttYXRyaXhQcm9kdWN0KHQsbyxuKX0obix2LEYpO2NvbnN0IE89czttYXRyaXhQcm9kdWN0KGEsRixPKTtoW3VdPTI1NSpzUkdCVHJhbnNmZXJGdW5jdGlvbihPWzBdKTtoW3UrMV09MjU1KnNSR0JUcmFuc2ZlckZ1bmN0aW9uKE9bMV0pO2hbdSsyXT0yNTUqc1JHQlRyYW5zZmVyRnVuY3Rpb24oT1syXSl9cmV0dXJuIGNsYXNzIENhbFJHQkNTIGV4dGVuZHMgQ29sb3JTcGFjZXtjb25zdHJ1Y3RvcihlLHQsYSxuKXtzdXBlcigiQ2FsUkdCIiwzKTtpZighZSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiV2hpdGVQb2ludCBtaXNzaW5nIC0gcmVxdWlyZWQgZm9yIGNvbG9yIHNwYWNlIENhbFJHQiIpO3Q9dHx8bmV3IEZsb2F0MzJBcnJheSgzKTthPWF8fG5ldyBGbG9hdDMyQXJyYXkoWzEsMSwxXSk7bj1ufHxuZXcgRmxvYXQzMkFycmF5KFsxLDAsMCwwLDEsMCwwLDAsMV0pO2NvbnN0IGk9ZVswXSxzPWVbMV0sbz1lWzJdO3RoaXMud2hpdGVQb2ludD1lO2NvbnN0IGM9dFswXSxsPXRbMV0saD10WzJdO3RoaXMuYmxhY2tQb2ludD10O3RoaXMuR1I9YVswXTt0aGlzLkdHPWFbMV07dGhpcy5HQj1hWzJdO3RoaXMuTVhBPW5bMF07dGhpcy5NWUE9blsxXTt0aGlzLk1aQT1uWzJdO3RoaXMuTVhCPW5bM107dGhpcy5NWUI9bls0XTt0aGlzLk1aQj1uWzVdO3RoaXMuTVhDPW5bNl07dGhpcy5NWUM9bls3XTt0aGlzLk1aQz1uWzhdO2lmKGk8MHx8bzwwfHwxIT09cyl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcihgSW52YWxpZCBXaGl0ZVBvaW50IGNvbXBvbmVudHMgZm9yICR7dGhpcy5uYW1lfSwgbm8gZmFsbGJhY2sgYXZhaWxhYmxlYCk7aWYoYzwwfHxsPDB8fGg8MCl7KDAsci5pbmZvKShgSW52YWxpZCBCbGFja1BvaW50IGZvciAke3RoaXMubmFtZX0gWyR7Y30sICR7bH0sICR7aH1dLCBmYWxsaW5nIGJhY2sgdG8gZGVmYXVsdC5gKTt0aGlzLmJsYWNrUG9pbnQ9bmV3IEZsb2F0MzJBcnJheSgzKX1pZih0aGlzLkdSPDB8fHRoaXMuR0c8MHx8dGhpcy5HQjwwKXsoMCxyLmluZm8pKGBJbnZhbGlkIEdhbW1hIFske3RoaXMuR1J9LCAke3RoaXMuR0d9LCAke3RoaXMuR0J9XSBmb3IgJHt0aGlzLm5hbWV9LCBmYWxsaW5nIGJhY2sgdG8gZGVmYXVsdC5gKTt0aGlzLkdSPXRoaXMuR0c9dGhpcy5HQj0xfX1nZXRSZ2JJdGVtKGUsdCxhLHIpe2NvbnZlcnRUb1JnYih0aGlzLGUsdCxhLHIsMSl9Z2V0UmdiQnVmZmVyKGUsdCxhLHIsbixpLHMpe2NvbnN0IG89MS8oKDE8PGkpLTEpO2ZvcihsZXQgaT0wO2k8YTsrK2kpe2NvbnZlcnRUb1JnYih0aGlzLGUsdCxyLG4sbyk7dCs9MztuKz0zK3N9fWdldE91dHB1dExlbmd0aChlLHQpe3JldHVybiBlKigzK3QpLzN8MH19fSgpLGg9ZnVuY3Rpb24gTGFiQ1NDbG9zdXJlKCl7ZnVuY3Rpb24gZm5fZyhlKXtsZXQgdDt0PWU+PTYvMjk/ZSoqMzoxMDgvODQxKihlLTQvMjkpO3JldHVybiB0fWZ1bmN0aW9uIGRlY29kZShlLHQsYSxyKXtyZXR1cm4gYStlKihyLWEpL3R9ZnVuY3Rpb24gY29udmVydFRvUmdiKGUsdCxhLHIsbixpKXtsZXQgcz10W2FdLG89dFthKzFdLGM9dFthKzJdO2lmKCExIT09cil7cz1kZWNvZGUocyxyLDAsMTAwKTtvPWRlY29kZShvLHIsZS5hbWluLGUuYW1heCk7Yz1kZWNvZGUoYyxyLGUuYm1pbixlLmJtYXgpfW8+ZS5hbWF4P289ZS5hbWF4Om88ZS5hbWluJiYobz1lLmFtaW4pO2M+ZS5ibWF4P2M9ZS5ibWF4OmM8ZS5ibWluJiYoYz1lLmJtaW4pO2NvbnN0IGw9KHMrMTYpLzExNixoPWwrby81MDAsdT1sLWMvMjAwLGQ9ZS5YVypmbl9nKGgpLGY9ZS5ZVypmbl9nKGwpLGc9ZS5aVypmbl9nKHUpO2xldCBwLG0sYjtpZihlLlpXPDEpe3A9My4xMzM5KmQrLTEuNjE3KmYrLS40OTA2Kmc7bT0tLjk3ODUqZCsxLjkxNipmKy4wMzMzKmc7Yj0uMDcyKmQrLS4yMjkqZisxLjQwNTcqZ31lbHNle3A9My4yNDA2KmQrLTEuNTM3MipmKy0uNDk4NipnO209LS45Njg5KmQrMS44NzU4KmYrLjA0MTUqZztiPS4wNTU3KmQrLS4yMDQqZisxLjA1NypnfW5baV09MjU1Kk1hdGguc3FydChwKTtuW2krMV09MjU1Kk1hdGguc3FydChtKTtuW2krMl09MjU1Kk1hdGguc3FydChiKX1yZXR1cm4gY2xhc3MgTGFiQ1MgZXh0ZW5kcyBDb2xvclNwYWNle2NvbnN0cnVjdG9yKGUsdCxhKXtzdXBlcigiTGFiIiwzKTtpZighZSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiV2hpdGVQb2ludCBtaXNzaW5nIC0gcmVxdWlyZWQgZm9yIGNvbG9yIHNwYWNlIExhYiIpO3Q9dHx8WzAsMCwwXTthPWF8fFstMTAwLDEwMCwtMTAwLDEwMF07dGhpcy5YVz1lWzBdO3RoaXMuWVc9ZVsxXTt0aGlzLlpXPWVbMl07dGhpcy5hbWluPWFbMF07dGhpcy5hbWF4PWFbMV07dGhpcy5ibWluPWFbMl07dGhpcy5ibWF4PWFbM107dGhpcy5YQj10WzBdO3RoaXMuWUI9dFsxXTt0aGlzLlpCPXRbMl07aWYodGhpcy5YVzwwfHx0aGlzLlpXPDB8fDEhPT10aGlzLllXKXRocm93IG5ldyByLkZvcm1hdEVycm9yKCJJbnZhbGlkIFdoaXRlUG9pbnQgY29tcG9uZW50cywgbm8gZmFsbGJhY2sgYXZhaWxhYmxlIik7aWYodGhpcy5YQjwwfHx0aGlzLllCPDB8fHRoaXMuWkI8MCl7KDAsci5pbmZvKSgiSW52YWxpZCBCbGFja1BvaW50LCBmYWxsaW5nIGJhY2sgdG8gZGVmYXVsdCIpO3RoaXMuWEI9dGhpcy5ZQj10aGlzLlpCPTB9aWYodGhpcy5hbWluPnRoaXMuYW1heHx8dGhpcy5ibWluPnRoaXMuYm1heCl7KDAsci5pbmZvKSgiSW52YWxpZCBSYW5nZSwgZmFsbGluZyBiYWNrIHRvIGRlZmF1bHRzIik7dGhpcy5hbWluPS0xMDA7dGhpcy5hbWF4PTEwMDt0aGlzLmJtaW49LTEwMDt0aGlzLmJtYXg9MTAwfX1nZXRSZ2JJdGVtKGUsdCxhLHIpe2NvbnZlcnRUb1JnYih0aGlzLGUsdCwhMSxhLHIpfWdldFJnYkJ1ZmZlcihlLHQsYSxyLG4saSxzKXtjb25zdCBvPSgxPDxpKS0xO2ZvcihsZXQgaT0wO2k8YTtpKyspe2NvbnZlcnRUb1JnYih0aGlzLGUsdCxvLHIsbik7dCs9MztuKz0zK3N9fWdldE91dHB1dExlbmd0aChlLHQpe3JldHVybiBlKigzK3QpLzN8MH1pc0RlZmF1bHREZWNvZGUoZSx0KXtyZXR1cm4hMH1nZXQgdXNlc1plcm9Ub09uZVJhbmdlKCl7cmV0dXJuKDAsci5zaGFkb3cpKHRoaXMsInVzZXNaZXJvVG9PbmVSYW5nZSIsITEpfX19KCl9LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5QYXJ0aWFsRXZhbHVhdG9yPXQuRXZhbHVhdG9yUHJlcHJvY2Vzc29yPXZvaWQgMDt2YXIgcj1hKDIpLG49YSgxNiksaT1hKDUpLHM9YSgzNCksbz1hKDM4KSxjPWEoMzcpLGw9YSg0MSksaD1hKDQwKSx1PWEoNTApLGQ9YSg1MSksZj1hKDQyKSxnPWEoNTcpLHA9YSgxNyksbT1hKDU5KSxiPWEoMTApLHk9YSg3KSx3PWEoNjApLFM9YSgxNCkseD1hKDE5KSxrPWEoMzkpLEM9YSg2KSx2PWEoNDUpLEY9YSg2MSksTz1hKDYyKSxUPWEoNjMpO2NvbnN0IE09T2JqZWN0LmZyZWV6ZSh7bWF4SW1hZ2VTaXplOi0xLGRpc2FibGVGb250RmFjZTohMSxpZ25vcmVFcnJvcnM6ITEsaXNFdmFsU3VwcG9ydGVkOiEwLGZvbnRFeHRyYVByb3BlcnRpZXM6ITEsdXNlU3lzdGVtRm9udHM6ITAsY01hcFVybDpudWxsLHN0YW5kYXJkRm9udERhdGFVcmw6bnVsbH0pLEU9MSxEPTIsTj1Qcm9taXNlLnJlc29sdmUoKTtmdW5jdGlvbiBub3JtYWxpemVCbGVuZE1vZGUoZSx0PSExKXtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IobGV0IHQ9MCxhPWUubGVuZ3RoO3Q8YTt0Kyspe2NvbnN0IGE9bm9ybWFsaXplQmxlbmRNb2RlKGVbdF0sITApO2lmKGEpcmV0dXJuIGF9KDAsci53YXJuKShgVW5zdXBwb3J0ZWQgYmxlbmQgbW9kZSBBcnJheTogJHtlfWApO3JldHVybiJzb3VyY2Utb3ZlciJ9aWYoIShlIGluc3RhbmNlb2YgaS5OYW1lKSlyZXR1cm4gdD9udWxsOiJzb3VyY2Utb3ZlciI7c3dpdGNoKGUubmFtZSl7Y2FzZSJOb3JtYWwiOmNhc2UiQ29tcGF0aWJsZSI6cmV0dXJuInNvdXJjZS1vdmVyIjtjYXNlIk11bHRpcGx5IjpyZXR1cm4ibXVsdGlwbHkiO2Nhc2UiU2NyZWVuIjpyZXR1cm4ic2NyZWVuIjtjYXNlIk92ZXJsYXkiOnJldHVybiJvdmVybGF5IjtjYXNlIkRhcmtlbiI6cmV0dXJuImRhcmtlbiI7Y2FzZSJMaWdodGVuIjpyZXR1cm4ibGlnaHRlbiI7Y2FzZSJDb2xvckRvZGdlIjpyZXR1cm4iY29sb3ItZG9kZ2UiO2Nhc2UiQ29sb3JCdXJuIjpyZXR1cm4iY29sb3ItYnVybiI7Y2FzZSJIYXJkTGlnaHQiOnJldHVybiJoYXJkLWxpZ2h0IjtjYXNlIlNvZnRMaWdodCI6cmV0dXJuInNvZnQtbGlnaHQiO2Nhc2UiRGlmZmVyZW5jZSI6cmV0dXJuImRpZmZlcmVuY2UiO2Nhc2UiRXhjbHVzaW9uIjpyZXR1cm4iZXhjbHVzaW9uIjtjYXNlIkh1ZSI6cmV0dXJuImh1ZSI7Y2FzZSJTYXR1cmF0aW9uIjpyZXR1cm4ic2F0dXJhdGlvbiI7Y2FzZSJDb2xvciI6cmV0dXJuImNvbG9yIjtjYXNlIkx1bWlub3NpdHkiOnJldHVybiJsdW1pbm9zaXR5In1pZih0KXJldHVybiBudWxsOygwLHIud2FybikoYFVuc3VwcG9ydGVkIGJsZW5kIG1vZGU6ICR7ZS5uYW1lfWApO3JldHVybiJzb3VyY2Utb3ZlciJ9ZnVuY3Rpb24gaW5jcmVtZW50Q2FjaGVkSW1hZ2VNYXNrQ291bnQoZSl7ZS5mbj09PXIuT1BTLnBhaW50SW1hZ2VNYXNrWE9iamVjdCYmZS5hcmdzWzBdJiZlLmFyZ3NbMF0uY291bnQ+MCYmZS5hcmdzWzBdLmNvdW50Kyt9Y2xhc3MgVGltZVNsb3RNYW5hZ2Vye3N0YXRpYyBnZXQgVElNRV9TTE9UX0RVUkFUSU9OX01TKCl7cmV0dXJuKDAsci5zaGFkb3cpKHRoaXMsIlRJTUVfU0xPVF9EVVJBVElPTl9NUyIsMjApfXN0YXRpYyBnZXQgQ0hFQ0tfVElNRV9FVkVSWSgpe3JldHVybigwLHIuc2hhZG93KSh0aGlzLCJDSEVDS19USU1FX0VWRVJZIiwxMDApfWNvbnN0cnVjdG9yKCl7dGhpcy5yZXNldCgpfWNoZWNrKCl7aWYoKyt0aGlzLmNoZWNrZWQ8VGltZVNsb3RNYW5hZ2VyLkNIRUNLX1RJTUVfRVZFUlkpcmV0dXJuITE7dGhpcy5jaGVja2VkPTA7cmV0dXJuIHRoaXMuZW5kVGltZTw9RGF0ZS5ub3coKX1yZXNldCgpe3RoaXMuZW5kVGltZT1EYXRlLm5vdygpK1RpbWVTbG90TWFuYWdlci5USU1FX1NMT1RfRFVSQVRJT05fTVM7dGhpcy5jaGVja2VkPTB9fWNsYXNzIFBhcnRpYWxFdmFsdWF0b3J7Y29uc3RydWN0b3Ioe3hyZWY6ZSxoYW5kbGVyOnQscGFnZUluZGV4OmEsaWRGYWN0b3J5OnIsZm9udENhY2hlOm4sYnVpbHRJbkNNYXBDYWNoZTppLHN0YW5kYXJkRm9udERhdGFDYWNoZTpzLGdsb2JhbEltYWdlQ2FjaGU6byxvcHRpb25zOmM9bnVsbH0pe3RoaXMueHJlZj1lO3RoaXMuaGFuZGxlcj10O3RoaXMucGFnZUluZGV4PWE7dGhpcy5pZEZhY3Rvcnk9cjt0aGlzLmZvbnRDYWNoZT1uO3RoaXMuYnVpbHRJbkNNYXBDYWNoZT1pO3RoaXMuc3RhbmRhcmRGb250RGF0YUNhY2hlPXM7dGhpcy5nbG9iYWxJbWFnZUNhY2hlPW87dGhpcy5vcHRpb25zPWN8fE07dGhpcy5wYXJzaW5nVHlwZTNGb250PSExO3RoaXMuX2ZldGNoQnVpbHRJbkNNYXBCb3VuZD10aGlzLmZldGNoQnVpbHRJbkNNYXAuYmluZCh0aGlzKX1nZXQgX3BkZkZ1bmN0aW9uRmFjdG9yeSgpe2NvbnN0IGU9bmV3IGcuUERGRnVuY3Rpb25GYWN0b3J5KHt4cmVmOnRoaXMueHJlZixpc0V2YWxTdXBwb3J0ZWQ6dGhpcy5vcHRpb25zLmlzRXZhbFN1cHBvcnRlZH0pO3JldHVybigwLHIuc2hhZG93KSh0aGlzLCJfcGRmRnVuY3Rpb25GYWN0b3J5IixlKX1jbG9uZShlPW51bGwpe2NvbnN0IHQ9T2JqZWN0LmNyZWF0ZSh0aGlzKTt0Lm9wdGlvbnM9T2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLHRoaXMub3B0aW9ucyxlKTtyZXR1cm4gdH1oYXNCbGVuZE1vZGVzKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgaS5EaWN0KSlyZXR1cm4hMTtpZihlLm9iaklkJiZ0LmhhcyhlLm9iaklkKSlyZXR1cm4hMTtjb25zdCBhPW5ldyBpLlJlZlNldCh0KTtlLm9iaklkJiZhLnB1dChlLm9iaklkKTtjb25zdCBuPVtlXSxzPXRoaXMueHJlZjtmb3IoO24ubGVuZ3RoOyl7Y29uc3QgZT1uLnNoaWZ0KCksdD1lLmdldCgiRXh0R1N0YXRlIik7aWYodCBpbnN0YW5jZW9mIGkuRGljdClmb3IobGV0IGUgb2YgdC5nZXRSYXdWYWx1ZXMoKSl7aWYoZSBpbnN0YW5jZW9mIGkuUmVmKXtpZihhLmhhcyhlKSljb250aW51ZTt0cnl7ZT1zLmZldGNoKGUpfWNhdGNoKHQpe2EucHV0KGUpOygwLHIuaW5mbykoYGhhc0JsZW5kTW9kZXMgLSBpZ25vcmluZyBFeHRHU3RhdGU6ICIke3R9Ii5gKTtjb250aW51ZX19aWYoIShlIGluc3RhbmNlb2YgaS5EaWN0KSljb250aW51ZTtlLm9iaklkJiZhLnB1dChlLm9iaklkKTtjb25zdCB0PWUuZ2V0KCJCTSIpO2lmKHQgaW5zdGFuY2VvZiBpLk5hbWUpe2lmKCJOb3JtYWwiIT09dC5uYW1lKXJldHVybiEwfWVsc2UgaWYodm9pZCAwIT09dCYmQXJyYXkuaXNBcnJheSh0KSlmb3IoY29uc3QgZSBvZiB0KWlmKGUgaW5zdGFuY2VvZiBpLk5hbWUmJiJOb3JtYWwiIT09ZS5uYW1lKXJldHVybiEwfWNvbnN0IG89ZS5nZXQoIlhPYmplY3QiKTtpZihvIGluc3RhbmNlb2YgaS5EaWN0KWZvcihsZXQgZSBvZiBvLmdldFJhd1ZhbHVlcygpKXtpZihlIGluc3RhbmNlb2YgaS5SZWYpe2lmKGEuaGFzKGUpKWNvbnRpbnVlO3RyeXtlPXMuZmV0Y2goZSl9Y2F0Y2godCl7YS5wdXQoZSk7KDAsci5pbmZvKShgaGFzQmxlbmRNb2RlcyAtIGlnbm9yaW5nIFhPYmplY3Q6ICIke3R9Ii5gKTtjb250aW51ZX19aWYoIShlIGluc3RhbmNlb2YgeS5CYXNlU3RyZWFtKSljb250aW51ZTtlLmRpY3Qub2JqSWQmJmEucHV0KGUuZGljdC5vYmpJZCk7Y29uc3QgdD1lLmRpY3QuZ2V0KCJSZXNvdXJjZXMiKTtpZih0IGluc3RhbmNlb2YgaS5EaWN0JiYoIXQub2JqSWR8fCFhLmhhcyh0Lm9iaklkKSkpe24ucHVzaCh0KTt0Lm9iaklkJiZhLnB1dCh0Lm9iaklkKX19fWZvcihjb25zdCBlIG9mIGEpdC5wdXQoZSk7cmV0dXJuITF9YXN5bmMgZmV0Y2hCdWlsdEluQ01hcChlKXtjb25zdCB0PXRoaXMuYnVpbHRJbkNNYXBDYWNoZS5nZXQoZSk7aWYodClyZXR1cm4gdDtsZXQgYTtpZihudWxsIT09dGhpcy5vcHRpb25zLmNNYXBVcmwpe2NvbnN0IHQ9YCR7dGhpcy5vcHRpb25zLmNNYXBVcmx9JHtlfS5iY21hcGAsbj1hd2FpdCBmZXRjaCh0KTtpZighbi5vayl0aHJvdyBuZXcgRXJyb3IoYGZldGNoQnVpbHRJbkNNYXA6IGZhaWxlZCB0byBmZXRjaCBmaWxlICIke3R9IiB3aXRoICIke24uc3RhdHVzVGV4dH0iLmApO2E9e2NNYXBEYXRhOm5ldyBVaW50OEFycmF5KGF3YWl0IG4uYXJyYXlCdWZmZXIoKSksY29tcHJlc3Npb25UeXBlOnIuQ01hcENvbXByZXNzaW9uVHlwZS5CSU5BUll9fWVsc2UgYT1hd2FpdCB0aGlzLmhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKCJGZXRjaEJ1aWx0SW5DTWFwIix7bmFtZTplfSk7YS5jb21wcmVzc2lvblR5cGUhPT1yLkNNYXBDb21wcmVzc2lvblR5cGUuTk9ORSYmdGhpcy5idWlsdEluQ01hcENhY2hlLnNldChlLGEpO3JldHVybiBhfWFzeW5jIGZldGNoU3RhbmRhcmRGb250RGF0YShlKXtjb25zdCB0PXRoaXMuc3RhbmRhcmRGb250RGF0YUNhY2hlLmdldChlKTtpZih0KXJldHVybiBuZXcgYi5TdHJlYW0odCk7aWYodGhpcy5vcHRpb25zLnVzZVN5c3RlbUZvbnRzJiYiU3ltYm9sIiE9PWUmJiJaYXBmRGluZ2JhdHMiIT09ZSlyZXR1cm4gbnVsbDtjb25zdCBhPSgwLGwuZ2V0Rm9udE5hbWVUb0ZpbGVNYXApKClbZV07bGV0IG47aWYobnVsbCE9PXRoaXMub3B0aW9ucy5zdGFuZGFyZEZvbnREYXRhVXJsKXtjb25zdCBlPWAke3RoaXMub3B0aW9ucy5zdGFuZGFyZEZvbnREYXRhVXJsfSR7YX1gLHQ9YXdhaXQgZmV0Y2goZSk7dC5vaz9uPWF3YWl0IHQuYXJyYXlCdWZmZXIoKTooMCxyLndhcm4pKGBmZXRjaFN0YW5kYXJkRm9udERhdGE6IGZhaWxlZCB0byBmZXRjaCBmaWxlICIke2V9IiB3aXRoICIke3Quc3RhdHVzVGV4dH0iLmApfWVsc2UgdHJ5e249YXdhaXQgdGhpcy5oYW5kbGVyLnNlbmRXaXRoUHJvbWlzZSgiRmV0Y2hTdGFuZGFyZEZvbnREYXRhIix7ZmlsZW5hbWU6YX0pfWNhdGNoKGUpeygwLHIud2FybikoYGZldGNoU3RhbmRhcmRGb250RGF0YTogZmFpbGVkIHRvIGZldGNoIGZpbGUgIiR7YX0iIHdpdGggIiR7ZX0iLmApfWlmKCFuKXJldHVybiBudWxsO3RoaXMuc3RhbmRhcmRGb250RGF0YUNhY2hlLnNldChlLG4pO3JldHVybiBuZXcgYi5TdHJlYW0obil9YXN5bmMgYnVpbGRGb3JtWE9iamVjdChlLHQsYSxuLHMsbyxjKXtjb25zdCBsPXQuZGljdCxoPWwuZ2V0QXJyYXkoIk1hdHJpeCIpO2xldCB1LGQsZj1sLmdldEFycmF5KCJCQm94Iik7Zj1BcnJheS5pc0FycmF5KGYpJiY0PT09Zi5sZW5ndGg/ci5VdGlsLm5vcm1hbGl6ZVJlY3QoZik6bnVsbDtsLmhhcygiT0MiKSYmKHU9YXdhaXQgdGhpcy5wYXJzZU1hcmtlZENvbnRlbnRQcm9wcyhsLmdldCgiT0MiKSxlKSk7dm9pZCAwIT09dSYmbi5hZGRPcChyLk9QUy5iZWdpbk1hcmtlZENvbnRlbnRQcm9wcyxbIk9DIix1XSk7Y29uc3QgZz1sLmdldCgiR3JvdXAiKTtpZihnKXtkPXttYXRyaXg6aCxiYm94OmYsc21hc2s6YSxpc29sYXRlZDohMSxrbm9ja291dDohMX07Y29uc3QgdD1nLmdldCgiUyIpO2xldCBzPW51bGw7aWYoKDAsaS5pc05hbWUpKHQsIlRyYW5zcGFyZW5jeSIpKXtkLmlzb2xhdGVkPWcuZ2V0KCJJIil8fCExO2Qua25vY2tvdXQ9Zy5nZXQoIksiKXx8ITE7aWYoZy5oYXMoIkNTIikpe2NvbnN0IHQ9Zy5nZXRSYXcoIkNTIiksYT1TLkNvbG9yU3BhY2UuZ2V0Q2FjaGVkKHQsdGhpcy54cmVmLGMpO3M9YXx8YXdhaXQgdGhpcy5wYXJzZUNvbG9yU3BhY2Uoe2NzOnQscmVzb3VyY2VzOmUsbG9jYWxDb2xvclNwYWNlQ2FjaGU6Y30pfX1pZihhJiZhLmJhY2tkcm9wKXtzPXN8fFMuQ29sb3JTcGFjZS5zaW5nbGV0b25zLnJnYjthLmJhY2tkcm9wPXMuZ2V0UmdiKGEuYmFja2Ryb3AsMCl9bi5hZGRPcChyLk9QUy5iZWdpbkdyb3VwLFtkXSl9Y29uc3QgcD1nP1toLG51bGxdOltoLGZdO24uYWRkT3Aoci5PUFMucGFpbnRGb3JtWE9iamVjdEJlZ2luLHApO3JldHVybiB0aGlzLmdldE9wZXJhdG9yTGlzdCh7c3RyZWFtOnQsdGFzazpzLHJlc291cmNlczpsLmdldCgiUmVzb3VyY2VzIil8fGUsb3BlcmF0b3JMaXN0Om4saW5pdGlhbFN0YXRlOm99KS50aGVuKChmdW5jdGlvbigpe24uYWRkT3Aoci5PUFMucGFpbnRGb3JtWE9iamVjdEVuZCxbXSk7ZyYmbi5hZGRPcChyLk9QUy5lbmRHcm91cCxbZF0pO3ZvaWQgMCE9PXUmJm4uYWRkT3Aoci5PUFMuZW5kTWFya2VkQ29udGVudCxbXSl9KSl9X3NlbmRJbWdEYXRhKGUsdCxhPSExKXtjb25zdCByPXQ/W3QuYml0bWFwfHx0LmRhdGEuYnVmZmVyXTpudWxsO3JldHVybiB0aGlzLnBhcnNpbmdUeXBlM0ZvbnR8fGE/dGhpcy5oYW5kbGVyLnNlbmQoImNvbW1vbm9iaiIsW2UsIkltYWdlIix0XSxyKTp0aGlzLmhhbmRsZXIuc2VuZCgib2JqIixbZSx0aGlzLnBhZ2VJbmRleCwiSW1hZ2UiLHRdLHIpfWFzeW5jIGJ1aWxkUGFpbnRJbWFnZVhPYmplY3Qoe3Jlc291cmNlczplLGltYWdlOnQsaXNJbmxpbmU6YT0hMSxvcGVyYXRvckxpc3Q6bixjYWNoZUtleTppLGxvY2FsSW1hZ2VDYWNoZTpzLGxvY2FsQ29sb3JTcGFjZUNhY2hlOm99KXtjb25zdCBjPXQuZGljdCxsPWMub2JqSWQsaD1jLmdldCgiVyIsIldpZHRoIiksdT1jLmdldCgiSCIsIkhlaWdodCIpO2lmKCFofHwibnVtYmVyIiE9dHlwZW9mIGh8fCF1fHwibnVtYmVyIiE9dHlwZW9mIHUpeygwLHIud2FybikoIkltYWdlIGRpbWVuc2lvbnMgYXJlIG1pc3NpbmcsIG9yIG5vdCBudW1iZXJzLiIpO3JldHVybn1jb25zdCBkPXRoaXMub3B0aW9ucy5tYXhJbWFnZVNpemU7aWYoLTEhPT1kJiZoKnU+ZCl7Y29uc3QgZT0iSW1hZ2UgZXhjZWVkZWQgbWF4aW11bSBhbGxvd2VkIHNpemUgYW5kIHdhcyByZW1vdmVkLiI7aWYodGhpcy5vcHRpb25zLmlnbm9yZUVycm9ycyl7KDAsci53YXJuKShlKTtyZXR1cm59dGhyb3cgbmV3IEVycm9yKGUpfWxldCBmO2MuaGFzKCJPQyIpJiYoZj1hd2FpdCB0aGlzLnBhcnNlTWFya2VkQ29udGVudFByb3BzKGMuZ2V0KCJPQyIpLGUpKTtsZXQgZyxwO2lmKGMuZ2V0KCJJTSIsIkltYWdlTWFzayIpfHwhMSl7Y29uc3QgZT1jLmdldCgiSSIsIkludGVycG9sYXRlIiksYT1oKzc+PjMsbz10LmdldEJ5dGVzKGEqdSksZD1jLmdldEFycmF5KCJEIiwiRGVjb2RlIik7aWYodGhpcy5wYXJzaW5nVHlwZTNGb250KXtnPVQuUERGSW1hZ2UuY3JlYXRlUmF3TWFzayh7aW1nQXJyYXk6byx3aWR0aDpoLGhlaWdodDp1LGltYWdlSXNGcm9tRGVjb2RlU3RyZWFtOnQgaW5zdGFuY2VvZiB4LkRlY29kZVN0cmVhbSxpbnZlcnNlRGVjb2RlOiEhZCYmZFswXT4wLGludGVycG9sYXRlOmV9KTtnLmNhY2hlZD0hIWk7cD1bZ107bi5hZGRJbWFnZU9wcyhyLk9QUy5wYWludEltYWdlTWFza1hPYmplY3QscCxmKTtpJiZzLnNldChpLGwse2ZuOnIuT1BTLnBhaW50SW1hZ2VNYXNrWE9iamVjdCxhcmdzOnAsb3B0aW9uYWxDb250ZW50OmZ9KTtyZXR1cm59Zz1ULlBERkltYWdlLmNyZWF0ZU1hc2soe2ltZ0FycmF5Om8sd2lkdGg6aCxoZWlnaHQ6dSxpbWFnZUlzRnJvbURlY29kZVN0cmVhbTp0IGluc3RhbmNlb2YgeC5EZWNvZGVTdHJlYW0saW52ZXJzZURlY29kZTohIWQmJmRbMF0+MCxpbnRlcnBvbGF0ZTplfSk7aWYoZy5pc1NpbmdsZU9wYXF1ZVBpeGVsKXtuLmFkZEltYWdlT3BzKHIuT1BTLnBhaW50U29saWRDb2xvckltYWdlTWFzayxbXSxmKTtpJiZzLnNldChpLGwse2ZuOnIuT1BTLnBhaW50U29saWRDb2xvckltYWdlTWFzayxhcmdzOltdLG9wdGlvbmFsQ29udGVudDpmfSk7cmV0dXJufWNvbnN0IG09YG1hc2tfJHt0aGlzLmlkRmFjdG9yeS5jcmVhdGVPYmpJZCgpfWA7bi5hZGREZXBlbmRlbmN5KG0pO3RoaXMuX3NlbmRJbWdEYXRhKG0sZyk7cD1be2RhdGE6bSx3aWR0aDpnLndpZHRoLGhlaWdodDpnLmhlaWdodCxpbnRlcnBvbGF0ZTpnLmludGVycG9sYXRlLGNvdW50OjF9XTtuLmFkZEltYWdlT3BzKHIuT1BTLnBhaW50SW1hZ2VNYXNrWE9iamVjdCxwLGYpO2kmJnMuc2V0KGksbCx7Zm46ci5PUFMucGFpbnRJbWFnZU1hc2tYT2JqZWN0LGFyZ3M6cCxvcHRpb25hbENvbnRlbnQ6Zn0pO3JldHVybn1jb25zdCBtPWMuZ2V0KCJTTSIsIlNNYXNrIil8fCExLGI9Yy5nZXQoIk1hc2siKXx8ITE7aWYoYSYmIW0mJiFiJiZoK3U8MjAwKXtjb25zdCBpPW5ldyBULlBERkltYWdlKHt4cmVmOnRoaXMueHJlZixyZXM6ZSxpbWFnZTp0LGlzSW5saW5lOmEscGRmRnVuY3Rpb25GYWN0b3J5OnRoaXMuX3BkZkZ1bmN0aW9uRmFjdG9yeSxsb2NhbENvbG9yU3BhY2VDYWNoZTpvfSk7Zz1pLmNyZWF0ZUltYWdlRGF0YSghMCk7bi5hZGRJbWFnZU9wcyhyLk9QUy5wYWludElubGluZUltYWdlWE9iamVjdCxbZ10sZik7cmV0dXJufWxldCB5PWBpbWdfJHt0aGlzLmlkRmFjdG9yeS5jcmVhdGVPYmpJZCgpfWAsdz0hMTtpZih0aGlzLnBhcnNpbmdUeXBlM0ZvbnQpeT1gJHt0aGlzLmlkRmFjdG9yeS5nZXREb2NJZCgpfV90eXBlM18ke3l9YDtlbHNlIGlmKGwpe3c9dGhpcy5nbG9iYWxJbWFnZUNhY2hlLnNob3VsZENhY2hlKGwsdGhpcy5wYWdlSW5kZXgpO3cmJih5PWAke3RoaXMuaWRGYWN0b3J5LmdldERvY0lkKCl9XyR7eX1gKX1uLmFkZERlcGVuZGVuY3koeSk7cD1beSxoLHVdO1QuUERGSW1hZ2UuYnVpbGRJbWFnZSh7eHJlZjp0aGlzLnhyZWYscmVzOmUsaW1hZ2U6dCxpc0lubGluZTphLHBkZkZ1bmN0aW9uRmFjdG9yeTp0aGlzLl9wZGZGdW5jdGlvbkZhY3RvcnksbG9jYWxDb2xvclNwYWNlQ2FjaGU6b30pLnRoZW4oKGU9PntnPWUuY3JlYXRlSW1hZ2VEYXRhKCExKTtpJiZsJiZ3JiZ0aGlzLmdsb2JhbEltYWdlQ2FjaGUuYWRkQnl0ZVNpemUobCxnLmRhdGEubGVuZ3RoKTtyZXR1cm4gdGhpcy5fc2VuZEltZ0RhdGEoeSxnLHcpfSkpLmNhdGNoKChlPT57KDAsci53YXJuKShgVW5hYmxlIHRvIGRlY29kZSBpbWFnZSAiJHt5fSI6ICIke2V9Ii5gKTtyZXR1cm4gdGhpcy5fc2VuZEltZ0RhdGEoeSxudWxsLHcpfSkpO24uYWRkSW1hZ2VPcHMoci5PUFMucGFpbnRJbWFnZVhPYmplY3QscCxmKTtpZihpKXtzLnNldChpLGwse2ZuOnIuT1BTLnBhaW50SW1hZ2VYT2JqZWN0LGFyZ3M6cCxvcHRpb25hbENvbnRlbnQ6Zn0pO2lmKGwpeygwLHIuYXNzZXJ0KSghYSwiQ2Fubm90IGNhY2hlIGFuIGlubGluZSBpbWFnZSBnbG9iYWxseS4iKTt0aGlzLmdsb2JhbEltYWdlQ2FjaGUuYWRkUGFnZUluZGV4KGwsdGhpcy5wYWdlSW5kZXgpO3cmJnRoaXMuZ2xvYmFsSW1hZ2VDYWNoZS5zZXREYXRhKGwse29iaklkOnksZm46ci5PUFMucGFpbnRJbWFnZVhPYmplY3QsYXJnczpwLG9wdGlvbmFsQ29udGVudDpmLGJ5dGVTaXplOjB9KX19fWhhbmRsZVNNYXNrKGUsdCxhLHIsbixpKXtjb25zdCBzPWUuZ2V0KCJHIiksbz17c3VidHlwZTplLmdldCgiUyIpLm5hbWUsYmFja2Ryb3A6ZS5nZXQoIkJDIil9LGM9ZS5nZXQoIlRSIik7aWYoKDAsZy5pc1BERkZ1bmN0aW9uKShjKSl7Y29uc3QgZT10aGlzLl9wZGZGdW5jdGlvbkZhY3RvcnkuY3JlYXRlKGMpLHQ9bmV3IFVpbnQ4QXJyYXkoMjU2KSxhPW5ldyBGbG9hdDMyQXJyYXkoMSk7Zm9yKGxldCByPTA7cjwyNTY7cisrKXthWzBdPXIvMjU1O2UoYSwwLGEsMCk7dFtyXT0yNTUqYVswXXwwfW8udHJhbnNmZXJNYXA9dH1yZXR1cm4gdGhpcy5idWlsZEZvcm1YT2JqZWN0KHQscyxvLGEscixuLnN0YXRlLmNsb25lKCksaSl9aGFuZGxlVHJhbnNmZXJGdW5jdGlvbihlKXtsZXQgdDtpZihBcnJheS5pc0FycmF5KGUpKXQ9ZTtlbHNle2lmKCEoMCxnLmlzUERGRnVuY3Rpb24pKGUpKXJldHVybiBudWxsO3Q9W2VdfWNvbnN0IGE9W107bGV0IHI9MCxuPTA7Zm9yKGNvbnN0IGUgb2YgdCl7Y29uc3QgdD10aGlzLnhyZWYuZmV0Y2hJZlJlZihlKTtyKys7aWYoKDAsaS5pc05hbWUpKHQsIklkZW50aXR5Iikpe2EucHVzaChudWxsKTtjb250aW51ZX1pZighKDAsZy5pc1BERkZ1bmN0aW9uKSh0KSlyZXR1cm4gbnVsbDtjb25zdCBzPXRoaXMuX3BkZkZ1bmN0aW9uRmFjdG9yeS5jcmVhdGUodCksbz1uZXcgVWludDhBcnJheSgyNTYpLGM9bmV3IEZsb2F0MzJBcnJheSgxKTtmb3IobGV0IGU9MDtlPDI1NjtlKyspe2NbMF09ZS8yNTU7cyhjLDAsYywwKTtvW2VdPTI1NSpjWzBdfDB9YS5wdXNoKG8pO24rK31yZXR1cm4gMSE9PXImJjQhPT1yfHwwPT09bj9udWxsOmF9aGFuZGxlVGlsaW5nVHlwZShlLHQsYSxuLHMsbyxjLGwpe2NvbnN0IGg9bmV3IE8uT3BlcmF0b3JMaXN0LGQ9aS5EaWN0Lm1lcmdlKHt4cmVmOnRoaXMueHJlZixkaWN0QXJyYXk6W3MuZ2V0KCJSZXNvdXJjZXMiKSxhXX0pO3JldHVybiB0aGlzLmdldE9wZXJhdG9yTGlzdCh7c3RyZWFtOm4sdGFzazpjLHJlc291cmNlczpkLG9wZXJhdG9yTGlzdDpofSkudGhlbigoZnVuY3Rpb24oKXtjb25zdCBhPWguZ2V0SVIoKSxyPSgwLHUuZ2V0VGlsaW5nUGF0dGVybklSKShhLHMsdCk7by5hZGREZXBlbmRlbmNpZXMoaC5kZXBlbmRlbmNpZXMpO28uYWRkT3AoZSxyKTtzLm9iaklkJiZsLnNldChudWxsLHMub2JqSWQse29wZXJhdG9yTGlzdElSOmEsZGljdDpzfSl9KSkuY2F0Y2goKGU9PntpZighKGUgaW5zdGFuY2VvZiByLkFib3J0RXhjZXB0aW9uKSl7aWYoIXRoaXMub3B0aW9ucy5pZ25vcmVFcnJvcnMpdGhyb3cgZTt0aGlzLmhhbmRsZXIuc2VuZCgiVW5zdXBwb3J0ZWRGZWF0dXJlIix7ZmVhdHVyZUlkOnIuVU5TVVBQT1JURURfRkVBVFVSRVMuZXJyb3JUaWxpbmdQYXR0ZXJufSk7KDAsci53YXJuKShgaGFuZGxlVGlsaW5nVHlwZSAtIGlnbm9yaW5nIHBhdHRlcm46ICIke2V9Ii5gKX19KSl9aGFuZGxlU2V0Rm9udChlLHQsYSxuLG8sYyxsPW51bGwsaD1udWxsKXtjb25zdCB1PXQmJnRbMF1pbnN0YW5jZW9mIGkuTmFtZT90WzBdLm5hbWU6bnVsbDtyZXR1cm4gdGhpcy5sb2FkRm9udCh1LGEsZSxsLGgpLnRoZW4oKHQ9PnQuZm9udC5pc1R5cGUzRm9udD90LmxvYWRUeXBlM0RhdGEodGhpcyxlLG8pLnRoZW4oKGZ1bmN0aW9uKCl7bi5hZGREZXBlbmRlbmNpZXModC50eXBlM0RlcGVuZGVuY2llcyk7cmV0dXJuIHR9KSkuY2F0Y2goKGU9Pnt0aGlzLmhhbmRsZXIuc2VuZCgiVW5zdXBwb3J0ZWRGZWF0dXJlIix7ZmVhdHVyZUlkOnIuVU5TVVBQT1JURURfRkVBVFVSRVMuZXJyb3JGb250TG9hZFR5cGUzfSk7cmV0dXJuIG5ldyBUcmFuc2xhdGVkRm9udCh7bG9hZGVkTmFtZToiZ19mb250X2Vycm9yIixmb250Om5ldyBzLkVycm9yRm9udChgVHlwZTMgZm9udCBsb2FkIGVycm9yOiAke2V9YCksZGljdDp0LmZvbnQsZXZhbHVhdG9yT3B0aW9uczp0aGlzLm9wdGlvbnN9KX0pKTp0KSkudGhlbigoZT0+e2MuZm9udD1lLmZvbnQ7ZS5zZW5kKHRoaXMuaGFuZGxlcik7cmV0dXJuIGUubG9hZGVkTmFtZX0pKX1oYW5kbGVUZXh0KGUsdCl7Y29uc3QgYT10LmZvbnQsbj1hLmNoYXJzVG9HbHlwaHMoZSk7aWYoYS5kYXRhKXsoISEodC50ZXh0UmVuZGVyaW5nTW9kZSZyLlRleHRSZW5kZXJpbmdNb2RlLkFERF9UT19QQVRIX0ZMQUcpfHwiUGF0dGVybiI9PT10LmZpbGxDb2xvclNwYWNlLm5hbWV8fGEuZGlzYWJsZUZvbnRGYWNlfHx0aGlzLm9wdGlvbnMuZGlzYWJsZUZvbnRGYWNlKSYmUGFydGlhbEV2YWx1YXRvci5idWlsZEZvbnRQYXRocyhhLG4sdGhpcy5oYW5kbGVyLHRoaXMub3B0aW9ucyl9cmV0dXJuIG59ZW5zdXJlU3RhdGVGb250KGUpe2lmKGUuZm9udClyZXR1cm47Y29uc3QgdD1uZXcgci5Gb3JtYXRFcnJvcigiTWlzc2luZyBzZXRGb250IChUZikgb3BlcmF0b3IgYmVmb3JlIHRleHQgcmVuZGVyaW5nIG9wZXJhdG9yLiIpO2lmKCF0aGlzLm9wdGlvbnMuaWdub3JlRXJyb3JzKXRocm93IHQ7dGhpcy5oYW5kbGVyLnNlbmQoIlVuc3VwcG9ydGVkRmVhdHVyZSIse2ZlYXR1cmVJZDpyLlVOU1VQUE9SVEVEX0ZFQVRVUkVTLmVycm9yRm9udFN0YXRlfSk7KDAsci53YXJuKShgZW5zdXJlU3RhdGVGb250OiAiJHt0fSIuYCl9YXN5bmMgc2V0R1N0YXRlKHtyZXNvdXJjZXM6ZSxnU3RhdGU6dCxvcGVyYXRvckxpc3Q6YSxjYWNoZUtleTpuLHRhc2s6cyxzdGF0ZU1hbmFnZXI6byxsb2NhbEdTdGF0ZUNhY2hlOmMsbG9jYWxDb2xvclNwYWNlQ2FjaGU6bH0pe2NvbnN0IGg9dC5vYmpJZDtsZXQgdT0hMDtjb25zdCBkPVtdLGY9dC5nZXRLZXlzKCk7bGV0IGc9UHJvbWlzZS5yZXNvbHZlKCk7Zm9yKGxldCBuPTAsYz1mLmxlbmd0aDtuPGM7bisrKXtjb25zdCBjPWZbbl0saD10LmdldChjKTtzd2l0Y2goYyl7Y2FzZSJUeXBlIjpicmVhaztjYXNlIkxXIjpjYXNlIkxDIjpjYXNlIkxKIjpjYXNlIk1MIjpjYXNlIkQiOmNhc2UiUkkiOmNhc2UiRkwiOmNhc2UiQ0EiOmNhc2UiY2EiOmQucHVzaChbYyxoXSk7YnJlYWs7Y2FzZSJGb250Ijp1PSExO2c9Zy50aGVuKCgoKT0+dGhpcy5oYW5kbGVTZXRGb250KGUsbnVsbCxoWzBdLGEscyxvLnN0YXRlKS50aGVuKChmdW5jdGlvbihlKXthLmFkZERlcGVuZGVuY3koZSk7ZC5wdXNoKFtjLFtlLGhbMV1dXSl9KSkpKTticmVhaztjYXNlIkJNIjpkLnB1c2goW2Msbm9ybWFsaXplQmxlbmRNb2RlKGgpXSk7YnJlYWs7Y2FzZSJTTWFzayI6aWYoKDAsaS5pc05hbWUpKGgsIk5vbmUiKSl7ZC5wdXNoKFtjLCExXSk7YnJlYWt9aWYoaCBpbnN0YW5jZW9mIGkuRGljdCl7dT0hMTtnPWcudGhlbigoKCk9PnRoaXMuaGFuZGxlU01hc2soaCxlLGEscyxvLGwpKSk7ZC5wdXNoKFtjLCEwXSl9ZWxzZSgwLHIud2FybikoIlVuc3VwcG9ydGVkIFNNYXNrIHR5cGUiKTticmVhaztjYXNlIlRSIjpjb25zdCB0PXRoaXMuaGFuZGxlVHJhbnNmZXJGdW5jdGlvbihoKTtkLnB1c2goW2MsdF0pO2JyZWFrO2Nhc2UiT1AiOmNhc2Uib3AiOmNhc2UiT1BNIjpjYXNlIkJHIjpjYXNlIkJHMiI6Y2FzZSJVQ1IiOmNhc2UiVUNSMiI6Y2FzZSJUUjIiOmNhc2UiSFQiOmNhc2UiU00iOmNhc2UiU0EiOmNhc2UiQUlTIjpjYXNlIlRLIjooMCxyLmluZm8pKCJncmFwaGljIHN0YXRlIG9wZXJhdG9yICIrYyk7YnJlYWs7ZGVmYXVsdDooMCxyLmluZm8pKCJVbmtub3duIGdyYXBoaWMgc3RhdGUgb3BlcmF0b3IgIitjKX19cmV0dXJuIGcudGhlbigoZnVuY3Rpb24oKXtkLmxlbmd0aD4wJiZhLmFkZE9wKHIuT1BTLnNldEdTdGF0ZSxbZF0pO3UmJmMuc2V0KG4saCxkKX0pKX1sb2FkRm9udChlLHQsYSxuPW51bGwsYz1udWxsKXtjb25zdCBlcnJvckZvbnQ9YXN5bmMoKT0+bmV3IFRyYW5zbGF0ZWRGb250KHtsb2FkZWROYW1lOiJnX2ZvbnRfZXJyb3IiLGZvbnQ6bmV3IHMuRXJyb3JGb250KGBGb250ICIke2V9IiBpcyBub3QgYXZhaWxhYmxlLmApLGRpY3Q6dCxldmFsdWF0b3JPcHRpb25zOnRoaXMub3B0aW9uc30pLGw9dGhpcy54cmVmO2xldCBoO2lmKHQpdCBpbnN0YW5jZW9mIGkuUmVmJiYoaD10KTtlbHNle2NvbnN0IHQ9YS5nZXQoIkZvbnQiKTt0JiYoaD10LmdldFJhdyhlKSl9aWYoIWgpe2NvbnN0IGE9YEZvbnQgIiR7ZXx8dCYmdC50b1N0cmluZygpfSIgaXMgbm90IGF2YWlsYWJsZWA7aWYoIXRoaXMub3B0aW9ucy5pZ25vcmVFcnJvcnMmJiF0aGlzLnBhcnNpbmdUeXBlM0ZvbnQpeygwLHIud2FybikoYCR7YX0uYCk7cmV0dXJuIGVycm9yRm9udCgpfXRoaXMuaGFuZGxlci5zZW5kKCJVbnN1cHBvcnRlZEZlYXR1cmUiLHtmZWF0dXJlSWQ6ci5VTlNVUFBPUlRFRF9GRUFUVVJFUy5lcnJvckZvbnRNaXNzaW5nfSk7KDAsci53YXJuKShgJHthfSAtLSBhdHRlbXB0aW5nIHRvIGZhbGxiYWNrIHRvIGEgZGVmYXVsdCBmb250LmApO2g9bnx8UGFydGlhbEV2YWx1YXRvci5mYWxsYmFja0ZvbnREaWN0fWlmKHRoaXMucGFyc2luZ1R5cGUzRm9udCYmdGhpcy50eXBlM0ZvbnRSZWZzLmhhcyhoKSlyZXR1cm4gZXJyb3JGb250KCk7aWYodGhpcy5mb250Q2FjaGUuaGFzKGgpKXJldHVybiB0aGlzLmZvbnRDYWNoZS5nZXQoaCk7aWYoISgodD1sLmZldGNoSWZSZWYoaCkpaW5zdGFuY2VvZiBpLkRpY3QpKXJldHVybiBlcnJvckZvbnQoKTtpZih0LmNhY2hlS2V5JiZ0aGlzLmZvbnRDYWNoZS5oYXModC5jYWNoZUtleSkpcmV0dXJuIHRoaXMuZm9udENhY2hlLmdldCh0LmNhY2hlS2V5KTtjb25zdCB1PSgwLHIuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7bGV0IGQ7dHJ5e2Q9dGhpcy5wcmVFdmFsdWF0ZUZvbnQodCk7ZC5jc3NGb250SW5mbz1jfWNhdGNoKGUpeygwLHIud2FybikoYGxvYWRGb250IC0gcHJlRXZhbHVhdGVGb250IGZhaWxlZDogIiR7ZX0iLmApO3JldHVybiBlcnJvckZvbnQoKX1jb25zdHtkZXNjcmlwdG9yOmYsaGFzaDpnfT1kLHA9aCBpbnN0YW5jZW9mIGkuUmVmO2xldCBtO3AmJihtPWBmJHtoLnRvU3RyaW5nKCl9YCk7aWYoZyYmZiBpbnN0YW5jZW9mIGkuRGljdCl7Zi5mb250QWxpYXNlc3x8KGYuZm9udEFsaWFzZXM9T2JqZWN0LmNyZWF0ZShudWxsKSk7Y29uc3QgZT1mLmZvbnRBbGlhc2VzO2lmKGVbZ10pe2NvbnN0IHQ9ZVtnXS5hbGlhc1JlZjtpZihwJiZ0JiZ0aGlzLmZvbnRDYWNoZS5oYXModCkpe3RoaXMuZm9udENhY2hlLnB1dEFsaWFzKGgsdCk7cmV0dXJuIHRoaXMuZm9udENhY2hlLmdldChoKX19ZWxzZSBlW2ddPXtmb250SUQ6dGhpcy5pZEZhY3RvcnkuY3JlYXRlRm9udElkKCl9O3AmJihlW2ddLmFsaWFzUmVmPWgpO209ZVtnXS5mb250SUR9aWYocCl0aGlzLmZvbnRDYWNoZS5wdXQoaCx1LnByb21pc2UpO2Vsc2V7bXx8KG09dGhpcy5pZEZhY3RvcnkuY3JlYXRlRm9udElkKCkpO3QuY2FjaGVLZXk9YGNhY2hlS2V5XyR7bX1gO3RoaXMuZm9udENhY2hlLnB1dCh0LmNhY2hlS2V5LHUucHJvbWlzZSl9KDAsci5hc3NlcnQpKG0mJm0uc3RhcnRzV2l0aCgiZiIpLCdUaGUgImZvbnRJRCIgbXVzdCBiZSAoY29ycmVjdGx5KSBkZWZpbmVkLicpO3QubG9hZGVkTmFtZT1gJHt0aGlzLmlkRmFjdG9yeS5nZXREb2NJZCgpfV8ke219YDt0aGlzLnRyYW5zbGF0ZUZvbnQoZCkudGhlbigoZT0+e3ZvaWQgMCE9PWUuZm9udFR5cGUmJmwuc3RhdHMuYWRkRm9udFR5cGUoZS5mb250VHlwZSk7dS5yZXNvbHZlKG5ldyBUcmFuc2xhdGVkRm9udCh7bG9hZGVkTmFtZTp0LmxvYWRlZE5hbWUsZm9udDplLGRpY3Q6dCxldmFsdWF0b3JPcHRpb25zOnRoaXMub3B0aW9uc30pKX0pKS5jYXRjaCgoZT0+e3RoaXMuaGFuZGxlci5zZW5kKCJVbnN1cHBvcnRlZEZlYXR1cmUiLHtmZWF0dXJlSWQ6ci5VTlNVUFBPUlRFRF9GRUFUVVJFUy5lcnJvckZvbnRUcmFuc2xhdGV9KTsoMCxyLndhcm4pKGBsb2FkRm9udCAtIHRyYW5zbGF0ZUZvbnQgZmFpbGVkOiAiJHtlfSIuYCk7dHJ5e2NvbnN0IGU9ZiYmZi5nZXQoIkZvbnRGaWxlMyIpLHQ9ZSYmZS5nZXQoIlN1YnR5cGUiKSxhPSgwLG8uZ2V0Rm9udFR5cGUpKGQudHlwZSx0JiZ0Lm5hbWUpO3ZvaWQgMCE9PWEmJmwuc3RhdHMuYWRkRm9udFR5cGUoYSl9Y2F0Y2goZSl7fXUucmVzb2x2ZShuZXcgVHJhbnNsYXRlZEZvbnQoe2xvYWRlZE5hbWU6dC5sb2FkZWROYW1lLGZvbnQ6bmV3IHMuRXJyb3JGb250KGUgaW5zdGFuY2VvZiBFcnJvcj9lLm1lc3NhZ2U6ZSksZGljdDp0LGV2YWx1YXRvck9wdGlvbnM6dGhpcy5vcHRpb25zfSkpfSkpO3JldHVybiB1LnByb21pc2V9YnVpbGRQYXRoKGUsdCxhLG49ITEpe2NvbnN0IGk9ZS5sZW5ndGgtMTthfHwoYT1bXSk7bGV0IHM7aWYoaTwwfHxlLmZuQXJyYXlbaV0hPT1yLk9QUy5jb25zdHJ1Y3RQYXRoKXtpZihuKXsoMCxyLndhcm4pKGBFbmNvdW50ZXJlZCBwYXRoIG9wZXJhdG9yICIke3R9IiBpbnNpZGUgb2YgYSB0ZXh0IG9iamVjdC5gKTtlLmFkZE9wKHIuT1BTLnNhdmUsbnVsbCl9cz1bMS8wLC0xLzAsMS8wLC0xLzBdO2UuYWRkT3Aoci5PUFMuY29uc3RydWN0UGF0aCxbW3RdLGEsc10pO24mJmUuYWRkT3Aoci5PUFMucmVzdG9yZSxudWxsKX1lbHNle2NvbnN0IHI9ZS5hcmdzQXJyYXlbaV07clswXS5wdXNoKHQpO0FycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJbMV0sYSk7cz1yWzJdfXN3aXRjaCh0KXtjYXNlIHIuT1BTLnJlY3RhbmdsZTpzWzBdPU1hdGgubWluKHNbMF0sYVswXSxhWzBdK2FbMl0pO3NbMV09TWF0aC5tYXgoc1sxXSxhWzBdLGFbMF0rYVsyXSk7c1syXT1NYXRoLm1pbihzWzJdLGFbMV0sYVsxXSthWzNdKTtzWzNdPU1hdGgubWF4KHNbM10sYVsxXSxhWzFdK2FbM10pO2JyZWFrO2Nhc2Ugci5PUFMubW92ZVRvOmNhc2Ugci5PUFMubGluZVRvOnNbMF09TWF0aC5taW4oc1swXSxhWzBdKTtzWzFdPU1hdGgubWF4KHNbMV0sYVswXSk7c1syXT1NYXRoLm1pbihzWzJdLGFbMV0pO3NbM109TWF0aC5tYXgoc1szXSxhWzFdKX19cGFyc2VDb2xvclNwYWNlKHtjczplLHJlc291cmNlczp0LGxvY2FsQ29sb3JTcGFjZUNhY2hlOmF9KXtyZXR1cm4gUy5Db2xvclNwYWNlLnBhcnNlQXN5bmMoe2NzOmUseHJlZjp0aGlzLnhyZWYscmVzb3VyY2VzOnQscGRmRnVuY3Rpb25GYWN0b3J5OnRoaXMuX3BkZkZ1bmN0aW9uRmFjdG9yeSxsb2NhbENvbG9yU3BhY2VDYWNoZTphfSkuY2F0Y2goKGU9PntpZihlIGluc3RhbmNlb2Ygci5BYm9ydEV4Y2VwdGlvbilyZXR1cm4gbnVsbDtpZih0aGlzLm9wdGlvbnMuaWdub3JlRXJyb3JzKXt0aGlzLmhhbmRsZXIuc2VuZCgiVW5zdXBwb3J0ZWRGZWF0dXJlIix7ZmVhdHVyZUlkOnIuVU5TVVBQT1JURURfRkVBVFVSRVMuZXJyb3JDb2xvclNwYWNlfSk7KDAsci53YXJuKShgcGFyc2VDb2xvclNwYWNlIC0gaWdub3JpbmcgQ29sb3JTcGFjZTogIiR7ZX0iLmApO3JldHVybiBudWxsfXRocm93IGV9KSl9cGFyc2VTaGFkaW5nKHtzaGFkaW5nOmUscmVzb3VyY2VzOnQsbG9jYWxDb2xvclNwYWNlQ2FjaGU6YSxsb2NhbFNoYWRpbmdQYXR0ZXJuQ2FjaGU6cn0pe2xldCBuPXIuZ2V0KGUpO2lmKCFuKXtjb25zdCBpPXUuUGF0dGVybi5wYXJzZVNoYWRpbmcoZSx0aGlzLnhyZWYsdCx0aGlzLmhhbmRsZXIsdGhpcy5fcGRmRnVuY3Rpb25GYWN0b3J5LGEpLmdldElSKCk7bj1gcGF0dGVybl8ke3RoaXMuaWRGYWN0b3J5LmNyZWF0ZU9iaklkKCl9YDtyLnNldChlLG4pO3RoaXMuaGFuZGxlci5zZW5kKCJvYmoiLFtuLHRoaXMucGFnZUluZGV4LCJQYXR0ZXJuIixpXSl9cmV0dXJuIG59aGFuZGxlQ29sb3JOKGUsdCxhLG4scyxvLGMsbCxoLGQpe2NvbnN0IGY9YS5wb3AoKTtpZihmIGluc3RhbmNlb2YgaS5OYW1lKXtjb25zdCBnPXMuZ2V0UmF3KGYubmFtZSkscD1nIGluc3RhbmNlb2YgaS5SZWYmJmguZ2V0QnlSZWYoZyk7aWYocCl0cnl7Y29uc3Qgcj1uLmJhc2U/bi5iYXNlLmdldFJnYihhLDApOm51bGwsaT0oMCx1LmdldFRpbGluZ1BhdHRlcm5JUikocC5vcGVyYXRvckxpc3RJUixwLmRpY3Qscik7ZS5hZGRPcCh0LGkpO3JldHVybn1jYXRjaChlKXt9Y29uc3QgbT10aGlzLnhyZWYuZmV0Y2hJZlJlZihnKTtpZihtKXtjb25zdCBpPW0gaW5zdGFuY2VvZiB5LkJhc2VTdHJlYW0/bS5kaWN0Om0scz1pLmdldCgiUGF0dGVyblR5cGUiKTtpZihzPT09RSl7Y29uc3Qgcj1uLmJhc2U/bi5iYXNlLmdldFJnYihhLDApOm51bGw7cmV0dXJuIHRoaXMuaGFuZGxlVGlsaW5nVHlwZSh0LHIsbyxtLGksZSxjLGgpfWlmKHM9PT1EKXtjb25zdCBhPWkuZ2V0KCJTaGFkaW5nIikscj1pLmdldEFycmF5KCJNYXRyaXgiKSxuPXRoaXMucGFyc2VTaGFkaW5nKHtzaGFkaW5nOmEscmVzb3VyY2VzOm8sbG9jYWxDb2xvclNwYWNlQ2FjaGU6bCxsb2NhbFNoYWRpbmdQYXR0ZXJuQ2FjaGU6ZH0pO2UuYWRkT3AodCxbIlNoYWRpbmciLG4scl0pO3JldHVybn10aHJvdyBuZXcgci5Gb3JtYXRFcnJvcihgVW5rbm93biBQYXR0ZXJuVHlwZTogJHtzfWApfX10aHJvdyBuZXcgci5Gb3JtYXRFcnJvcihgVW5rbm93biBQYXR0ZXJuTmFtZTogJHtmfWApfV9wYXJzZVZpc2liaWxpdHlFeHByZXNzaW9uKGUsdCxhKXtpZigrK3Q+MTApeygwLHIud2FybikoIlZpc2liaWxpdHkgZXhwcmVzc2lvbiBpcyB0b28gZGVlcGx5IG5lc3RlZCIpO3JldHVybn1jb25zdCBuPWUubGVuZ3RoLHM9dGhpcy54cmVmLmZldGNoSWZSZWYoZVswXSk7aWYoIShuPDIpJiZzIGluc3RhbmNlb2YgaS5OYW1lKXtzd2l0Y2gocy5uYW1lKXtjYXNlIkFuZCI6Y2FzZSJPciI6Y2FzZSJOb3QiOmEucHVzaChzLm5hbWUpO2JyZWFrO2RlZmF1bHQ6KDAsci53YXJuKShgSW52YWxpZCBvcGVyYXRvciAke3MubmFtZX0gaW4gdmlzaWJpbGl0eSBleHByZXNzaW9uYCk7cmV0dXJufWZvcihsZXQgcj0xO3I8bjtyKyspe2NvbnN0IG49ZVtyXSxzPXRoaXMueHJlZi5mZXRjaElmUmVmKG4pO2lmKEFycmF5LmlzQXJyYXkocykpe2NvbnN0IGU9W107YS5wdXNoKGUpO3RoaXMuX3BhcnNlVmlzaWJpbGl0eUV4cHJlc3Npb24ocyx0LGUpfWVsc2UgbiBpbnN0YW5jZW9mIGkuUmVmJiZhLnB1c2gobi50b1N0cmluZygpKX19ZWxzZSgwLHIud2FybikoIkludmFsaWQgdmlzaWJpbGl0eSBleHByZXNzaW9uIil9YXN5bmMgcGFyc2VNYXJrZWRDb250ZW50UHJvcHMoZSx0KXtsZXQgYTtpZihlIGluc3RhbmNlb2YgaS5OYW1lKXthPXQuZ2V0KCJQcm9wZXJ0aWVzIikuZ2V0KGUubmFtZSl9ZWxzZXtpZighKGUgaW5zdGFuY2VvZiBpLkRpY3QpKXRocm93IG5ldyByLkZvcm1hdEVycm9yKCJPcHRpb25hbCBjb250ZW50IHByb3BlcnRpZXMgbWFsZm9ybWVkLiIpO2E9ZX1jb25zdCBuPWEuZ2V0KCJUeXBlIikubmFtZTtpZigiT0NHIj09PW4pcmV0dXJue3R5cGU6bixpZDphLm9iaklkfTtpZigiT0NNRCI9PT1uKXtjb25zdCBlPWEuZ2V0KCJWRSIpO2lmKEFycmF5LmlzQXJyYXkoZSkpe2NvbnN0IHQ9W107dGhpcy5fcGFyc2VWaXNpYmlsaXR5RXhwcmVzc2lvbihlLDAsdCk7aWYodC5sZW5ndGg+MClyZXR1cm57dHlwZToiT0NNRCIsZXhwcmVzc2lvbjp0fX1jb25zdCB0PWEuZ2V0KCJPQ0dzIik7aWYoQXJyYXkuaXNBcnJheSh0KXx8dCBpbnN0YW5jZW9mIGkuRGljdCl7Y29uc3QgZT1bXTtpZihBcnJheS5pc0FycmF5KHQpKWZvcihjb25zdCBhIG9mIHQpZS5wdXNoKGEudG9TdHJpbmcoKSk7ZWxzZSBlLnB1c2godC5vYmpJZCk7cmV0dXJue3R5cGU6bixpZHM6ZSxwb2xpY3k6YS5nZXQoIlAiKWluc3RhbmNlb2YgaS5OYW1lP2EuZ2V0KCJQIikubmFtZTpudWxsLGV4cHJlc3Npb246bnVsbH19aWYodCBpbnN0YW5jZW9mIGkuUmVmKXJldHVybnt0eXBlOm4saWQ6dC50b1N0cmluZygpfX1yZXR1cm4gbnVsbH1nZXRPcGVyYXRvckxpc3Qoe3N0cmVhbTplLHRhc2s6dCxyZXNvdXJjZXM6YSxvcGVyYXRvckxpc3Q6bixpbml0aWFsU3RhdGU6cz1udWxsLGZhbGxiYWNrRm9udERpY3Q6bz1udWxsfSl7YT1hfHxpLkRpY3QuZW1wdHk7cz1zfHxuZXcgRXZhbFN0YXRlO2lmKCFuKXRocm93IG5ldyBFcnJvcignZ2V0T3BlcmF0b3JMaXN0OiBtaXNzaW5nICJvcGVyYXRvckxpc3QiIHBhcmFtZXRlcicpO2NvbnN0IGM9dGhpcyxsPXRoaXMueHJlZjtsZXQgaD0hMTtjb25zdCB1PW5ldyBtLkxvY2FsSW1hZ2VDYWNoZSxkPW5ldyBtLkxvY2FsQ29sb3JTcGFjZUNhY2hlLGY9bmV3IG0uTG9jYWxHU3RhdGVDYWNoZSxnPW5ldyBtLkxvY2FsVGlsaW5nUGF0dGVybkNhY2hlLHA9bmV3IE1hcCxiPWEuZ2V0KCJYT2JqZWN0Iil8fGkuRGljdC5lbXB0eSx3PWEuZ2V0KCJQYXR0ZXJuIil8fGkuRGljdC5lbXB0eSx4PW5ldyBTdGF0ZU1hbmFnZXIocyksaz1uZXcgRXZhbHVhdG9yUHJlcHJvY2Vzc29yKGUsbCx4KSxDPW5ldyBUaW1lU2xvdE1hbmFnZXI7ZnVuY3Rpb24gY2xvc2VQZW5kaW5nUmVzdG9yZU9QUyhlKXtmb3IobGV0IGU9MCx0PWsuc2F2ZWRTdGF0ZXNEZXB0aDtlPHQ7ZSsrKW4uYWRkT3Aoci5PUFMucmVzdG9yZSxbXSl9cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbiBwcm9taXNlQm9keShlLHMpe2NvbnN0IG5leHQ9ZnVuY3Rpb24odCl7UHJvbWlzZS5hbGwoW3Qsbi5yZWFkeV0pLnRoZW4oKGZ1bmN0aW9uKCl7dHJ5e3Byb21pc2VCb2R5KGUscyl9Y2F0Y2goZSl7cyhlKX19KSxzKX07dC5lbnN1cmVOb3RUZXJtaW5hdGVkKCk7Qy5yZXNldCgpO2NvbnN0IG09e307bGV0IHYsRixPLFQsTSxFO2Zvcig7ISh2PUMuY2hlY2soKSk7KXttLmFyZ3M9bnVsbDtpZighay5yZWFkKG0pKWJyZWFrO2xldCBlPW0uYXJncyxzPW0uZm47c3dpdGNoKDB8cyl7Y2FzZSByLk9QUy5wYWludFhPYmplY3Q6RT1lWzBdaW5zdGFuY2VvZiBpLk5hbWU7TT1lWzBdLm5hbWU7aWYoRSl7Y29uc3QgdD11LmdldEJ5TmFtZShNKTtpZih0KXtuLmFkZEltYWdlT3BzKHQuZm4sdC5hcmdzLHQub3B0aW9uYWxDb250ZW50KTtpbmNyZW1lbnRDYWNoZWRJbWFnZU1hc2tDb3VudCh0KTtlPW51bGw7Y29udGludWV9fW5leHQobmV3IFByb21pc2UoKGZ1bmN0aW9uKGUscyl7aWYoIUUpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoIlhPYmplY3QgbXVzdCBiZSByZWZlcnJlZCB0byBieSBuYW1lLiIpO2xldCBvPWIuZ2V0UmF3KE0pO2lmKG8gaW5zdGFuY2VvZiBpLlJlZil7Y29uc3QgdD11LmdldEJ5UmVmKG8pO2lmKHQpe24uYWRkSW1hZ2VPcHModC5mbix0LmFyZ3MsdC5vcHRpb25hbENvbnRlbnQpO2luY3JlbWVudENhY2hlZEltYWdlTWFza0NvdW50KHQpO2UoKTtyZXR1cm59Y29uc3QgYT1jLmdsb2JhbEltYWdlQ2FjaGUuZ2V0RGF0YShvLGMucGFnZUluZGV4KTtpZihhKXtuLmFkZERlcGVuZGVuY3koYS5vYmpJZCk7bi5hZGRJbWFnZU9wcyhhLmZuLGEuYXJncyxhLm9wdGlvbmFsQ29udGVudCk7ZSgpO3JldHVybn1vPWwuZmV0Y2gobyl9aWYoIShvIGluc3RhbmNlb2YgeS5CYXNlU3RyZWFtKSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiWE9iamVjdCBzaG91bGQgYmUgYSBzdHJlYW0iKTtjb25zdCBoPW8uZGljdC5nZXQoIlN1YnR5cGUiKTtpZighKGggaW5zdGFuY2VvZiBpLk5hbWUpKXRocm93IG5ldyByLkZvcm1hdEVycm9yKCJYT2JqZWN0IHNob3VsZCBoYXZlIGEgTmFtZSBzdWJ0eXBlIik7aWYoIkZvcm0iIT09aC5uYW1lKWlmKCJJbWFnZSIhPT1oLm5hbWUpe2lmKCJQUyIhPT1oLm5hbWUpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoYFVuaGFuZGxlZCBYT2JqZWN0IHN1YnR5cGUgJHtoLm5hbWV9YCk7KDAsci5pbmZvKSgiSWdub3JlZCBYT2JqZWN0IHN1YnR5cGUgUFMiKTtlKCl9ZWxzZSBjLmJ1aWxkUGFpbnRJbWFnZVhPYmplY3Qoe3Jlc291cmNlczphLGltYWdlOm8sb3BlcmF0b3JMaXN0Om4sY2FjaGVLZXk6TSxsb2NhbEltYWdlQ2FjaGU6dSxsb2NhbENvbG9yU3BhY2VDYWNoZTpkfSkudGhlbihlLHMpO2Vsc2V7eC5zYXZlKCk7Yy5idWlsZEZvcm1YT2JqZWN0KGEsbyxudWxsLG4sdCx4LnN0YXRlLmNsb25lKCksZCkudGhlbigoZnVuY3Rpb24oKXt4LnJlc3RvcmUoKTtlKCl9KSxzKX19KSkuY2F0Y2goKGZ1bmN0aW9uKGUpe2lmKCEoZSBpbnN0YW5jZW9mIHIuQWJvcnRFeGNlcHRpb24pKXtpZighYy5vcHRpb25zLmlnbm9yZUVycm9ycyl0aHJvdyBlO2MuaGFuZGxlci5zZW5kKCJVbnN1cHBvcnRlZEZlYXR1cmUiLHtmZWF0dXJlSWQ6ci5VTlNVUFBPUlRFRF9GRUFUVVJFUy5lcnJvclhPYmplY3R9KTsoMCxyLndhcm4pKGBnZXRPcGVyYXRvckxpc3QgLSBpZ25vcmluZyBYT2JqZWN0OiAiJHtlfSIuYCl9fSkpKTtyZXR1cm47Y2FzZSByLk9QUy5zZXRGb250OnZhciBEPWVbMV07bmV4dChjLmhhbmRsZVNldEZvbnQoYSxlLG51bGwsbix0LHguc3RhdGUsbykudGhlbigoZnVuY3Rpb24oZSl7bi5hZGREZXBlbmRlbmN5KGUpO24uYWRkT3Aoci5PUFMuc2V0Rm9udCxbZSxEXSl9KSkpO3JldHVybjtjYXNlIHIuT1BTLmJlZ2luVGV4dDpoPSEwO2JyZWFrO2Nhc2Ugci5PUFMuZW5kVGV4dDpoPSExO2JyZWFrO2Nhc2Ugci5PUFMuZW5kSW5saW5lSW1hZ2U6dmFyIFI9ZVswXS5jYWNoZUtleTtpZihSKXtjb25zdCB0PXUuZ2V0QnlOYW1lKFIpO2lmKHQpe24uYWRkSW1hZ2VPcHModC5mbix0LmFyZ3MsdC5vcHRpb25hbENvbnRlbnQpO2luY3JlbWVudENhY2hlZEltYWdlTWFza0NvdW50KHQpO2U9bnVsbDtjb250aW51ZX19bmV4dChjLmJ1aWxkUGFpbnRJbWFnZVhPYmplY3Qoe3Jlc291cmNlczphLGltYWdlOmVbMF0saXNJbmxpbmU6ITAsb3BlcmF0b3JMaXN0Om4sY2FjaGVLZXk6Uixsb2NhbEltYWdlQ2FjaGU6dSxsb2NhbENvbG9yU3BhY2VDYWNoZTpkfSkpO3JldHVybjtjYXNlIHIuT1BTLnNob3dUZXh0OmlmKCF4LnN0YXRlLmZvbnQpe2MuZW5zdXJlU3RhdGVGb250KHguc3RhdGUpO2NvbnRpbnVlfWVbMF09Yy5oYW5kbGVUZXh0KGVbMF0seC5zdGF0ZSk7YnJlYWs7Y2FzZSByLk9QUy5zaG93U3BhY2VkVGV4dDppZigheC5zdGF0ZS5mb250KXtjLmVuc3VyZVN0YXRlRm9udCh4LnN0YXRlKTtjb250aW51ZX12YXIgTD1lWzBdLGo9W10sJD1MLmxlbmd0aCxfPXguc3RhdGU7Zm9yKEY9MDtGPCQ7KytGKXtjb25zdCBlPUxbRl07InN0cmluZyI9PXR5cGVvZiBlP0FycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGosYy5oYW5kbGVUZXh0KGUsXykpOiJudW1iZXIiPT10eXBlb2YgZSYmai5wdXNoKGUpfWVbMF09ajtzPXIuT1BTLnNob3dUZXh0O2JyZWFrO2Nhc2Ugci5PUFMubmV4dExpbmVTaG93VGV4dDppZigheC5zdGF0ZS5mb250KXtjLmVuc3VyZVN0YXRlRm9udCh4LnN0YXRlKTtjb250aW51ZX1uLmFkZE9wKHIuT1BTLm5leHRMaW5lKTtlWzBdPWMuaGFuZGxlVGV4dChlWzBdLHguc3RhdGUpO3M9ci5PUFMuc2hvd1RleHQ7YnJlYWs7Y2FzZSByLk9QUy5uZXh0TGluZVNldFNwYWNpbmdTaG93VGV4dDppZigheC5zdGF0ZS5mb250KXtjLmVuc3VyZVN0YXRlRm9udCh4LnN0YXRlKTtjb250aW51ZX1uLmFkZE9wKHIuT1BTLm5leHRMaW5lKTtuLmFkZE9wKHIuT1BTLnNldFdvcmRTcGFjaW5nLFtlLnNoaWZ0KCldKTtuLmFkZE9wKHIuT1BTLnNldENoYXJTcGFjaW5nLFtlLnNoaWZ0KCldKTtlWzBdPWMuaGFuZGxlVGV4dChlWzBdLHguc3RhdGUpO3M9ci5PUFMuc2hvd1RleHQ7YnJlYWs7Y2FzZSByLk9QUy5zZXRUZXh0UmVuZGVyaW5nTW9kZTp4LnN0YXRlLnRleHRSZW5kZXJpbmdNb2RlPWVbMF07YnJlYWs7Y2FzZSByLk9QUy5zZXRGaWxsQ29sb3JTcGFjZTp7Y29uc3QgdD1TLkNvbG9yU3BhY2UuZ2V0Q2FjaGVkKGVbMF0sbCxkKTtpZih0KXt4LnN0YXRlLmZpbGxDb2xvclNwYWNlPXQ7Y29udGludWV9bmV4dChjLnBhcnNlQ29sb3JTcGFjZSh7Y3M6ZVswXSxyZXNvdXJjZXM6YSxsb2NhbENvbG9yU3BhY2VDYWNoZTpkfSkudGhlbigoZnVuY3Rpb24oZSl7ZSYmKHguc3RhdGUuZmlsbENvbG9yU3BhY2U9ZSl9KSkpO3JldHVybn1jYXNlIHIuT1BTLnNldFN0cm9rZUNvbG9yU3BhY2U6e2NvbnN0IHQ9Uy5Db2xvclNwYWNlLmdldENhY2hlZChlWzBdLGwsZCk7aWYodCl7eC5zdGF0ZS5zdHJva2VDb2xvclNwYWNlPXQ7Y29udGludWV9bmV4dChjLnBhcnNlQ29sb3JTcGFjZSh7Y3M6ZVswXSxyZXNvdXJjZXM6YSxsb2NhbENvbG9yU3BhY2VDYWNoZTpkfSkudGhlbigoZnVuY3Rpb24oZSl7ZSYmKHguc3RhdGUuc3Ryb2tlQ29sb3JTcGFjZT1lKX0pKSk7cmV0dXJufWNhc2Ugci5PUFMuc2V0RmlsbENvbG9yOlQ9eC5zdGF0ZS5maWxsQ29sb3JTcGFjZTtlPVQuZ2V0UmdiKGUsMCk7cz1yLk9QUy5zZXRGaWxsUkdCQ29sb3I7YnJlYWs7Y2FzZSByLk9QUy5zZXRTdHJva2VDb2xvcjpUPXguc3RhdGUuc3Ryb2tlQ29sb3JTcGFjZTtlPVQuZ2V0UmdiKGUsMCk7cz1yLk9QUy5zZXRTdHJva2VSR0JDb2xvcjticmVhaztjYXNlIHIuT1BTLnNldEZpbGxHcmF5Onguc3RhdGUuZmlsbENvbG9yU3BhY2U9Uy5Db2xvclNwYWNlLnNpbmdsZXRvbnMuZ3JheTtlPVMuQ29sb3JTcGFjZS5zaW5nbGV0b25zLmdyYXkuZ2V0UmdiKGUsMCk7cz1yLk9QUy5zZXRGaWxsUkdCQ29sb3I7YnJlYWs7Y2FzZSByLk9QUy5zZXRTdHJva2VHcmF5Onguc3RhdGUuc3Ryb2tlQ29sb3JTcGFjZT1TLkNvbG9yU3BhY2Uuc2luZ2xldG9ucy5ncmF5O2U9Uy5Db2xvclNwYWNlLnNpbmdsZXRvbnMuZ3JheS5nZXRSZ2IoZSwwKTtzPXIuT1BTLnNldFN0cm9rZVJHQkNvbG9yO2JyZWFrO2Nhc2Ugci5PUFMuc2V0RmlsbENNWUtDb2xvcjp4LnN0YXRlLmZpbGxDb2xvclNwYWNlPVMuQ29sb3JTcGFjZS5zaW5nbGV0b25zLmNteWs7ZT1TLkNvbG9yU3BhY2Uuc2luZ2xldG9ucy5jbXlrLmdldFJnYihlLDApO3M9ci5PUFMuc2V0RmlsbFJHQkNvbG9yO2JyZWFrO2Nhc2Ugci5PUFMuc2V0U3Ryb2tlQ01ZS0NvbG9yOnguc3RhdGUuc3Ryb2tlQ29sb3JTcGFjZT1TLkNvbG9yU3BhY2Uuc2luZ2xldG9ucy5jbXlrO2U9Uy5Db2xvclNwYWNlLnNpbmdsZXRvbnMuY215ay5nZXRSZ2IoZSwwKTtzPXIuT1BTLnNldFN0cm9rZVJHQkNvbG9yO2JyZWFrO2Nhc2Ugci5PUFMuc2V0RmlsbFJHQkNvbG9yOnguc3RhdGUuZmlsbENvbG9yU3BhY2U9Uy5Db2xvclNwYWNlLnNpbmdsZXRvbnMucmdiO2U9Uy5Db2xvclNwYWNlLnNpbmdsZXRvbnMucmdiLmdldFJnYihlLDApO2JyZWFrO2Nhc2Ugci5PUFMuc2V0U3Ryb2tlUkdCQ29sb3I6eC5zdGF0ZS5zdHJva2VDb2xvclNwYWNlPVMuQ29sb3JTcGFjZS5zaW5nbGV0b25zLnJnYjtlPVMuQ29sb3JTcGFjZS5zaW5nbGV0b25zLnJnYi5nZXRSZ2IoZSwwKTticmVhaztjYXNlIHIuT1BTLnNldEZpbGxDb2xvck46VD14LnN0YXRlLmZpbGxDb2xvclNwYWNlO2lmKCJQYXR0ZXJuIj09PVQubmFtZSl7bmV4dChjLmhhbmRsZUNvbG9yTihuLHIuT1BTLnNldEZpbGxDb2xvck4sZSxULHcsYSx0LGQsZyxwKSk7cmV0dXJufWU9VC5nZXRSZ2IoZSwwKTtzPXIuT1BTLnNldEZpbGxSR0JDb2xvcjticmVhaztjYXNlIHIuT1BTLnNldFN0cm9rZUNvbG9yTjpUPXguc3RhdGUuc3Ryb2tlQ29sb3JTcGFjZTtpZigiUGF0dGVybiI9PT1ULm5hbWUpe25leHQoYy5oYW5kbGVDb2xvck4obixyLk9QUy5zZXRTdHJva2VDb2xvck4sZSxULHcsYSx0LGQsZyxwKSk7cmV0dXJufWU9VC5nZXRSZ2IoZSwwKTtzPXIuT1BTLnNldFN0cm9rZVJHQkNvbG9yO2JyZWFrO2Nhc2Ugci5PUFMuc2hhZGluZ0ZpbGw6dmFyIFU9YS5nZXQoIlNoYWRpbmciKTtpZighVSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiTm8gc2hhZGluZyByZXNvdXJjZSBmb3VuZCIpO3ZhciBYPVUuZ2V0KGVbMF0ubmFtZSk7aWYoIVgpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoIk5vIHNoYWRpbmcgb2JqZWN0IGZvdW5kIik7ZT1bYy5wYXJzZVNoYWRpbmcoe3NoYWRpbmc6WCxyZXNvdXJjZXM6YSxsb2NhbENvbG9yU3BhY2VDYWNoZTpkLGxvY2FsU2hhZGluZ1BhdHRlcm5DYWNoZTpwfSldO3M9ci5PUFMuc2hhZGluZ0ZpbGw7YnJlYWs7Y2FzZSByLk9QUy5zZXRHU3RhdGU6RT1lWzBdaW5zdGFuY2VvZiBpLk5hbWU7TT1lWzBdLm5hbWU7aWYoRSl7Y29uc3QgdD1mLmdldEJ5TmFtZShNKTtpZih0KXt0Lmxlbmd0aD4wJiZuLmFkZE9wKHIuT1BTLnNldEdTdGF0ZSxbdF0pO2U9bnVsbDtjb250aW51ZX19bmV4dChuZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSxzKXtpZighRSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiR1N0YXRlIG11c3QgYmUgcmVmZXJyZWQgdG8gYnkgbmFtZS4iKTtjb25zdCBvPWEuZ2V0KCJFeHRHU3RhdGUiKTtpZighKG8gaW5zdGFuY2VvZiBpLkRpY3QpKXRocm93IG5ldyByLkZvcm1hdEVycm9yKCJFeHRHU3RhdGUgc2hvdWxkIGJlIGEgZGljdGlvbmFyeS4iKTtjb25zdCBsPW8uZ2V0KE0pO2lmKCEobCBpbnN0YW5jZW9mIGkuRGljdCkpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoIkdTdGF0ZSBzaG91bGQgYmUgYSBkaWN0aW9uYXJ5LiIpO2Muc2V0R1N0YXRlKHtyZXNvdXJjZXM6YSxnU3RhdGU6bCxvcGVyYXRvckxpc3Q6bixjYWNoZUtleTpNLHRhc2s6dCxzdGF0ZU1hbmFnZXI6eCxsb2NhbEdTdGF0ZUNhY2hlOmYsbG9jYWxDb2xvclNwYWNlQ2FjaGU6ZH0pLnRoZW4oZSxzKX0pKS5jYXRjaCgoZnVuY3Rpb24oZSl7aWYoIShlIGluc3RhbmNlb2Ygci5BYm9ydEV4Y2VwdGlvbikpe2lmKCFjLm9wdGlvbnMuaWdub3JlRXJyb3JzKXRocm93IGU7Yy5oYW5kbGVyLnNlbmQoIlVuc3VwcG9ydGVkRmVhdHVyZSIse2ZlYXR1cmVJZDpyLlVOU1VQUE9SVEVEX0ZFQVRVUkVTLmVycm9yRXh0R1N0YXRlfSk7KDAsci53YXJuKShgZ2V0T3BlcmF0b3JMaXN0IC0gaWdub3JpbmcgRXh0R1N0YXRlOiAiJHtlfSIuYCl9fSkpKTtyZXR1cm47Y2FzZSByLk9QUy5tb3ZlVG86Y2FzZSByLk9QUy5saW5lVG86Y2FzZSByLk9QUy5jdXJ2ZVRvOmNhc2Ugci5PUFMuY3VydmVUbzI6Y2FzZSByLk9QUy5jdXJ2ZVRvMzpjYXNlIHIuT1BTLmNsb3NlUGF0aDpjYXNlIHIuT1BTLnJlY3RhbmdsZTpjLmJ1aWxkUGF0aChuLHMsZSxoKTtjb250aW51ZTtjYXNlIHIuT1BTLm1hcmtQb2ludDpjYXNlIHIuT1BTLm1hcmtQb2ludFByb3BzOmNhc2Ugci5PUFMuYmVnaW5Db21wYXQ6Y2FzZSByLk9QUy5lbmRDb21wYXQ6Y29udGludWU7Y2FzZSByLk9QUy5iZWdpbk1hcmtlZENvbnRlbnRQcm9wczppZighKGVbMF1pbnN0YW5jZW9mIGkuTmFtZSkpeygwLHIud2FybikoYEV4cGVjdGVkIG5hbWUgZm9yIGJlZ2luTWFya2VkQ29udGVudFByb3BzIGFyZzA9JHtlWzBdfWApO2NvbnRpbnVlfWlmKCJPQyI9PT1lWzBdLm5hbWUpe25leHQoYy5wYXJzZU1hcmtlZENvbnRlbnRQcm9wcyhlWzFdLGEpLnRoZW4oKGU9PntuLmFkZE9wKHIuT1BTLmJlZ2luTWFya2VkQ29udGVudFByb3BzLFsiT0MiLGVdKX0pKS5jYXRjaCgoZT0+e2lmKCEoZSBpbnN0YW5jZW9mIHIuQWJvcnRFeGNlcHRpb24pKXtpZighYy5vcHRpb25zLmlnbm9yZUVycm9ycyl0aHJvdyBlO2MuaGFuZGxlci5zZW5kKCJVbnN1cHBvcnRlZEZlYXR1cmUiLHtmZWF0dXJlSWQ6ci5VTlNVUFBPUlRFRF9GRUFUVVJFUy5lcnJvck1hcmtlZENvbnRlbnR9KTsoMCxyLndhcm4pKGBnZXRPcGVyYXRvckxpc3QgLSBpZ25vcmluZyBiZWdpbk1hcmtlZENvbnRlbnRQcm9wczogIiR7ZX0iLmApfX0pKSk7cmV0dXJufWU9W2VbMF0ubmFtZSxlWzFdaW5zdGFuY2VvZiBpLkRpY3Q/ZVsxXS5nZXQoIk1DSUQiKTpudWxsXTticmVhaztjYXNlIHIuT1BTLmJlZ2luTWFya2VkQ29udGVudDpjYXNlIHIuT1BTLmVuZE1hcmtlZENvbnRlbnQ6ZGVmYXVsdDppZihudWxsIT09ZSl7Zm9yKEY9MCxPPWUubGVuZ3RoO0Y8TyYmIShlW0ZdaW5zdGFuY2VvZiBpLkRpY3QpO0YrKyk7aWYoRjxPKXsoMCxyLndhcm4pKCJnZXRPcGVyYXRvckxpc3QgLSBpZ25vcmluZyBvcGVyYXRvcjogIitzKTtjb250aW51ZX19fW4uYWRkT3AocyxlKX1pZih2KW5leHQoTik7ZWxzZXtjbG9zZVBlbmRpbmdSZXN0b3JlT1BTKCk7ZSgpfX0pKS5jYXRjaCgoZT0+e2lmKCEoZSBpbnN0YW5jZW9mIHIuQWJvcnRFeGNlcHRpb24pKXtpZighdGhpcy5vcHRpb25zLmlnbm9yZUVycm9ycyl0aHJvdyBlO3RoaXMuaGFuZGxlci5zZW5kKCJVbnN1cHBvcnRlZEZlYXR1cmUiLHtmZWF0dXJlSWQ6ci5VTlNVUFBPUlRFRF9GRUFUVVJFUy5lcnJvck9wZXJhdG9yTGlzdH0pOygwLHIud2FybikoYGdldE9wZXJhdG9yTGlzdCAtIGlnbm9yaW5nIGVycm9ycyBkdXJpbmcgIiR7dC5uYW1lfSIgdGFzazogIiR7ZX0iLmApO2Nsb3NlUGVuZGluZ1Jlc3RvcmVPUFMoKX19KSl9Z2V0VGV4dENvbnRlbnQoe3N0cmVhbTplLHRhc2s6dCxyZXNvdXJjZXM6YSxzdGF0ZU1hbmFnZXI6bj1udWxsLGNvbWJpbmVUZXh0SXRlbXM6cz0hMSxpbmNsdWRlTWFya2VkQ29udGVudDpvPSExLHNpbms6YyxzZWVuU3R5bGVzOmw9bmV3IFNldCx2aWV3Qm94OnV9KXthPWF8fGkuRGljdC5lbXB0eTtuPW58fG5ldyBTdGF0ZU1hbmFnZXIobmV3IFRleHRTdGF0ZSk7Y29uc3QgZD0oMCxoLmdldE5vcm1hbGl6ZWRVbmljb2RlcykoKSxmPXtpdGVtczpbXSxzdHlsZXM6T2JqZWN0LmNyZWF0ZShudWxsKX0sZz17aW5pdGlhbGl6ZWQ6ITEsc3RyOltdLHRvdGFsV2lkdGg6MCx0b3RhbEhlaWdodDowLHdpZHRoOjAsaGVpZ2h0OjAsdmVydGljYWw6ITEscHJldlRyYW5zZm9ybTpudWxsLHRleHRBZHZhbmNlU2NhbGU6MCxzcGFjZUluRmxvd01pbjowLHNwYWNlSW5GbG93TWF4OjAsdHJhY2tpbmdTcGFjZU1pbjoxLzAsbmVnYXRpdmVTcGFjZU1heDotMS8wLG5vdEFTcGFjZTotMS8wLHRyYW5zZm9ybTpudWxsLGZvbnROYW1lOm51bGwsaGFzRU9MOiExfSxwPVsiICIsIiAiXTtsZXQgYj0wO2Z1bmN0aW9uIHNhdmVMYXN0Q2hhcihlKXtjb25zdCB0PShiKzEpJTIsYT0iICIhPT1wW2JdJiYiICI9PT1wW3RdO3BbYl09ZTtiPXQ7cmV0dXJuIGF9ZnVuY3Rpb24gcmVzZXRMYXN0Q2hhcnMoKXtwWzBdPXBbMV09IiAiO2I9MH1jb25zdCBTPXRoaXMseD10aGlzLnhyZWYsaz1bXTtsZXQgQz1udWxsO2NvbnN0IHY9bmV3IG0uTG9jYWxJbWFnZUNhY2hlLEY9bmV3IG0uTG9jYWxHU3RhdGVDYWNoZSxPPW5ldyBFdmFsdWF0b3JQcmVwcm9jZXNzb3IoZSx4LG4pO2xldCBUO2Z1bmN0aW9uIGdldEN1cnJlbnRUZXh0VHJhbnNmb3JtKCl7Y29uc3QgZT1ULmZvbnQsdD1bVC5mb250U2l6ZSpULnRleHRIU2NhbGUsMCwwLFQuZm9udFNpemUsMCxULnRleHRSaXNlXTtpZihlLmlzVHlwZTNGb250JiYoVC5mb250U2l6ZTw9MXx8ZS5pc0NoYXJCQm94KSYmISgwLHIuaXNBcnJheUVxdWFsKShULmZvbnRNYXRyaXgsci5GT05UX0lERU5USVRZX01BVFJJWCkpe2NvbnN0IGE9ZS5iYm94WzNdLWUuYmJveFsxXTthPjAmJih0WzNdKj1hKlQuZm9udE1hdHJpeFszXSl9cmV0dXJuIHIuVXRpbC50cmFuc2Zvcm0oVC5jdG0sci5VdGlsLnRyYW5zZm9ybShULnRleHRNYXRyaXgsdCkpfWZ1bmN0aW9uIGVuc3VyZVRleHRDb250ZW50SXRlbSgpe2lmKGcuaW5pdGlhbGl6ZWQpcmV0dXJuIGc7Y29uc3QgZT1ULmZvbnQsdD1lLmxvYWRlZE5hbWU7aWYoIWwuaGFzKHQpKXtsLmFkZCh0KTtmLnN0eWxlc1t0XT17Zm9udEZhbWlseTplLmZhbGxiYWNrTmFtZSxhc2NlbnQ6ZS5hc2NlbnQsZGVzY2VudDplLmRlc2NlbnQsdmVydGljYWw6ZS52ZXJ0aWNhbH19Zy5mb250TmFtZT10O2NvbnN0IGE9Zy50cmFuc2Zvcm09Z2V0Q3VycmVudFRleHRUcmFuc2Zvcm0oKTtpZihlLnZlcnRpY2FsKXtnLndpZHRoPWcudG90YWxXaWR0aD1NYXRoLmh5cG90KGFbMF0sYVsxXSk7Zy5oZWlnaHQ9Zy50b3RhbEhlaWdodD0wO2cudmVydGljYWw9ITB9ZWxzZXtnLndpZHRoPWcudG90YWxXaWR0aD0wO2cuaGVpZ2h0PWcudG90YWxIZWlnaHQ9TWF0aC5oeXBvdChhWzJdLGFbM10pO2cudmVydGljYWw9ITF9Y29uc3Qgcj1NYXRoLmh5cG90KFQudGV4dExpbmVNYXRyaXhbMF0sVC50ZXh0TGluZU1hdHJpeFsxXSksbj1NYXRoLmh5cG90KFQuY3RtWzBdLFQuY3RtWzFdKTtnLnRleHRBZHZhbmNlU2NhbGU9bipyO2cudHJhY2tpbmdTcGFjZU1pbj0uMSpULmZvbnRTaXplO2cubm90QVNwYWNlPS4wMypULmZvbnRTaXplO2cubmVnYXRpdmVTcGFjZU1heD0tLjIqVC5mb250U2l6ZTtnLnNwYWNlSW5GbG93TWluPS4xKlQuZm9udFNpemU7Zy5zcGFjZUluRmxvd01heD0uNipULmZvbnRTaXplO2cuaGFzRU9MPSExO2cuaW5pdGlhbGl6ZWQ9ITA7cmV0dXJuIGd9ZnVuY3Rpb24gdXBkYXRlQWR2YW5jZVNjYWxlKCl7aWYoIWcuaW5pdGlhbGl6ZWQpcmV0dXJuO2NvbnN0IGU9TWF0aC5oeXBvdChULnRleHRMaW5lTWF0cml4WzBdLFQudGV4dExpbmVNYXRyaXhbMV0pLHQ9TWF0aC5oeXBvdChULmN0bVswXSxULmN0bVsxXSkqZTtpZih0IT09Zy50ZXh0QWR2YW5jZVNjYWxlKXtpZihnLnZlcnRpY2FsKXtnLnRvdGFsSGVpZ2h0Kz1nLmhlaWdodCpnLnRleHRBZHZhbmNlU2NhbGU7Zy5oZWlnaHQ9MH1lbHNle2cudG90YWxXaWR0aCs9Zy53aWR0aCpnLnRleHRBZHZhbmNlU2NhbGU7Zy53aWR0aD0wfWcudGV4dEFkdmFuY2VTY2FsZT10fX1mdW5jdGlvbiBoYW5kbGVTZXRGb250KGUsbil7cmV0dXJuIFMubG9hZEZvbnQoZSxuLGEpLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBlLmZvbnQuaXNUeXBlM0ZvbnQ/ZS5sb2FkVHlwZTNEYXRhKFMsYSx0KS5jYXRjaCgoZnVuY3Rpb24oKXt9KSkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gZX0pKTplfSkpLnRoZW4oKGZ1bmN0aW9uKGUpe1QuZm9udD1lLmZvbnQ7VC5mb250TWF0cml4PWUuZm9udC5mb250TWF0cml4fHxyLkZPTlRfSURFTlRJVFlfTUFUUklYfSkpfWZ1bmN0aW9uIGFwcGx5SW52ZXJzZVJvdGF0aW9uKGUsdCxhKXtjb25zdCByPU1hdGguaHlwb3QoYVswXSxhWzFdKTtyZXR1cm5bKGFbMF0qZSthWzFdKnQpL3IsKGFbMl0qZSthWzNdKnQpL3JdfWZ1bmN0aW9uIGNvbXBhcmVXaXRoTGFzdFBvc2l0aW9uKCl7Y29uc3QgZT1nZXRDdXJyZW50VGV4dFRyYW5zZm9ybSgpO2xldCB0PWVbNF0sYT1lWzVdO2NvbnN0IHI9dC11WzBdLG49YS11WzFdO2lmKHI8MHx8cj51WzJdfHxuPDB8fG4+dVszXSlyZXR1cm4hMTtpZighc3x8IVQuZm9udHx8IWcucHJldlRyYW5zZm9ybSlyZXR1cm4hMDtsZXQgaT1nLnByZXZUcmFuc2Zvcm1bNF0sbz1nLnByZXZUcmFuc2Zvcm1bNV07aWYoaT09PXQmJm89PT1hKXJldHVybiEwO2xldCBjPS0xO2VbMF0mJjA9PT1lWzFdJiYwPT09ZVsyXT9jPWVbMF0+MD8wOjE4MDplWzFdJiYwPT09ZVswXSYmMD09PWVbM10mJihjPWVbMV0+MD85MDoyNzApO3N3aXRjaChjKXtjYXNlIDA6YnJlYWs7Y2FzZSA5MDpbdCxhXT1bYSx0XTtbaSxvXT1bbyxpXTticmVhaztjYXNlIDE4MDpbdCxhLGksb109Wy10LC1hLC1pLC1vXTticmVhaztjYXNlIDI3MDpbdCxhXT1bLWEsLXRdO1tpLG9dPVstbywtaV07YnJlYWs7ZGVmYXVsdDpbdCxhXT1hcHBseUludmVyc2VSb3RhdGlvbih0LGEsZSk7W2ksb109YXBwbHlJbnZlcnNlUm90YXRpb24oaSxvLGcucHJldlRyYW5zZm9ybSl9aWYoVC5mb250LnZlcnRpY2FsKXtjb25zdCBlPShvLWEpL2cudGV4dEFkdmFuY2VTY2FsZSxyPXQtaSxuPU1hdGguc2lnbihnLmhlaWdodCk7aWYoZTxuKmcubmVnYXRpdmVTcGFjZU1heCl7aWYoTWF0aC5hYnMocik+LjUqZy53aWR0aCl7YXBwZW5kRU9MKCk7cmV0dXJuITB9cmVzZXRMYXN0Q2hhcnMoKTtmbHVzaFRleHRDb250ZW50SXRlbSgpO3JldHVybiEwfWlmKE1hdGguYWJzKHIpPmcud2lkdGgpe2FwcGVuZEVPTCgpO3JldHVybiEwfWU8PW4qZy5ub3RBU3BhY2UmJnJlc2V0TGFzdENoYXJzKCk7aWYoZTw9bipnLnRyYWNraW5nU3BhY2VNaW4pZy5oZWlnaHQrPWU7ZWxzZSBpZighYWRkRmFrZVNwYWNlcyhlLGcucHJldlRyYW5zZm9ybSxuKSlpZigwPT09Zy5zdHIubGVuZ3RoKXtyZXNldExhc3RDaGFycygpO2YuaXRlbXMucHVzaCh7c3RyOiIgIixkaXI6Imx0ciIsd2lkdGg6MCxoZWlnaHQ6TWF0aC5hYnMoZSksdHJhbnNmb3JtOmcucHJldlRyYW5zZm9ybSxmb250TmFtZTpnLmZvbnROYW1lLGhhc0VPTDohMX0pfWVsc2UgZy5oZWlnaHQrPWU7cmV0dXJuITB9Y29uc3QgbD0odC1pKS9nLnRleHRBZHZhbmNlU2NhbGUsaD1hLW8sZD1NYXRoLnNpZ24oZy53aWR0aCk7aWYobDxkKmcubmVnYXRpdmVTcGFjZU1heCl7aWYoTWF0aC5hYnMoaCk+LjUqZy5oZWlnaHQpe2FwcGVuZEVPTCgpO3JldHVybiEwfXJlc2V0TGFzdENoYXJzKCk7Zmx1c2hUZXh0Q29udGVudEl0ZW0oKTtyZXR1cm4hMH1pZihNYXRoLmFicyhoKT5nLmhlaWdodCl7YXBwZW5kRU9MKCk7cmV0dXJuITB9bDw9ZCpnLm5vdEFTcGFjZSYmcmVzZXRMYXN0Q2hhcnMoKTtpZihsPD1kKmcudHJhY2tpbmdTcGFjZU1pbilnLndpZHRoKz1sO2Vsc2UgaWYoIWFkZEZha2VTcGFjZXMobCxnLnByZXZUcmFuc2Zvcm0sZCkpaWYoMD09PWcuc3RyLmxlbmd0aCl7cmVzZXRMYXN0Q2hhcnMoKTtmLml0ZW1zLnB1c2goe3N0cjoiICIsZGlyOiJsdHIiLHdpZHRoOk1hdGguYWJzKGwpLGhlaWdodDowLHRyYW5zZm9ybTpnLnByZXZUcmFuc2Zvcm0sZm9udE5hbWU6Zy5mb250TmFtZSxoYXNFT0w6ITF9KX1lbHNlIGcud2lkdGgrPWw7cmV0dXJuITB9ZnVuY3Rpb24gYnVpbGRUZXh0Q29udGVudEl0ZW0oe2NoYXJzOmUsZXh0cmFTcGFjaW5nOnR9KXtjb25zdCBhPVQuZm9udDtpZighZSl7Y29uc3QgZT1ULmNoYXJTcGFjaW5nK3Q7ZSYmKGEudmVydGljYWw/VC50cmFuc2xhdGVUZXh0TWF0cml4KDAsLWUpOlQudHJhbnNsYXRlVGV4dE1hdHJpeChlKlQudGV4dEhTY2FsZSwwKSk7cmV0dXJufWNvbnN0IHI9YS5jaGFyc1RvR2x5cGhzKGUpLG49VC5mb250TWF0cml4WzBdKlQuZm9udFNpemU7Zm9yKGxldCBlPTAsaT1yLmxlbmd0aDtlPGk7ZSsrKXtjb25zdCBzPXJbZV07aWYocy5pc0ludmlzaWJsZUZvcm1hdE1hcmspY29udGludWU7bGV0IG89VC5jaGFyU3BhY2luZysoZSsxPT09aT90OjApLGM9cy53aWR0aDthLnZlcnRpY2FsJiYoYz1zLnZtZXRyaWM/cy52bWV0cmljWzBdOi1jKTtsZXQgbD1jKm47aWYocy5pc1doaXRlc3BhY2Upe2lmKGEudmVydGljYWwpe28rPS1sK1Qud29yZFNwYWNpbmc7VC50cmFuc2xhdGVUZXh0TWF0cml4KDAsLW8pfWVsc2V7bys9bCtULndvcmRTcGFjaW5nO1QudHJhbnNsYXRlVGV4dE1hdHJpeChvKlQudGV4dEhTY2FsZSwwKX1zYXZlTGFzdENoYXIoIiAiKTtjb250aW51ZX1pZighY29tcGFyZVdpdGhMYXN0UG9zaXRpb24oKSljb250aW51ZTtjb25zdCB1PWVuc3VyZVRleHRDb250ZW50SXRlbSgpO3MuaXNaZXJvV2lkdGhEaWFjcml0aWMmJihsPTApO2lmKGEudmVydGljYWwpe1QudHJhbnNsYXRlVGV4dE1hdHJpeCgwLGwpO2w9TWF0aC5hYnMobCk7dS5oZWlnaHQrPWx9ZWxzZXtsKj1ULnRleHRIU2NhbGU7VC50cmFuc2xhdGVUZXh0TWF0cml4KGwsMCk7dS53aWR0aCs9bH1sJiYodS5wcmV2VHJhbnNmb3JtPWdldEN1cnJlbnRUZXh0VHJhbnNmb3JtKCkpO2xldCBmPXMudW5pY29kZTtmPWRbZl18fGY7Zj0oMCxoLnJldmVyc2VJZlJ0bCkoZik7c2F2ZUxhc3RDaGFyKGYpJiZ1LnN0ci5wdXNoKCIgIik7dS5zdHIucHVzaChmKTtvJiYoYS52ZXJ0aWNhbD9ULnRyYW5zbGF0ZVRleHRNYXRyaXgoMCwtbyk6VC50cmFuc2xhdGVUZXh0TWF0cml4KG8qVC50ZXh0SFNjYWxlLDApKX19ZnVuY3Rpb24gYXBwZW5kRU9MKCl7cmVzZXRMYXN0Q2hhcnMoKTtpZihnLmluaXRpYWxpemVkKXtnLmhhc0VPTD0hMDtmbHVzaFRleHRDb250ZW50SXRlbSgpfWVsc2UgZi5pdGVtcy5wdXNoKHtzdHI6IiIsZGlyOiJsdHIiLHdpZHRoOjAsaGVpZ2h0OjAsdHJhbnNmb3JtOmdldEN1cnJlbnRUZXh0VHJhbnNmb3JtKCksZm9udE5hbWU6VC5mb250LmxvYWRlZE5hbWUsaGFzRU9MOiEwfSl9ZnVuY3Rpb24gYWRkRmFrZVNwYWNlcyhlLHQsYSl7aWYoYSpnLnNwYWNlSW5GbG93TWluPD1lJiZlPD1hKmcuc3BhY2VJbkZsb3dNYXgpe2lmKGcuaW5pdGlhbGl6ZWQpe3Jlc2V0TGFzdENoYXJzKCk7Zy5zdHIucHVzaCgiICIpfXJldHVybiExfWNvbnN0IHI9Zy5mb250TmFtZTtsZXQgbj0wO2lmKGcudmVydGljYWwpe249ZTtlPTB9Zmx1c2hUZXh0Q29udGVudEl0ZW0oKTtyZXNldExhc3RDaGFycygpO2YuaXRlbXMucHVzaCh7c3RyOiIgIixkaXI6Imx0ciIsd2lkdGg6TWF0aC5hYnMoZSksaGVpZ2h0Ok1hdGguYWJzKG4pLHRyYW5zZm9ybTp0fHxnZXRDdXJyZW50VGV4dFRyYW5zZm9ybSgpLGZvbnROYW1lOnIsaGFzRU9MOiExfSk7cmV0dXJuITB9ZnVuY3Rpb24gZmx1c2hUZXh0Q29udGVudEl0ZW0oKXtpZihnLmluaXRpYWxpemVkJiZnLnN0cil7Zy52ZXJ0aWNhbD9nLnRvdGFsSGVpZ2h0Kz1nLmhlaWdodCpnLnRleHRBZHZhbmNlU2NhbGU6Zy50b3RhbFdpZHRoKz1nLndpZHRoKmcudGV4dEFkdmFuY2VTY2FsZTtmLml0ZW1zLnB1c2goZnVuY3Rpb24gcnVuQmlkaVRyYW5zZm9ybShlKXtjb25zdCB0PWUuc3RyLmpvaW4oIiIpLGE9KDAsdy5iaWRpKSh0LC0xLGUudmVydGljYWwpO3JldHVybntzdHI6YS5zdHIsZGlyOmEuZGlyLHdpZHRoOk1hdGguYWJzKGUudG90YWxXaWR0aCksaGVpZ2h0Ok1hdGguYWJzKGUudG90YWxIZWlnaHQpLHRyYW5zZm9ybTplLnRyYW5zZm9ybSxmb250TmFtZTplLmZvbnROYW1lLGhhc0VPTDplLmhhc0VPTH19KGcpKTtnLmluaXRpYWxpemVkPSExO2cuc3RyLmxlbmd0aD0wfX1mdW5jdGlvbiBlbnF1ZXVlQ2h1bmsoZT0hMSl7Y29uc3QgdD1mLml0ZW1zLmxlbmd0aDtpZigwIT09dCYmIShlJiZ0PDEwKSl7Yy5lbnF1ZXVlKGYsdCk7Zi5pdGVtcz1bXTtmLnN0eWxlcz1PYmplY3QuY3JlYXRlKG51bGwpfX1jb25zdCBNPW5ldyBUaW1lU2xvdE1hbmFnZXI7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbiBwcm9taXNlQm9keShlLGgpe2NvbnN0IG5leHQ9ZnVuY3Rpb24odCl7ZW5xdWV1ZUNodW5rKCEwKTtQcm9taXNlLmFsbChbdCxjLnJlYWR5XSkudGhlbigoZnVuY3Rpb24oKXt0cnl7cHJvbWlzZUJvZHkoZSxoKX1jYXRjaChlKXtoKGUpfX0pLGgpfTt0LmVuc3VyZU5vdFRlcm1pbmF0ZWQoKTtNLnJlc2V0KCk7Y29uc3QgZD17fTtsZXQgZyxwPVtdO2Zvcig7IShnPU0uY2hlY2soKSk7KXtwLmxlbmd0aD0wO2QuYXJncz1wO2lmKCFPLnJlYWQoZCkpYnJlYWs7VD1uLnN0YXRlO2NvbnN0IGU9ZC5mbjtwPWQuYXJncztzd2l0Y2goMHxlKXtjYXNlIHIuT1BTLnNldEZvbnQ6dmFyIG09cFswXS5uYW1lLGI9cFsxXTtpZihULmZvbnQmJm09PT1ULmZvbnROYW1lJiZiPT09VC5mb250U2l6ZSlicmVhaztmbHVzaFRleHRDb250ZW50SXRlbSgpO1QuZm9udE5hbWU9bTtULmZvbnRTaXplPWI7bmV4dChoYW5kbGVTZXRGb250KG0sbnVsbCkpO3JldHVybjtjYXNlIHIuT1BTLnNldFRleHRSaXNlOlQudGV4dFJpc2U9cFswXTticmVhaztjYXNlIHIuT1BTLnNldEhTY2FsZTpULnRleHRIU2NhbGU9cFswXS8xMDA7YnJlYWs7Y2FzZSByLk9QUy5zZXRMZWFkaW5nOlQubGVhZGluZz1wWzBdO2JyZWFrO2Nhc2Ugci5PUFMubW92ZVRleHQ6VC50cmFuc2xhdGVUZXh0TGluZU1hdHJpeChwWzBdLHBbMV0pO1QudGV4dE1hdHJpeD1ULnRleHRMaW5lTWF0cml4LnNsaWNlKCk7YnJlYWs7Y2FzZSByLk9QUy5zZXRMZWFkaW5nTW92ZVRleHQ6VC5sZWFkaW5nPS1wWzFdO1QudHJhbnNsYXRlVGV4dExpbmVNYXRyaXgocFswXSxwWzFdKTtULnRleHRNYXRyaXg9VC50ZXh0TGluZU1hdHJpeC5zbGljZSgpO2JyZWFrO2Nhc2Ugci5PUFMubmV4dExpbmU6VC5jYXJyaWFnZVJldHVybigpO2JyZWFrO2Nhc2Ugci5PUFMuc2V0VGV4dE1hdHJpeDpULnNldFRleHRNYXRyaXgocFswXSxwWzFdLHBbMl0scFszXSxwWzRdLHBbNV0pO1Quc2V0VGV4dExpbmVNYXRyaXgocFswXSxwWzFdLHBbMl0scFszXSxwWzRdLHBbNV0pO3VwZGF0ZUFkdmFuY2VTY2FsZSgpO2JyZWFrO2Nhc2Ugci5PUFMuc2V0Q2hhclNwYWNpbmc6VC5jaGFyU3BhY2luZz1wWzBdO2JyZWFrO2Nhc2Ugci5PUFMuc2V0V29yZFNwYWNpbmc6VC53b3JkU3BhY2luZz1wWzBdO2JyZWFrO2Nhc2Ugci5PUFMuYmVnaW5UZXh0OlQudGV4dE1hdHJpeD1yLklERU5USVRZX01BVFJJWC5zbGljZSgpO1QudGV4dExpbmVNYXRyaXg9ci5JREVOVElUWV9NQVRSSVguc2xpY2UoKTticmVhaztjYXNlIHIuT1BTLnNob3dTcGFjZWRUZXh0OmlmKCFuLnN0YXRlLmZvbnQpe1MuZW5zdXJlU3RhdGVGb250KG4uc3RhdGUpO2NvbnRpbnVlfWNvbnN0IGU9KFQuZm9udC52ZXJ0aWNhbD8xOi0xKSpULmZvbnRTaXplLzFlMyxoPXBbMF07Zm9yKGxldCB0PTAsYT1oLmxlbmd0aDt0PGEtMTt0Kyspe2NvbnN0IGE9aFt0XTtpZigic3RyaW5nIj09dHlwZW9mIGEpay5wdXNoKGEpO2Vsc2UgaWYoIm51bWJlciI9PXR5cGVvZiBhJiYwIT09YSl7Y29uc3QgdD1rLmpvaW4oIiIpO2subGVuZ3RoPTA7YnVpbGRUZXh0Q29udGVudEl0ZW0oe2NoYXJzOnQsZXh0cmFTcGFjaW5nOmEqZX0pfX1jb25zdCBkPWguYXQoLTEpOyJzdHJpbmciPT10eXBlb2YgZCYmay5wdXNoKGQpO2lmKGsubGVuZ3RoPjApe2NvbnN0IGU9ay5qb2luKCIiKTtrLmxlbmd0aD0wO2J1aWxkVGV4dENvbnRlbnRJdGVtKHtjaGFyczplLGV4dHJhU3BhY2luZzowfSl9YnJlYWs7Y2FzZSByLk9QUy5zaG93VGV4dDppZighbi5zdGF0ZS5mb250KXtTLmVuc3VyZVN0YXRlRm9udChuLnN0YXRlKTtjb250aW51ZX1idWlsZFRleHRDb250ZW50SXRlbSh7Y2hhcnM6cFswXSxleHRyYVNwYWNpbmc6MH0pO2JyZWFrO2Nhc2Ugci5PUFMubmV4dExpbmVTaG93VGV4dDppZighbi5zdGF0ZS5mb250KXtTLmVuc3VyZVN0YXRlRm9udChuLnN0YXRlKTtjb250aW51ZX1ULmNhcnJpYWdlUmV0dXJuKCk7YnVpbGRUZXh0Q29udGVudEl0ZW0oe2NoYXJzOnBbMF0sZXh0cmFTcGFjaW5nOjB9KTticmVhaztjYXNlIHIuT1BTLm5leHRMaW5lU2V0U3BhY2luZ1Nob3dUZXh0OmlmKCFuLnN0YXRlLmZvbnQpe1MuZW5zdXJlU3RhdGVGb250KG4uc3RhdGUpO2NvbnRpbnVlfVQud29yZFNwYWNpbmc9cFswXTtULmNoYXJTcGFjaW5nPXBbMV07VC5jYXJyaWFnZVJldHVybigpO2J1aWxkVGV4dENvbnRlbnRJdGVtKHtjaGFyczpwWzJdLGV4dHJhU3BhY2luZzowfSk7YnJlYWs7Y2FzZSByLk9QUy5wYWludFhPYmplY3Q6Zmx1c2hUZXh0Q29udGVudEl0ZW0oKTtDfHwoQz1hLmdldCgiWE9iamVjdCIpfHxpLkRpY3QuZW1wdHkpO3ZhciB3PXBbMF1pbnN0YW5jZW9mIGkuTmFtZSxFPXBbMF0ubmFtZTtpZih3JiZ2LmdldEJ5TmFtZShFKSlicmVhaztuZXh0KG5ldyBQcm9taXNlKChmdW5jdGlvbihlLGgpe2lmKCF3KXRocm93IG5ldyByLkZvcm1hdEVycm9yKCJYT2JqZWN0IG11c3QgYmUgcmVmZXJyZWQgdG8gYnkgbmFtZS4iKTtsZXQgZD1DLmdldFJhdyhFKTtpZihkIGluc3RhbmNlb2YgaS5SZWYpe2lmKHYuZ2V0QnlSZWYoZCkpe2UoKTtyZXR1cm59aWYoUy5nbG9iYWxJbWFnZUNhY2hlLmdldERhdGEoZCxTLnBhZ2VJbmRleCkpe2UoKTtyZXR1cm59ZD14LmZldGNoKGQpfWlmKCEoZCBpbnN0YW5jZW9mIHkuQmFzZVN0cmVhbSkpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoIlhPYmplY3Qgc2hvdWxkIGJlIGEgc3RyZWFtIik7Y29uc3QgZj1kLmRpY3QuZ2V0KCJTdWJ0eXBlIik7aWYoIShmIGluc3RhbmNlb2YgaS5OYW1lKSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiWE9iamVjdCBzaG91bGQgaGF2ZSBhIE5hbWUgc3VidHlwZSIpO2lmKCJGb3JtIiE9PWYubmFtZSl7di5zZXQoRSxkLmRpY3Qub2JqSWQsITApO2UoKTtyZXR1cm59Y29uc3QgZz1uLnN0YXRlLmNsb25lKCkscD1uZXcgU3RhdGVNYW5hZ2VyKGcpLG09ZC5kaWN0LmdldEFycmF5KCJNYXRyaXgiKTtBcnJheS5pc0FycmF5KG0pJiY2PT09bS5sZW5ndGgmJnAudHJhbnNmb3JtKG0pO2VucXVldWVDaHVuaygpO2NvbnN0IGI9e2VucXVldWVJbnZva2VkOiExLGVucXVldWUoZSx0KXt0aGlzLmVucXVldWVJbnZva2VkPSEwO2MuZW5xdWV1ZShlLHQpfSxnZXQgZGVzaXJlZFNpemUoKXtyZXR1cm4gYy5kZXNpcmVkU2l6ZX0sZ2V0IHJlYWR5KCl7cmV0dXJuIGMucmVhZHl9fTtTLmdldFRleHRDb250ZW50KHtzdHJlYW06ZCx0YXNrOnQscmVzb3VyY2VzOmQuZGljdC5nZXQoIlJlc291cmNlcyIpfHxhLHN0YXRlTWFuYWdlcjpwLGNvbWJpbmVUZXh0SXRlbXM6cyxpbmNsdWRlTWFya2VkQ29udGVudDpvLHNpbms6YixzZWVuU3R5bGVzOmwsdmlld0JveDp1fSkudGhlbigoZnVuY3Rpb24oKXtiLmVucXVldWVJbnZva2VkfHx2LnNldChFLGQuZGljdC5vYmpJZCwhMCk7ZSgpfSksaCl9KSkuY2F0Y2goKGZ1bmN0aW9uKGUpe2lmKCEoZSBpbnN0YW5jZW9mIHIuQWJvcnRFeGNlcHRpb24pKXtpZighUy5vcHRpb25zLmlnbm9yZUVycm9ycyl0aHJvdyBlOygwLHIud2FybikoYGdldFRleHRDb250ZW50IC0gaWdub3JpbmcgWE9iamVjdDogIiR7ZX0iLmApfX0pKSk7cmV0dXJuO2Nhc2Ugci5PUFMuc2V0R1N0YXRlOnc9cFswXWluc3RhbmNlb2YgaS5OYW1lO0U9cFswXS5uYW1lO2lmKHcmJkYuZ2V0QnlOYW1lKEUpKWJyZWFrO25leHQobmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsdCl7aWYoIXcpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoIkdTdGF0ZSBtdXN0IGJlIHJlZmVycmVkIHRvIGJ5IG5hbWUuIik7Y29uc3Qgbj1hLmdldCgiRXh0R1N0YXRlIik7aWYoIShuIGluc3RhbmNlb2YgaS5EaWN0KSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiRXh0R1N0YXRlIHNob3VsZCBiZSBhIGRpY3Rpb25hcnkuIik7Y29uc3Qgcz1uLmdldChFKTtpZighKHMgaW5zdGFuY2VvZiBpLkRpY3QpKXRocm93IG5ldyByLkZvcm1hdEVycm9yKCJHU3RhdGUgc2hvdWxkIGJlIGEgZGljdGlvbmFyeS4iKTtjb25zdCBvPXMuZ2V0KCJGb250Iik7aWYobyl7Zmx1c2hUZXh0Q29udGVudEl0ZW0oKTtULmZvbnROYW1lPW51bGw7VC5mb250U2l6ZT1vWzFdO2hhbmRsZVNldEZvbnQobnVsbCxvWzBdKS50aGVuKGUsdCl9ZWxzZXtGLnNldChFLHMub2JqSWQsITApO2UoKX19KSkuY2F0Y2goKGZ1bmN0aW9uKGUpe2lmKCEoZSBpbnN0YW5jZW9mIHIuQWJvcnRFeGNlcHRpb24pKXtpZighUy5vcHRpb25zLmlnbm9yZUVycm9ycyl0aHJvdyBlOygwLHIud2FybikoYGdldFRleHRDb250ZW50IC0gaWdub3JpbmcgRXh0R1N0YXRlOiAiJHtlfSIuYCl9fSkpKTtyZXR1cm47Y2FzZSByLk9QUy5iZWdpbk1hcmtlZENvbnRlbnQ6Zmx1c2hUZXh0Q29udGVudEl0ZW0oKTtvJiZmLml0ZW1zLnB1c2goe3R5cGU6ImJlZ2luTWFya2VkQ29udGVudCIsdGFnOnBbMF1pbnN0YW5jZW9mIGkuTmFtZT9wWzBdLm5hbWU6bnVsbH0pO2JyZWFrO2Nhc2Ugci5PUFMuYmVnaW5NYXJrZWRDb250ZW50UHJvcHM6Zmx1c2hUZXh0Q29udGVudEl0ZW0oKTtpZihvKXtsZXQgZT1udWxsO3BbMV1pbnN0YW5jZW9mIGkuRGljdCYmKGU9cFsxXS5nZXQoIk1DSUQiKSk7Zi5pdGVtcy5wdXNoKHt0eXBlOiJiZWdpbk1hcmtlZENvbnRlbnRQcm9wcyIsaWQ6TnVtYmVyLmlzSW50ZWdlcihlKT9gJHtTLmlkRmFjdG9yeS5nZXRQYWdlT2JqSWQoKX1fbWNpZCR7ZX1gOm51bGwsdGFnOnBbMF1pbnN0YW5jZW9mIGkuTmFtZT9wWzBdLm5hbWU6bnVsbH0pfWJyZWFrO2Nhc2Ugci5PUFMuZW5kTWFya2VkQ29udGVudDpmbHVzaFRleHRDb250ZW50SXRlbSgpO28mJmYuaXRlbXMucHVzaCh7dHlwZToiZW5kTWFya2VkQ29udGVudCJ9KX1pZihmLml0ZW1zLmxlbmd0aD49Yy5kZXNpcmVkU2l6ZSl7Zz0hMDticmVha319aWYoZyluZXh0KE4pO2Vsc2V7Zmx1c2hUZXh0Q29udGVudEl0ZW0oKTtlbnF1ZXVlQ2h1bmsoKTtlKCl9fSkpLmNhdGNoKChlPT57aWYoIShlIGluc3RhbmNlb2Ygci5BYm9ydEV4Y2VwdGlvbikpe2lmKCF0aGlzLm9wdGlvbnMuaWdub3JlRXJyb3JzKXRocm93IGU7KDAsci53YXJuKShgZ2V0VGV4dENvbnRlbnQgLSBpZ25vcmluZyBlcnJvcnMgZHVyaW5nICIke3QubmFtZX0iIHRhc2s6ICIke2V9Ii5gKTtmbHVzaFRleHRDb250ZW50SXRlbSgpO2VucXVldWVDaHVuaygpfX0pKX1leHRyYWN0RGF0YVN0cnVjdHVyZXMoZSx0LGEpe2NvbnN0IG49dGhpcy54cmVmO2xldCBzO2NvbnN0IGw9dGhpcy5yZWFkVG9Vbmljb2RlKGEudG9Vbmljb2RlfHxlLmdldCgiVG9Vbmljb2RlIil8fHQuZ2V0KCJUb1VuaWNvZGUiKSk7aWYoYS5jb21wb3NpdGUpe2NvbnN0IHQ9ZS5nZXQoIkNJRFN5c3RlbUluZm8iKTt0IGluc3RhbmNlb2YgaS5EaWN0JiYoYS5jaWRTeXN0ZW1JbmZvPXtyZWdpc3RyeTooMCxyLnN0cmluZ1RvUERGU3RyaW5nKSh0LmdldCgiUmVnaXN0cnkiKSksb3JkZXJpbmc6KDAsci5zdHJpbmdUb1BERlN0cmluZykodC5nZXQoIk9yZGVyaW5nIikpLHN1cHBsZW1lbnQ6dC5nZXQoIlN1cHBsZW1lbnQiKX0pO3RyeXtjb25zdCB0PWUuZ2V0KCJDSURUb0dJRE1hcCIpO3QgaW5zdGFuY2VvZiB5LkJhc2VTdHJlYW0mJihzPXQuZ2V0Qnl0ZXMoKSl9Y2F0Y2goZSl7aWYoIXRoaXMub3B0aW9ucy5pZ25vcmVFcnJvcnMpdGhyb3cgZTsoMCxyLndhcm4pKGBleHRyYWN0RGF0YVN0cnVjdHVyZXMgLSBpZ25vcmluZyBDSURUb0dJRE1hcCBkYXRhOiAiJHtlfSIuYCl9fWNvbnN0IGg9W107bGV0IHUsZD1udWxsO2lmKGUuaGFzKCJFbmNvZGluZyIpKXt1PWUuZ2V0KCJFbmNvZGluZyIpO2lmKHUgaW5zdGFuY2VvZiBpLkRpY3Qpe2Q9dS5nZXQoIkJhc2VFbmNvZGluZyIpO2Q9ZCBpbnN0YW5jZW9mIGkuTmFtZT9kLm5hbWU6bnVsbDtpZih1LmhhcygiRGlmZmVyZW5jZXMiKSl7Y29uc3QgZT11LmdldCgiRGlmZmVyZW5jZXMiKTtsZXQgdD0wO2ZvcihsZXQgYT0wLHM9ZS5sZW5ndGg7YTxzO2ErKyl7Y29uc3Qgcz1uLmZldGNoSWZSZWYoZVthXSk7aWYoIm51bWJlciI9PXR5cGVvZiBzKXQ9cztlbHNle2lmKCEocyBpbnN0YW5jZW9mIGkuTmFtZSkpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoYEludmFsaWQgZW50cnkgaW4gJ0RpZmZlcmVuY2VzJyBhcnJheTogJHtzfWApO2hbdCsrXT1zLm5hbWV9fX19ZWxzZSBpZih1IGluc3RhbmNlb2YgaS5OYW1lKWQ9dS5uYW1lO2Vsc2V7Y29uc3QgZT0iRW5jb2RpbmcgaXMgbm90IGEgTmFtZSBub3IgYSBEaWN0IjtpZighdGhpcy5vcHRpb25zLmlnbm9yZUVycm9ycyl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcihlKTsoMCxyLndhcm4pKGUpfSJNYWNSb21hbkVuY29kaW5nIiE9PWQmJiJNYWNFeHBlcnRFbmNvZGluZyIhPT1kJiYiV2luQW5zaUVuY29kaW5nIiE9PWQmJihkPW51bGwpfWlmKGQpYS5kZWZhdWx0RW5jb2Rpbmc9KDAsYy5nZXRFbmNvZGluZykoZCk7ZWxzZXtjb25zdCBlPSEhKGEuZmxhZ3Mmby5Gb250RmxhZ3MuU3ltYm9saWMpLHQ9ISEoYS5mbGFncyZvLkZvbnRGbGFncy5Ob25zeW1ib2xpYyk7dT1jLlN0YW5kYXJkRW5jb2Rpbmc7IlRydWVUeXBlIiE9PWEudHlwZXx8dHx8KHU9Yy5XaW5BbnNpRW5jb2RpbmcpO2lmKGUpe3U9Yy5NYWNSb21hbkVuY29kaW5nO2EuZmlsZSYmIWEuaXNJbnRlcm5hbEZvbnR8fCgvU3ltYm9sL2kudGVzdChhLm5hbWUpP3U9Yy5TeW1ib2xTZXRFbmNvZGluZzovRGluZ2JhdHN8V2luZ2RpbmdzL2kudGVzdChhLm5hbWUpJiYodT1jLlphcGZEaW5nYmF0c0VuY29kaW5nKSl9YS5kZWZhdWx0RW5jb2Rpbmc9dX1hLmRpZmZlcmVuY2VzPWg7YS5iYXNlRW5jb2RpbmdOYW1lPWQ7YS5oYXNFbmNvZGluZz0hIWR8fGgubGVuZ3RoPjA7YS5kaWN0PWU7cmV0dXJuIGwudGhlbigoZT0+e2EudG9Vbmljb2RlPWU7cmV0dXJuIHRoaXMuYnVpbGRUb1VuaWNvZGUoYSl9KSkudGhlbigoZT0+e2EudG9Vbmljb2RlPWU7cyYmKGEuY2lkVG9HaWRNYXA9dGhpcy5yZWFkQ2lkVG9HaWRNYXAocyxlKSk7cmV0dXJuIGF9KSl9X3NpbXBsZUZvbnRUb1VuaWNvZGUoZSx0PSExKXsoMCxyLmFzc2VydCkoIWUuY29tcG9zaXRlLCJNdXN0IGJlIGEgc2ltcGxlIGZvbnQuIik7Y29uc3QgYT1bXSxuPWUuZGVmYXVsdEVuY29kaW5nLnNsaWNlKCksaT1lLmJhc2VFbmNvZGluZ05hbWUscz1lLmRpZmZlcmVuY2VzO2Zvcihjb25zdCBlIGluIHMpe2NvbnN0IHQ9c1tlXTsiLm5vdGRlZiIhPT10JiYobltlXT10KX1jb25zdCBvPSgwLGsuZ2V0R2x5cGhzVW5pY29kZSkoKTtmb3IoY29uc3QgciBpbiBuKXtsZXQgcz1uW3JdO2lmKCIiIT09cylpZih2b2lkIDAhPT1vW3NdKWFbcl09U3RyaW5nLmZyb21DaGFyQ29kZShvW3NdKTtlbHNle2xldCBuPTA7c3dpdGNoKHNbMF0pe2Nhc2UiRyI6Mz09PXMubGVuZ3RoJiYobj1wYXJzZUludChzLnN1YnN0cmluZygxKSwxNikpO2JyZWFrO2Nhc2UiZyI6NT09PXMubGVuZ3RoJiYobj1wYXJzZUludChzLnN1YnN0cmluZygxKSwxNikpO2JyZWFrO2Nhc2UiQyI6Y2FzZSJjIjppZihzLmxlbmd0aD49MyYmcy5sZW5ndGg8PTQpe2NvbnN0IGE9cy5zdWJzdHJpbmcoMSk7aWYodCl7bj1wYXJzZUludChhLDE2KTticmVha31uPSthO2lmKE51bWJlci5pc05hTihuKSYmTnVtYmVyLmlzSW50ZWdlcihwYXJzZUludChhLDE2KSkpcmV0dXJuIHRoaXMuX3NpbXBsZUZvbnRUb1VuaWNvZGUoZSwhMCl9YnJlYWs7ZGVmYXVsdDpjb25zdCBhPSgwLGguZ2V0VW5pY29kZUZvckdseXBoKShzLG8pOy0xIT09YSYmKG49YSl9aWYobj4wJiZuPD0xMTE0MTExJiZOdW1iZXIuaXNJbnRlZ2VyKG4pKXtpZihpJiZuPT09K3Ipe2NvbnN0IGU9KDAsYy5nZXRFbmNvZGluZykoaSk7aWYoZSYmKHM9ZVtyXSkpe2Fbcl09U3RyaW5nLmZyb21DaGFyQ29kZShvW3NdKTtjb250aW51ZX19YVtyXT1TdHJpbmcuZnJvbUNvZGVQb2ludChuKX19fXJldHVybiBhfWFzeW5jIGJ1aWxkVG9Vbmljb2RlKGUpe2UuaGFzSW5jbHVkZWRUb1VuaWNvZGVNYXA9ISFlLnRvVW5pY29kZSYmZS50b1VuaWNvZGUubGVuZ3RoPjA7aWYoZS5oYXNJbmNsdWRlZFRvVW5pY29kZU1hcCl7IWUuY29tcG9zaXRlJiZlLmhhc0VuY29kaW5nJiYoZS5mYWxsYmFja1RvVW5pY29kZT10aGlzLl9zaW1wbGVGb250VG9Vbmljb2RlKGUpKTtyZXR1cm4gZS50b1VuaWNvZGV9aWYoIWUuY29tcG9zaXRlKXJldHVybiBuZXcgZi5Ub1VuaWNvZGVNYXAodGhpcy5fc2ltcGxlRm9udFRvVW5pY29kZShlKSk7aWYoZS5jb21wb3NpdGUmJihlLmNNYXAuYnVpbHRJbkNNYXAmJiEoZS5jTWFwIGluc3RhbmNlb2Ygbi5JZGVudGl0eUNNYXApfHwiQWRvYmUiPT09ZS5jaWRTeXN0ZW1JbmZvLnJlZ2lzdHJ5JiYoIkdCMSI9PT1lLmNpZFN5c3RlbUluZm8ub3JkZXJpbmd8fCJDTlMxIj09PWUuY2lkU3lzdGVtSW5mby5vcmRlcmluZ3x8IkphcGFuMSI9PT1lLmNpZFN5c3RlbUluZm8ub3JkZXJpbmd8fCJLb3JlYTEiPT09ZS5jaWRTeXN0ZW1JbmZvLm9yZGVyaW5nKSkpe2NvbnN0e3JlZ2lzdHJ5OnQsb3JkZXJpbmc6YX09ZS5jaWRTeXN0ZW1JbmZvLHM9aS5OYW1lLmdldChgJHt0fS0ke2F9LVVDUzJgKSxvPWF3YWl0IG4uQ01hcEZhY3RvcnkuY3JlYXRlKHtlbmNvZGluZzpzLGZldGNoQnVpbHRJbkNNYXA6dGhpcy5fZmV0Y2hCdWlsdEluQ01hcEJvdW5kLHVzZUNNYXA6bnVsbH0pLGM9W107ZS5jTWFwLmZvckVhY2goKGZ1bmN0aW9uKGUsdCl7aWYodD42NTUzNSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiTWF4IHNpemUgb2YgQ0lEIGlzIDY1LDUzNSIpO2NvbnN0IGE9by5sb29rdXAodCk7YSYmKGNbZV09U3RyaW5nLmZyb21DaGFyQ29kZSgoYS5jaGFyQ29kZUF0KDApPDw4KSthLmNoYXJDb2RlQXQoMSkpKX0pKTtyZXR1cm4gbmV3IGYuVG9Vbmljb2RlTWFwKGMpfXJldHVybiBuZXcgZi5JZGVudGl0eVRvVW5pY29kZU1hcChlLmZpcnN0Q2hhcixlLmxhc3RDaGFyKX1yZWFkVG9Vbmljb2RlKGUpe3JldHVybiBlP2UgaW5zdGFuY2VvZiBpLk5hbWU/bi5DTWFwRmFjdG9yeS5jcmVhdGUoe2VuY29kaW5nOmUsZmV0Y2hCdWlsdEluQ01hcDp0aGlzLl9mZXRjaEJ1aWx0SW5DTWFwQm91bmQsdXNlQ01hcDpudWxsfSkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBuLklkZW50aXR5Q01hcD9uZXcgZi5JZGVudGl0eVRvVW5pY29kZU1hcCgwLDY1NTM1KTpuZXcgZi5Ub1VuaWNvZGVNYXAoZS5nZXRNYXAoKSl9KSk6ZSBpbnN0YW5jZW9mIHkuQmFzZVN0cmVhbT9uLkNNYXBGYWN0b3J5LmNyZWF0ZSh7ZW5jb2Rpbmc6ZSxmZXRjaEJ1aWx0SW5DTWFwOnRoaXMuX2ZldGNoQnVpbHRJbkNNYXBCb3VuZCx1c2VDTWFwOm51bGx9KS50aGVuKChmdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2Ygbi5JZGVudGl0eUNNYXApcmV0dXJuIG5ldyBmLklkZW50aXR5VG9Vbmljb2RlTWFwKDAsNjU1MzUpO2NvbnN0IHQ9bmV3IEFycmF5KGUubGVuZ3RoKTtlLmZvckVhY2goKGZ1bmN0aW9uKGUsYSl7aWYoIm51bWJlciI9PXR5cGVvZiBhKXt0W2VdPVN0cmluZy5mcm9tQ29kZVBvaW50KGEpO3JldHVybn1jb25zdCByPVtdO2ZvcihsZXQgZT0wO2U8YS5sZW5ndGg7ZSs9Mil7Y29uc3QgdD1hLmNoYXJDb2RlQXQoZSk8PDh8YS5jaGFyQ29kZUF0KGUrMSk7aWYoNTUyOTYhPSg2MzQ4OCZ0KSl7ci5wdXNoKHQpO2NvbnRpbnVlfWUrPTI7Y29uc3Qgbj1hLmNoYXJDb2RlQXQoZSk8PDh8YS5jaGFyQ29kZUF0KGUrMSk7ci5wdXNoKCgoMTAyMyZ0KTw8MTApKygxMDIzJm4pKzY1NTM2KX10W2VdPVN0cmluZy5mcm9tQ29kZVBvaW50KC4uLnIpfSkpO3JldHVybiBuZXcgZi5Ub1VuaWNvZGVNYXAodCl9KSwoZT0+e2lmKGUgaW5zdGFuY2VvZiByLkFib3J0RXhjZXB0aW9uKXJldHVybiBudWxsO2lmKHRoaXMub3B0aW9ucy5pZ25vcmVFcnJvcnMpe3RoaXMuaGFuZGxlci5zZW5kKCJVbnN1cHBvcnRlZEZlYXR1cmUiLHtmZWF0dXJlSWQ6ci5VTlNVUFBPUlRFRF9GRUFUVVJFUy5lcnJvckZvbnRUb1VuaWNvZGV9KTsoMCxyLndhcm4pKGByZWFkVG9Vbmljb2RlIC0gaWdub3JpbmcgVG9Vbmljb2RlIGRhdGE6ICIke2V9Ii5gKTtyZXR1cm4gbnVsbH10aHJvdyBlfSkpOlByb21pc2UucmVzb2x2ZShudWxsKTpQcm9taXNlLnJlc29sdmUobnVsbCl9cmVhZENpZFRvR2lkTWFwKGUsdCl7Y29uc3QgYT1bXTtmb3IobGV0IHI9MCxuPWUubGVuZ3RoO3I8bjtyKyspe2NvbnN0IG49ZVtyKytdPDw4fGVbcl0saT1yPj4xOygwIT09bnx8dC5oYXMoaSkpJiYoYVtpXT1uKX1yZXR1cm4gYX1leHRyYWN0V2lkdGhzKGUsdCxhKXtjb25zdCByPXRoaXMueHJlZjtsZXQgbj1bXSxzPTA7Y29uc3QgYz1bXTtsZXQgbCxoLHUsZCxmLGcscCxtO2lmKGEuY29tcG9zaXRlKXtzPWUuaGFzKCJEVyIpP2UuZ2V0KCJEVyIpOjFlMzttPWUuZ2V0KCJXIik7aWYobSlmb3IoaD0wLHU9bS5sZW5ndGg7aDx1O2grKyl7Zz1yLmZldGNoSWZSZWYobVtoKytdKTtwPXIuZmV0Y2hJZlJlZihtW2hdKTtpZihBcnJheS5pc0FycmF5KHApKWZvcihkPTAsZj1wLmxlbmd0aDtkPGY7ZCsrKW5bZysrXT1yLmZldGNoSWZSZWYocFtkXSk7ZWxzZXtjb25zdCBlPXIuZmV0Y2hJZlJlZihtWysraF0pO2ZvcihkPWc7ZDw9cDtkKyspbltkXT1lfX1pZihhLnZlcnRpY2FsKXtsZXQgdD1lLmdldEFycmF5KCJEVzIiKXx8Wzg4MCwtMWUzXTtsPVt0WzFdLC41KnMsdFswXV07dD1lLmdldCgiVzIiKTtpZih0KWZvcihoPTAsdT10Lmxlbmd0aDtoPHU7aCsrKXtnPXIuZmV0Y2hJZlJlZih0W2grK10pO3A9ci5mZXRjaElmUmVmKHRbaF0pO2lmKEFycmF5LmlzQXJyYXkocCkpZm9yKGQ9MCxmPXAubGVuZ3RoO2Q8ZjtkKyspY1tnKytdPVtyLmZldGNoSWZSZWYocFtkKytdKSxyLmZldGNoSWZSZWYocFtkKytdKSxyLmZldGNoSWZSZWYocFtkXSldO2Vsc2V7Y29uc3QgZT1bci5mZXRjaElmUmVmKHRbKytoXSksci5mZXRjaElmUmVmKHRbKytoXSksci5mZXRjaElmUmVmKHRbKytoXSldO2ZvcihkPWc7ZDw9cDtkKyspY1tkXT1lfX19fWVsc2V7Y29uc3Qgbz1hLmZpcnN0Q2hhcjttPWUuZ2V0KCJXaWR0aHMiKTtpZihtKXtkPW87Zm9yKGg9MCx1PW0ubGVuZ3RoO2g8dTtoKyspbltkKytdPXIuZmV0Y2hJZlJlZihtW2hdKTtzPXBhcnNlRmxvYXQodC5nZXQoIk1pc3NpbmdXaWR0aCIpKXx8MH1lbHNle2NvbnN0IHQ9ZS5nZXQoIkJhc2VGb250Iik7aWYodCBpbnN0YW5jZW9mIGkuTmFtZSl7Y29uc3QgZT10aGlzLmdldEJhc2VGb250TWV0cmljcyh0Lm5hbWUpO249dGhpcy5idWlsZENoYXJDb2RlVG9XaWR0aChlLndpZHRocyxhKTtzPWUuZGVmYXVsdFdpZHRofX19bGV0IGI9ITAseT1zO2Zvcihjb25zdCBlIGluIG4pe2NvbnN0IHQ9bltlXTtpZih0KWlmKHkpe2lmKHkhPT10KXtiPSExO2JyZWFrfX1lbHNlIHk9dH1iJiYoYS5mbGFnc3w9by5Gb250RmxhZ3MuRml4ZWRQaXRjaCk7YS5kZWZhdWx0V2lkdGg9czthLndpZHRocz1uO2EuZGVmYXVsdFZNZXRyaWNzPWw7YS52bWV0cmljcz1jfWlzU2VyaWZGb250KGUpe2NvbnN0IHQ9ZS5zcGxpdCgiLSIpWzBdO3JldHVybiB0IGluKDAsbC5nZXRTZXJpZkZvbnRzKSgpfHwtMSE9PXQuc2VhcmNoKC9zZXJpZi9naSl9Z2V0QmFzZUZvbnRNZXRyaWNzKGUpe2xldCB0PTAsYT1PYmplY3QuY3JlYXRlKG51bGwpLHI9ITE7bGV0IG49KDAsbC5nZXRTdGRGb250TWFwKSgpW2VdfHxlO2NvbnN0IGk9KDAsdi5nZXRNZXRyaWNzKSgpO24gaW4gaXx8KG49dGhpcy5pc1NlcmlmRm9udChlKT8iVGltZXMtUm9tYW4iOiJIZWx2ZXRpY2EiKTtjb25zdCBzPWlbbl07aWYoIm51bWJlciI9PXR5cGVvZiBzKXt0PXM7cj0hMH1lbHNlIGE9cygpO3JldHVybntkZWZhdWx0V2lkdGg6dCxtb25vc3BhY2U6cix3aWR0aHM6YX19YnVpbGRDaGFyQ29kZVRvV2lkdGgoZSx0KXtjb25zdCBhPU9iamVjdC5jcmVhdGUobnVsbCkscj10LmRpZmZlcmVuY2VzLG49dC5kZWZhdWx0RW5jb2Rpbmc7Zm9yKGxldCB0PTA7dDwyNTY7dCsrKXQgaW4gciYmZVtyW3RdXT9hW3RdPWVbclt0XV06dCBpbiBuJiZlW25bdF1dJiYoYVt0XT1lW25bdF1dKTtyZXR1cm4gYX1wcmVFdmFsdWF0ZUZvbnQoZSl7Y29uc3QgdD1lO2xldCBhPWUuZ2V0KCJTdWJ0eXBlIik7aWYoIShhIGluc3RhbmNlb2YgaS5OYW1lKSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiaW52YWxpZCBmb250IFN1YnR5cGUiKTtsZXQgbixzLG89ITE7aWYoIlR5cGUwIj09PWEubmFtZSl7Y29uc3QgdD1lLmdldCgiRGVzY2VuZGFudEZvbnRzIik7aWYoIXQpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoIkRlc2NlbmRhbnQgZm9udHMgYXJlIG5vdCBzcGVjaWZpZWQiKTtpZighKChlPUFycmF5LmlzQXJyYXkodCk/dGhpcy54cmVmLmZldGNoSWZSZWYodFswXSk6dClpbnN0YW5jZW9mIGkuRGljdCkpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoIkRlc2NlbmRhbnQgZm9udCBpcyBub3QgYSBkaWN0aW9uYXJ5LiIpO2E9ZS5nZXQoIlN1YnR5cGUiKTtpZighKGEgaW5zdGFuY2VvZiBpLk5hbWUpKXRocm93IG5ldyByLkZvcm1hdEVycm9yKCJpbnZhbGlkIGZvbnQgU3VidHlwZSIpO289ITB9Y29uc3QgYz1lLmdldCgiRmlyc3RDaGFyIil8fDAsbD1lLmdldCgiTGFzdENoYXIiKXx8KG8/NjU1MzU6MjU1KSxoPWUuZ2V0KCJGb250RGVzY3JpcHRvciIpO2lmKGgpe249bmV3IEYuTXVybXVySGFzaDNfNjQ7Y29uc3QgYT10LmdldFJhdygiRW5jb2RpbmciKTtpZihhIGluc3RhbmNlb2YgaS5OYW1lKW4udXBkYXRlKGEubmFtZSk7ZWxzZSBpZihhIGluc3RhbmNlb2YgaS5SZWYpbi51cGRhdGUoYS50b1N0cmluZygpKTtlbHNlIGlmKGEgaW5zdGFuY2VvZiBpLkRpY3QpZm9yKGNvbnN0IGUgb2YgYS5nZXRSYXdWYWx1ZXMoKSlpZihlIGluc3RhbmNlb2YgaS5OYW1lKW4udXBkYXRlKGUubmFtZSk7ZWxzZSBpZihlIGluc3RhbmNlb2YgaS5SZWYpbi51cGRhdGUoZS50b1N0cmluZygpKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoZSkpe2NvbnN0IHQ9ZS5sZW5ndGgsYT1uZXcgQXJyYXkodCk7Zm9yKGxldCByPTA7cjx0O3IrKyl7Y29uc3QgdD1lW3JdO3QgaW5zdGFuY2VvZiBpLk5hbWU/YVtyXT10Lm5hbWU6KCJudW1iZXIiPT10eXBlb2YgdHx8dCBpbnN0YW5jZW9mIGkuUmVmKSYmKGFbcl09dC50b1N0cmluZygpKX1uLnVwZGF0ZShhLmpvaW4oKSl9bi51cGRhdGUoYCR7Y30tJHtsfWApO3M9ZS5nZXQoIlRvVW5pY29kZSIpfHx0LmdldCgiVG9Vbmljb2RlIik7aWYocyBpbnN0YW5jZW9mIHkuQmFzZVN0cmVhbSl7Y29uc3QgZT1zLnN0cnx8cyx0PWUuYnVmZmVyP25ldyBVaW50OEFycmF5KGUuYnVmZmVyLmJ1ZmZlciwwLGUuYnVmZmVyTGVuZ3RoKTpuZXcgVWludDhBcnJheShlLmJ5dGVzLmJ1ZmZlcixlLnN0YXJ0LGUuZW5kLWUuc3RhcnQpO24udXBkYXRlKHQpfWVsc2UgcyBpbnN0YW5jZW9mIGkuTmFtZSYmbi51cGRhdGUocy5uYW1lKTtjb25zdCByPWUuZ2V0KCJXaWR0aHMiKXx8dC5nZXQoIldpZHRocyIpO2lmKEFycmF5LmlzQXJyYXkocikpe2NvbnN0IGU9W107Zm9yKGNvbnN0IHQgb2YgcikoIm51bWJlciI9PXR5cGVvZiB0fHx0IGluc3RhbmNlb2YgaS5SZWYpJiZlLnB1c2godC50b1N0cmluZygpKTtuLnVwZGF0ZShlLmpvaW4oKSl9aWYobyl7bi51cGRhdGUoImNvbXBvc2l0ZUZvbnQiKTtjb25zdCBhPWUuZ2V0KCJXIil8fHQuZ2V0KCJXIik7aWYoQXJyYXkuaXNBcnJheShhKSl7Y29uc3QgZT1bXTtmb3IoY29uc3QgdCBvZiBhKWlmKCJudW1iZXIiPT10eXBlb2YgdHx8dCBpbnN0YW5jZW9mIGkuUmVmKWUucHVzaCh0LnRvU3RyaW5nKCkpO2Vsc2UgaWYoQXJyYXkuaXNBcnJheSh0KSl7Y29uc3QgYT1bXTtmb3IoY29uc3QgZSBvZiB0KSgibnVtYmVyIj09dHlwZW9mIGV8fGUgaW5zdGFuY2VvZiBpLlJlZikmJmEucHVzaChlLnRvU3RyaW5nKCkpO2UucHVzaChgWyR7YS5qb2luKCl9XWApfW4udXBkYXRlKGUuam9pbigpKX1jb25zdCByPWUuZ2V0UmF3KCJDSURUb0dJRE1hcCIpfHx0LmdldFJhdygiQ0lEVG9HSURNYXAiKTtyIGluc3RhbmNlb2YgaS5OYW1lP24udXBkYXRlKHIubmFtZSk6ciBpbnN0YW5jZW9mIGkuUmVmP24udXBkYXRlKHIudG9TdHJpbmcoKSk6ciBpbnN0YW5jZW9mIHkuQmFzZVN0cmVhbSYmbi51cGRhdGUoci5wZWVrQnl0ZXMoKSl9fXJldHVybntkZXNjcmlwdG9yOmgsZGljdDplLGJhc2VEaWN0OnQsY29tcG9zaXRlOm8sdHlwZTphLm5hbWUsZmlyc3RDaGFyOmMsbGFzdENoYXI6bCx0b1VuaWNvZGU6cyxoYXNoOm4/bi5oZXhkaWdlc3QoKToiIn19YXN5bmMgdHJhbnNsYXRlRm9udCh7ZGVzY3JpcHRvcjplLGRpY3Q6dCxiYXNlRGljdDphLGNvbXBvc2l0ZTpjLHR5cGU6aCxmaXJzdENoYXI6dSxsYXN0Q2hhcjpmLHRvVW5pY29kZTpnLGNzc0ZvbnRJbmZvOnB9KXtjb25zdCBtPSJUeXBlMyI9PT1oO2xldCB5O2lmKCFlKXtpZighbSl7bGV0IGU9dC5nZXQoIkJhc2VGb250Iik7aWYoIShlIGluc3RhbmNlb2YgaS5OYW1lKSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiQmFzZSBmb250IGlzIG5vdCBzcGVjaWZpZWQiKTtlPWUubmFtZS5yZXBsYWNlKC9bLF9dL2csIi0iKTtjb25zdCBuPXRoaXMuZ2V0QmFzZUZvbnRNZXRyaWNzKGUpLGM9ZS5zcGxpdCgiLSIpWzBdLGQ9KHRoaXMuaXNTZXJpZkZvbnQoYyk/by5Gb250RmxhZ3MuU2VyaWY6MCl8KG4ubW9ub3NwYWNlP28uRm9udEZsYWdzLkZpeGVkUGl0Y2g6MCl8KCgwLGwuZ2V0U3ltYm9sc0ZvbnRzKSgpW2NdP28uRm9udEZsYWdzLlN5bWJvbGljOm8uRm9udEZsYWdzLk5vbnN5bWJvbGljKTt5PXt0eXBlOmgsbmFtZTplLGxvYWRlZE5hbWU6YS5sb2FkZWROYW1lLHdpZHRoczpuLndpZHRocyxkZWZhdWx0V2lkdGg6bi5kZWZhdWx0V2lkdGgsaXNTaW11bGF0ZWRGbGFnczohMCxmbGFnczpkLGZpcnN0Q2hhcjp1LGxhc3RDaGFyOmYsdG9Vbmljb2RlOmcseEhlaWdodDowLGNhcEhlaWdodDowLGl0YWxpY0FuZ2xlOjAsaXNUeXBlM0ZvbnQ6bX07Y29uc3QgcD10LmdldCgiV2lkdGhzIiksYj0oMCxsLmdldFN0YW5kYXJkRm9udE5hbWUpKGUpO2xldCB3PW51bGw7aWYoYil7eS5pc1N0YW5kYXJkRm9udD0hMDt3PWF3YWl0IHRoaXMuZmV0Y2hTdGFuZGFyZEZvbnREYXRhKGIpO3kuaXNJbnRlcm5hbEZvbnQ9ISF3fXJldHVybiB0aGlzLmV4dHJhY3REYXRhU3RydWN0dXJlcyh0LHQseSkudGhlbigodD0+e2lmKHApe2NvbnN0IGU9W107bGV0IGE9dTtmb3IobGV0IHQ9MCxyPXAubGVuZ3RoO3Q8cjt0KyspZVthKytdPXRoaXMueHJlZi5mZXRjaElmUmVmKHBbdF0pO3Qud2lkdGhzPWV9ZWxzZSB0LndpZHRocz10aGlzLmJ1aWxkQ2hhckNvZGVUb1dpZHRoKG4ud2lkdGhzLHQpO3JldHVybiBuZXcgcy5Gb250KGUsdyx0KX0pKX0oZT1uZXcgaS5EaWN0KG51bGwpKS5zZXQoIkZvbnROYW1lIixpLk5hbWUuZ2V0KGgpKTtlLnNldCgiRm9udEJCb3giLHQuZ2V0QXJyYXkoIkZvbnRCQm94Iil8fFswLDAsMCwwXSl9bGV0IHcsUyx4LGssQyx2PWUuZ2V0KCJGb250TmFtZSIpLEY9dC5nZXQoIkJhc2VGb250Iik7InN0cmluZyI9PXR5cGVvZiB2JiYodj1pLk5hbWUuZ2V0KHYpKTsic3RyaW5nIj09dHlwZW9mIEYmJihGPWkuTmFtZS5nZXQoRikpO2lmKCFtKXtjb25zdCBlPXYmJnYubmFtZSx0PUYmJkYubmFtZTtpZihlIT09dCl7KDAsci5pbmZvKShgVGhlIEZvbnREZXNjcmlwdG9yJ3MgRm9udE5hbWUgaXMgIiR7ZX0iIGJ1dCBzaG91bGQgYmUgdGhlIHNhbWUgYXMgdGhlIEZvbnQncyBCYXNlRm9udCAiJHt0fSIuYCk7ZSYmdCYmdC5zdGFydHNXaXRoKGUpJiYodj1GKX19dj12fHxGO2lmKCEodiBpbnN0YW5jZW9mIGkuTmFtZSkpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoImludmFsaWQgZm9udCBuYW1lIik7dHJ5e3c9ZS5nZXQoIkZvbnRGaWxlIiwiRm9udEZpbGUyIiwiRm9udEZpbGUzIil9Y2F0Y2goZSl7aWYoIXRoaXMub3B0aW9ucy5pZ25vcmVFcnJvcnMpdGhyb3cgZTsoMCxyLndhcm4pKGB0cmFuc2xhdGVGb250IC0gZmV0Y2hpbmcgIiR7di5uYW1lfSIgZm9udCBmaWxlOiAiJHtlfSIuYCk7dz1uZXcgYi5OdWxsU3RyZWFtfWxldCBPPSExLFQ9ITEsTT1udWxsO2lmKHcpe2lmKHcuZGljdCl7Y29uc3QgZT13LmRpY3QuZ2V0KCJTdWJ0eXBlIik7ZSBpbnN0YW5jZW9mIGkuTmFtZSYmKFM9ZS5uYW1lKTt4PXcuZGljdC5nZXQoIkxlbmd0aDEiKTtrPXcuZGljdC5nZXQoIkxlbmd0aDIiKTtDPXcuZGljdC5nZXQoIkxlbmd0aDMiKX19ZWxzZSBpZihwKXtjb25zdCBlPSgwLGQuZ2V0WGZhRm9udE5hbWUpKHYubmFtZSk7aWYoZSl7cC5mb250RmFtaWx5PWAke3AuZm9udEZhbWlseX0tUGRmSlMtWEZBYDtwLm1ldHJpY3M9ZS5tZXRyaWNzfHxudWxsO009ZS5mYWN0b3JzfHxudWxsO3c9YXdhaXQgdGhpcy5mZXRjaFN0YW5kYXJkRm9udERhdGEoZS5uYW1lKTtUPSEhdzthPXQ9KDAsZC5nZXRYZmFGb250RGljdCkodi5uYW1lKTtjPSEwfX1lbHNlIGlmKCFtKXtjb25zdCBlPSgwLGwuZ2V0U3RhbmRhcmRGb250TmFtZSkodi5uYW1lKTtpZihlKXtPPSEwO3c9YXdhaXQgdGhpcy5mZXRjaFN0YW5kYXJkRm9udERhdGEoZSk7VD0hIXd9fXk9e3R5cGU6aCxuYW1lOnYubmFtZSxzdWJ0eXBlOlMsZmlsZTp3LGxlbmd0aDE6eCxsZW5ndGgyOmssbGVuZ3RoMzpDLGlzU3RhbmRhcmRGb250Ok8saXNJbnRlcm5hbEZvbnQ6VCxsb2FkZWROYW1lOmEubG9hZGVkTmFtZSxjb21wb3NpdGU6YyxmaXhlZFBpdGNoOiExLGZvbnRNYXRyaXg6dC5nZXRBcnJheSgiRm9udE1hdHJpeCIpfHxyLkZPTlRfSURFTlRJVFlfTUFUUklYLGZpcnN0Q2hhcjp1LGxhc3RDaGFyOmYsdG9Vbmljb2RlOmcsYmJveDplLmdldEFycmF5KCJGb250QkJveCIpfHx0LmdldEFycmF5KCJGb250QkJveCIpLGFzY2VudDplLmdldCgiQXNjZW50IiksZGVzY2VudDplLmdldCgiRGVzY2VudCIpLHhIZWlnaHQ6ZS5nZXQoIlhIZWlnaHQiKXx8MCxjYXBIZWlnaHQ6ZS5nZXQoIkNhcEhlaWdodCIpfHwwLGZsYWdzOmUuZ2V0KCJGbGFncyIpLGl0YWxpY0FuZ2xlOmUuZ2V0KCJJdGFsaWNBbmdsZSIpfHwwLGlzVHlwZTNGb250Om0sY3NzRm9udEluZm86cCxzY2FsZUZhY3RvcnM6TX07aWYoYyl7Y29uc3QgZT1hLmdldCgiRW5jb2RpbmciKTtlIGluc3RhbmNlb2YgaS5OYW1lJiYoeS5jaWRFbmNvZGluZz1lLm5hbWUpO2NvbnN0IHQ9YXdhaXQgbi5DTWFwRmFjdG9yeS5jcmVhdGUoe2VuY29kaW5nOmUsZmV0Y2hCdWlsdEluQ01hcDp0aGlzLl9mZXRjaEJ1aWx0SW5DTWFwQm91bmQsdXNlQ01hcDpudWxsfSk7eS5jTWFwPXQ7eS52ZXJ0aWNhbD15LmNNYXAudmVydGljYWx9cmV0dXJuIHRoaXMuZXh0cmFjdERhdGFTdHJ1Y3R1cmVzKHQsYSx5KS50aGVuKChhPT57dGhpcy5leHRyYWN0V2lkdGhzKHQsZSxhKTtyZXR1cm4gbmV3IHMuRm9udCh2Lm5hbWUsdyxhKX0pKX1zdGF0aWMgYnVpbGRGb250UGF0aHMoZSx0LGEsbil7ZnVuY3Rpb24gYnVpbGRQYXRoKHQpe2NvbnN0IGk9YCR7ZS5sb2FkZWROYW1lfV9wYXRoXyR7dH1gO3RyeXtpZihlLnJlbmRlcmVyLmhhc0J1aWx0UGF0aCh0KSlyZXR1cm47YS5zZW5kKCJjb21tb25vYmoiLFtpLCJGb250UGF0aCIsZS5yZW5kZXJlci5nZXRQYXRoSnModCldKX1jYXRjaChlKXtpZihuLmlnbm9yZUVycm9ycyl7YS5zZW5kKCJVbnN1cHBvcnRlZEZlYXR1cmUiLHtmZWF0dXJlSWQ6ci5VTlNVUFBPUlRFRF9GRUFUVVJFUy5lcnJvckZvbnRCdWlsZFBhdGh9KTsoMCxyLndhcm4pKGBidWlsZEZvbnRQYXRocyAtIGlnbm9yaW5nICR7aX0gZ2x5cGg6ICIke2V9Ii5gKTtyZXR1cm59dGhyb3cgZX19Zm9yKGNvbnN0IGUgb2YgdCl7YnVpbGRQYXRoKGUuZm9udENoYXIpO2NvbnN0IHQ9ZS5hY2NlbnQ7dCYmdC5mb250Q2hhciYmYnVpbGRQYXRoKHQuZm9udENoYXIpfX1zdGF0aWMgZ2V0IGZhbGxiYWNrRm9udERpY3QoKXtjb25zdCBlPW5ldyBpLkRpY3Q7ZS5zZXQoIkJhc2VGb250IixpLk5hbWUuZ2V0KCJQREZKUy1GYWxsYmFja0ZvbnQiKSk7ZS5zZXQoIlR5cGUiLGkuTmFtZS5nZXQoIkZhbGxiYWNrVHlwZSIpKTtlLnNldCgiU3VidHlwZSIsaS5OYW1lLmdldCgiRmFsbGJhY2tUeXBlIikpO2Uuc2V0KCJFbmNvZGluZyIsaS5OYW1lLmdldCgiV2luQW5zaUVuY29kaW5nIikpO3JldHVybigwLHIuc2hhZG93KSh0aGlzLCJmYWxsYmFja0ZvbnREaWN0IixlKX19dC5QYXJ0aWFsRXZhbHVhdG9yPVBhcnRpYWxFdmFsdWF0b3I7Y2xhc3MgVHJhbnNsYXRlZEZvbnR7Y29uc3RydWN0b3Ioe2xvYWRlZE5hbWU6ZSxmb250OnQsZGljdDphLGV2YWx1YXRvck9wdGlvbnM6cn0pe3RoaXMubG9hZGVkTmFtZT1lO3RoaXMuZm9udD10O3RoaXMuZGljdD1hO3RoaXMuX2V2YWx1YXRvck9wdGlvbnM9cnx8TTt0aGlzLnR5cGUzTG9hZGVkPW51bGw7dGhpcy50eXBlM0RlcGVuZGVuY2llcz10LmlzVHlwZTNGb250P25ldyBTZXQ6bnVsbDt0aGlzLnNlbnQ9ITF9c2VuZChlKXtpZighdGhpcy5zZW50KXt0aGlzLnNlbnQ9ITA7ZS5zZW5kKCJjb21tb25vYmoiLFt0aGlzLmxvYWRlZE5hbWUsIkZvbnQiLHRoaXMuZm9udC5leHBvcnREYXRhKHRoaXMuX2V2YWx1YXRvck9wdGlvbnMuZm9udEV4dHJhUHJvcGVydGllcyldKX19ZmFsbGJhY2soZSl7aWYodGhpcy5mb250LmRhdGEpe3RoaXMuZm9udC5kaXNhYmxlRm9udEZhY2U9ITA7UGFydGlhbEV2YWx1YXRvci5idWlsZEZvbnRQYXRocyh0aGlzLmZvbnQsdGhpcy5mb250LmdseXBoQ2FjaGVWYWx1ZXMsZSx0aGlzLl9ldmFsdWF0b3JPcHRpb25zKX19bG9hZFR5cGUzRGF0YShlLHQsYSl7aWYodGhpcy50eXBlM0xvYWRlZClyZXR1cm4gdGhpcy50eXBlM0xvYWRlZDtpZighdGhpcy5mb250LmlzVHlwZTNGb250KXRocm93IG5ldyBFcnJvcigiTXVzdCBiZSBhIFR5cGUzIGZvbnQuIik7Y29uc3Qgbj1lLmNsb25lKHtpZ25vcmVFcnJvcnM6ITF9KTtuLnBhcnNpbmdUeXBlM0ZvbnQ9ITA7Y29uc3Qgcz1uZXcgaS5SZWZTZXQoZS50eXBlM0ZvbnRSZWZzKTt0aGlzLmRpY3Qub2JqSWQmJiFzLmhhcyh0aGlzLmRpY3Qub2JqSWQpJiZzLnB1dCh0aGlzLmRpY3Qub2JqSWQpO24udHlwZTNGb250UmVmcz1zO2NvbnN0IG89dGhpcy5mb250LGM9dGhpcy50eXBlM0RlcGVuZGVuY2llcztsZXQgbD1Qcm9taXNlLnJlc29sdmUoKTtjb25zdCBoPXRoaXMuZGljdC5nZXQoIkNoYXJQcm9jcyIpLHU9dGhpcy5kaWN0LmdldCgiUmVzb3VyY2VzIil8fHQsZD1PYmplY3QuY3JlYXRlKG51bGwpLGY9ci5VdGlsLm5vcm1hbGl6ZVJlY3Qoby5iYm94fHxbMCwwLDAsMF0pLGc9ZlsyXS1mWzBdLHA9ZlszXS1mWzFdLG09TWF0aC5oeXBvdChnLHApO2Zvcihjb25zdCBlIG9mIGguZ2V0S2V5cygpKWw9bC50aGVuKCgoKT0+e2NvbnN0IHQ9aC5nZXQoZSksaT1uZXcgTy5PcGVyYXRvckxpc3Q7cmV0dXJuIG4uZ2V0T3BlcmF0b3JMaXN0KHtzdHJlYW06dCx0YXNrOmEscmVzb3VyY2VzOnUsb3BlcmF0b3JMaXN0Oml9KS50aGVuKCgoKT0+e2kuZm5BcnJheVswXT09PXIuT1BTLnNldENoYXJXaWR0aEFuZEJvdW5kcyYmdGhpcy5fcmVtb3ZlVHlwZTNDb2xvck9wZXJhdG9ycyhpLG0pO2RbZV09aS5nZXRJUigpO2Zvcihjb25zdCBlIG9mIGkuZGVwZW5kZW5jaWVzKWMuYWRkKGUpfSkpLmNhdGNoKChmdW5jdGlvbih0KXsoMCxyLndhcm4pKGBUeXBlMyBmb250IHJlc291cmNlICIke2V9IiBpcyBub3QgYXZhaWxhYmxlLmApO2NvbnN0IGE9bmV3IE8uT3BlcmF0b3JMaXN0O2RbZV09YS5nZXRJUigpfSkpfSkpO3RoaXMudHlwZTNMb2FkZWQ9bC50aGVuKCgoKT0+e28uY2hhclByb2NPcGVyYXRvckxpc3Q9ZDtpZih0aGlzLl9iYm94KXtvLmlzQ2hhckJCb3g9ITA7by5iYm94PXRoaXMuX2Jib3h9fSkpO3JldHVybiB0aGlzLnR5cGUzTG9hZGVkfV9yZW1vdmVUeXBlM0NvbG9yT3BlcmF0b3JzKGUsdD1OYU4pe2NvbnN0IGE9ci5VdGlsLm5vcm1hbGl6ZVJlY3QoZS5hcmdzQXJyYXlbMF0uc2xpY2UoMikpLG49YVsyXS1hWzBdLGk9YVszXS1hWzFdLHM9TWF0aC5oeXBvdChuLGkpO2lmKDA9PT1ufHwwPT09aSl7ZS5mbkFycmF5LnNwbGljZSgwLDEpO2UuYXJnc0FycmF5LnNwbGljZSgwLDEpfWVsc2UgaWYoMD09PXR8fE1hdGgucm91bmQocy90KT49MTApe3RoaXMuX2Jib3h8fCh0aGlzLl9iYm94PVsxLzAsMS8wLC0xLzAsLTEvMF0pO3RoaXMuX2Jib3hbMF09TWF0aC5taW4odGhpcy5fYmJveFswXSxhWzBdKTt0aGlzLl9iYm94WzFdPU1hdGgubWluKHRoaXMuX2Jib3hbMV0sYVsxXSk7dGhpcy5fYmJveFsyXT1NYXRoLm1heCh0aGlzLl9iYm94WzJdLGFbMl0pO3RoaXMuX2Jib3hbM109TWF0aC5tYXgodGhpcy5fYmJveFszXSxhWzNdKX1sZXQgbz0wLGM9ZS5sZW5ndGg7Zm9yKDtvPGM7KXtzd2l0Y2goZS5mbkFycmF5W29dKXtjYXNlIHIuT1BTLnNldENoYXJXaWR0aEFuZEJvdW5kczpicmVhaztjYXNlIHIuT1BTLnNldFN0cm9rZUNvbG9yU3BhY2U6Y2FzZSByLk9QUy5zZXRGaWxsQ29sb3JTcGFjZTpjYXNlIHIuT1BTLnNldFN0cm9rZUNvbG9yOmNhc2Ugci5PUFMuc2V0U3Ryb2tlQ29sb3JOOmNhc2Ugci5PUFMuc2V0RmlsbENvbG9yOmNhc2Ugci5PUFMuc2V0RmlsbENvbG9yTjpjYXNlIHIuT1BTLnNldFN0cm9rZUdyYXk6Y2FzZSByLk9QUy5zZXRGaWxsR3JheTpjYXNlIHIuT1BTLnNldFN0cm9rZVJHQkNvbG9yOmNhc2Ugci5PUFMuc2V0RmlsbFJHQkNvbG9yOmNhc2Ugci5PUFMuc2V0U3Ryb2tlQ01ZS0NvbG9yOmNhc2Ugci5PUFMuc2V0RmlsbENNWUtDb2xvcjpjYXNlIHIuT1BTLnNoYWRpbmdGaWxsOmNhc2Ugci5PUFMuc2V0UmVuZGVyaW5nSW50ZW50OmUuZm5BcnJheS5zcGxpY2UobywxKTtlLmFyZ3NBcnJheS5zcGxpY2UobywxKTtjLS07Y29udGludWU7Y2FzZSByLk9QUy5zZXRHU3RhdGU6Y29uc3RbdF09ZS5hcmdzQXJyYXlbb107bGV0IGE9MCxuPXQubGVuZ3RoO2Zvcig7YTxuOyl7Y29uc3RbZV09dFthXTtzd2l0Y2goZSl7Y2FzZSJUUiI6Y2FzZSJUUjIiOmNhc2UiSFQiOmNhc2UiQkciOmNhc2UiQkcyIjpjYXNlIlVDUiI6Y2FzZSJVQ1IyIjp0LnNwbGljZShhLDEpO24tLTtjb250aW51ZX1hKyt9fW8rK319fWNsYXNzIFN0YXRlTWFuYWdlcntjb25zdHJ1Y3RvcihlPW5ldyBFdmFsU3RhdGUpe3RoaXMuc3RhdGU9ZTt0aGlzLnN0YXRlU3RhY2s9W119c2F2ZSgpe2NvbnN0IGU9dGhpcy5zdGF0ZTt0aGlzLnN0YXRlU3RhY2sucHVzaCh0aGlzLnN0YXRlKTt0aGlzLnN0YXRlPWUuY2xvbmUoKX1yZXN0b3JlKCl7Y29uc3QgZT10aGlzLnN0YXRlU3RhY2sucG9wKCk7ZSYmKHRoaXMuc3RhdGU9ZSl9dHJhbnNmb3JtKGUpe3RoaXMuc3RhdGUuY3RtPXIuVXRpbC50cmFuc2Zvcm0odGhpcy5zdGF0ZS5jdG0sZSl9fWNsYXNzIFRleHRTdGF0ZXtjb25zdHJ1Y3Rvcigpe3RoaXMuY3RtPW5ldyBGbG9hdDMyQXJyYXkoci5JREVOVElUWV9NQVRSSVgpO3RoaXMuZm9udE5hbWU9bnVsbDt0aGlzLmZvbnRTaXplPTA7dGhpcy5mb250PW51bGw7dGhpcy5mb250TWF0cml4PXIuRk9OVF9JREVOVElUWV9NQVRSSVg7dGhpcy50ZXh0TWF0cml4PXIuSURFTlRJVFlfTUFUUklYLnNsaWNlKCk7dGhpcy50ZXh0TGluZU1hdHJpeD1yLklERU5USVRZX01BVFJJWC5zbGljZSgpO3RoaXMuY2hhclNwYWNpbmc9MDt0aGlzLndvcmRTcGFjaW5nPTA7dGhpcy5sZWFkaW5nPTA7dGhpcy50ZXh0SFNjYWxlPTE7dGhpcy50ZXh0UmlzZT0wfXNldFRleHRNYXRyaXgoZSx0LGEscixuLGkpe2NvbnN0IHM9dGhpcy50ZXh0TWF0cml4O3NbMF09ZTtzWzFdPXQ7c1syXT1hO3NbM109cjtzWzRdPW47c1s1XT1pfXNldFRleHRMaW5lTWF0cml4KGUsdCxhLHIsbixpKXtjb25zdCBzPXRoaXMudGV4dExpbmVNYXRyaXg7c1swXT1lO3NbMV09dDtzWzJdPWE7c1szXT1yO3NbNF09bjtzWzVdPWl9dHJhbnNsYXRlVGV4dE1hdHJpeChlLHQpe2NvbnN0IGE9dGhpcy50ZXh0TWF0cml4O2FbNF09YVswXSplK2FbMl0qdCthWzRdO2FbNV09YVsxXSplK2FbM10qdCthWzVdfXRyYW5zbGF0ZVRleHRMaW5lTWF0cml4KGUsdCl7Y29uc3QgYT10aGlzLnRleHRMaW5lTWF0cml4O2FbNF09YVswXSplK2FbMl0qdCthWzRdO2FbNV09YVsxXSplK2FbM10qdCthWzVdfWNhcnJpYWdlUmV0dXJuKCl7dGhpcy50cmFuc2xhdGVUZXh0TGluZU1hdHJpeCgwLC10aGlzLmxlYWRpbmcpO3RoaXMudGV4dE1hdHJpeD10aGlzLnRleHRMaW5lTWF0cml4LnNsaWNlKCl9Y2xvbmUoKXtjb25zdCBlPU9iamVjdC5jcmVhdGUodGhpcyk7ZS50ZXh0TWF0cml4PXRoaXMudGV4dE1hdHJpeC5zbGljZSgpO2UudGV4dExpbmVNYXRyaXg9dGhpcy50ZXh0TGluZU1hdHJpeC5zbGljZSgpO2UuZm9udE1hdHJpeD10aGlzLmZvbnRNYXRyaXguc2xpY2UoKTtyZXR1cm4gZX19Y2xhc3MgRXZhbFN0YXRle2NvbnN0cnVjdG9yKCl7dGhpcy5jdG09bmV3IEZsb2F0MzJBcnJheShyLklERU5USVRZX01BVFJJWCk7dGhpcy5mb250PW51bGw7dGhpcy50ZXh0UmVuZGVyaW5nTW9kZT1yLlRleHRSZW5kZXJpbmdNb2RlLkZJTEw7dGhpcy5maWxsQ29sb3JTcGFjZT1TLkNvbG9yU3BhY2Uuc2luZ2xldG9ucy5ncmF5O3RoaXMuc3Ryb2tlQ29sb3JTcGFjZT1TLkNvbG9yU3BhY2Uuc2luZ2xldG9ucy5ncmF5fWNsb25lKCl7cmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcyl9fWNsYXNzIEV2YWx1YXRvclByZXByb2Nlc3NvcntzdGF0aWMgZ2V0IG9wTWFwKCl7Y29uc3QgZT0oMCxDLmdldExvb2t1cFRhYmxlRmFjdG9yeSkoKGZ1bmN0aW9uKGUpe2Uudz17aWQ6ci5PUFMuc2V0TGluZVdpZHRoLG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9O2UuSj17aWQ6ci5PUFMuc2V0TGluZUNhcCxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfTtlLmo9e2lkOnIuT1BTLnNldExpbmVKb2luLG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9O2UuTT17aWQ6ci5PUFMuc2V0TWl0ZXJMaW1pdCxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfTtlLmQ9e2lkOnIuT1BTLnNldERhc2gsbnVtQXJnczoyLHZhcmlhYmxlQXJnczohMX07ZS5yaT17aWQ6ci5PUFMuc2V0UmVuZGVyaW5nSW50ZW50LG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9O2UuaT17aWQ6ci5PUFMuc2V0RmxhdG5lc3MsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX07ZS5ncz17aWQ6ci5PUFMuc2V0R1N0YXRlLG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9O2UucT17aWQ6ci5PUFMuc2F2ZSxudW1BcmdzOjAsdmFyaWFibGVBcmdzOiExfTtlLlE9e2lkOnIuT1BTLnJlc3RvcmUsbnVtQXJnczowLHZhcmlhYmxlQXJnczohMX07ZS5jbT17aWQ6ci5PUFMudHJhbnNmb3JtLG51bUFyZ3M6Nix2YXJpYWJsZUFyZ3M6ITF9O2UubT17aWQ6ci5PUFMubW92ZVRvLG51bUFyZ3M6Mix2YXJpYWJsZUFyZ3M6ITF9O2UubD17aWQ6ci5PUFMubGluZVRvLG51bUFyZ3M6Mix2YXJpYWJsZUFyZ3M6ITF9O2UuYz17aWQ6ci5PUFMuY3VydmVUbyxudW1BcmdzOjYsdmFyaWFibGVBcmdzOiExfTtlLnY9e2lkOnIuT1BTLmN1cnZlVG8yLG51bUFyZ3M6NCx2YXJpYWJsZUFyZ3M6ITF9O2UueT17aWQ6ci5PUFMuY3VydmVUbzMsbnVtQXJnczo0LHZhcmlhYmxlQXJnczohMX07ZS5oPXtpZDpyLk9QUy5jbG9zZVBhdGgsbnVtQXJnczowLHZhcmlhYmxlQXJnczohMX07ZS5yZT17aWQ6ci5PUFMucmVjdGFuZ2xlLG51bUFyZ3M6NCx2YXJpYWJsZUFyZ3M6ITF9O2UuUz17aWQ6ci5PUFMuc3Ryb2tlLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9O2Uucz17aWQ6ci5PUFMuY2xvc2VTdHJva2UsbnVtQXJnczowLHZhcmlhYmxlQXJnczohMX07ZS5mPXtpZDpyLk9QUy5maWxsLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9O2UuRj17aWQ6ci5PUFMuZmlsbCxudW1BcmdzOjAsdmFyaWFibGVBcmdzOiExfTtlWyJmKiJdPXtpZDpyLk9QUy5lb0ZpbGwsbnVtQXJnczowLHZhcmlhYmxlQXJnczohMX07ZS5CPXtpZDpyLk9QUy5maWxsU3Ryb2tlLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9O2VbIkIqIl09e2lkOnIuT1BTLmVvRmlsbFN0cm9rZSxudW1BcmdzOjAsdmFyaWFibGVBcmdzOiExfTtlLmI9e2lkOnIuT1BTLmNsb3NlRmlsbFN0cm9rZSxudW1BcmdzOjAsdmFyaWFibGVBcmdzOiExfTtlWyJiKiJdPXtpZDpyLk9QUy5jbG9zZUVPRmlsbFN0cm9rZSxudW1BcmdzOjAsdmFyaWFibGVBcmdzOiExfTtlLm49e2lkOnIuT1BTLmVuZFBhdGgsbnVtQXJnczowLHZhcmlhYmxlQXJnczohMX07ZS5XPXtpZDpyLk9QUy5jbGlwLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9O2VbIlcqIl09e2lkOnIuT1BTLmVvQ2xpcCxudW1BcmdzOjAsdmFyaWFibGVBcmdzOiExfTtlLkJUPXtpZDpyLk9QUy5iZWdpblRleHQsbnVtQXJnczowLHZhcmlhYmxlQXJnczohMX07ZS5FVD17aWQ6ci5PUFMuZW5kVGV4dCxudW1BcmdzOjAsdmFyaWFibGVBcmdzOiExfTtlLlRjPXtpZDpyLk9QUy5zZXRDaGFyU3BhY2luZyxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfTtlLlR3PXtpZDpyLk9QUy5zZXRXb3JkU3BhY2luZyxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfTtlLlR6PXtpZDpyLk9QUy5zZXRIU2NhbGUsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX07ZS5UTD17aWQ6ci5PUFMuc2V0TGVhZGluZyxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfTtlLlRmPXtpZDpyLk9QUy5zZXRGb250LG51bUFyZ3M6Mix2YXJpYWJsZUFyZ3M6ITF9O2UuVHI9e2lkOnIuT1BTLnNldFRleHRSZW5kZXJpbmdNb2RlLG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9O2UuVHM9e2lkOnIuT1BTLnNldFRleHRSaXNlLG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9O2UuVGQ9e2lkOnIuT1BTLm1vdmVUZXh0LG51bUFyZ3M6Mix2YXJpYWJsZUFyZ3M6ITF9O2UuVEQ9e2lkOnIuT1BTLnNldExlYWRpbmdNb3ZlVGV4dCxudW1BcmdzOjIsdmFyaWFibGVBcmdzOiExfTtlLlRtPXtpZDpyLk9QUy5zZXRUZXh0TWF0cml4LG51bUFyZ3M6Nix2YXJpYWJsZUFyZ3M6ITF9O2VbIlQqIl09e2lkOnIuT1BTLm5leHRMaW5lLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9O2UuVGo9e2lkOnIuT1BTLnNob3dUZXh0LG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9O2UuVEo9e2lkOnIuT1BTLnNob3dTcGFjZWRUZXh0LG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9O2VbIiciXT17aWQ6ci5PUFMubmV4dExpbmVTaG93VGV4dCxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfTtlWyciJ109e2lkOnIuT1BTLm5leHRMaW5lU2V0U3BhY2luZ1Nob3dUZXh0LG51bUFyZ3M6Myx2YXJpYWJsZUFyZ3M6ITF9O2UuZDA9e2lkOnIuT1BTLnNldENoYXJXaWR0aCxudW1BcmdzOjIsdmFyaWFibGVBcmdzOiExfTtlLmQxPXtpZDpyLk9QUy5zZXRDaGFyV2lkdGhBbmRCb3VuZHMsbnVtQXJnczo2LHZhcmlhYmxlQXJnczohMX07ZS5DUz17aWQ6ci5PUFMuc2V0U3Ryb2tlQ29sb3JTcGFjZSxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfTtlLmNzPXtpZDpyLk9QUy5zZXRGaWxsQ29sb3JTcGFjZSxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfTtlLlNDPXtpZDpyLk9QUy5zZXRTdHJva2VDb2xvcixudW1BcmdzOjQsdmFyaWFibGVBcmdzOiEwfTtlLlNDTj17aWQ6ci5PUFMuc2V0U3Ryb2tlQ29sb3JOLG51bUFyZ3M6MzMsdmFyaWFibGVBcmdzOiEwfTtlLnNjPXtpZDpyLk9QUy5zZXRGaWxsQ29sb3IsbnVtQXJnczo0LHZhcmlhYmxlQXJnczohMH07ZS5zY249e2lkOnIuT1BTLnNldEZpbGxDb2xvck4sbnVtQXJnczozMyx2YXJpYWJsZUFyZ3M6ITB9O2UuRz17aWQ6ci5PUFMuc2V0U3Ryb2tlR3JheSxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfTtlLmc9e2lkOnIuT1BTLnNldEZpbGxHcmF5LG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9O2UuUkc9e2lkOnIuT1BTLnNldFN0cm9rZVJHQkNvbG9yLG51bUFyZ3M6Myx2YXJpYWJsZUFyZ3M6ITF9O2Uucmc9e2lkOnIuT1BTLnNldEZpbGxSR0JDb2xvcixudW1BcmdzOjMsdmFyaWFibGVBcmdzOiExfTtlLks9e2lkOnIuT1BTLnNldFN0cm9rZUNNWUtDb2xvcixudW1BcmdzOjQsdmFyaWFibGVBcmdzOiExfTtlLms9e2lkOnIuT1BTLnNldEZpbGxDTVlLQ29sb3IsbnVtQXJnczo0LHZhcmlhYmxlQXJnczohMX07ZS5zaD17aWQ6ci5PUFMuc2hhZGluZ0ZpbGwsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX07ZS5CST17aWQ6ci5PUFMuYmVnaW5JbmxpbmVJbWFnZSxudW1BcmdzOjAsdmFyaWFibGVBcmdzOiExfTtlLklEPXtpZDpyLk9QUy5iZWdpbkltYWdlRGF0YSxudW1BcmdzOjAsdmFyaWFibGVBcmdzOiExfTtlLkVJPXtpZDpyLk9QUy5lbmRJbmxpbmVJbWFnZSxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfTtlLkRvPXtpZDpyLk9QUy5wYWludFhPYmplY3QsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX07ZS5NUD17aWQ6ci5PUFMubWFya1BvaW50LG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9O2UuRFA9e2lkOnIuT1BTLm1hcmtQb2ludFByb3BzLG51bUFyZ3M6Mix2YXJpYWJsZUFyZ3M6ITF9O2UuQk1DPXtpZDpyLk9QUy5iZWdpbk1hcmtlZENvbnRlbnQsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX07ZS5CREM9e2lkOnIuT1BTLmJlZ2luTWFya2VkQ29udGVudFByb3BzLG51bUFyZ3M6Mix2YXJpYWJsZUFyZ3M6ITF9O2UuRU1DPXtpZDpyLk9QUy5lbmRNYXJrZWRDb250ZW50LG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9O2UuQlg9e2lkOnIuT1BTLmJlZ2luQ29tcGF0LG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9O2UuRVg9e2lkOnIuT1BTLmVuZENvbXBhdCxudW1BcmdzOjAsdmFyaWFibGVBcmdzOiExfTtlLkJNPW51bGw7ZS5CRD1udWxsO2UudHJ1ZT1udWxsO2UuZmE9bnVsbDtlLmZhbD1udWxsO2UuZmFscz1udWxsO2UuZmFsc2U9bnVsbDtlLm51PW51bGw7ZS5udWw9bnVsbDtlLm51bGw9bnVsbH0pKTtyZXR1cm4oMCxyLnNoYWRvdykodGhpcywib3BNYXAiLGUoKSl9c3RhdGljIGdldCBNQVhfSU5WQUxJRF9QQVRIX09QUygpe3JldHVybigwLHIuc2hhZG93KSh0aGlzLCJNQVhfSU5WQUxJRF9QQVRIX09QUyIsMTApfWNvbnN0cnVjdG9yKGUsdCxhPW5ldyBTdGF0ZU1hbmFnZXIpe3RoaXMucGFyc2VyPW5ldyBwLlBhcnNlcih7bGV4ZXI6bmV3IHAuTGV4ZXIoZSxFdmFsdWF0b3JQcmVwcm9jZXNzb3Iub3BNYXApLHhyZWY6dH0pO3RoaXMuc3RhdGVNYW5hZ2VyPWE7dGhpcy5ub25Qcm9jZXNzZWRBcmdzPVtdO3RoaXMuX2lzUGF0aE9wPSExO3RoaXMuX251bUludmFsaWRQYXRoT1BTPTB9Z2V0IHNhdmVkU3RhdGVzRGVwdGgoKXtyZXR1cm4gdGhpcy5zdGF0ZU1hbmFnZXIuc3RhdGVTdGFjay5sZW5ndGh9cmVhZChlKXtsZXQgdD1lLmFyZ3M7Zm9yKDs7KXtjb25zdCBhPXRoaXMucGFyc2VyLmdldE9iaigpO2lmKGEgaW5zdGFuY2VvZiBpLkNtZCl7Y29uc3Qgbj1hLmNtZCxpPUV2YWx1YXRvclByZXByb2Nlc3Nvci5vcE1hcFtuXTtpZighaSl7KDAsci53YXJuKShgVW5rbm93biBjb21tYW5kICIke259Ii5gKTtjb250aW51ZX1jb25zdCBzPWkuaWQsbz1pLm51bUFyZ3M7bGV0IGM9bnVsbCE9PXQ/dC5sZW5ndGg6MDt0aGlzLl9pc1BhdGhPcHx8KHRoaXMuX251bUludmFsaWRQYXRoT1BTPTApO3RoaXMuX2lzUGF0aE9wPXM+PXIuT1BTLm1vdmVUbyYmczw9ci5PUFMuZW5kUGF0aDtpZihpLnZhcmlhYmxlQXJncyljPm8mJigwLHIuaW5mbykoYENvbW1hbmQgJHtufTogZXhwZWN0ZWQgWzAsICR7b31dIGFyZ3MsIGJ1dCByZWNlaXZlZCAke2N9IGFyZ3MuYCk7ZWxzZXtpZihjIT09byl7Y29uc3QgZT10aGlzLm5vblByb2Nlc3NlZEFyZ3M7Zm9yKDtjPm87KXtlLnB1c2godC5zaGlmdCgpKTtjLS19Zm9yKDtjPG8mJjAhPT1lLmxlbmd0aDspe251bGw9PT10JiYodD1bXSk7dC51bnNoaWZ0KGUucG9wKCkpO2MrK319aWYoYzxvKXtjb25zdCBlPWBjb21tYW5kICR7bn06IGV4cGVjdGVkICR7b30gYXJncywgYnV0IHJlY2VpdmVkICR7Y30gYXJncy5gO2lmKHRoaXMuX2lzUGF0aE9wJiYrK3RoaXMuX251bUludmFsaWRQYXRoT1BTPkV2YWx1YXRvclByZXByb2Nlc3Nvci5NQVhfSU5WQUxJRF9QQVRIX09QUyl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcihgSW52YWxpZCAke2V9YCk7KDAsci53YXJuKShgU2tpcHBpbmcgJHtlfWApO251bGwhPT10JiYodC5sZW5ndGg9MCk7Y29udGludWV9fXRoaXMucHJlcHJvY2Vzc0NvbW1hbmQocyx0KTtlLmZuPXM7ZS5hcmdzPXQ7cmV0dXJuITB9aWYoYT09PWkuRU9GKXJldHVybiExO2lmKG51bGwhPT1hKXtudWxsPT09dCYmKHQ9W10pO3QucHVzaChhKTtpZih0Lmxlbmd0aD4zMyl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiVG9vIG1hbnkgYXJndW1lbnRzIil9fX1wcmVwcm9jZXNzQ29tbWFuZChlLHQpe3N3aXRjaCgwfGUpe2Nhc2Ugci5PUFMuc2F2ZTp0aGlzLnN0YXRlTWFuYWdlci5zYXZlKCk7YnJlYWs7Y2FzZSByLk9QUy5yZXN0b3JlOnRoaXMuc3RhdGVNYW5hZ2VyLnJlc3RvcmUoKTticmVhaztjYXNlIHIuT1BTLnRyYW5zZm9ybTp0aGlzLnN0YXRlTWFuYWdlci50cmFuc2Zvcm0odCl9fX10LkV2YWx1YXRvclByZXByb2Nlc3Nvcj1FdmFsdWF0b3JQcmVwcm9jZXNzb3J9LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5JZGVudGl0eUNNYXA9dC5DTWFwRmFjdG9yeT10LkNNYXA9dm9pZCAwO3ZhciByPWEoMiksbj1hKDUpLGk9YSg3KSxzPWEoMTcpLG89YSg2KSxjPWEoMTApO2NvbnN0IGw9WyJBZG9iZS1HQjEtVUNTMiIsIkFkb2JlLUNOUzEtVUNTMiIsIkFkb2JlLUphcGFuMS1VQ1MyIiwiQWRvYmUtS29yZWExLVVDUzIiLCI3OC1FVUMtSCIsIjc4LUVVQy1WIiwiNzgtSCIsIjc4LVJLU0otSCIsIjc4LVJLU0otViIsIjc4LVYiLCI3OG1zLVJLU0otSCIsIjc4bXMtUktTSi1WIiwiODNwdi1SS1NKLUgiLCI5MG1zLVJLU0otSCIsIjkwbXMtUktTSi1WIiwiOTBtc3AtUktTSi1IIiwiOTBtc3AtUktTSi1WIiwiOTBwdi1SS1NKLUgiLCI5MHB2LVJLU0otViIsIkFkZC1IIiwiQWRkLVJLU0otSCIsIkFkZC1SS1NKLVYiLCJBZGQtViIsIkFkb2JlLUNOUzEtMCIsIkFkb2JlLUNOUzEtMSIsIkFkb2JlLUNOUzEtMiIsIkFkb2JlLUNOUzEtMyIsIkFkb2JlLUNOUzEtNCIsIkFkb2JlLUNOUzEtNSIsIkFkb2JlLUNOUzEtNiIsIkFkb2JlLUdCMS0wIiwiQWRvYmUtR0IxLTEiLCJBZG9iZS1HQjEtMiIsIkFkb2JlLUdCMS0zIiwiQWRvYmUtR0IxLTQiLCJBZG9iZS1HQjEtNSIsIkFkb2JlLUphcGFuMS0wIiwiQWRvYmUtSmFwYW4xLTEiLCJBZG9iZS1KYXBhbjEtMiIsIkFkb2JlLUphcGFuMS0zIiwiQWRvYmUtSmFwYW4xLTQiLCJBZG9iZS1KYXBhbjEtNSIsIkFkb2JlLUphcGFuMS02IiwiQWRvYmUtS29yZWExLTAiLCJBZG9iZS1Lb3JlYTEtMSIsIkFkb2JlLUtvcmVhMS0yIiwiQjUtSCIsIkI1LVYiLCJCNXBjLUgiLCJCNXBjLVYiLCJDTlMtRVVDLUgiLCJDTlMtRVVDLVYiLCJDTlMxLUgiLCJDTlMxLVYiLCJDTlMyLUgiLCJDTlMyLVYiLCJFVEhLLUI1LUgiLCJFVEhLLUI1LVYiLCJFVGVuLUI1LUgiLCJFVGVuLUI1LVYiLCJFVGVubXMtQjUtSCIsIkVUZW5tcy1CNS1WIiwiRVVDLUgiLCJFVUMtViIsIkV4dC1IIiwiRXh0LVJLU0otSCIsIkV4dC1SS1NKLVYiLCJFeHQtViIsIkdCLUVVQy1IIiwiR0ItRVVDLVYiLCJHQi1IIiwiR0ItViIsIkdCSy1FVUMtSCIsIkdCSy1FVUMtViIsIkdCSzJLLUgiLCJHQksySy1WIiwiR0JLcC1FVUMtSCIsIkdCS3AtRVVDLVYiLCJHQlQtRVVDLUgiLCJHQlQtRVVDLVYiLCJHQlQtSCIsIkdCVC1WIiwiR0JUcGMtRVVDLUgiLCJHQlRwYy1FVUMtViIsIkdCcGMtRVVDLUgiLCJHQnBjLUVVQy1WIiwiSCIsIkhLZGxhLUI1LUgiLCJIS2RsYS1CNS1WIiwiSEtkbGItQjUtSCIsIkhLZGxiLUI1LVYiLCJIS2djY3MtQjUtSCIsIkhLZ2Njcy1CNS1WIiwiSEttMzE0LUI1LUgiLCJIS20zMTQtQjUtViIsIkhLbTQ3MS1CNS1IIiwiSEttNDcxLUI1LVYiLCJIS3Njcy1CNS1IIiwiSEtzY3MtQjUtViIsIkhhbmtha3UiLCJIaXJhZ2FuYSIsIktTQy1FVUMtSCIsIktTQy1FVUMtViIsIktTQy1IIiwiS1NDLUpvaGFiLUgiLCJLU0MtSm9oYWItViIsIktTQy1WIiwiS1NDbXMtVUhDLUgiLCJLU0Ntcy1VSEMtSFctSCIsIktTQ21zLVVIQy1IVy1WIiwiS1NDbXMtVUhDLVYiLCJLU0NwYy1FVUMtSCIsIktTQ3BjLUVVQy1WIiwiS2F0YWthbmEiLCJOV1AtSCIsIk5XUC1WIiwiUktTSi1IIiwiUktTSi1WIiwiUm9tYW4iLCJVbmlDTlMtVUNTMi1IIiwiVW5pQ05TLVVDUzItViIsIlVuaUNOUy1VVEYxNi1IIiwiVW5pQ05TLVVURjE2LVYiLCJVbmlDTlMtVVRGMzItSCIsIlVuaUNOUy1VVEYzMi1WIiwiVW5pQ05TLVVURjgtSCIsIlVuaUNOUy1VVEY4LVYiLCJVbmlHQi1VQ1MyLUgiLCJVbmlHQi1VQ1MyLVYiLCJVbmlHQi1VVEYxNi1IIiwiVW5pR0ItVVRGMTYtViIsIlVuaUdCLVVURjMyLUgiLCJVbmlHQi1VVEYzMi1WIiwiVW5pR0ItVVRGOC1IIiwiVW5pR0ItVVRGOC1WIiwiVW5pSklTLVVDUzItSCIsIlVuaUpJUy1VQ1MyLUhXLUgiLCJVbmlKSVMtVUNTMi1IVy1WIiwiVW5pSklTLVVDUzItViIsIlVuaUpJUy1VVEYxNi1IIiwiVW5pSklTLVVURjE2LVYiLCJVbmlKSVMtVVRGMzItSCIsIlVuaUpJUy1VVEYzMi1WIiwiVW5pSklTLVVURjgtSCIsIlVuaUpJUy1VVEY4LVYiLCJVbmlKSVMyMDA0LVVURjE2LUgiLCJVbmlKSVMyMDA0LVVURjE2LVYiLCJVbmlKSVMyMDA0LVVURjMyLUgiLCJVbmlKSVMyMDA0LVVURjMyLVYiLCJVbmlKSVMyMDA0LVVURjgtSCIsIlVuaUpJUzIwMDQtVVRGOC1WIiwiVW5pSklTUHJvLVVDUzItSFctViIsIlVuaUpJU1Byby1VQ1MyLVYiLCJVbmlKSVNQcm8tVVRGOC1WIiwiVW5pSklTWDAyMTMtVVRGMzItSCIsIlVuaUpJU1gwMjEzLVVURjMyLVYiLCJVbmlKSVNYMDIxMzIwMDQtVVRGMzItSCIsIlVuaUpJU1gwMjEzMjAwNC1VVEYzMi1WIiwiVW5pS1MtVUNTMi1IIiwiVW5pS1MtVUNTMi1WIiwiVW5pS1MtVVRGMTYtSCIsIlVuaUtTLVVURjE2LVYiLCJVbmlLUy1VVEYzMi1IIiwiVW5pS1MtVVRGMzItViIsIlVuaUtTLVVURjgtSCIsIlVuaUtTLVVURjgtViIsIlYiLCJXUC1TeW1ib2wiXSxoPTIqKjI0LTE7Y2xhc3MgQ01hcHtjb25zdHJ1Y3RvcihlPSExKXt0aGlzLmNvZGVzcGFjZVJhbmdlcz1bW10sW10sW10sW11dO3RoaXMubnVtQ29kZXNwYWNlUmFuZ2VzPTA7dGhpcy5fbWFwPVtdO3RoaXMubmFtZT0iIjt0aGlzLnZlcnRpY2FsPSExO3RoaXMudXNlQ01hcD1udWxsO3RoaXMuYnVpbHRJbkNNYXA9ZX1hZGRDb2Rlc3BhY2VSYW5nZShlLHQsYSl7dGhpcy5jb2Rlc3BhY2VSYW5nZXNbZS0xXS5wdXNoKHQsYSk7dGhpcy5udW1Db2Rlc3BhY2VSYW5nZXMrK31tYXBDaWRSYW5nZShlLHQsYSl7aWYodC1lPmgpdGhyb3cgbmV3IEVycm9yKCJtYXBDaWRSYW5nZSAtIGlnbm9yaW5nIGRhdGEgYWJvdmUgTUFYX01BUF9SQU5HRS4iKTtmb3IoO2U8PXQ7KXRoaXMuX21hcFtlKytdPWErK31tYXBCZlJhbmdlKGUsdCxhKXtpZih0LWU+aCl0aHJvdyBuZXcgRXJyb3IoIm1hcEJmUmFuZ2UgLSBpZ25vcmluZyBkYXRhIGFib3ZlIE1BWF9NQVBfUkFOR0UuIik7Y29uc3Qgcj1hLmxlbmd0aC0xO2Zvcig7ZTw9dDspe3RoaXMuX21hcFtlKytdPWE7Y29uc3QgdD1hLmNoYXJDb2RlQXQocikrMTt0PjI1NT9hPWEuc3Vic3RyaW5nKDAsci0xKStTdHJpbmcuZnJvbUNoYXJDb2RlKGEuY2hhckNvZGVBdChyLTEpKzEpKyJcMCI6YT1hLnN1YnN0cmluZygwLHIpK1N0cmluZy5mcm9tQ2hhckNvZGUodCl9fW1hcEJmUmFuZ2VUb0FycmF5KGUsdCxhKXtpZih0LWU+aCl0aHJvdyBuZXcgRXJyb3IoIm1hcEJmUmFuZ2VUb0FycmF5IC0gaWdub3JpbmcgZGF0YSBhYm92ZSBNQVhfTUFQX1JBTkdFLiIpO2NvbnN0IHI9YS5sZW5ndGg7bGV0IG49MDtmb3IoO2U8PXQmJm48cjspe3RoaXMuX21hcFtlXT1hW24rK107KytlfX1tYXBPbmUoZSx0KXt0aGlzLl9tYXBbZV09dH1sb29rdXAoZSl7cmV0dXJuIHRoaXMuX21hcFtlXX1jb250YWlucyhlKXtyZXR1cm4gdm9pZCAwIT09dGhpcy5fbWFwW2VdfWZvckVhY2goZSl7Y29uc3QgdD10aGlzLl9tYXAsYT10Lmxlbmd0aDtpZihhPD02NTUzNilmb3IobGV0IHI9MDtyPGE7cisrKXZvaWQgMCE9PXRbcl0mJmUocix0W3JdKTtlbHNlIGZvcihjb25zdCBhIGluIHQpZShhLHRbYV0pfWNoYXJDb2RlT2YoZSl7Y29uc3QgdD10aGlzLl9tYXA7aWYodC5sZW5ndGg8PTY1NTM2KXJldHVybiB0LmluZGV4T2YoZSk7Zm9yKGNvbnN0IGEgaW4gdClpZih0W2FdPT09ZSlyZXR1cm4gMHxhO3JldHVybi0xfWdldE1hcCgpe3JldHVybiB0aGlzLl9tYXB9cmVhZENoYXJDb2RlKGUsdCxhKXtsZXQgcj0wO2NvbnN0IG49dGhpcy5jb2Rlc3BhY2VSYW5nZXM7Zm9yKGxldCBpPTAscz1uLmxlbmd0aDtpPHM7aSsrKXtyPShyPDw4fGUuY2hhckNvZGVBdCh0K2kpKT4+PjA7Y29uc3Qgcz1uW2ldO2ZvcihsZXQgZT0wLHQ9cy5sZW5ndGg7ZTx0Oyl7Y29uc3QgdD1zW2UrK10sbj1zW2UrK107aWYocj49dCYmcjw9bil7YS5jaGFyY29kZT1yO2EubGVuZ3RoPWkrMTtyZXR1cm59fX1hLmNoYXJjb2RlPTA7YS5sZW5ndGg9MX1nZXRDaGFyQ29kZUxlbmd0aChlKXtjb25zdCB0PXRoaXMuY29kZXNwYWNlUmFuZ2VzO2ZvcihsZXQgYT0wLHI9dC5sZW5ndGg7YTxyO2ErKyl7Y29uc3Qgcj10W2FdO2ZvcihsZXQgdD0wLG49ci5sZW5ndGg7dDxuOyl7Y29uc3Qgbj1yW3QrK10saT1yW3QrK107aWYoZT49biYmZTw9aSlyZXR1cm4gYSsxfX1yZXR1cm4gMX1nZXQgbGVuZ3RoKCl7cmV0dXJuIHRoaXMuX21hcC5sZW5ndGh9Z2V0IGlzSWRlbnRpdHlDTWFwKCl7aWYoIklkZW50aXR5LUgiIT09dGhpcy5uYW1lJiYiSWRlbnRpdHktViIhPT10aGlzLm5hbWUpcmV0dXJuITE7aWYoNjU1MzYhPT10aGlzLl9tYXAubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgZT0wO2U8NjU1MzY7ZSsrKWlmKHRoaXMuX21hcFtlXSE9PWUpcmV0dXJuITE7cmV0dXJuITB9fXQuQ01hcD1DTWFwO2NsYXNzIElkZW50aXR5Q01hcCBleHRlbmRzIENNYXB7Y29uc3RydWN0b3IoZSx0KXtzdXBlcigpO3RoaXMudmVydGljYWw9ZTt0aGlzLmFkZENvZGVzcGFjZVJhbmdlKHQsMCw2NTUzNSl9bWFwQ2lkUmFuZ2UoZSx0LGEpeygwLHIudW5yZWFjaGFibGUpKCJzaG91bGQgbm90IGNhbGwgbWFwQ2lkUmFuZ2UiKX1tYXBCZlJhbmdlKGUsdCxhKXsoMCxyLnVucmVhY2hhYmxlKSgic2hvdWxkIG5vdCBjYWxsIG1hcEJmUmFuZ2UiKX1tYXBCZlJhbmdlVG9BcnJheShlLHQsYSl7KDAsci51bnJlYWNoYWJsZSkoInNob3VsZCBub3QgY2FsbCBtYXBCZlJhbmdlVG9BcnJheSIpfW1hcE9uZShlLHQpeygwLHIudW5yZWFjaGFibGUpKCJzaG91bGQgbm90IGNhbGwgbWFwQ2lkT25lIil9bG9va3VwKGUpe3JldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGUpJiZlPD02NTUzNT9lOnZvaWQgMH1jb250YWlucyhlKXtyZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihlKSYmZTw9NjU1MzV9Zm9yRWFjaChlKXtmb3IobGV0IHQ9MDt0PD02NTUzNTt0KyspZSh0LHQpfWNoYXJDb2RlT2YoZSl7cmV0dXJuIE51bWJlci5pc0ludGVnZXIoZSkmJmU8PTY1NTM1P2U6LTF9Z2V0TWFwKCl7Y29uc3QgZT1uZXcgQXJyYXkoNjU1MzYpO2ZvcihsZXQgdD0wO3Q8PTY1NTM1O3QrKyllW3RdPXQ7cmV0dXJuIGV9Z2V0IGxlbmd0aCgpe3JldHVybiA2NTUzNn1nZXQgaXNJZGVudGl0eUNNYXAoKXsoMCxyLnVucmVhY2hhYmxlKSgic2hvdWxkIG5vdCBhY2Nlc3MgLmlzSWRlbnRpdHlDTWFwIil9fXQuSWRlbnRpdHlDTWFwPUlkZW50aXR5Q01hcDtjb25zdCB1PWZ1bmN0aW9uIEJpbmFyeUNNYXBSZWFkZXJDbG9zdXJlKCl7ZnVuY3Rpb24gaGV4VG9JbnQoZSx0KXtsZXQgYT0wO2ZvcihsZXQgcj0wO3I8PXQ7cisrKWE9YTw8OHxlW3JdO3JldHVybiBhPj4+MH1mdW5jdGlvbiBoZXhUb1N0cihlLHQpe3JldHVybiAxPT09dD9TdHJpbmcuZnJvbUNoYXJDb2RlKGVbMF0sZVsxXSk6Mz09PXQ/U3RyaW5nLmZyb21DaGFyQ29kZShlWzBdLGVbMV0sZVsyXSxlWzNdKTpTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsZS5zdWJhcnJheSgwLHQrMSkpfWZ1bmN0aW9uIGFkZEhleChlLHQsYSl7bGV0IHI9MDtmb3IobGV0IG49YTtuPj0wO24tLSl7cis9ZVtuXSt0W25dO2Vbbl09MjU1JnI7cj4+PTh9fWZ1bmN0aW9uIGluY0hleChlLHQpe2xldCBhPTE7Zm9yKGxldCByPXQ7cj49MCYmYT4wO3ItLSl7YSs9ZVtyXTtlW3JdPTI1NSZhO2E+Pj04fX1jb25zdCBlPTE2O2NsYXNzIEJpbmFyeUNNYXBTdHJlYW17Y29uc3RydWN0b3IoZSl7dGhpcy5idWZmZXI9ZTt0aGlzLnBvcz0wO3RoaXMuZW5kPWUubGVuZ3RoO3RoaXMudG1wQnVmPW5ldyBVaW50OEFycmF5KDE5KX1yZWFkQnl0ZSgpe3JldHVybiB0aGlzLnBvcz49dGhpcy5lbmQ/LTE6dGhpcy5idWZmZXJbdGhpcy5wb3MrK119cmVhZE51bWJlcigpe2xldCBlLHQ9MDtkb3tjb25zdCBhPXRoaXMucmVhZEJ5dGUoKTtpZihhPDApdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoInVuZXhwZWN0ZWQgRU9GIGluIGJjbWFwIik7ZT0hKDEyOCZhKTt0PXQ8PDd8MTI3JmF9d2hpbGUoIWUpO3JldHVybiB0fXJlYWRTaWduZWQoKXtjb25zdCBlPXRoaXMucmVhZE51bWJlcigpO3JldHVybiAxJmU/fihlPj4+MSk6ZT4+PjF9cmVhZEhleChlLHQpe2Uuc2V0KHRoaXMuYnVmZmVyLnN1YmFycmF5KHRoaXMucG9zLHRoaXMucG9zK3QrMSkpO3RoaXMucG9zKz10KzF9cmVhZEhleE51bWJlcihlLHQpe2xldCBhO2NvbnN0IG49dGhpcy50bXBCdWY7bGV0IGk9MDtkb3tjb25zdCBlPXRoaXMucmVhZEJ5dGUoKTtpZihlPDApdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoInVuZXhwZWN0ZWQgRU9GIGluIGJjbWFwIik7YT0hKDEyOCZlKTtuW2krK109MTI3JmV9d2hpbGUoIWEpO2xldCBzPXQsbz0wLGM9MDtmb3IoO3M+PTA7KXtmb3IoO2M8OCYmbi5sZW5ndGg+MDspe298PW5bLS1pXTw8YztjKz03fWVbc109MjU1Jm87cy0tO28+Pj04O2MtPTh9fXJlYWRIZXhTaWduZWQoZSx0KXt0aGlzLnJlYWRIZXhOdW1iZXIoZSx0KTtjb25zdCBhPTEmZVt0XT8yNTU6MDtsZXQgcj0wO2ZvcihsZXQgbj0wO248PXQ7bisrKXtyPSgxJnIpPDw4fGVbbl07ZVtuXT1yPj4xXmF9fXJlYWRTdHJpbmcoKXtjb25zdCBlPXRoaXMucmVhZE51bWJlcigpO2xldCB0PSIiO2ZvcihsZXQgYT0wO2E8ZTthKyspdCs9U3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWROdW1iZXIoKSk7cmV0dXJuIHR9fXJldHVybiBjbGFzcyBCaW5hcnlDTWFwUmVhZGVye2FzeW5jIHByb2Nlc3ModCxhLHIpe2NvbnN0IG49bmV3IEJpbmFyeUNNYXBTdHJlYW0odCksaT1uLnJlYWRCeXRlKCk7YS52ZXJ0aWNhbD0hISgxJmkpO2xldCBzPW51bGw7Y29uc3Qgbz1uZXcgVWludDhBcnJheShlKSxjPW5ldyBVaW50OEFycmF5KGUpLGw9bmV3IFVpbnQ4QXJyYXkoZSksaD1uZXcgVWludDhBcnJheShlKSx1PW5ldyBVaW50OEFycmF5KGUpO2xldCBkLGY7Zm9yKDsoZj1uLnJlYWRCeXRlKCkpPj0wOyl7Y29uc3QgdD1mPj41O2lmKDc9PT10KXtzd2l0Y2goMzEmZil7Y2FzZSAwOm4ucmVhZFN0cmluZygpO2JyZWFrO2Nhc2UgMTpzPW4ucmVhZFN0cmluZygpfWNvbnRpbnVlfWNvbnN0IHI9ISEoMTYmZiksaT0xNSZmO2lmKGkrMT5lKXRocm93IG5ldyBFcnJvcigiQmluYXJ5Q01hcFJlYWRlci5wcm9jZXNzOiBJbnZhbGlkIGRhdGFTaXplLiIpO2NvbnN0IGc9MSxwPW4ucmVhZE51bWJlcigpO3N3aXRjaCh0KXtjYXNlIDA6bi5yZWFkSGV4KG8saSk7bi5yZWFkSGV4TnVtYmVyKGMsaSk7YWRkSGV4KGMsbyxpKTthLmFkZENvZGVzcGFjZVJhbmdlKGkrMSxoZXhUb0ludChvLGkpLGhleFRvSW50KGMsaSkpO2ZvcihsZXQgZT0xO2U8cDtlKyspe2luY0hleChjLGkpO24ucmVhZEhleE51bWJlcihvLGkpO2FkZEhleChvLGMsaSk7bi5yZWFkSGV4TnVtYmVyKGMsaSk7YWRkSGV4KGMsbyxpKTthLmFkZENvZGVzcGFjZVJhbmdlKGkrMSxoZXhUb0ludChvLGkpLGhleFRvSW50KGMsaSkpfWJyZWFrO2Nhc2UgMTpuLnJlYWRIZXgobyxpKTtuLnJlYWRIZXhOdW1iZXIoYyxpKTthZGRIZXgoYyxvLGkpO24ucmVhZE51bWJlcigpO2ZvcihsZXQgZT0xO2U8cDtlKyspe2luY0hleChjLGkpO24ucmVhZEhleE51bWJlcihvLGkpO2FkZEhleChvLGMsaSk7bi5yZWFkSGV4TnVtYmVyKGMsaSk7YWRkSGV4KGMsbyxpKTtuLnJlYWROdW1iZXIoKX1icmVhaztjYXNlIDI6bi5yZWFkSGV4KGwsaSk7ZD1uLnJlYWROdW1iZXIoKTthLm1hcE9uZShoZXhUb0ludChsLGkpLGQpO2ZvcihsZXQgZT0xO2U8cDtlKyspe2luY0hleChsLGkpO2lmKCFyKXtuLnJlYWRIZXhOdW1iZXIodSxpKTthZGRIZXgobCx1LGkpfWQ9bi5yZWFkU2lnbmVkKCkrKGQrMSk7YS5tYXBPbmUoaGV4VG9JbnQobCxpKSxkKX1icmVhaztjYXNlIDM6bi5yZWFkSGV4KG8saSk7bi5yZWFkSGV4TnVtYmVyKGMsaSk7YWRkSGV4KGMsbyxpKTtkPW4ucmVhZE51bWJlcigpO2EubWFwQ2lkUmFuZ2UoaGV4VG9JbnQobyxpKSxoZXhUb0ludChjLGkpLGQpO2ZvcihsZXQgZT0xO2U8cDtlKyspe2luY0hleChjLGkpO2lmKHIpby5zZXQoYyk7ZWxzZXtuLnJlYWRIZXhOdW1iZXIobyxpKTthZGRIZXgobyxjLGkpfW4ucmVhZEhleE51bWJlcihjLGkpO2FkZEhleChjLG8saSk7ZD1uLnJlYWROdW1iZXIoKTthLm1hcENpZFJhbmdlKGhleFRvSW50KG8saSksaGV4VG9JbnQoYyxpKSxkKX1icmVhaztjYXNlIDQ6bi5yZWFkSGV4KGwsZyk7bi5yZWFkSGV4KGgsaSk7YS5tYXBPbmUoaGV4VG9JbnQobCxnKSxoZXhUb1N0cihoLGkpKTtmb3IobGV0IGU9MTtlPHA7ZSsrKXtpbmNIZXgobCxnKTtpZighcil7bi5yZWFkSGV4TnVtYmVyKHUsZyk7YWRkSGV4KGwsdSxnKX1pbmNIZXgoaCxpKTtuLnJlYWRIZXhTaWduZWQodSxpKTthZGRIZXgoaCx1LGkpO2EubWFwT25lKGhleFRvSW50KGwsZyksaGV4VG9TdHIoaCxpKSl9YnJlYWs7Y2FzZSA1Om4ucmVhZEhleChvLGcpO24ucmVhZEhleE51bWJlcihjLGcpO2FkZEhleChjLG8sZyk7bi5yZWFkSGV4KGgsaSk7YS5tYXBCZlJhbmdlKGhleFRvSW50KG8sZyksaGV4VG9JbnQoYyxnKSxoZXhUb1N0cihoLGkpKTtmb3IobGV0IGU9MTtlPHA7ZSsrKXtpbmNIZXgoYyxnKTtpZihyKW8uc2V0KGMpO2Vsc2V7bi5yZWFkSGV4TnVtYmVyKG8sZyk7YWRkSGV4KG8sYyxnKX1uLnJlYWRIZXhOdW1iZXIoYyxnKTthZGRIZXgoYyxvLGcpO24ucmVhZEhleChoLGkpO2EubWFwQmZSYW5nZShoZXhUb0ludChvLGcpLGhleFRvSW50KGMsZyksaGV4VG9TdHIoaCxpKSl9YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEJpbmFyeUNNYXBSZWFkZXIucHJvY2VzcyAtIHVua25vd24gdHlwZTogJHt0fWApfX1yZXR1cm4gcz9yKHMpOmF9fX0oKSxkPWZ1bmN0aW9uIENNYXBGYWN0b3J5Q2xvc3VyZSgpe2Z1bmN0aW9uIHN0clRvSW50KGUpe2xldCB0PTA7Zm9yKGxldCBhPTA7YTxlLmxlbmd0aDthKyspdD10PDw4fGUuY2hhckNvZGVBdChhKTtyZXR1cm4gdD4+PjB9ZnVuY3Rpb24gZXhwZWN0U3RyaW5nKGUpe2lmKCJzdHJpbmciIT10eXBlb2YgZSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiTWFsZm9ybWVkIENNYXA6IGV4cGVjdGVkIHN0cmluZy4iKX1mdW5jdGlvbiBleHBlY3RJbnQoZSl7aWYoIU51bWJlci5pc0ludGVnZXIoZSkpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoIk1hbGZvcm1lZCBDTWFwOiBleHBlY3RlZCBpbnQuIil9ZnVuY3Rpb24gcGFyc2VCZkNoYXIoZSx0KXtmb3IoOzspe2xldCBhPXQuZ2V0T2JqKCk7aWYoYT09PW4uRU9GKWJyZWFrO2lmKCgwLG4uaXNDbWQpKGEsImVuZGJmY2hhciIpKXJldHVybjtleHBlY3RTdHJpbmcoYSk7Y29uc3Qgcj1zdHJUb0ludChhKTthPXQuZ2V0T2JqKCk7ZXhwZWN0U3RyaW5nKGEpO2NvbnN0IGk9YTtlLm1hcE9uZShyLGkpfX1mdW5jdGlvbiBwYXJzZUJmUmFuZ2UoZSx0KXtmb3IoOzspe2xldCBhPXQuZ2V0T2JqKCk7aWYoYT09PW4uRU9GKWJyZWFrO2lmKCgwLG4uaXNDbWQpKGEsImVuZGJmcmFuZ2UiKSlyZXR1cm47ZXhwZWN0U3RyaW5nKGEpO2NvbnN0IHI9c3RyVG9JbnQoYSk7YT10LmdldE9iaigpO2V4cGVjdFN0cmluZyhhKTtjb25zdCBpPXN0clRvSW50KGEpO2E9dC5nZXRPYmooKTtpZihOdW1iZXIuaXNJbnRlZ2VyKGEpfHwic3RyaW5nIj09dHlwZW9mIGEpe2NvbnN0IHQ9TnVtYmVyLmlzSW50ZWdlcihhKT9TdHJpbmcuZnJvbUNoYXJDb2RlKGEpOmE7ZS5tYXBCZlJhbmdlKHIsaSx0KX1lbHNle2lmKCEoMCxuLmlzQ21kKShhLCJbIikpYnJlYWs7e2E9dC5nZXRPYmooKTtjb25zdCBzPVtdO2Zvcig7ISgwLG4uaXNDbWQpKGEsIl0iKSYmYSE9PW4uRU9GOyl7cy5wdXNoKGEpO2E9dC5nZXRPYmooKX1lLm1hcEJmUmFuZ2VUb0FycmF5KHIsaSxzKX19fXRocm93IG5ldyByLkZvcm1hdEVycm9yKCJJbnZhbGlkIGJmIHJhbmdlLiIpfWZ1bmN0aW9uIHBhcnNlQ2lkQ2hhcihlLHQpe2Zvcig7Oyl7bGV0IGE9dC5nZXRPYmooKTtpZihhPT09bi5FT0YpYnJlYWs7aWYoKDAsbi5pc0NtZCkoYSwiZW5kY2lkY2hhciIpKXJldHVybjtleHBlY3RTdHJpbmcoYSk7Y29uc3Qgcj1zdHJUb0ludChhKTthPXQuZ2V0T2JqKCk7ZXhwZWN0SW50KGEpO2NvbnN0IGk9YTtlLm1hcE9uZShyLGkpfX1mdW5jdGlvbiBwYXJzZUNpZFJhbmdlKGUsdCl7Zm9yKDs7KXtsZXQgYT10LmdldE9iaigpO2lmKGE9PT1uLkVPRilicmVhaztpZigoMCxuLmlzQ21kKShhLCJlbmRjaWRyYW5nZSIpKXJldHVybjtleHBlY3RTdHJpbmcoYSk7Y29uc3Qgcj1zdHJUb0ludChhKTthPXQuZ2V0T2JqKCk7ZXhwZWN0U3RyaW5nKGEpO2NvbnN0IGk9c3RyVG9JbnQoYSk7YT10LmdldE9iaigpO2V4cGVjdEludChhKTtjb25zdCBzPWE7ZS5tYXBDaWRSYW5nZShyLGkscyl9fWZ1bmN0aW9uIHBhcnNlQ29kZXNwYWNlUmFuZ2UoZSx0KXtmb3IoOzspe2xldCBhPXQuZ2V0T2JqKCk7aWYoYT09PW4uRU9GKWJyZWFrO2lmKCgwLG4uaXNDbWQpKGEsImVuZGNvZGVzcGFjZXJhbmdlIikpcmV0dXJuO2lmKCJzdHJpbmciIT10eXBlb2YgYSlicmVhaztjb25zdCByPXN0clRvSW50KGEpO2E9dC5nZXRPYmooKTtpZigic3RyaW5nIiE9dHlwZW9mIGEpYnJlYWs7Y29uc3QgaT1zdHJUb0ludChhKTtlLmFkZENvZGVzcGFjZVJhbmdlKGEubGVuZ3RoLHIsaSl9dGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoIkludmFsaWQgY29kZXNwYWNlIHJhbmdlLiIpfWZ1bmN0aW9uIHBhcnNlV01vZGUoZSx0KXtjb25zdCBhPXQuZ2V0T2JqKCk7TnVtYmVyLmlzSW50ZWdlcihhKSYmKGUudmVydGljYWw9ISFhKX1mdW5jdGlvbiBwYXJzZUNNYXBOYW1lKGUsdCl7Y29uc3QgYT10LmdldE9iaigpO2EgaW5zdGFuY2VvZiBuLk5hbWUmJihlLm5hbWU9YS5uYW1lKX1hc3luYyBmdW5jdGlvbiBwYXJzZUNNYXAoZSx0LGEsaSl7bGV0IHMsYztlOmZvcig7Oyl0cnl7Y29uc3QgYT10LmdldE9iaigpO2lmKGE9PT1uLkVPRilicmVhaztpZihhIGluc3RhbmNlb2Ygbi5OYW1lKXsiV01vZGUiPT09YS5uYW1lP3BhcnNlV01vZGUoZSx0KToiQ01hcE5hbWUiPT09YS5uYW1lJiZwYXJzZUNNYXBOYW1lKGUsdCk7cz1hfWVsc2UgaWYoYSBpbnN0YW5jZW9mIG4uQ21kKXN3aXRjaChhLmNtZCl7Y2FzZSJlbmRjbWFwIjpicmVhayBlO2Nhc2UidXNlY21hcCI6cyBpbnN0YW5jZW9mIG4uTmFtZSYmKGM9cy5uYW1lKTticmVhaztjYXNlImJlZ2luY29kZXNwYWNlcmFuZ2UiOnBhcnNlQ29kZXNwYWNlUmFuZ2UoZSx0KTticmVhaztjYXNlImJlZ2luYmZjaGFyIjpwYXJzZUJmQ2hhcihlLHQpO2JyZWFrO2Nhc2UiYmVnaW5jaWRjaGFyIjpwYXJzZUNpZENoYXIoZSx0KTticmVhaztjYXNlImJlZ2luYmZyYW5nZSI6cGFyc2VCZlJhbmdlKGUsdCk7YnJlYWs7Y2FzZSJiZWdpbmNpZHJhbmdlIjpwYXJzZUNpZFJhbmdlKGUsdCl9fWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBvLk1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7KDAsci53YXJuKSgiSW52YWxpZCBjTWFwIGRhdGE6ICIrZSk7Y29udGludWV9IWkmJmMmJihpPWMpO3JldHVybiBpP2V4dGVuZENNYXAoZSxhLGkpOmV9YXN5bmMgZnVuY3Rpb24gZXh0ZW5kQ01hcChlLHQsYSl7ZS51c2VDTWFwPWF3YWl0IGNyZWF0ZUJ1aWx0SW5DTWFwKGEsdCk7aWYoMD09PWUubnVtQ29kZXNwYWNlUmFuZ2VzKXtjb25zdCB0PWUudXNlQ01hcC5jb2Rlc3BhY2VSYW5nZXM7Zm9yKGxldCBhPTA7YTx0Lmxlbmd0aDthKyspZS5jb2Rlc3BhY2VSYW5nZXNbYV09dFthXS5zbGljZSgpO2UubnVtQ29kZXNwYWNlUmFuZ2VzPWUudXNlQ01hcC5udW1Db2Rlc3BhY2VSYW5nZXN9ZS51c2VDTWFwLmZvckVhY2goKGZ1bmN0aW9uKHQsYSl7ZS5jb250YWlucyh0KXx8ZS5tYXBPbmUodCxlLnVzZUNNYXAubG9va3VwKHQpKX0pKTtyZXR1cm4gZX1hc3luYyBmdW5jdGlvbiBjcmVhdGVCdWlsdEluQ01hcChlLHQpe2lmKCJJZGVudGl0eS1IIj09PWUpcmV0dXJuIG5ldyBJZGVudGl0eUNNYXAoITEsMik7aWYoIklkZW50aXR5LVYiPT09ZSlyZXR1cm4gbmV3IElkZW50aXR5Q01hcCghMCwyKTtpZighbC5pbmNsdWRlcyhlKSl0aHJvdyBuZXcgRXJyb3IoIlVua25vd24gQ01hcCBuYW1lOiAiK2UpO2lmKCF0KXRocm93IG5ldyBFcnJvcigiQnVpbHQtaW4gQ01hcCBwYXJhbWV0ZXJzIGFyZSBub3QgcHJvdmlkZWQuIik7Y29uc3R7Y01hcERhdGE6YSxjb21wcmVzc2lvblR5cGU6bn09YXdhaXQgdChlKSxpPW5ldyBDTWFwKCEwKTtpZihuPT09ci5DTWFwQ29tcHJlc3Npb25UeXBlLkJJTkFSWSlyZXR1cm4obmV3IHUpLnByb2Nlc3MoYSxpLChlPT5leHRlbmRDTWFwKGksdCxlKSkpO2lmKG49PT1yLkNNYXBDb21wcmVzc2lvblR5cGUuTk9ORSl7Y29uc3QgZT1uZXcgcy5MZXhlcihuZXcgYy5TdHJlYW0oYSkpO3JldHVybiBwYXJzZUNNYXAoaSxlLHQsbnVsbCl9dGhyb3cgbmV3IEVycm9yKCJUT0RPOiBPbmx5IEJJTkFSWS9OT05FIENNYXAgY29tcHJlc3Npb24gaXMgY3VycmVudGx5IHN1cHBvcnRlZC4iKX1yZXR1cm57YXN5bmMgY3JlYXRlKGUpe2NvbnN0IHQ9ZS5lbmNvZGluZyxhPWUuZmV0Y2hCdWlsdEluQ01hcCxyPWUudXNlQ01hcDtpZih0IGluc3RhbmNlb2Ygbi5OYW1lKXJldHVybiBjcmVhdGVCdWlsdEluQ01hcCh0Lm5hbWUsYSk7aWYodCBpbnN0YW5jZW9mIGkuQmFzZVN0cmVhbSl7Y29uc3QgZT1hd2FpdCBwYXJzZUNNYXAobmV3IENNYXAsbmV3IHMuTGV4ZXIodCksYSxyKTtyZXR1cm4gZS5pc0lkZW50aXR5Q01hcD9jcmVhdGVCdWlsdEluQ01hcChlLm5hbWUsYSk6ZX10aHJvdyBuZXcgRXJyb3IoIkVuY29kaW5nIHJlcXVpcmVkLiIpfX19KCk7dC5DTWFwRmFjdG9yeT1kfSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuUGFyc2VyPXQuTGluZWFyaXphdGlvbj10LkxleGVyPXZvaWQgMDt2YXIgcj1hKDIpLG49YSg1KSxpPWEoNikscz1hKDE4KSxvPWEoMjApLGM9YSgyMSksbD1hKDIzKSxoPWEoMjQpLHU9YSgyNyksZD1hKDI5KSxmPWEoMzEpLGc9YSgxMCkscD1hKDMyKSxtPWEoMzMpO2Z1bmN0aW9uIGNvbXB1dGVBZGxlcjMyKGUpe2NvbnN0IHQ9ZS5sZW5ndGg7bGV0IGE9MSxyPTA7Zm9yKGxldCBuPTA7bjx0Oysrbil7YSs9MjU1JmVbbl07cis9YX1yZXR1cm4gciU2NTUyMTw8MTZ8YSU2NTUyMX1jbGFzcyBQYXJzZXJ7Y29uc3RydWN0b3Ioe2xleGVyOmUseHJlZjp0LGFsbG93U3RyZWFtczphPSExLHJlY292ZXJ5TW9kZTpyPSExfSl7dGhpcy5sZXhlcj1lO3RoaXMueHJlZj10O3RoaXMuYWxsb3dTdHJlYW1zPWE7dGhpcy5yZWNvdmVyeU1vZGU9cjt0aGlzLmltYWdlQ2FjaGU9T2JqZWN0LmNyZWF0ZShudWxsKTt0aGlzLnJlZmlsbCgpfXJlZmlsbCgpe3RoaXMuYnVmMT10aGlzLmxleGVyLmdldE9iaigpO3RoaXMuYnVmMj10aGlzLmxleGVyLmdldE9iaigpfXNoaWZ0KCl7aWYodGhpcy5idWYyIGluc3RhbmNlb2Ygbi5DbWQmJiJJRCI9PT10aGlzLmJ1ZjIuY21kKXt0aGlzLmJ1ZjE9dGhpcy5idWYyO3RoaXMuYnVmMj1udWxsfWVsc2V7dGhpcy5idWYxPXRoaXMuYnVmMjt0aGlzLmJ1ZjI9dGhpcy5sZXhlci5nZXRPYmooKX19dHJ5U2hpZnQoKXt0cnl7dGhpcy5zaGlmdCgpO3JldHVybiEwfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBpLk1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7cmV0dXJuITF9fWdldE9iaihlPW51bGwpe2NvbnN0IHQ9dGhpcy5idWYxO3RoaXMuc2hpZnQoKTtpZih0IGluc3RhbmNlb2Ygbi5DbWQpc3dpdGNoKHQuY21kKXtjYXNlIkJJIjpyZXR1cm4gdGhpcy5tYWtlSW5saW5lSW1hZ2UoZSk7Y2FzZSJbIjpjb25zdCBhPVtdO2Zvcig7ISgwLG4uaXNDbWQpKHRoaXMuYnVmMSwiXSIpJiZ0aGlzLmJ1ZjEhPT1uLkVPRjspYS5wdXNoKHRoaXMuZ2V0T2JqKGUpKTtpZih0aGlzLmJ1ZjE9PT1uLkVPRil7aWYodGhpcy5yZWNvdmVyeU1vZGUpcmV0dXJuIGE7dGhyb3cgbmV3IGkuUGFyc2VyRU9GRXhjZXB0aW9uKCJFbmQgb2YgZmlsZSBpbnNpZGUgYXJyYXkuIil9dGhpcy5zaGlmdCgpO3JldHVybiBhO2Nhc2UiPDwiOmNvbnN0IHM9bmV3IG4uRGljdCh0aGlzLnhyZWYpO2Zvcig7ISgwLG4uaXNDbWQpKHRoaXMuYnVmMSwiPj4iKSYmdGhpcy5idWYxIT09bi5FT0Y7KXtpZighKHRoaXMuYnVmMSBpbnN0YW5jZW9mIG4uTmFtZSkpeygwLHIuaW5mbykoIk1hbGZvcm1lZCBkaWN0aW9uYXJ5OiBrZXkgbXVzdCBiZSBhIG5hbWUgb2JqZWN0Iik7dGhpcy5zaGlmdCgpO2NvbnRpbnVlfWNvbnN0IHQ9dGhpcy5idWYxLm5hbWU7dGhpcy5zaGlmdCgpO2lmKHRoaXMuYnVmMT09PW4uRU9GKWJyZWFrO3Muc2V0KHQsdGhpcy5nZXRPYmooZSkpfWlmKHRoaXMuYnVmMT09PW4uRU9GKXtpZih0aGlzLnJlY292ZXJ5TW9kZSlyZXR1cm4gczt0aHJvdyBuZXcgaS5QYXJzZXJFT0ZFeGNlcHRpb24oIkVuZCBvZiBmaWxlIGluc2lkZSBkaWN0aW9uYXJ5LiIpfWlmKCgwLG4uaXNDbWQpKHRoaXMuYnVmMiwic3RyZWFtIikpcmV0dXJuIHRoaXMuYWxsb3dTdHJlYW1zP3RoaXMubWFrZVN0cmVhbShzLGUpOnM7dGhpcy5zaGlmdCgpO3JldHVybiBzO2RlZmF1bHQ6cmV0dXJuIHR9aWYoTnVtYmVyLmlzSW50ZWdlcih0KSl7aWYoTnVtYmVyLmlzSW50ZWdlcih0aGlzLmJ1ZjEpJiYoMCxuLmlzQ21kKSh0aGlzLmJ1ZjIsIlIiKSl7Y29uc3QgZT1uLlJlZi5nZXQodCx0aGlzLmJ1ZjEpO3RoaXMuc2hpZnQoKTt0aGlzLnNoaWZ0KCk7cmV0dXJuIGV9cmV0dXJuIHR9cmV0dXJuInN0cmluZyI9PXR5cGVvZiB0JiZlP2UuZGVjcnlwdFN0cmluZyh0KTp0fWZpbmREZWZhdWx0SW5saW5lU3RyZWFtRW5kKGUpe2NvbnN0IHQ9dGhpcy5sZXhlcixhPWUucG9zO2xldCBzLG8sYz0wO2Zvcig7LTEhPT0ocz1lLmdldEJ5dGUoKSk7KWlmKDA9PT1jKWM9Njk9PT1zPzE6MDtlbHNlIGlmKDE9PT1jKWM9NzM9PT1zPzI6MDtlbHNleygwLHIuYXNzZXJ0KSgyPT09YywiZmluZERlZmF1bHRJbmxpbmVTdHJlYW1FbmQgLSBpbnZhbGlkIHN0YXRlLiIpO2lmKDMyPT09c3x8MTA9PT1zfHwxMz09PXMpe289ZS5wb3M7Y29uc3QgYT1lLnBlZWtCeXRlcygxMCk7Zm9yKGxldCBlPTAsdD1hLmxlbmd0aDtlPHQ7ZSsrKXtzPWFbZV07aWYoKDAhPT1zfHwwPT09YVtlKzFdKSYmKDEwIT09cyYmMTMhPT1zJiYoczwzMnx8cz4xMjcpKSl7Yz0wO2JyZWFrfX1pZigyIT09Yyljb250aW51ZTtpZih0Lmtub3duQ29tbWFuZHMpe2NvbnN0IGU9dC5wZWVrT2JqKCk7ZSBpbnN0YW5jZW9mIG4uQ21kJiYhdC5rbm93bkNvbW1hbmRzW2UuY21kXSYmKGM9MCl9ZWxzZSgwLHIud2FybikoImZpbmREZWZhdWx0SW5saW5lU3RyZWFtRW5kIC0gYGxleGVyLmtub3duQ29tbWFuZHNgIGlzIHVuZGVmaW5lZC4iKTtpZigyPT09YylicmVha31lbHNlIGM9MH1pZigtMT09PXMpeygwLHIud2FybikoImZpbmREZWZhdWx0SW5saW5lU3RyZWFtRW5kOiBSZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHN0cmVhbSB3aXRob3V0IGZpbmRpbmcgYSB2YWxpZCBFSSBtYXJrZXIiKTtpZihvKXsoMCxyLndhcm4pKCcuLi4gdHJ5aW5nIHRvIHJlY292ZXIgYnkgdXNpbmcgdGhlIGxhc3QgIkVJIiBvY2N1cnJlbmNlLicpO2Uuc2tpcCgtKGUucG9zLW8pKX19bGV0IGw9NDtlLnNraXAoLWwpO3M9ZS5wZWVrQnl0ZSgpO2Uuc2tpcChsKTsoMCxpLmlzV2hpdGVTcGFjZSkocyl8fGwtLTtyZXR1cm4gZS5wb3MtbC1hfWZpbmREQ1REZWNvZGVJbmxpbmVTdHJlYW1FbmQoZSl7Y29uc3QgdD1lLnBvcztsZXQgYSxuLGk9ITE7Zm9yKDstMSE9PShhPWUuZ2V0Qnl0ZSgpKTspaWYoMjU1PT09YSl7c3dpdGNoKGUuZ2V0Qnl0ZSgpKXtjYXNlIDA6YnJlYWs7Y2FzZSAyNTU6ZS5za2lwKC0xKTticmVhaztjYXNlIDIxNzppPSEwO2JyZWFrO2Nhc2UgMTkyOmNhc2UgMTkzOmNhc2UgMTk0OmNhc2UgMTk1OmNhc2UgMTk3OmNhc2UgMTk4OmNhc2UgMTk5OmNhc2UgMjAxOmNhc2UgMjAyOmNhc2UgMjAzOmNhc2UgMjA1OmNhc2UgMjA2OmNhc2UgMjA3OmNhc2UgMTk2OmNhc2UgMjA0OmNhc2UgMjE4OmNhc2UgMjE5OmNhc2UgMjIwOmNhc2UgMjIxOmNhc2UgMjIyOmNhc2UgMjIzOmNhc2UgMjI0OmNhc2UgMjI1OmNhc2UgMjI2OmNhc2UgMjI3OmNhc2UgMjI4OmNhc2UgMjI5OmNhc2UgMjMwOmNhc2UgMjMxOmNhc2UgMjMyOmNhc2UgMjMzOmNhc2UgMjM0OmNhc2UgMjM1OmNhc2UgMjM2OmNhc2UgMjM3OmNhc2UgMjM4OmNhc2UgMjM5OmNhc2UgMjU0Om49ZS5nZXRVaW50MTYoKTtuPjI/ZS5za2lwKG4tMik6ZS5za2lwKC0yKX1pZihpKWJyZWFrfWNvbnN0IHM9ZS5wb3MtdDtpZigtMT09PWEpeygwLHIud2FybikoIklubGluZSBEQ1REZWNvZGUgaW1hZ2Ugc3RyZWFtOiBFT0kgbWFya2VyIG5vdCBmb3VuZCwgc2VhcmNoaW5nIGZvciAvRUkvIGluc3RlYWQuIik7ZS5za2lwKC1zKTtyZXR1cm4gdGhpcy5maW5kRGVmYXVsdElubGluZVN0cmVhbUVuZChlKX10aGlzLmlubGluZVN0cmVhbVNraXBFSShlKTtyZXR1cm4gc31maW5kQVNDSUk4NURlY29kZUlubGluZVN0cmVhbUVuZChlKXtjb25zdCB0PWUucG9zO2xldCBhO2Zvcig7LTEhPT0oYT1lLmdldEJ5dGUoKSk7KWlmKDEyNj09PWEpe2NvbnN0IHQ9ZS5wb3M7YT1lLnBlZWtCeXRlKCk7Zm9yKDsoMCxpLmlzV2hpdGVTcGFjZSkoYSk7KXtlLnNraXAoKTthPWUucGVla0J5dGUoKX1pZig2Mj09PWEpe2Uuc2tpcCgpO2JyZWFrfWlmKGUucG9zPnQpe2NvbnN0IHQ9ZS5wZWVrQnl0ZXMoMik7aWYoNjk9PT10WzBdJiY3Mz09PXRbMV0pYnJlYWt9fWNvbnN0IG49ZS5wb3MtdDtpZigtMT09PWEpeygwLHIud2FybikoIklubGluZSBBU0NJSTg1RGVjb2RlIGltYWdlIHN0cmVhbTogRU9EIG1hcmtlciBub3QgZm91bmQsIHNlYXJjaGluZyBmb3IgL0VJLyBpbnN0ZWFkLiIpO2Uuc2tpcCgtbik7cmV0dXJuIHRoaXMuZmluZERlZmF1bHRJbmxpbmVTdHJlYW1FbmQoZSl9dGhpcy5pbmxpbmVTdHJlYW1Ta2lwRUkoZSk7cmV0dXJuIG59ZmluZEFTQ0lJSGV4RGVjb2RlSW5saW5lU3RyZWFtRW5kKGUpe2NvbnN0IHQ9ZS5wb3M7bGV0IGE7Zm9yKDstMSE9PShhPWUuZ2V0Qnl0ZSgpKSYmNjIhPT1hOyk7Y29uc3Qgbj1lLnBvcy10O2lmKC0xPT09YSl7KDAsci53YXJuKSgiSW5saW5lIEFTQ0lJSGV4RGVjb2RlIGltYWdlIHN0cmVhbTogRU9EIG1hcmtlciBub3QgZm91bmQsIHNlYXJjaGluZyBmb3IgL0VJLyBpbnN0ZWFkLiIpO2Uuc2tpcCgtbik7cmV0dXJuIHRoaXMuZmluZERlZmF1bHRJbmxpbmVTdHJlYW1FbmQoZSl9dGhpcy5pbmxpbmVTdHJlYW1Ta2lwRUkoZSk7cmV0dXJuIG59aW5saW5lU3RyZWFtU2tpcEVJKGUpe2xldCB0LGE9MDtmb3IoOy0xIT09KHQ9ZS5nZXRCeXRlKCkpOylpZigwPT09YSlhPTY5PT09dD8xOjA7ZWxzZSBpZigxPT09YSlhPTczPT09dD8yOjA7ZWxzZSBpZigyPT09YSlicmVha31tYWtlSW5saW5lSW1hZ2UoZSl7Y29uc3QgdD10aGlzLmxleGVyLGE9dC5zdHJlYW0saT1uZXcgbi5EaWN0KHRoaXMueHJlZik7bGV0IHM7Zm9yKDshKDAsbi5pc0NtZCkodGhpcy5idWYxLCJJRCIpJiZ0aGlzLmJ1ZjEhPT1uLkVPRjspe2lmKCEodGhpcy5idWYxIGluc3RhbmNlb2Ygbi5OYW1lKSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiRGljdGlvbmFyeSBrZXkgbXVzdCBiZSBhIG5hbWUgb2JqZWN0Iik7Y29uc3QgdD10aGlzLmJ1ZjEubmFtZTt0aGlzLnNoaWZ0KCk7aWYodGhpcy5idWYxPT09bi5FT0YpYnJlYWs7aS5zZXQodCx0aGlzLmdldE9iaihlKSl9LTEhPT10LmJlZ2luSW5saW5lSW1hZ2VQb3MmJihzPWEucG9zLXQuYmVnaW5JbmxpbmVJbWFnZVBvcyk7Y29uc3Qgbz1pLmdldCgiRiIsIkZpbHRlciIpO2xldCBjO2lmKG8gaW5zdGFuY2VvZiBuLk5hbWUpYz1vLm5hbWU7ZWxzZSBpZihBcnJheS5pc0FycmF5KG8pKXtjb25zdCBlPXRoaXMueHJlZi5mZXRjaElmUmVmKG9bMF0pO2UgaW5zdGFuY2VvZiBuLk5hbWUmJihjPWUubmFtZSl9Y29uc3QgbD1hLnBvcztsZXQgaDtzd2l0Y2goYyl7Y2FzZSJEQ1QiOmNhc2UiRENURGVjb2RlIjpoPXRoaXMuZmluZERDVERlY29kZUlubGluZVN0cmVhbUVuZChhKTticmVhaztjYXNlIkE4NSI6Y2FzZSJBU0NJSTg1RGVjb2RlIjpoPXRoaXMuZmluZEFTQ0lJODVEZWNvZGVJbmxpbmVTdHJlYW1FbmQoYSk7YnJlYWs7Y2FzZSJBSHgiOmNhc2UiQVNDSUlIZXhEZWNvZGUiOmg9dGhpcy5maW5kQVNDSUlIZXhEZWNvZGVJbmxpbmVTdHJlYW1FbmQoYSk7YnJlYWs7ZGVmYXVsdDpoPXRoaXMuZmluZERlZmF1bHRJbmxpbmVTdHJlYW1FbmQoYSl9bGV0IHUsZD1hLm1ha2VTdWJTdHJlYW0obCxoLGkpO2lmKGg8MWUzJiZzPDU1NTIpe2NvbnN0IGU9ZC5nZXRCeXRlcygpO2QucmVzZXQoKTtjb25zdCByPWEucG9zO2EucG9zPXQuYmVnaW5JbmxpbmVJbWFnZVBvcztjb25zdCBpPWEuZ2V0Qnl0ZXMocyk7YS5wb3M9cjt1PWNvbXB1dGVBZGxlcjMyKGUpKyJfIitjb21wdXRlQWRsZXIzMihpKTtjb25zdCBvPXRoaXMuaW1hZ2VDYWNoZVt1XTtpZih2b2lkIDAhPT1vKXt0aGlzLmJ1ZjI9bi5DbWQuZ2V0KCJFSSIpO3RoaXMuc2hpZnQoKTtvLnJlc2V0KCk7cmV0dXJuIG99fWUmJihkPWUuY3JlYXRlU3RyZWFtKGQsaCkpO2Q9dGhpcy5maWx0ZXIoZCxpLGgpO2QuZGljdD1pO2lmKHZvaWQgMCE9PXUpe2QuY2FjaGVLZXk9YGlubGluZV8ke2h9XyR7dX1gO3RoaXMuaW1hZ2VDYWNoZVt1XT1kfXRoaXMuYnVmMj1uLkNtZC5nZXQoIkVJIik7dGhpcy5zaGlmdCgpO3JldHVybiBkfV9maW5kU3RyZWFtTGVuZ3RoKGUsdCl7Y29uc3R7c3RyZWFtOmF9PXRoaXMubGV4ZXI7YS5wb3M9ZTtjb25zdCByPXQubGVuZ3RoO2Zvcig7YS5wb3M8YS5lbmQ7KXtjb25zdCBuPWEucGVla0J5dGVzKDIwNDgpLGk9bi5sZW5ndGgtcjtpZihpPD0wKWJyZWFrO2xldCBzPTA7Zm9yKDtzPGk7KXtsZXQgaT0wO2Zvcig7aTxyJiZuW3MraV09PT10W2ldOylpKys7aWYoaT49cil7YS5wb3MrPXM7cmV0dXJuIGEucG9zLWV9cysrfWEucG9zKz1pfXJldHVybi0xfW1ha2VTdHJlYW0oZSx0KXtjb25zdCBhPXRoaXMubGV4ZXI7bGV0IHM9YS5zdHJlYW07YS5za2lwVG9OZXh0TGluZSgpO2NvbnN0IG89cy5wb3MtMTtsZXQgYz1lLmdldCgiTGVuZ3RoIik7aWYoIU51bWJlci5pc0ludGVnZXIoYykpeygwLHIuaW5mbykoYEJhZCBsZW5ndGggIiR7YyYmYy50b1N0cmluZygpfSIgaW4gc3RyZWFtLmApO2M9MH1zLnBvcz1vK2M7YS5uZXh0Q2hhcigpO2lmKHRoaXMudHJ5U2hpZnQoKSYmKDAsbi5pc0NtZCkodGhpcy5idWYyLCJlbmRzdHJlYW0iKSl0aGlzLnNoaWZ0KCk7ZWxzZXtjb25zdCBlPW5ldyBVaW50OEFycmF5KFsxMDEsMTEwLDEwMCwxMTUsMTE2LDExNCwxMDEsOTcsMTA5XSk7bGV0IHQ9dGhpcy5fZmluZFN0cmVhbUxlbmd0aChvLGUpO2lmKHQ8MCl7Y29uc3QgYT0xO2ZvcihsZXQgbj0xO248PWE7bisrKXtjb25zdCBhPWUubGVuZ3RoLW4sYz1lLnNsaWNlKDAsYSksbD10aGlzLl9maW5kU3RyZWFtTGVuZ3RoKG8sYyk7aWYobD49MCl7Y29uc3QgZT1zLnBlZWtCeXRlcyhhKzEpW2FdO2lmKCEoMCxpLmlzV2hpdGVTcGFjZSkoZSkpYnJlYWs7KDAsci5pbmZvKShgRm91bmQgIiR7KDAsci5ieXRlc1RvU3RyaW5nKShjKX0iIHdoZW4gc2VhcmNoaW5nIGZvciBlbmRzdHJlYW0gY29tbWFuZC5gKTt0PWw7YnJlYWt9fWlmKHQ8MCl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiTWlzc2luZyBlbmRzdHJlYW0gY29tbWFuZC4iKX1jPXQ7YS5uZXh0Q2hhcigpO3RoaXMuc2hpZnQoKTt0aGlzLnNoaWZ0KCl9dGhpcy5zaGlmdCgpO3M9cy5tYWtlU3ViU3RyZWFtKG8sYyxlKTt0JiYocz10LmNyZWF0ZVN0cmVhbShzLGMpKTtzPXRoaXMuZmlsdGVyKHMsZSxjKTtzLmRpY3Q9ZTtyZXR1cm4gc31maWx0ZXIoZSx0LGEpe2xldCBpPXQuZ2V0KCJGIiwiRmlsdGVyIikscz10LmdldCgiRFAiLCJEZWNvZGVQYXJtcyIpO2lmKGkgaW5zdGFuY2VvZiBuLk5hbWUpe0FycmF5LmlzQXJyYXkocykmJigwLHIud2FybikoIi9EZWNvZGVQYXJtcyBzaG91bGQgbm90IGJlIGFuIEFycmF5LCB3aGVuIC9GaWx0ZXIgaXMgYSBOYW1lLiIpO3JldHVybiB0aGlzLm1ha2VGaWx0ZXIoZSxpLm5hbWUsYSxzKX1sZXQgbz1hO2lmKEFycmF5LmlzQXJyYXkoaSkpe2NvbnN0IHQ9aSxhPXM7Zm9yKGxldCBjPTAsbD10Lmxlbmd0aDtjPGw7KytjKXtpPXRoaXMueHJlZi5mZXRjaElmUmVmKHRbY10pO2lmKCEoaSBpbnN0YW5jZW9mIG4uTmFtZSkpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoYEJhZCBmaWx0ZXIgbmFtZSAiJHtpfSJgKTtzPW51bGw7QXJyYXkuaXNBcnJheShhKSYmYyBpbiBhJiYocz10aGlzLnhyZWYuZmV0Y2hJZlJlZihhW2NdKSk7ZT10aGlzLm1ha2VGaWx0ZXIoZSxpLm5hbWUsbyxzKTtvPW51bGx9fXJldHVybiBlfW1ha2VGaWx0ZXIoZSx0LGEsbil7aWYoMD09PWEpeygwLHIud2FybikoYEVtcHR5ICIke3R9IiBzdHJlYW0uYCk7cmV0dXJuIG5ldyBnLk51bGxTdHJlYW19Y29uc3QgYj10aGlzLnhyZWYuc3RhdHM7dHJ5e3N3aXRjaCh0KXtjYXNlIkZsIjpjYXNlIkZsYXRlRGVjb2RlIjpiLmFkZFN0cmVhbVR5cGUoci5TdHJlYW1UeXBlLkZMQVRFKTtyZXR1cm4gbj9uZXcgcC5QcmVkaWN0b3JTdHJlYW0obmV3IGwuRmxhdGVTdHJlYW0oZSxhKSxhLG4pOm5ldyBsLkZsYXRlU3RyZWFtKGUsYSk7Y2FzZSJMWlciOmNhc2UiTFpXRGVjb2RlIjpiLmFkZFN0cmVhbVR5cGUoci5TdHJlYW1UeXBlLkxaVyk7bGV0IHQ9MTtpZihuKXtuLmhhcygiRWFybHlDaGFuZ2UiKSYmKHQ9bi5nZXQoIkVhcmx5Q2hhbmdlIikpO3JldHVybiBuZXcgcC5QcmVkaWN0b3JTdHJlYW0obmV3IGYuTFpXU3RyZWFtKGUsYSx0KSxhLG4pfXJldHVybiBuZXcgZi5MWldTdHJlYW0oZSxhLHQpO2Nhc2UiRENUIjpjYXNlIkRDVERlY29kZSI6Yi5hZGRTdHJlYW1UeXBlKHIuU3RyZWFtVHlwZS5EQ1QpO3JldHVybiBuZXcgdS5KcGVnU3RyZWFtKGUsYSxuKTtjYXNlIkpQWCI6Y2FzZSJKUFhEZWNvZGUiOmIuYWRkU3RyZWFtVHlwZShyLlN0cmVhbVR5cGUuSlBYKTtyZXR1cm4gbmV3IGQuSnB4U3RyZWFtKGUsYSxuKTtjYXNlIkE4NSI6Y2FzZSJBU0NJSTg1RGVjb2RlIjpiLmFkZFN0cmVhbVR5cGUoci5TdHJlYW1UeXBlLkE4NSk7cmV0dXJuIG5ldyBzLkFzY2lpODVTdHJlYW0oZSxhKTtjYXNlIkFIeCI6Y2FzZSJBU0NJSUhleERlY29kZSI6Yi5hZGRTdHJlYW1UeXBlKHIuU3RyZWFtVHlwZS5BSFgpO3JldHVybiBuZXcgby5Bc2NpaUhleFN0cmVhbShlLGEpO2Nhc2UiQ0NGIjpjYXNlIkNDSVRURmF4RGVjb2RlIjpiLmFkZFN0cmVhbVR5cGUoci5TdHJlYW1UeXBlLkNDRik7cmV0dXJuIG5ldyBjLkNDSVRURmF4U3RyZWFtKGUsYSxuKTtjYXNlIlJMIjpjYXNlIlJ1bkxlbmd0aERlY29kZSI6Yi5hZGRTdHJlYW1UeXBlKHIuU3RyZWFtVHlwZS5STFgpO3JldHVybiBuZXcgbS5SdW5MZW5ndGhTdHJlYW0oZSxhKTtjYXNlIkpCSUcyRGVjb2RlIjpiLmFkZFN0cmVhbVR5cGUoci5TdHJlYW1UeXBlLkpCSUcpO3JldHVybiBuZXcgaC5KYmlnMlN0cmVhbShlLGEsbil9KDAsci53YXJuKShgRmlsdGVyICIke3R9IiBpcyBub3Qgc3VwcG9ydGVkLmApO3JldHVybiBlfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBpLk1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7KDAsci53YXJuKShgSW52YWxpZCBzdHJlYW06ICIke2V9ImApO3JldHVybiBuZXcgZy5OdWxsU3RyZWFtfX19dC5QYXJzZXI9UGFyc2VyO2NvbnN0IGI9WzEsMCwwLDAsMCwwLDAsMCwwLDEsMSwwLDEsMSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxLDAsMCwwLDAsMiwwLDAsMiwyLDAsMCwwLDAsMCwyLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMCwyLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwwLDIsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMCwyLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdO2Z1bmN0aW9uIHRvSGV4RGlnaXQoZSl7cmV0dXJuIGU+PTQ4JiZlPD01Nz8xNSZlOmU+PTY1JiZlPD03MHx8ZT49OTcmJmU8PTEwMj85KygxNSZlKTotMX1jbGFzcyBMZXhlcntjb25zdHJ1Y3RvcihlLHQ9bnVsbCl7dGhpcy5zdHJlYW09ZTt0aGlzLm5leHRDaGFyKCk7dGhpcy5zdHJCdWY9W107dGhpcy5rbm93bkNvbW1hbmRzPXQ7dGhpcy5faGV4U3RyaW5nTnVtV2Fybj0wO3RoaXMuYmVnaW5JbmxpbmVJbWFnZVBvcz0tMX1uZXh0Q2hhcigpe3JldHVybiB0aGlzLmN1cnJlbnRDaGFyPXRoaXMuc3RyZWFtLmdldEJ5dGUoKX1wZWVrQ2hhcigpe3JldHVybiB0aGlzLnN0cmVhbS5wZWVrQnl0ZSgpfWdldE51bWJlcigpe2xldCBlPXRoaXMuY3VycmVudENoYXIsdD0hMSxhPTAsbj0wO2lmKDQ1PT09ZSl7bj0tMTtlPXRoaXMubmV4dENoYXIoKTs0NT09PWUmJihlPXRoaXMubmV4dENoYXIoKSl9ZWxzZSBpZig0Mz09PWUpe249MTtlPXRoaXMubmV4dENoYXIoKX1pZigxMD09PWV8fDEzPT09ZSlkb3tlPXRoaXMubmV4dENoYXIoKX13aGlsZSgxMD09PWV8fDEzPT09ZSk7aWYoNDY9PT1lKXthPTEwO2U9dGhpcy5uZXh0Q2hhcigpfWlmKGU8NDh8fGU+NTcpe2lmKCgwLGkuaXNXaGl0ZVNwYWNlKShlKXx8LTE9PT1lKXtpZigxMD09PWEmJjA9PT1uKXsoMCxyLndhcm4pKCJMZXhlci5nZXROdW1iZXIgLSB0cmVhdGluZyBhIHNpbmdsZSBkZWNpbWFsIHBvaW50IGFzIHplcm8uIik7cmV0dXJuIDB9aWYoMD09PWEmJi0xPT09bil7KDAsci53YXJuKSgiTGV4ZXIuZ2V0TnVtYmVyIC0gdHJlYXRpbmcgYSBzaW5nbGUgbWludXMgc2lnbiBhcyB6ZXJvLiIpO3JldHVybiAwfX10aHJvdyBuZXcgci5Gb3JtYXRFcnJvcihgSW52YWxpZCBudW1iZXI6ICR7U3RyaW5nLmZyb21DaGFyQ29kZShlKX0gKGNoYXJDb2RlICR7ZX0pYCl9bj1ufHwxO2xldCBzPWUtNDgsbz0wLGM9MTtmb3IoOyhlPXRoaXMubmV4dENoYXIoKSk+PTA7KWlmKGU+PTQ4JiZlPD01Nyl7Y29uc3Qgcj1lLTQ4O2lmKHQpbz0xMCpvK3I7ZWxzZXswIT09YSYmKGEqPTEwKTtzPTEwKnMrcn19ZWxzZSBpZig0Nj09PWUpe2lmKDAhPT1hKWJyZWFrO2E9MX1lbHNlIGlmKDQ1PT09ZSkoMCxyLndhcm4pKCJCYWRseSBmb3JtYXR0ZWQgbnVtYmVyOiBtaW51cyBzaWduIGluIHRoZSBtaWRkbGUiKTtlbHNle2lmKDY5IT09ZSYmMTAxIT09ZSlicmVhaztlPXRoaXMucGVla0NoYXIoKTtpZig0Mz09PWV8fDQ1PT09ZSl7Yz00NT09PWU/LTE6MTt0aGlzLm5leHRDaGFyKCl9ZWxzZSBpZihlPDQ4fHxlPjU3KWJyZWFrO3Q9ITB9MCE9PWEmJihzLz1hKTt0JiYocyo9MTAqKihjKm8pKTtyZXR1cm4gbipzfWdldFN0cmluZygpe2xldCBlPTEsdD0hMTtjb25zdCBhPXRoaXMuc3RyQnVmO2EubGVuZ3RoPTA7bGV0IG49dGhpcy5uZXh0Q2hhcigpO2Zvcig7Oyl7bGV0IGk9ITE7c3dpdGNoKDB8bil7Y2FzZS0xOigwLHIud2FybikoIlVudGVybWluYXRlZCBzdHJpbmciKTt0PSEwO2JyZWFrO2Nhc2UgNDA6KytlO2EucHVzaCgiKCIpO2JyZWFrO2Nhc2UgNDE6aWYoMD09LS1lKXt0aGlzLm5leHRDaGFyKCk7dD0hMH1lbHNlIGEucHVzaCgiKSIpO2JyZWFrO2Nhc2UgOTI6bj10aGlzLm5leHRDaGFyKCk7c3dpdGNoKG4pe2Nhc2UtMTooMCxyLndhcm4pKCJVbnRlcm1pbmF0ZWQgc3RyaW5nIik7dD0hMDticmVhaztjYXNlIDExMDphLnB1c2goIlxuIik7YnJlYWs7Y2FzZSAxMTQ6YS5wdXNoKCJcciIpO2JyZWFrO2Nhc2UgMTE2OmEucHVzaCgiXHQiKTticmVhaztjYXNlIDk4OmEucHVzaCgiXGIiKTticmVhaztjYXNlIDEwMjphLnB1c2goIlxmIik7YnJlYWs7Y2FzZSA5MjpjYXNlIDQwOmNhc2UgNDE6YS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUobikpO2JyZWFrO2Nhc2UgNDg6Y2FzZSA0OTpjYXNlIDUwOmNhc2UgNTE6Y2FzZSA1MjpjYXNlIDUzOmNhc2UgNTQ6Y2FzZSA1NTpsZXQgZT0xNSZuO249dGhpcy5uZXh0Q2hhcigpO2k9ITA7aWYobj49NDgmJm48PTU1KXtlPShlPDwzKSsoMTUmbik7bj10aGlzLm5leHRDaGFyKCk7aWYobj49NDgmJm48PTU1KXtpPSExO2U9KGU8PDMpKygxNSZuKX19YS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoZSkpO2JyZWFrO2Nhc2UgMTM6MTA9PT10aGlzLnBlZWtDaGFyKCkmJnRoaXMubmV4dENoYXIoKTticmVhaztjYXNlIDEwOmJyZWFrO2RlZmF1bHQ6YS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUobikpfWJyZWFrO2RlZmF1bHQ6YS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUobikpfWlmKHQpYnJlYWs7aXx8KG49dGhpcy5uZXh0Q2hhcigpKX1yZXR1cm4gYS5qb2luKCIiKX1nZXROYW1lKCl7bGV0IGUsdDtjb25zdCBhPXRoaXMuc3RyQnVmO2EubGVuZ3RoPTA7Zm9yKDsoZT10aGlzLm5leHRDaGFyKCkpPj0wJiYhYltlXTspaWYoMzU9PT1lKXtlPXRoaXMubmV4dENoYXIoKTtpZihiW2VdKXsoMCxyLndhcm4pKCJMZXhlcl9nZXROYW1lOiBOVU1CRVIgU0lHTiAoIykgc2hvdWxkIGJlIGZvbGxvd2VkIGJ5IGEgaGV4YWRlY2ltYWwgbnVtYmVyLiIpO2EucHVzaCgiIyIpO2JyZWFrfWNvbnN0IG49dG9IZXhEaWdpdChlKTtpZigtMSE9PW4pe3Q9ZTtlPXRoaXMubmV4dENoYXIoKTtjb25zdCBpPXRvSGV4RGlnaXQoZSk7aWYoLTE9PT1pKXsoMCxyLndhcm4pKGBMZXhlcl9nZXROYW1lOiBJbGxlZ2FsIGRpZ2l0ICgke1N0cmluZy5mcm9tQ2hhckNvZGUoZSl9KSBpbiBoZXhhZGVjaW1hbCBudW1iZXIuYCk7YS5wdXNoKCIjIixTdHJpbmcuZnJvbUNoYXJDb2RlKHQpKTtpZihiW2VdKWJyZWFrO2EucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGUpKTtjb250aW51ZX1hLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShuPDw0fGkpKX1lbHNlIGEucHVzaCgiIyIsU3RyaW5nLmZyb21DaGFyQ29kZShlKSl9ZWxzZSBhLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShlKSk7YS5sZW5ndGg+MTI3JiYoMCxyLndhcm4pKGBOYW1lIHRva2VuIGlzIGxvbmdlciB0aGFuIGFsbG93ZWQgYnkgdGhlIHNwZWM6ICR7YS5sZW5ndGh9YCk7cmV0dXJuIG4uTmFtZS5nZXQoYS5qb2luKCIiKSl9X2hleFN0cmluZ1dhcm4oZSl7NSE9dGhpcy5faGV4U3RyaW5nTnVtV2FybisrP3RoaXMuX2hleFN0cmluZ051bVdhcm4+NXx8KDAsci53YXJuKShgZ2V0SGV4U3RyaW5nIC0gaWdub3JpbmcgaW52YWxpZCBjaGFyYWN0ZXI6ICR7ZX1gKTooMCxyLndhcm4pKCJnZXRIZXhTdHJpbmcgLSBpZ25vcmluZyBhZGRpdGlvbmFsIGludmFsaWQgY2hhcmFjdGVycy4iKX1nZXRIZXhTdHJpbmcoKXtjb25zdCBlPXRoaXMuc3RyQnVmO2UubGVuZ3RoPTA7bGV0IHQsYSxuPXRoaXMuY3VycmVudENoYXIsaT0hMDt0aGlzLl9oZXhTdHJpbmdOdW1XYXJuPTA7Zm9yKDs7KXtpZihuPDApeygwLHIud2FybikoIlVudGVybWluYXRlZCBoZXggc3RyaW5nIik7YnJlYWt9aWYoNjI9PT1uKXt0aGlzLm5leHRDaGFyKCk7YnJlYWt9aWYoMSE9PWJbbl0pe2lmKGkpe3Q9dG9IZXhEaWdpdChuKTtpZigtMT09PXQpe3RoaXMuX2hleFN0cmluZ1dhcm4obik7bj10aGlzLm5leHRDaGFyKCk7Y29udGludWV9fWVsc2V7YT10b0hleERpZ2l0KG4pO2lmKC0xPT09YSl7dGhpcy5faGV4U3RyaW5nV2FybihuKTtuPXRoaXMubmV4dENoYXIoKTtjb250aW51ZX1lLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSh0PDw0fGEpKX1pPSFpO249dGhpcy5uZXh0Q2hhcigpfWVsc2Ugbj10aGlzLm5leHRDaGFyKCl9cmV0dXJuIGUuam9pbigiIil9Z2V0T2JqKCl7bGV0IGU9ITEsdD10aGlzLmN1cnJlbnRDaGFyO2Zvcig7Oyl7aWYodDwwKXJldHVybiBuLkVPRjtpZihlKTEwIT09dCYmMTMhPT10fHwoZT0hMSk7ZWxzZSBpZigzNz09PXQpZT0hMDtlbHNlIGlmKDEhPT1iW3RdKWJyZWFrO3Q9dGhpcy5uZXh0Q2hhcigpfXN3aXRjaCgwfHQpe2Nhc2UgNDg6Y2FzZSA0OTpjYXNlIDUwOmNhc2UgNTE6Y2FzZSA1MjpjYXNlIDUzOmNhc2UgNTQ6Y2FzZSA1NTpjYXNlIDU2OmNhc2UgNTc6Y2FzZSA0MzpjYXNlIDQ1OmNhc2UgNDY6cmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCk7Y2FzZSA0MDpyZXR1cm4gdGhpcy5nZXRTdHJpbmcoKTtjYXNlIDQ3OnJldHVybiB0aGlzLmdldE5hbWUoKTtjYXNlIDkxOnRoaXMubmV4dENoYXIoKTtyZXR1cm4gbi5DbWQuZ2V0KCJbIik7Y2FzZSA5Mzp0aGlzLm5leHRDaGFyKCk7cmV0dXJuIG4uQ21kLmdldCgiXSIpO2Nhc2UgNjA6dD10aGlzLm5leHRDaGFyKCk7aWYoNjA9PT10KXt0aGlzLm5leHRDaGFyKCk7cmV0dXJuIG4uQ21kLmdldCgiPDwiKX1yZXR1cm4gdGhpcy5nZXRIZXhTdHJpbmcoKTtjYXNlIDYyOnQ9dGhpcy5uZXh0Q2hhcigpO2lmKDYyPT09dCl7dGhpcy5uZXh0Q2hhcigpO3JldHVybiBuLkNtZC5nZXQoIj4+Iil9cmV0dXJuIG4uQ21kLmdldCgiPiIpO2Nhc2UgMTIzOnRoaXMubmV4dENoYXIoKTtyZXR1cm4gbi5DbWQuZ2V0KCJ7Iik7Y2FzZSAxMjU6dGhpcy5uZXh0Q2hhcigpO3JldHVybiBuLkNtZC5nZXQoIn0iKTtjYXNlIDQxOnRoaXMubmV4dENoYXIoKTt0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcihgSWxsZWdhbCBjaGFyYWN0ZXI6ICR7dH1gKX1sZXQgYT1TdHJpbmcuZnJvbUNoYXJDb2RlKHQpO2lmKHQ8MzJ8fHQ+MTI3KXtjb25zdCBlPXRoaXMucGVla0NoYXIoKTtpZihlPj0zMiYmZTw9MTI3KXt0aGlzLm5leHRDaGFyKCk7cmV0dXJuIG4uQ21kLmdldChhKX19Y29uc3QgaT10aGlzLmtub3duQ29tbWFuZHM7bGV0IHM9aSYmdm9pZCAwIT09aVthXTtmb3IoOyh0PXRoaXMubmV4dENoYXIoKSk+PTAmJiFiW3RdOyl7Y29uc3QgZT1hK1N0cmluZy5mcm9tQ2hhckNvZGUodCk7aWYocyYmdm9pZCAwPT09aVtlXSlicmVhaztpZigxMjg9PT1hLmxlbmd0aCl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcihgQ29tbWFuZCB0b2tlbiB0b28gbG9uZzogJHthLmxlbmd0aH1gKTthPWU7cz1pJiZ2b2lkIDAhPT1pW2FdfWlmKCJ0cnVlIj09PWEpcmV0dXJuITA7aWYoImZhbHNlIj09PWEpcmV0dXJuITE7aWYoIm51bGwiPT09YSlyZXR1cm4gbnVsbDsiQkkiPT09YSYmKHRoaXMuYmVnaW5JbmxpbmVJbWFnZVBvcz10aGlzLnN0cmVhbS5wb3MpO3JldHVybiBuLkNtZC5nZXQoYSl9cGVla09iaigpe2NvbnN0IGU9dGhpcy5zdHJlYW0ucG9zLHQ9dGhpcy5jdXJyZW50Q2hhcixhPXRoaXMuYmVnaW5JbmxpbmVJbWFnZVBvcztsZXQgbjt0cnl7bj10aGlzLmdldE9iaigpfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBpLk1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7KDAsci53YXJuKShgcGVla09iajogJHtlfWApfXRoaXMuc3RyZWFtLnBvcz1lO3RoaXMuY3VycmVudENoYXI9dDt0aGlzLmJlZ2luSW5saW5lSW1hZ2VQb3M9YTtyZXR1cm4gbn1za2lwVG9OZXh0TGluZSgpe2xldCBlPXRoaXMuY3VycmVudENoYXI7Zm9yKDtlPj0wOyl7aWYoMTM9PT1lKXtlPXRoaXMubmV4dENoYXIoKTsxMD09PWUmJnRoaXMubmV4dENoYXIoKTticmVha31pZigxMD09PWUpe3RoaXMubmV4dENoYXIoKTticmVha31lPXRoaXMubmV4dENoYXIoKX19fXQuTGV4ZXI9TGV4ZXI7dC5MaW5lYXJpemF0aW9uPWNsYXNzIExpbmVhcml6YXRpb257c3RhdGljIGNyZWF0ZShlKXtmdW5jdGlvbiBnZXRJbnQoZSx0LGE9ITEpe2NvbnN0IHI9ZS5nZXQodCk7aWYoTnVtYmVyLmlzSW50ZWdlcihyKSYmKGE/cj49MDpyPjApKXJldHVybiByO3Rocm93IG5ldyBFcnJvcihgVGhlICIke3R9IiBwYXJhbWV0ZXIgaW4gdGhlIGxpbmVhcml6YXRpb24gZGljdGlvbmFyeSBpcyBpbnZhbGlkLmApfWNvbnN0IHQ9bmV3IFBhcnNlcih7bGV4ZXI6bmV3IExleGVyKGUpLHhyZWY6bnVsbH0pLGE9dC5nZXRPYmooKSxyPXQuZ2V0T2JqKCksaT10LmdldE9iaigpLHM9dC5nZXRPYmooKTtsZXQgbyxjO2lmKCEoTnVtYmVyLmlzSW50ZWdlcihhKSYmTnVtYmVyLmlzSW50ZWdlcihyKSYmKDAsbi5pc0NtZCkoaSwib2JqIikmJnMgaW5zdGFuY2VvZiBuLkRpY3QmJiJudW1iZXIiPT10eXBlb2Yobz1zLmdldCgiTGluZWFyaXplZCIpKSYmbz4wKSlyZXR1cm4gbnVsbDtpZigoYz1nZXRJbnQocywiTCIpKSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcignVGhlICJMIiBwYXJhbWV0ZXIgaW4gdGhlIGxpbmVhcml6YXRpb24gZGljdGlvbmFyeSBkb2VzIG5vdCBlcXVhbCB0aGUgc3RyZWFtIGxlbmd0aC4nKTtyZXR1cm57bGVuZ3RoOmMsaGludHM6ZnVuY3Rpb24gZ2V0SGludHMoZSl7Y29uc3QgdD1lLmdldCgiSCIpO2xldCBhO2lmKEFycmF5LmlzQXJyYXkodCkmJigyPT09KGE9dC5sZW5ndGgpfHw0PT09YSkpe2ZvcihsZXQgZT0wO2U8YTtlKyspe2NvbnN0IGE9dFtlXTtpZighKE51bWJlci5pc0ludGVnZXIoYSkmJmE+MCkpdGhyb3cgbmV3IEVycm9yKGBIaW50ICgke2V9KSBpbiB0aGUgbGluZWFyaXphdGlvbiBkaWN0aW9uYXJ5IGlzIGludmFsaWQuYCl9cmV0dXJuIHR9dGhyb3cgbmV3IEVycm9yKCJIaW50IGFycmF5IGluIHRoZSBsaW5lYXJpemF0aW9uIGRpY3Rpb25hcnkgaXMgaW52YWxpZC4iKX0ocyksb2JqZWN0TnVtYmVyRmlyc3Q6Z2V0SW50KHMsIk8iKSxlbmRGaXJzdDpnZXRJbnQocywiRSIpLG51bVBhZ2VzOmdldEludChzLCJOIiksbWFpblhSZWZFbnRyaWVzT2Zmc2V0OmdldEludChzLCJUIikscGFnZUZpcnN0OnMuaGFzKCJQIik/Z2V0SW50KHMsIlAiLCEwKTowfX19fSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuQXNjaWk4NVN0cmVhbT12b2lkIDA7dmFyIHI9YSgxOSksbj1hKDYpO2NsYXNzIEFzY2lpODVTdHJlYW0gZXh0ZW5kcyByLkRlY29kZVN0cmVhbXtjb25zdHJ1Y3RvcihlLHQpe3QmJih0Kj0uOCk7c3VwZXIodCk7dGhpcy5zdHI9ZTt0aGlzLmRpY3Q9ZS5kaWN0O3RoaXMuaW5wdXQ9bmV3IFVpbnQ4QXJyYXkoNSl9cmVhZEJsb2NrKCl7Y29uc3QgZT10aGlzLnN0cjtsZXQgdD1lLmdldEJ5dGUoKTtmb3IoOygwLG4uaXNXaGl0ZVNwYWNlKSh0KTspdD1lLmdldEJ5dGUoKTtpZigtMT09PXR8fDEyNj09PXQpe3RoaXMuZW9mPSEwO3JldHVybn1jb25zdCBhPXRoaXMuYnVmZmVyTGVuZ3RoO2xldCByLGk7aWYoMTIyPT09dCl7cj10aGlzLmVuc3VyZUJ1ZmZlcihhKzQpO2ZvcihpPTA7aTw0OysraSlyW2EraV09MDt0aGlzLmJ1ZmZlckxlbmd0aCs9NH1lbHNle2NvbnN0IHM9dGhpcy5pbnB1dDtzWzBdPXQ7Zm9yKGk9MTtpPDU7KytpKXt0PWUuZ2V0Qnl0ZSgpO2Zvcig7KDAsbi5pc1doaXRlU3BhY2UpKHQpOyl0PWUuZ2V0Qnl0ZSgpO3NbaV09dDtpZigtMT09PXR8fDEyNj09PXQpYnJlYWt9cj10aGlzLmVuc3VyZUJ1ZmZlcihhK2ktMSk7dGhpcy5idWZmZXJMZW5ndGgrPWktMTtpZihpPDUpe2Zvcig7aTw1OysraSlzW2ldPTExNzt0aGlzLmVvZj0hMH1sZXQgbz0wO2ZvcihpPTA7aTw1OysraSlvPTg1Km8rKHNbaV0tMzMpO2ZvcihpPTM7aT49MDstLWkpe3JbYStpXT0yNTUmbztvPj49OH19fX10LkFzY2lpODVTdHJlYW09QXNjaWk4NVN0cmVhbX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LlN0cmVhbXNTZXF1ZW5jZVN0cmVhbT10LkRlY29kZVN0cmVhbT12b2lkIDA7dmFyIHI9YSg3KSxuPWEoMTApO2NvbnN0IGk9bmV3IFVpbnQ4QXJyYXkoMCk7Y2xhc3MgRGVjb2RlU3RyZWFtIGV4dGVuZHMgci5CYXNlU3RyZWFte2NvbnN0cnVjdG9yKGUpe3N1cGVyKCk7dGhpcy5fcmF3TWluQnVmZmVyTGVuZ3RoPWV8fDA7dGhpcy5wb3M9MDt0aGlzLmJ1ZmZlckxlbmd0aD0wO3RoaXMuZW9mPSExO3RoaXMuYnVmZmVyPWk7dGhpcy5taW5CdWZmZXJMZW5ndGg9NTEyO2lmKGUpZm9yKDt0aGlzLm1pbkJ1ZmZlckxlbmd0aDxlOyl0aGlzLm1pbkJ1ZmZlckxlbmd0aCo9Mn1nZXQgaXNFbXB0eSgpe2Zvcig7IXRoaXMuZW9mJiYwPT09dGhpcy5idWZmZXJMZW5ndGg7KXRoaXMucmVhZEJsb2NrKCk7cmV0dXJuIDA9PT10aGlzLmJ1ZmZlckxlbmd0aH1lbnN1cmVCdWZmZXIoZSl7Y29uc3QgdD10aGlzLmJ1ZmZlcjtpZihlPD10LmJ5dGVMZW5ndGgpcmV0dXJuIHQ7bGV0IGE9dGhpcy5taW5CdWZmZXJMZW5ndGg7Zm9yKDthPGU7KWEqPTI7Y29uc3Qgcj1uZXcgVWludDhBcnJheShhKTtyLnNldCh0KTtyZXR1cm4gdGhpcy5idWZmZXI9cn1nZXRCeXRlKCl7Y29uc3QgZT10aGlzLnBvcztmb3IoO3RoaXMuYnVmZmVyTGVuZ3RoPD1lOyl7aWYodGhpcy5lb2YpcmV0dXJuLTE7dGhpcy5yZWFkQmxvY2soKX1yZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5wb3MrK119Z2V0Qnl0ZXMoZSl7Y29uc3QgdD10aGlzLnBvcztsZXQgYTtpZihlKXt0aGlzLmVuc3VyZUJ1ZmZlcih0K2UpO2E9dCtlO2Zvcig7IXRoaXMuZW9mJiZ0aGlzLmJ1ZmZlckxlbmd0aDxhOyl0aGlzLnJlYWRCbG9jaygpO2NvbnN0IHI9dGhpcy5idWZmZXJMZW5ndGg7YT5yJiYoYT1yKX1lbHNle2Zvcig7IXRoaXMuZW9mOyl0aGlzLnJlYWRCbG9jaygpO2E9dGhpcy5idWZmZXJMZW5ndGh9dGhpcy5wb3M9YTtyZXR1cm4gdGhpcy5idWZmZXIuc3ViYXJyYXkodCxhKX1yZXNldCgpe3RoaXMucG9zPTB9bWFrZVN1YlN0cmVhbShlLHQsYT1udWxsKXtpZih2b2lkIDA9PT10KWZvcig7IXRoaXMuZW9mOyl0aGlzLnJlYWRCbG9jaygpO2Vsc2V7Y29uc3QgYT1lK3Q7Zm9yKDt0aGlzLmJ1ZmZlckxlbmd0aDw9YSYmIXRoaXMuZW9mOyl0aGlzLnJlYWRCbG9jaygpfXJldHVybiBuZXcgbi5TdHJlYW0odGhpcy5idWZmZXIsZSx0LGEpfWdldEJhc2VTdHJlYW1zKCl7cmV0dXJuIHRoaXMuc3RyP3RoaXMuc3RyLmdldEJhc2VTdHJlYW1zKCk6bnVsbH19dC5EZWNvZGVTdHJlYW09RGVjb2RlU3RyZWFtO3QuU3RyZWFtc1NlcXVlbmNlU3RyZWFtPWNsYXNzIFN0cmVhbXNTZXF1ZW5jZVN0cmVhbSBleHRlbmRzIERlY29kZVN0cmVhbXtjb25zdHJ1Y3RvcihlLHQ9bnVsbCl7bGV0IGE9MDtmb3IoY29uc3QgdCBvZiBlKWErPXQgaW5zdGFuY2VvZiBEZWNvZGVTdHJlYW0/dC5fcmF3TWluQnVmZmVyTGVuZ3RoOnQubGVuZ3RoO3N1cGVyKGEpO3RoaXMuc3RyZWFtcz1lO3RoaXMuX29uRXJyb3I9dH1yZWFkQmxvY2soKXtjb25zdCBlPXRoaXMuc3RyZWFtcztpZigwPT09ZS5sZW5ndGgpe3RoaXMuZW9mPSEwO3JldHVybn1jb25zdCB0PWUuc2hpZnQoKTtsZXQgYTt0cnl7YT10LmdldEJ5dGVzKCl9Y2F0Y2goZSl7aWYodGhpcy5fb25FcnJvcil7dGhpcy5fb25FcnJvcihlLHQuZGljdCYmdC5kaWN0Lm9iaklkKTtyZXR1cm59dGhyb3cgZX1jb25zdCByPXRoaXMuYnVmZmVyTGVuZ3RoLG49cithLmxlbmd0aDt0aGlzLmVuc3VyZUJ1ZmZlcihuKS5zZXQoYSxyKTt0aGlzLmJ1ZmZlckxlbmd0aD1ufWdldEJhc2VTdHJlYW1zKCl7Y29uc3QgZT1bXTtmb3IoY29uc3QgdCBvZiB0aGlzLnN0cmVhbXMpe2NvbnN0IGE9dC5nZXRCYXNlU3RyZWFtcygpO2EmJmUucHVzaCguLi5hKX1yZXR1cm4gZS5sZW5ndGg+MD9lOm51bGx9fX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LkFzY2lpSGV4U3RyZWFtPXZvaWQgMDt2YXIgcj1hKDE5KTtjbGFzcyBBc2NpaUhleFN0cmVhbSBleHRlbmRzIHIuRGVjb2RlU3RyZWFte2NvbnN0cnVjdG9yKGUsdCl7dCYmKHQqPS41KTtzdXBlcih0KTt0aGlzLnN0cj1lO3RoaXMuZGljdD1lLmRpY3Q7dGhpcy5maXJzdERpZ2l0PS0xfXJlYWRCbG9jaygpe2NvbnN0IGU9dGhpcy5zdHIuZ2V0Qnl0ZXMoOGUzKTtpZighZS5sZW5ndGgpe3RoaXMuZW9mPSEwO3JldHVybn1jb25zdCB0PWUubGVuZ3RoKzE+PjEsYT10aGlzLmVuc3VyZUJ1ZmZlcih0aGlzLmJ1ZmZlckxlbmd0aCt0KTtsZXQgcj10aGlzLmJ1ZmZlckxlbmd0aCxuPXRoaXMuZmlyc3REaWdpdDtmb3IoY29uc3QgdCBvZiBlKXtsZXQgZTtpZih0Pj00OCYmdDw9NTcpZT0xNSZ0O2Vsc2V7aWYoISh0Pj02NSYmdDw9NzB8fHQ+PTk3JiZ0PD0xMDIpKXtpZig2Mj09PXQpe3RoaXMuZW9mPSEwO2JyZWFrfWNvbnRpbnVlfWU9OSsoMTUmdCl9aWYobjwwKW49ZTtlbHNle2FbcisrXT1uPDw0fGU7bj0tMX19aWYobj49MCYmdGhpcy5lb2Ype2FbcisrXT1uPDw0O249LTF9dGhpcy5maXJzdERpZ2l0PW47dGhpcy5idWZmZXJMZW5ndGg9cn19dC5Bc2NpaUhleFN0cmVhbT1Bc2NpaUhleFN0cmVhbX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LkNDSVRURmF4U3RyZWFtPXZvaWQgMDt2YXIgcj1hKDIyKSxuPWEoMTkpLGk9YSg1KTtjbGFzcyBDQ0lUVEZheFN0cmVhbSBleHRlbmRzIG4uRGVjb2RlU3RyZWFte2NvbnN0cnVjdG9yKGUsdCxhKXtzdXBlcih0KTt0aGlzLnN0cj1lO3RoaXMuZGljdD1lLmRpY3Q7YSBpbnN0YW5jZW9mIGkuRGljdHx8KGE9aS5EaWN0LmVtcHR5KTtjb25zdCBuPXtuZXh0OigpPT5lLmdldEJ5dGUoKX07dGhpcy5jY2l0dEZheERlY29kZXI9bmV3IHIuQ0NJVFRGYXhEZWNvZGVyKG4se0s6YS5nZXQoIksiKSxFbmRPZkxpbmU6YS5nZXQoIkVuZE9mTGluZSIpLEVuY29kZWRCeXRlQWxpZ246YS5nZXQoIkVuY29kZWRCeXRlQWxpZ24iKSxDb2x1bW5zOmEuZ2V0KCJDb2x1bW5zIiksUm93czphLmdldCgiUm93cyIpLEVuZE9mQmxvY2s6YS5nZXQoIkVuZE9mQmxvY2siKSxCbGFja0lzMTphLmdldCgiQmxhY2tJczEiKX0pfXJlYWRCbG9jaygpe2Zvcig7IXRoaXMuZW9mOyl7Y29uc3QgZT10aGlzLmNjaXR0RmF4RGVjb2Rlci5yZWFkTmV4dENoYXIoKTtpZigtMT09PWUpe3RoaXMuZW9mPSEwO3JldHVybn10aGlzLmVuc3VyZUJ1ZmZlcih0aGlzLmJ1ZmZlckxlbmd0aCsxKTt0aGlzLmJ1ZmZlclt0aGlzLmJ1ZmZlckxlbmd0aCsrXT1lfX19dC5DQ0lUVEZheFN0cmVhbT1DQ0lUVEZheFN0cmVhbX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LkNDSVRURmF4RGVjb2Rlcj12b2lkIDA7dmFyIHI9YSgyKTtjb25zdCBuPS0xLGk9W1stMSwtMV0sWy0xLC0xXSxbNyw4XSxbNyw3XSxbNiw2XSxbNiw2XSxbNiw1XSxbNiw1XSxbNCwwXSxbNCwwXSxbNCwwXSxbNCwwXSxbNCwwXSxbNCwwXSxbNCwwXSxbNCwwXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXV0scz1bWy0xLC0xXSxbMTIsLTJdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbMTEsMTc5Ml0sWzExLDE3OTJdLFsxMiwxOTg0XSxbMTIsMjA0OF0sWzEyLDIxMTJdLFsxMiwyMTc2XSxbMTIsMjI0MF0sWzEyLDIzMDRdLFsxMSwxODU2XSxbMTEsMTg1Nl0sWzExLDE5MjBdLFsxMSwxOTIwXSxbMTIsMjM2OF0sWzEyLDI0MzJdLFsxMiwyNDk2XSxbMTIsMjU2MF1dLG89W1stMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWzgsMjldLFs4LDI5XSxbOCwzMF0sWzgsMzBdLFs4LDQ1XSxbOCw0NV0sWzgsNDZdLFs4LDQ2XSxbNywyMl0sWzcsMjJdLFs3LDIyXSxbNywyMl0sWzcsMjNdLFs3LDIzXSxbNywyM10sWzcsMjNdLFs4LDQ3XSxbOCw0N10sWzgsNDhdLFs4LDQ4XSxbNiwxM10sWzYsMTNdLFs2LDEzXSxbNiwxM10sWzYsMTNdLFs2LDEzXSxbNiwxM10sWzYsMTNdLFs3LDIwXSxbNywyMF0sWzcsMjBdLFs3LDIwXSxbOCwzM10sWzgsMzNdLFs4LDM0XSxbOCwzNF0sWzgsMzVdLFs4LDM1XSxbOCwzNl0sWzgsMzZdLFs4LDM3XSxbOCwzN10sWzgsMzhdLFs4LDM4XSxbNywxOV0sWzcsMTldLFs3LDE5XSxbNywxOV0sWzgsMzFdLFs4LDMxXSxbOCwzMl0sWzgsMzJdLFs2LDFdLFs2LDFdLFs2LDFdLFs2LDFdLFs2LDFdLFs2LDFdLFs2LDFdLFs2LDFdLFs2LDEyXSxbNiwxMl0sWzYsMTJdLFs2LDEyXSxbNiwxMl0sWzYsMTJdLFs2LDEyXSxbNiwxMl0sWzgsNTNdLFs4LDUzXSxbOCw1NF0sWzgsNTRdLFs3LDI2XSxbNywyNl0sWzcsMjZdLFs3LDI2XSxbOCwzOV0sWzgsMzldLFs4LDQwXSxbOCw0MF0sWzgsNDFdLFs4LDQxXSxbOCw0Ml0sWzgsNDJdLFs4LDQzXSxbOCw0M10sWzgsNDRdLFs4LDQ0XSxbNywyMV0sWzcsMjFdLFs3LDIxXSxbNywyMV0sWzcsMjhdLFs3LDI4XSxbNywyOF0sWzcsMjhdLFs4LDYxXSxbOCw2MV0sWzgsNjJdLFs4LDYyXSxbOCw2M10sWzgsNjNdLFs4LDBdLFs4LDBdLFs4LDMyMF0sWzgsMzIwXSxbOCwzODRdLFs4LDM4NF0sWzUsMTBdLFs1LDEwXSxbNSwxMF0sWzUsMTBdLFs1LDEwXSxbNSwxMF0sWzUsMTBdLFs1LDEwXSxbNSwxMF0sWzUsMTBdLFs1LDEwXSxbNSwxMF0sWzUsMTBdLFs1LDEwXSxbNSwxMF0sWzUsMTBdLFs1LDExXSxbNSwxMV0sWzUsMTFdLFs1LDExXSxbNSwxMV0sWzUsMTFdLFs1LDExXSxbNSwxMV0sWzUsMTFdLFs1LDExXSxbNSwxMV0sWzUsMTFdLFs1LDExXSxbNSwxMV0sWzUsMTFdLFs1LDExXSxbNywyN10sWzcsMjddLFs3LDI3XSxbNywyN10sWzgsNTldLFs4LDU5XSxbOCw2MF0sWzgsNjBdLFs5LDE0NzJdLFs5LDE1MzZdLFs5LDE2MDBdLFs5LDE3MjhdLFs3LDE4XSxbNywxOF0sWzcsMThdLFs3LDE4XSxbNywyNF0sWzcsMjRdLFs3LDI0XSxbNywyNF0sWzgsNDldLFs4LDQ5XSxbOCw1MF0sWzgsNTBdLFs4LDUxXSxbOCw1MV0sWzgsNTJdLFs4LDUyXSxbNywyNV0sWzcsMjVdLFs3LDI1XSxbNywyNV0sWzgsNTVdLFs4LDU1XSxbOCw1Nl0sWzgsNTZdLFs4LDU3XSxbOCw1N10sWzgsNThdLFs4LDU4XSxbNiwxOTJdLFs2LDE5Ml0sWzYsMTkyXSxbNiwxOTJdLFs2LDE5Ml0sWzYsMTkyXSxbNiwxOTJdLFs2LDE5Ml0sWzYsMTY2NF0sWzYsMTY2NF0sWzYsMTY2NF0sWzYsMTY2NF0sWzYsMTY2NF0sWzYsMTY2NF0sWzYsMTY2NF0sWzYsMTY2NF0sWzgsNDQ4XSxbOCw0NDhdLFs4LDUxMl0sWzgsNTEyXSxbOSw3MDRdLFs5LDc2OF0sWzgsNjQwXSxbOCw2NDBdLFs4LDU3Nl0sWzgsNTc2XSxbOSw4MzJdLFs5LDg5Nl0sWzksOTYwXSxbOSwxMDI0XSxbOSwxMDg4XSxbOSwxMTUyXSxbOSwxMjE2XSxbOSwxMjgwXSxbOSwxMzQ0XSxbOSwxNDA4XSxbNywyNTZdLFs3LDI1Nl0sWzcsMjU2XSxbNywyNTZdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs1LDEyOF0sWzUsMTI4XSxbNSwxMjhdLFs1LDEyOF0sWzUsMTI4XSxbNSwxMjhdLFs1LDEyOF0sWzUsMTI4XSxbNSwxMjhdLFs1LDEyOF0sWzUsMTI4XSxbNSwxMjhdLFs1LDEyOF0sWzUsMTI4XSxbNSwxMjhdLFs1LDEyOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzYsMTZdLFs2LDE2XSxbNiwxNl0sWzYsMTZdLFs2LDE2XSxbNiwxNl0sWzYsMTZdLFs2LDE2XSxbNiwxN10sWzYsMTddLFs2LDE3XSxbNiwxN10sWzYsMTddLFs2LDE3XSxbNiwxN10sWzYsMTddLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs2LDE0XSxbNiwxNF0sWzYsMTRdLFs2LDE0XSxbNiwxNF0sWzYsMTRdLFs2LDE0XSxbNiwxNF0sWzYsMTVdLFs2LDE1XSxbNiwxNV0sWzYsMTVdLFs2LDE1XSxbNiwxNV0sWzYsMTVdLFs2LDE1XSxbNSw2NF0sWzUsNjRdLFs1LDY0XSxbNSw2NF0sWzUsNjRdLFs1LDY0XSxbNSw2NF0sWzUsNjRdLFs1LDY0XSxbNSw2NF0sWzUsNjRdLFs1LDY0XSxbNSw2NF0sWzUsNjRdLFs1LDY0XSxbNSw2NF0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN11dLGM9W1stMSwtMV0sWy0xLC0xXSxbMTIsLTJdLFsxMiwtMl0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbMTEsMTc5Ml0sWzExLDE3OTJdLFsxMSwxNzkyXSxbMTEsMTc5Ml0sWzEyLDE5ODRdLFsxMiwxOTg0XSxbMTIsMjA0OF0sWzEyLDIwNDhdLFsxMiwyMTEyXSxbMTIsMjExMl0sWzEyLDIxNzZdLFsxMiwyMTc2XSxbMTIsMjI0MF0sWzEyLDIyNDBdLFsxMiwyMzA0XSxbMTIsMjMwNF0sWzExLDE4NTZdLFsxMSwxODU2XSxbMTEsMTg1Nl0sWzExLDE4NTZdLFsxMSwxOTIwXSxbMTEsMTkyMF0sWzExLDE5MjBdLFsxMSwxOTIwXSxbMTIsMjM2OF0sWzEyLDIzNjhdLFsxMiwyNDMyXSxbMTIsMjQzMl0sWzEyLDI0OTZdLFsxMiwyNDk2XSxbMTIsMjU2MF0sWzEyLDI1NjBdLFsxMCwxOF0sWzEwLDE4XSxbMTAsMThdLFsxMCwxOF0sWzEwLDE4XSxbMTAsMThdLFsxMCwxOF0sWzEwLDE4XSxbMTIsNTJdLFsxMiw1Ml0sWzEzLDY0MF0sWzEzLDcwNF0sWzEzLDc2OF0sWzEzLDgzMl0sWzEyLDU1XSxbMTIsNTVdLFsxMiw1Nl0sWzEyLDU2XSxbMTMsMTI4MF0sWzEzLDEzNDRdLFsxMywxNDA4XSxbMTMsMTQ3Ml0sWzEyLDU5XSxbMTIsNTldLFsxMiw2MF0sWzEyLDYwXSxbMTMsMTUzNl0sWzEzLDE2MDBdLFsxMSwyNF0sWzExLDI0XSxbMTEsMjRdLFsxMSwyNF0sWzExLDI1XSxbMTEsMjVdLFsxMSwyNV0sWzExLDI1XSxbMTMsMTY2NF0sWzEzLDE3MjhdLFsxMiwzMjBdLFsxMiwzMjBdLFsxMiwzODRdLFsxMiwzODRdLFsxMiw0NDhdLFsxMiw0NDhdLFsxMyw1MTJdLFsxMyw1NzZdLFsxMiw1M10sWzEyLDUzXSxbMTIsNTRdLFsxMiw1NF0sWzEzLDg5Nl0sWzEzLDk2MF0sWzEzLDEwMjRdLFsxMywxMDg4XSxbMTMsMTE1Ml0sWzEzLDEyMTZdLFsxMCw2NF0sWzEwLDY0XSxbMTAsNjRdLFsxMCw2NF0sWzEwLDY0XSxbMTAsNjRdLFsxMCw2NF0sWzEwLDY0XV0sbD1bWzgsMTNdLFs4LDEzXSxbOCwxM10sWzgsMTNdLFs4LDEzXSxbOCwxM10sWzgsMTNdLFs4LDEzXSxbOCwxM10sWzgsMTNdLFs4LDEzXSxbOCwxM10sWzgsMTNdLFs4LDEzXSxbOCwxM10sWzgsMTNdLFsxMSwyM10sWzExLDIzXSxbMTIsNTBdLFsxMiw1MV0sWzEyLDQ0XSxbMTIsNDVdLFsxMiw0Nl0sWzEyLDQ3XSxbMTIsNTddLFsxMiw1OF0sWzEyLDYxXSxbMTIsMjU2XSxbMTAsMTZdLFsxMCwxNl0sWzEwLDE2XSxbMTAsMTZdLFsxMCwxN10sWzEwLDE3XSxbMTAsMTddLFsxMCwxN10sWzEyLDQ4XSxbMTIsNDldLFsxMiw2Ml0sWzEyLDYzXSxbMTIsMzBdLFsxMiwzMV0sWzEyLDMyXSxbMTIsMzNdLFsxMiw0MF0sWzEyLDQxXSxbMTEsMjJdLFsxMSwyMl0sWzgsMTRdLFs4LDE0XSxbOCwxNF0sWzgsMTRdLFs4LDE0XSxbOCwxNF0sWzgsMTRdLFs4LDE0XSxbOCwxNF0sWzgsMTRdLFs4LDE0XSxbOCwxNF0sWzgsMTRdLFs4LDE0XSxbOCwxNF0sWzgsMTRdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbOSwxNV0sWzksMTVdLFs5LDE1XSxbOSwxNV0sWzksMTVdLFs5LDE1XSxbOSwxNV0sWzksMTVdLFsxMiwxMjhdLFsxMiwxOTJdLFsxMiwyNl0sWzEyLDI3XSxbMTIsMjhdLFsxMiwyOV0sWzExLDE5XSxbMTEsMTldLFsxMSwyMF0sWzExLDIwXSxbMTIsMzRdLFsxMiwzNV0sWzEyLDM2XSxbMTIsMzddLFsxMiwzOF0sWzEyLDM5XSxbMTEsMjFdLFsxMSwyMV0sWzEyLDQyXSxbMTIsNDNdLFsxMCwwXSxbMTAsMF0sWzEwLDBdLFsxMCwwXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdXSxoPVtbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFs2LDldLFs2LDhdLFs1LDddLFs1LDddLFs0LDZdLFs0LDZdLFs0LDZdLFs0LDZdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFszLDFdLFszLDFdLFszLDFdLFszLDFdLFszLDFdLFszLDFdLFszLDFdLFszLDFdLFszLDRdLFszLDRdLFszLDRdLFszLDRdLFszLDRdLFszLDRdLFszLDRdLFszLDRdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdXTt0LkNDSVRURmF4RGVjb2Rlcj1jbGFzcyBDQ0lUVEZheERlY29kZXJ7Y29uc3RydWN0b3IoZSx0PXt9KXtpZighZXx8ImZ1bmN0aW9uIiE9dHlwZW9mIGUubmV4dCl0aHJvdyBuZXcgRXJyb3IoJ0NDSVRURmF4RGVjb2RlciAtIGludmFsaWQgInNvdXJjZSIgcGFyYW1ldGVyLicpO3RoaXMuc291cmNlPWU7dGhpcy5lb2Y9ITE7dGhpcy5lbmNvZGluZz10Lkt8fDA7dGhpcy5lb2xpbmU9dC5FbmRPZkxpbmV8fCExO3RoaXMuYnl0ZUFsaWduPXQuRW5jb2RlZEJ5dGVBbGlnbnx8ITE7dGhpcy5jb2x1bW5zPXQuQ29sdW1uc3x8MTcyODt0aGlzLnJvd3M9dC5Sb3dzfHwwO2xldCBhLHI9dC5FbmRPZkJsb2NrO251bGw9PXImJihyPSEwKTt0aGlzLmVvYmxvY2s9cjt0aGlzLmJsYWNrPXQuQmxhY2tJczF8fCExO3RoaXMuY29kaW5nTGluZT1uZXcgVWludDMyQXJyYXkodGhpcy5jb2x1bW5zKzEpO3RoaXMucmVmTGluZT1uZXcgVWludDMyQXJyYXkodGhpcy5jb2x1bW5zKzIpO3RoaXMuY29kaW5nTGluZVswXT10aGlzLmNvbHVtbnM7dGhpcy5jb2RpbmdQb3M9MDt0aGlzLnJvdz0wO3RoaXMubmV4dExpbmUyRD10aGlzLmVuY29kaW5nPDA7dGhpcy5pbnB1dEJpdHM9MDt0aGlzLmlucHV0QnVmPTA7dGhpcy5vdXRwdXRCaXRzPTA7dGhpcy5yb3dzRG9uZT0hMTtmb3IoOzA9PT0oYT10aGlzLl9sb29rQml0cygxMikpOyl0aGlzLl9lYXRCaXRzKDEpOzE9PT1hJiZ0aGlzLl9lYXRCaXRzKDEyKTtpZih0aGlzLmVuY29kaW5nPjApe3RoaXMubmV4dExpbmUyRD0hdGhpcy5fbG9va0JpdHMoMSk7dGhpcy5fZWF0Qml0cygxKX19cmVhZE5leHRDaGFyKCl7aWYodGhpcy5lb2YpcmV0dXJuLTE7Y29uc3QgZT10aGlzLnJlZkxpbmUsdD10aGlzLmNvZGluZ0xpbmUsYT10aGlzLmNvbHVtbnM7bGV0IGkscyxvLGMsbDtpZigwPT09dGhpcy5vdXRwdXRCaXRzKXt0aGlzLnJvd3NEb25lJiYodGhpcy5lb2Y9ITApO2lmKHRoaXMuZW9mKXJldHVybi0xO3RoaXMuZXJyPSExO2xldCBvLGwsaDtpZih0aGlzLm5leHRMaW5lMkQpe2ZvcihjPTA7dFtjXTxhOysrYyllW2NdPXRbY107ZVtjKytdPWE7ZVtjXT1hO3RbMF09MDt0aGlzLmNvZGluZ1Bvcz0wO2k9MDtzPTA7Zm9yKDt0W3RoaXMuY29kaW5nUG9zXTxhOyl7bz10aGlzLl9nZXRUd29EaW1Db2RlKCk7c3dpdGNoKG8pe2Nhc2UgMDp0aGlzLl9hZGRQaXhlbHMoZVtpKzFdLHMpO2VbaSsxXTxhJiYoaSs9Mik7YnJlYWs7Y2FzZSAxOm89bD0wO2lmKHMpe2Rve28rPWg9dGhpcy5fZ2V0QmxhY2tDb2RlKCl9d2hpbGUoaD49NjQpO2Rve2wrPWg9dGhpcy5fZ2V0V2hpdGVDb2RlKCl9d2hpbGUoaD49NjQpfWVsc2V7ZG97bys9aD10aGlzLl9nZXRXaGl0ZUNvZGUoKX13aGlsZShoPj02NCk7ZG97bCs9aD10aGlzLl9nZXRCbGFja0NvZGUoKX13aGlsZShoPj02NCl9dGhpcy5fYWRkUGl4ZWxzKHRbdGhpcy5jb2RpbmdQb3NdK28scyk7dFt0aGlzLmNvZGluZ1Bvc108YSYmdGhpcy5fYWRkUGl4ZWxzKHRbdGhpcy5jb2RpbmdQb3NdK2wsMV5zKTtmb3IoO2VbaV08PXRbdGhpcy5jb2RpbmdQb3NdJiZlW2ldPGE7KWkrPTI7YnJlYWs7Y2FzZSA3OnRoaXMuX2FkZFBpeGVscyhlW2ldKzMscyk7c149MTtpZih0W3RoaXMuY29kaW5nUG9zXTxhKXsrK2k7Zm9yKDtlW2ldPD10W3RoaXMuY29kaW5nUG9zXSYmZVtpXTxhOylpKz0yfWJyZWFrO2Nhc2UgNTp0aGlzLl9hZGRQaXhlbHMoZVtpXSsyLHMpO3NePTE7aWYodFt0aGlzLmNvZGluZ1Bvc108YSl7KytpO2Zvcig7ZVtpXTw9dFt0aGlzLmNvZGluZ1Bvc10mJmVbaV08YTspaSs9Mn1icmVhaztjYXNlIDM6dGhpcy5fYWRkUGl4ZWxzKGVbaV0rMSxzKTtzXj0xO2lmKHRbdGhpcy5jb2RpbmdQb3NdPGEpeysraTtmb3IoO2VbaV08PXRbdGhpcy5jb2RpbmdQb3NdJiZlW2ldPGE7KWkrPTJ9YnJlYWs7Y2FzZSAyOnRoaXMuX2FkZFBpeGVscyhlW2ldLHMpO3NePTE7aWYodFt0aGlzLmNvZGluZ1Bvc108YSl7KytpO2Zvcig7ZVtpXTw9dFt0aGlzLmNvZGluZ1Bvc10mJmVbaV08YTspaSs9Mn1icmVhaztjYXNlIDg6dGhpcy5fYWRkUGl4ZWxzTmVnKGVbaV0tMyxzKTtzXj0xO2lmKHRbdGhpcy5jb2RpbmdQb3NdPGEpe2k+MD8tLWk6KytpO2Zvcig7ZVtpXTw9dFt0aGlzLmNvZGluZ1Bvc10mJmVbaV08YTspaSs9Mn1icmVhaztjYXNlIDY6dGhpcy5fYWRkUGl4ZWxzTmVnKGVbaV0tMixzKTtzXj0xO2lmKHRbdGhpcy5jb2RpbmdQb3NdPGEpe2k+MD8tLWk6KytpO2Zvcig7ZVtpXTw9dFt0aGlzLmNvZGluZ1Bvc10mJmVbaV08YTspaSs9Mn1icmVhaztjYXNlIDQ6dGhpcy5fYWRkUGl4ZWxzTmVnKGVbaV0tMSxzKTtzXj0xO2lmKHRbdGhpcy5jb2RpbmdQb3NdPGEpe2k+MD8tLWk6KytpO2Zvcig7ZVtpXTw9dFt0aGlzLmNvZGluZ1Bvc10mJmVbaV08YTspaSs9Mn1icmVhaztjYXNlIG46dGhpcy5fYWRkUGl4ZWxzKGEsMCk7dGhpcy5lb2Y9ITA7YnJlYWs7ZGVmYXVsdDooMCxyLmluZm8pKCJiYWQgMmQgY29kZSIpO3RoaXMuX2FkZFBpeGVscyhhLDApO3RoaXMuZXJyPSEwfX19ZWxzZXt0WzBdPTA7dGhpcy5jb2RpbmdQb3M9MDtzPTA7Zm9yKDt0W3RoaXMuY29kaW5nUG9zXTxhOyl7bz0wO2lmKHMpZG97bys9aD10aGlzLl9nZXRCbGFja0NvZGUoKX13aGlsZShoPj02NCk7ZWxzZSBkb3tvKz1oPXRoaXMuX2dldFdoaXRlQ29kZSgpfXdoaWxlKGg+PTY0KTt0aGlzLl9hZGRQaXhlbHModFt0aGlzLmNvZGluZ1Bvc10rbyxzKTtzXj0xfX1sZXQgdT0hMTt0aGlzLmJ5dGVBbGlnbiYmKHRoaXMuaW5wdXRCaXRzJj0tOCk7aWYodGhpcy5lb2Jsb2NrfHx0aGlzLnJvdyE9PXRoaXMucm93cy0xKXtvPXRoaXMuX2xvb2tCaXRzKDEyKTtpZih0aGlzLmVvbGluZSlmb3IoO28hPT1uJiYxIT09bzspe3RoaXMuX2VhdEJpdHMoMSk7bz10aGlzLl9sb29rQml0cygxMil9ZWxzZSBmb3IoOzA9PT1vOyl7dGhpcy5fZWF0Qml0cygxKTtvPXRoaXMuX2xvb2tCaXRzKDEyKX1pZigxPT09byl7dGhpcy5fZWF0Qml0cygxMik7dT0hMH1lbHNlIG89PT1uJiYodGhpcy5lb2Y9ITApfWVsc2UgdGhpcy5yb3dzRG9uZT0hMDtpZighdGhpcy5lb2YmJnRoaXMuZW5jb2Rpbmc+MCYmIXRoaXMucm93c0RvbmUpe3RoaXMubmV4dExpbmUyRD0hdGhpcy5fbG9va0JpdHMoMSk7dGhpcy5fZWF0Qml0cygxKX1pZih0aGlzLmVvYmxvY2smJnUmJnRoaXMuYnl0ZUFsaWduKXtvPXRoaXMuX2xvb2tCaXRzKDEyKTtpZigxPT09byl7dGhpcy5fZWF0Qml0cygxMik7aWYodGhpcy5lbmNvZGluZz4wKXt0aGlzLl9sb29rQml0cygxKTt0aGlzLl9lYXRCaXRzKDEpfWlmKHRoaXMuZW5jb2Rpbmc+PTApZm9yKGM9MDtjPDQ7KytjKXtvPXRoaXMuX2xvb2tCaXRzKDEyKTsxIT09byYmKDAsci5pbmZvKSgiYmFkIHJ0YyBjb2RlOiAiK28pO3RoaXMuX2VhdEJpdHMoMTIpO2lmKHRoaXMuZW5jb2Rpbmc+MCl7dGhpcy5fbG9va0JpdHMoMSk7dGhpcy5fZWF0Qml0cygxKX19dGhpcy5lb2Y9ITB9fWVsc2UgaWYodGhpcy5lcnImJnRoaXMuZW9saW5lKXtmb3IoOzspe289dGhpcy5fbG9va0JpdHMoMTMpO2lmKG89PT1uKXt0aGlzLmVvZj0hMDtyZXR1cm4tMX1pZihvPj4xPT0xKWJyZWFrO3RoaXMuX2VhdEJpdHMoMSl9dGhpcy5fZWF0Qml0cygxMik7aWYodGhpcy5lbmNvZGluZz4wKXt0aGlzLl9lYXRCaXRzKDEpO3RoaXMubmV4dExpbmUyRD0hKDEmbyl9fXRbMF0+MD90aGlzLm91dHB1dEJpdHM9dFt0aGlzLmNvZGluZ1Bvcz0wXTp0aGlzLm91dHB1dEJpdHM9dFt0aGlzLmNvZGluZ1Bvcz0xXTt0aGlzLnJvdysrfWlmKHRoaXMub3V0cHV0Qml0cz49OCl7bD0xJnRoaXMuY29kaW5nUG9zPzA6MjU1O3RoaXMub3V0cHV0Qml0cy09ODtpZigwPT09dGhpcy5vdXRwdXRCaXRzJiZ0W3RoaXMuY29kaW5nUG9zXTxhKXt0aGlzLmNvZGluZ1BvcysrO3RoaXMub3V0cHV0Qml0cz10W3RoaXMuY29kaW5nUG9zXS10W3RoaXMuY29kaW5nUG9zLTFdfX1lbHNle289ODtsPTA7ZG97aWYoIm51bWJlciIhPXR5cGVvZiB0aGlzLm91dHB1dEJpdHMpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoJ0ludmFsaWQgL0NDSVRURmF4RGVjb2RlIGRhdGEsICJvdXRwdXRCaXRzIiBtdXN0IGJlIGEgbnVtYmVyLicpO2lmKHRoaXMub3V0cHV0Qml0cz5vKXtsPDw9bzsxJnRoaXMuY29kaW5nUG9zfHwobHw9MjU1Pj44LW8pO3RoaXMub3V0cHV0Qml0cy09bztvPTB9ZWxzZXtsPDw9dGhpcy5vdXRwdXRCaXRzOzEmdGhpcy5jb2RpbmdQb3N8fChsfD0yNTU+PjgtdGhpcy5vdXRwdXRCaXRzKTtvLT10aGlzLm91dHB1dEJpdHM7dGhpcy5vdXRwdXRCaXRzPTA7aWYodFt0aGlzLmNvZGluZ1Bvc108YSl7dGhpcy5jb2RpbmdQb3MrKzt0aGlzLm91dHB1dEJpdHM9dFt0aGlzLmNvZGluZ1Bvc10tdFt0aGlzLmNvZGluZ1Bvcy0xXX1lbHNlIGlmKG8+MCl7bDw8PW87bz0wfX19d2hpbGUobyl9dGhpcy5ibGFjayYmKGxePTI1NSk7cmV0dXJuIGx9X2FkZFBpeGVscyhlLHQpe2NvbnN0IGE9dGhpcy5jb2RpbmdMaW5lO2xldCBuPXRoaXMuY29kaW5nUG9zO2lmKGU+YVtuXSl7aWYoZT50aGlzLmNvbHVtbnMpeygwLHIuaW5mbykoInJvdyBpcyB3cm9uZyBsZW5ndGgiKTt0aGlzLmVycj0hMDtlPXRoaXMuY29sdW1uc30xJm5edCYmKytuO2Fbbl09ZX10aGlzLmNvZGluZ1Bvcz1ufV9hZGRQaXhlbHNOZWcoZSx0KXtjb25zdCBhPXRoaXMuY29kaW5nTGluZTtsZXQgbj10aGlzLmNvZGluZ1BvcztpZihlPmFbbl0pe2lmKGU+dGhpcy5jb2x1bW5zKXsoMCxyLmluZm8pKCJyb3cgaXMgd3JvbmcgbGVuZ3RoIik7dGhpcy5lcnI9ITA7ZT10aGlzLmNvbHVtbnN9MSZuXnQmJisrbjthW25dPWV9ZWxzZSBpZihlPGFbbl0pe2lmKGU8MCl7KDAsci5pbmZvKSgiaW52YWxpZCBjb2RlIik7dGhpcy5lcnI9ITA7ZT0wfWZvcig7bj4wJiZlPGFbbi0xXTspLS1uO2Fbbl09ZX10aGlzLmNvZGluZ1Bvcz1ufV9maW5kVGFibGVDb2RlKGUsdCxhLHIpe2NvbnN0IGk9cnx8MDtmb3IobGV0IHI9ZTtyPD10Oysrcil7bGV0IGU9dGhpcy5fbG9va0JpdHMocik7aWYoZT09PW4pcmV0dXJuWyEwLDEsITFdO3I8dCYmKGU8PD10LXIpO2lmKCFpfHxlPj1pKXtjb25zdCB0PWFbZS1pXTtpZih0WzBdPT09cil7dGhpcy5fZWF0Qml0cyhyKTtyZXR1cm5bITAsdFsxXSwhMF19fX1yZXR1cm5bITEsMCwhMV19X2dldFR3b0RpbUNvZGUoKXtsZXQgZSx0PTA7aWYodGhpcy5lb2Jsb2NrKXt0PXRoaXMuX2xvb2tCaXRzKDcpO2U9aVt0XTtpZihlJiZlWzBdPjApe3RoaXMuX2VhdEJpdHMoZVswXSk7cmV0dXJuIGVbMV19fWVsc2V7Y29uc3QgZT10aGlzLl9maW5kVGFibGVDb2RlKDEsNyxpKTtpZihlWzBdJiZlWzJdKXJldHVybiBlWzFdfSgwLHIuaW5mbykoIkJhZCB0d28gZGltIGNvZGUiKTtyZXR1cm4gbn1fZ2V0V2hpdGVDb2RlKCl7bGV0IGUsdD0wO2lmKHRoaXMuZW9ibG9jayl7dD10aGlzLl9sb29rQml0cygxMik7aWYodD09PW4pcmV0dXJuIDE7ZT10Pj41PT0wP3NbdF06b1t0Pj4zXTtpZihlWzBdPjApe3RoaXMuX2VhdEJpdHMoZVswXSk7cmV0dXJuIGVbMV19fWVsc2V7bGV0IGU9dGhpcy5fZmluZFRhYmxlQ29kZSgxLDksbyk7aWYoZVswXSlyZXR1cm4gZVsxXTtlPXRoaXMuX2ZpbmRUYWJsZUNvZGUoMTEsMTIscyk7aWYoZVswXSlyZXR1cm4gZVsxXX0oMCxyLmluZm8pKCJiYWQgd2hpdGUgY29kZSIpO3RoaXMuX2VhdEJpdHMoMSk7cmV0dXJuIDF9X2dldEJsYWNrQ29kZSgpe2xldCBlLHQ7aWYodGhpcy5lb2Jsb2NrKXtlPXRoaXMuX2xvb2tCaXRzKDEzKTtpZihlPT09bilyZXR1cm4gMTt0PWU+Pjc9PTA/Y1tlXTplPj45PT0wJiZlPj43IT0wP2xbKGU+PjEpLTY0XTpoW2U+PjddO2lmKHRbMF0+MCl7dGhpcy5fZWF0Qml0cyh0WzBdKTtyZXR1cm4gdFsxXX19ZWxzZXtsZXQgZT10aGlzLl9maW5kVGFibGVDb2RlKDIsNixoKTtpZihlWzBdKXJldHVybiBlWzFdO2U9dGhpcy5fZmluZFRhYmxlQ29kZSg3LDEyLGwsNjQpO2lmKGVbMF0pcmV0dXJuIGVbMV07ZT10aGlzLl9maW5kVGFibGVDb2RlKDEwLDEzLGMpO2lmKGVbMF0pcmV0dXJuIGVbMV19KDAsci5pbmZvKSgiYmFkIGJsYWNrIGNvZGUiKTt0aGlzLl9lYXRCaXRzKDEpO3JldHVybiAxfV9sb29rQml0cyhlKXtsZXQgdDtmb3IoO3RoaXMuaW5wdXRCaXRzPGU7KXtpZigtMT09PSh0PXRoaXMuc291cmNlLm5leHQoKSkpcmV0dXJuIDA9PT10aGlzLmlucHV0Qml0cz9uOnRoaXMuaW5wdXRCdWY8PGUtdGhpcy5pbnB1dEJpdHMmNjU1MzU+PjE2LWU7dGhpcy5pbnB1dEJ1Zj10aGlzLmlucHV0QnVmPDw4fHQ7dGhpcy5pbnB1dEJpdHMrPTh9cmV0dXJuIHRoaXMuaW5wdXRCdWY+PnRoaXMuaW5wdXRCaXRzLWUmNjU1MzU+PjE2LWV9X2VhdEJpdHMoZSl7KHRoaXMuaW5wdXRCaXRzLT1lKTwwJiYodGhpcy5pbnB1dEJpdHM9MCl9fX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LkZsYXRlU3RyZWFtPXZvaWQgMDt2YXIgcj1hKDE5KSxuPWEoMik7Y29uc3QgaT1uZXcgSW50MzJBcnJheShbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0pLHM9bmV3IEludDMyQXJyYXkoWzMsNCw1LDYsNyw4LDksMTAsNjU1NDcsNjU1NDksNjU1NTEsNjU1NTMsMTMxMDkxLDEzMTA5NSwxMzEwOTksMTMxMTAzLDE5NjY0MywxOTY2NTEsMTk2NjU5LDE5NjY2NywyNjIyMTEsMjYyMjI3LDI2MjI0MywyNjIyNTksMzI3ODExLDMyNzg0MywzMjc4NzUsMzI3OTA3LDI1OCwyNTgsMjU4XSksbz1uZXcgSW50MzJBcnJheShbMSwyLDMsNCw2NTU0MSw2NTU0MywxMzEwODEsMTMxMDg1LDE5NjYyNSwxOTY2MzMsMjYyMTc3LDI2MjE5MywzMjc3NDUsMzI3Nzc3LDM5MzM0NSwzOTM0MDksNDU5MDA5LDQ1OTEzNyw1MjQ4MDEsNTI1MDU3LDU5MDg0OSw1OTEzNjEsNjU3NDA5LDY1ODQzMyw3MjQ5OTMsNzI3MDQxLDc5NDYyNSw3OTg3MjEsODY4MzUzLDg3NjU0NV0pLGM9W25ldyBJbnQzMkFycmF5KFs0NTkwMDgsNTI0MzY4LDUyNDMwNCw1MjQ1NjgsNDU5MDI0LDUyNDQwMCw1MjQzMzYsNTkwMDE2LDQ1OTAxNiw1MjQzODQsNTI0MzIwLDU4OTk4NCw1MjQyODgsNTI0NDE2LDUyNDM1Miw1OTAwNDgsNDU5MDEyLDUyNDM3Niw1MjQzMTIsNTg5OTY4LDQ1OTAyOCw1MjQ0MDgsNTI0MzQ0LDU5MDAzMiw0NTkwMjAsNTI0MzkyLDUyNDMyOCw1OWU0LDUyNDI5Niw1MjQ0MjQsNTI0MzYwLDU5MDA2NCw0NTkwMTAsNTI0MzcyLDUyNDMwOCw1MjQ1NzIsNDU5MDI2LDUyNDQwNCw1MjQzNDAsNTkwMDI0LDQ1OTAxOCw1MjQzODgsNTI0MzI0LDU4OTk5Miw1MjQyOTIsNTI0NDIwLDUyNDM1Niw1OTAwNTYsNDU5MDE0LDUyNDM4MCw1MjQzMTYsNTg5OTc2LDQ1OTAzMCw1MjQ0MTIsNTI0MzQ4LDU5MDA0MCw0NTkwMjIsNTI0Mzk2LDUyNDMzMiw1OTAwMDgsNTI0MzAwLDUyNDQyOCw1MjQzNjQsNTkwMDcyLDQ1OTAwOSw1MjQzNzAsNTI0MzA2LDUyNDU3MCw0NTkwMjUsNTI0NDAyLDUyNDMzOCw1OTAwMjAsNDU5MDE3LDUyNDM4Niw1MjQzMjIsNTg5OTg4LDUyNDI5MCw1MjQ0MTgsNTI0MzU0LDU5MDA1Miw0NTkwMTMsNTI0Mzc4LDUyNDMxNCw1ODk5NzIsNDU5MDI5LDUyNDQxMCw1MjQzNDYsNTkwMDM2LDQ1OTAyMSw1MjQzOTQsNTI0MzMwLDU5MDAwNCw1MjQyOTgsNTI0NDI2LDUyNDM2Miw1OTAwNjgsNDU5MDExLDUyNDM3NCw1MjQzMTAsNTI0NTc0LDQ1OTAyNyw1MjQ0MDYsNTI0MzQyLDU5MDAyOCw0NTkwMTksNTI0MzkwLDUyNDMyNiw1ODk5OTYsNTI0Mjk0LDUyNDQyMiw1MjQzNTgsNTkwMDYwLDQ1OTAxNSw1MjQzODIsNTI0MzE4LDU4OTk4MCw0NTkwMzEsNTI0NDE0LDUyNDM1MCw1OTAwNDQsNDU5MDIzLDUyNDM5OCw1MjQzMzQsNTkwMDEyLDUyNDMwMiw1MjQ0MzAsNTI0MzY2LDU5MDA3Niw0NTkwMDgsNTI0MzY5LDUyNDMwNSw1MjQ1NjksNDU5MDI0LDUyNDQwMSw1MjQzMzcsNTkwMDE4LDQ1OTAxNiw1MjQzODUsNTI0MzIxLDU4OTk4Niw1MjQyODksNTI0NDE3LDUyNDM1Myw1OTAwNTAsNDU5MDEyLDUyNDM3Nyw1MjQzMTMsNTg5OTcwLDQ1OTAyOCw1MjQ0MDksNTI0MzQ1LDU5MDAzNCw0NTkwMjAsNTI0MzkzLDUyNDMyOSw1OTAwMDIsNTI0Mjk3LDUyNDQyNSw1MjQzNjEsNTkwMDY2LDQ1OTAxMCw1MjQzNzMsNTI0MzA5LDUyNDU3Myw0NTkwMjYsNTI0NDA1LDUyNDM0MSw1OTAwMjYsNDU5MDE4LDUyNDM4OSw1MjQzMjUsNTg5OTk0LDUyNDI5Myw1MjQ0MjEsNTI0MzU3LDU5MDA1OCw0NTkwMTQsNTI0MzgxLDUyNDMxNyw1ODk5NzgsNDU5MDMwLDUyNDQxMyw1MjQzNDksNTkwMDQyLDQ1OTAyMiw1MjQzOTcsNTI0MzMzLDU5MDAxMCw1MjQzMDEsNTI0NDI5LDUyNDM2NSw1OTAwNzQsNDU5MDA5LDUyNDM3MSw1MjQzMDcsNTI0NTcxLDQ1OTAyNSw1MjQ0MDMsNTI0MzM5LDU5MDAyMiw0NTkwMTcsNTI0Mzg3LDUyNDMyMyw1ODk5OTAsNTI0MjkxLDUyNDQxOSw1MjQzNTUsNTkwMDU0LDQ1OTAxMyw1MjQzNzksNTI0MzE1LDU4OTk3NCw0NTkwMjksNTI0NDExLDUyNDM0Nyw1OTAwMzgsNDU5MDIxLDUyNDM5NSw1MjQzMzEsNTkwMDA2LDUyNDI5OSw1MjQ0MjcsNTI0MzYzLDU5MDA3MCw0NTkwMTEsNTI0Mzc1LDUyNDMxMSw1MjQ1NzUsNDU5MDI3LDUyNDQwNyw1MjQzNDMsNTkwMDMwLDQ1OTAxOSw1MjQzOTEsNTI0MzI3LDU4OTk5OCw1MjQyOTUsNTI0NDIzLDUyNDM1OSw1OTAwNjIsNDU5MDE1LDUyNDM4Myw1MjQzMTksNTg5OTgyLDQ1OTAzMSw1MjQ0MTUsNTI0MzUxLDU5MDA0Niw0NTkwMjMsNTI0Mzk5LDUyNDMzNSw1OTAwMTQsNTI0MzAzLDUyNDQzMSw1MjQzNjcsNTkwMDc4LDQ1OTAwOCw1MjQzNjgsNTI0MzA0LDUyNDU2OCw0NTkwMjQsNTI0NDAwLDUyNDMzNiw1OTAwMTcsNDU5MDE2LDUyNDM4NCw1MjQzMjAsNTg5OTg1LDUyNDI4OCw1MjQ0MTYsNTI0MzUyLDU5MDA0OSw0NTkwMTIsNTI0Mzc2LDUyNDMxMiw1ODk5NjksNDU5MDI4LDUyNDQwOCw1MjQzNDQsNTkwMDMzLDQ1OTAyMCw1MjQzOTIsNTI0MzI4LDU5MDAwMSw1MjQyOTYsNTI0NDI0LDUyNDM2MCw1OTAwNjUsNDU5MDEwLDUyNDM3Miw1MjQzMDgsNTI0NTcyLDQ1OTAyNiw1MjQ0MDQsNTI0MzQwLDU5MDAyNSw0NTkwMTgsNTI0Mzg4LDUyNDMyNCw1ODk5OTMsNTI0MjkyLDUyNDQyMCw1MjQzNTYsNTkwMDU3LDQ1OTAxNCw1MjQzODAsNTI0MzE2LDU4OTk3Nyw0NTkwMzAsNTI0NDEyLDUyNDM0OCw1OTAwNDEsNDU5MDIyLDUyNDM5Niw1MjQzMzIsNTkwMDA5LDUyNDMwMCw1MjQ0MjgsNTI0MzY0LDU5MDA3Myw0NTkwMDksNTI0MzcwLDUyNDMwNiw1MjQ1NzAsNDU5MDI1LDUyNDQwMiw1MjQzMzgsNTkwMDIxLDQ1OTAxNyw1MjQzODYsNTI0MzIyLDU4OTk4OSw1MjQyOTAsNTI0NDE4LDUyNDM1NCw1OTAwNTMsNDU5MDEzLDUyNDM3OCw1MjQzMTQsNTg5OTczLDQ1OTAyOSw1MjQ0MTAsNTI0MzQ2LDU5MDAzNyw0NTkwMjEsNTI0Mzk0LDUyNDMzMCw1OTAwMDUsNTI0Mjk4LDUyNDQyNiw1MjQzNjIsNTkwMDY5LDQ1OTAxMSw1MjQzNzQsNTI0MzEwLDUyNDU3NCw0NTkwMjcsNTI0NDA2LDUyNDM0Miw1OTAwMjksNDU5MDE5LDUyNDM5MCw1MjQzMjYsNTg5OTk3LDUyNDI5NCw1MjQ0MjIsNTI0MzU4LDU5MDA2MSw0NTkwMTUsNTI0MzgyLDUyNDMxOCw1ODk5ODEsNDU5MDMxLDUyNDQxNCw1MjQzNTAsNTkwMDQ1LDQ1OTAyMyw1MjQzOTgsNTI0MzM0LDU5MDAxMyw1MjQzMDIsNTI0NDMwLDUyNDM2Niw1OTAwNzcsNDU5MDA4LDUyNDM2OSw1MjQzMDUsNTI0NTY5LDQ1OTAyNCw1MjQ0MDEsNTI0MzM3LDU5MDAxOSw0NTkwMTYsNTI0Mzg1LDUyNDMyMSw1ODk5ODcsNTI0Mjg5LDUyNDQxNyw1MjQzNTMsNTkwMDUxLDQ1OTAxMiw1MjQzNzcsNTI0MzEzLDU4OTk3MSw0NTkwMjgsNTI0NDA5LDUyNDM0NSw1OTAwMzUsNDU5MDIwLDUyNDM5Myw1MjQzMjksNTkwMDAzLDUyNDI5Nyw1MjQ0MjUsNTI0MzYxLDU5MDA2Nyw0NTkwMTAsNTI0MzczLDUyNDMwOSw1MjQ1NzMsNDU5MDI2LDUyNDQwNSw1MjQzNDEsNTkwMDI3LDQ1OTAxOCw1MjQzODksNTI0MzI1LDU4OTk5NSw1MjQyOTMsNTI0NDIxLDUyNDM1Nyw1OTAwNTksNDU5MDE0LDUyNDM4MSw1MjQzMTcsNTg5OTc5LDQ1OTAzMCw1MjQ0MTMsNTI0MzQ5LDU5MDA0Myw0NTkwMjIsNTI0Mzk3LDUyNDMzMyw1OTAwMTEsNTI0MzAxLDUyNDQyOSw1MjQzNjUsNTkwMDc1LDQ1OTAwOSw1MjQzNzEsNTI0MzA3LDUyNDU3MSw0NTkwMjUsNTI0NDAzLDUyNDMzOSw1OTAwMjMsNDU5MDE3LDUyNDM4Nyw1MjQzMjMsNTg5OTkxLDUyNDI5MSw1MjQ0MTksNTI0MzU1LDU5MDA1NSw0NTkwMTMsNTI0Mzc5LDUyNDMxNSw1ODk5NzUsNDU5MDI5LDUyNDQxMSw1MjQzNDcsNTkwMDM5LDQ1OTAyMSw1MjQzOTUsNTI0MzMxLDU5MDAwNyw1MjQyOTksNTI0NDI3LDUyNDM2Myw1OTAwNzEsNDU5MDExLDUyNDM3NSw1MjQzMTEsNTI0NTc1LDQ1OTAyNyw1MjQ0MDcsNTI0MzQzLDU5MDAzMSw0NTkwMTksNTI0MzkxLDUyNDMyNyw1ODk5OTksNTI0Mjk1LDUyNDQyMyw1MjQzNTksNTkwMDYzLDQ1OTAxNSw1MjQzODMsNTI0MzE5LDU4OTk4Myw0NTkwMzEsNTI0NDE1LDUyNDM1MSw1OTAwNDcsNDU5MDIzLDUyNDM5OSw1MjQzMzUsNTkwMDE1LDUyNDMwMyw1MjQ0MzEsNTI0MzY3LDU5MDA3OV0pLDldLGw9W25ldyBJbnQzMkFycmF5KFszMjc2ODAsMzI3Njk2LDMyNzY4OCwzMjc3MDQsMzI3Njg0LDMyNzcwMCwzMjc2OTIsMzI3NzA4LDMyNzY4MiwzMjc2OTgsMzI3NjkwLDMyNzcwNiwzMjc2ODYsMzI3NzAyLDMyNzY5NCwwLDMyNzY4MSwzMjc2OTcsMzI3Njg5LDMyNzcwNSwzMjc2ODUsMzI3NzAxLDMyNzY5MywzMjc3MDksMzI3NjgzLDMyNzY5OSwzMjc2OTEsMzI3NzA3LDMyNzY4NywzMjc3MDMsMzI3Njk1LDBdKSw1XTtjbGFzcyBGbGF0ZVN0cmVhbSBleHRlbmRzIHIuRGVjb2RlU3RyZWFte2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIodCk7dGhpcy5zdHI9ZTt0aGlzLmRpY3Q9ZS5kaWN0O2NvbnN0IGE9ZS5nZXRCeXRlKCkscj1lLmdldEJ5dGUoKTtpZigtMT09PWF8fC0xPT09cil0aHJvdyBuZXcgbi5Gb3JtYXRFcnJvcihgSW52YWxpZCBoZWFkZXIgaW4gZmxhdGUgc3RyZWFtOiAke2F9LCAke3J9YCk7aWYoOCE9KDE1JmEpKXRocm93IG5ldyBuLkZvcm1hdEVycm9yKGBVbmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCBpbiBmbGF0ZSBzdHJlYW06ICR7YX0sICR7cn1gKTtpZigoKGE8PDgpK3IpJTMxIT0wKXRocm93IG5ldyBuLkZvcm1hdEVycm9yKGBCYWQgRkNIRUNLIGluIGZsYXRlIHN0cmVhbTogJHthfSwgJHtyfWApO2lmKDMyJnIpdGhyb3cgbmV3IG4uRm9ybWF0RXJyb3IoYEZESUNUIGJpdCBzZXQgaW4gZmxhdGUgc3RyZWFtOiAke2F9LCAke3J9YCk7dGhpcy5jb2RlU2l6ZT0wO3RoaXMuY29kZUJ1Zj0wfWdldEJpdHMoZSl7Y29uc3QgdD10aGlzLnN0cjtsZXQgYSxyPXRoaXMuY29kZVNpemUsaT10aGlzLmNvZGVCdWY7Zm9yKDtyPGU7KXtpZigtMT09PShhPXQuZ2V0Qnl0ZSgpKSl0aHJvdyBuZXcgbi5Gb3JtYXRFcnJvcigiQmFkIGVuY29kaW5nIGluIGZsYXRlIHN0cmVhbSIpO2l8PWE8PHI7cis9OH1hPWkmKDE8PGUpLTE7dGhpcy5jb2RlQnVmPWk+PmU7dGhpcy5jb2RlU2l6ZT1yLT1lO3JldHVybiBhfWdldENvZGUoZSl7Y29uc3QgdD10aGlzLnN0cixhPWVbMF0scj1lWzFdO2xldCBpLHM9dGhpcy5jb2RlU2l6ZSxvPXRoaXMuY29kZUJ1Zjtmb3IoO3M8ciYmLTEhPT0oaT10LmdldEJ5dGUoKSk7KXtvfD1pPDxzO3MrPTh9Y29uc3QgYz1hW28mKDE8PHIpLTFdLGw9Yz4+MTYsaD02NTUzNSZjO2lmKGw8MXx8czxsKXRocm93IG5ldyBuLkZvcm1hdEVycm9yKCJCYWQgZW5jb2RpbmcgaW4gZmxhdGUgc3RyZWFtIik7dGhpcy5jb2RlQnVmPW8+Pmw7dGhpcy5jb2RlU2l6ZT1zLWw7cmV0dXJuIGh9Z2VuZXJhdGVIdWZmbWFuVGFibGUoZSl7Y29uc3QgdD1lLmxlbmd0aDtsZXQgYSxyPTA7Zm9yKGE9MDthPHQ7KythKWVbYV0+ciYmKHI9ZVthXSk7Y29uc3Qgbj0xPDxyLGk9bmV3IEludDMyQXJyYXkobik7Zm9yKGxldCBzPTEsbz0wLGM9MjtzPD1yOysrcyxvPDw9MSxjPDw9MSlmb3IobGV0IHI9MDtyPHQ7KytyKWlmKGVbcl09PT1zKXtsZXQgZT0wLHQ9bztmb3IoYT0wO2E8czsrK2Epe2U9ZTw8MXwxJnQ7dD4+PTF9Zm9yKGE9ZTthPG47YSs9YylpW2FdPXM8PDE2fHI7KytvfXJldHVybltpLHJdfXJlYWRCbG9jaygpe2xldCBlLHQ7Y29uc3QgYT10aGlzLnN0cjtsZXQgcixoLHU9dGhpcy5nZXRCaXRzKDMpOzEmdSYmKHRoaXMuZW9mPSEwKTt1Pj49MTtpZigwPT09dSl7bGV0IHQ7aWYoLTE9PT0odD1hLmdldEJ5dGUoKSkpdGhyb3cgbmV3IG4uRm9ybWF0RXJyb3IoIkJhZCBibG9jayBoZWFkZXIgaW4gZmxhdGUgc3RyZWFtIik7bGV0IHI9dDtpZigtMT09PSh0PWEuZ2V0Qnl0ZSgpKSl0aHJvdyBuZXcgbi5Gb3JtYXRFcnJvcigiQmFkIGJsb2NrIGhlYWRlciBpbiBmbGF0ZSBzdHJlYW0iKTtyfD10PDw4O2lmKC0xPT09KHQ9YS5nZXRCeXRlKCkpKXRocm93IG5ldyBuLkZvcm1hdEVycm9yKCJCYWQgYmxvY2sgaGVhZGVyIGluIGZsYXRlIHN0cmVhbSIpO2xldCBpPXQ7aWYoLTE9PT0odD1hLmdldEJ5dGUoKSkpdGhyb3cgbmV3IG4uRm9ybWF0RXJyb3IoIkJhZCBibG9jayBoZWFkZXIgaW4gZmxhdGUgc3RyZWFtIik7aXw9dDw8ODtpZihpIT09KDY1NTM1Jn5yKSYmKDAhPT1yfHwwIT09aSkpdGhyb3cgbmV3IG4uRm9ybWF0RXJyb3IoIkJhZCB1bmNvbXByZXNzZWQgYmxvY2sgbGVuZ3RoIGluIGZsYXRlIHN0cmVhbSIpO3RoaXMuY29kZUJ1Zj0wO3RoaXMuY29kZVNpemU9MDtjb25zdCBzPXRoaXMuYnVmZmVyTGVuZ3RoLG89cytyO2U9dGhpcy5lbnN1cmVCdWZmZXIobyk7dGhpcy5idWZmZXJMZW5ndGg9bztpZigwPT09ciktMT09PWEucGVla0J5dGUoKSYmKHRoaXMuZW9mPSEwKTtlbHNle2NvbnN0IHQ9YS5nZXRCeXRlcyhyKTtlLnNldCh0LHMpO3QubGVuZ3RoPHImJih0aGlzLmVvZj0hMCl9cmV0dXJufWlmKDE9PT11KXtyPWM7aD1sfWVsc2V7aWYoMiE9PXUpdGhyb3cgbmV3IG4uRm9ybWF0RXJyb3IoIlVua25vd24gYmxvY2sgdHlwZSBpbiBmbGF0ZSBzdHJlYW0iKTt7Y29uc3QgZT10aGlzLmdldEJpdHMoNSkrMjU3LGE9dGhpcy5nZXRCaXRzKDUpKzEsbj10aGlzLmdldEJpdHMoNCkrNCxzPW5ldyBVaW50OEFycmF5KGkubGVuZ3RoKTtsZXQgbztmb3Iobz0wO288bjsrK28pc1tpW29dXT10aGlzLmdldEJpdHMoMyk7Y29uc3QgYz10aGlzLmdlbmVyYXRlSHVmZm1hblRhYmxlKHMpO3Q9MDtvPTA7Y29uc3QgbD1lK2EsdT1uZXcgVWludDhBcnJheShsKTtsZXQgZCxmLGc7Zm9yKDtvPGw7KXtjb25zdCBlPXRoaXMuZ2V0Q29kZShjKTtpZigxNj09PWUpe2Q9MjtmPTM7Zz10fWVsc2UgaWYoMTc9PT1lKXtkPTM7Zj0zO2c9dD0wfWVsc2V7aWYoMTghPT1lKXt1W28rK109dD1lO2NvbnRpbnVlfWQ9NztmPTExO2c9dD0wfWxldCBhPXRoaXMuZ2V0Qml0cyhkKStmO2Zvcig7YS0tID4wOyl1W28rK109Z31yPXRoaXMuZ2VuZXJhdGVIdWZmbWFuVGFibGUodS5zdWJhcnJheSgwLGUpKTtoPXRoaXMuZ2VuZXJhdGVIdWZmbWFuVGFibGUodS5zdWJhcnJheShlLGwpKX19ZT10aGlzLmJ1ZmZlcjtsZXQgZD1lP2UubGVuZ3RoOjAsZj10aGlzLmJ1ZmZlckxlbmd0aDtmb3IoOzspe2xldCBhPXRoaXMuZ2V0Q29kZShyKTtpZihhPDI1Nil7aWYoZisxPj1kKXtlPXRoaXMuZW5zdXJlQnVmZmVyKGYrMSk7ZD1lLmxlbmd0aH1lW2YrK109YTtjb250aW51ZX1pZigyNTY9PT1hKXt0aGlzLmJ1ZmZlckxlbmd0aD1mO3JldHVybn1hLT0yNTc7YT1zW2FdO2xldCBuPWE+PjE2O24+MCYmKG49dGhpcy5nZXRCaXRzKG4pKTt0PSg2NTUzNSZhKStuO2E9dGhpcy5nZXRDb2RlKGgpO2E9b1thXTtuPWE+PjE2O24+MCYmKG49dGhpcy5nZXRCaXRzKG4pKTtjb25zdCBpPSg2NTUzNSZhKStuO2lmKGYrdD49ZCl7ZT10aGlzLmVuc3VyZUJ1ZmZlcihmK3QpO2Q9ZS5sZW5ndGh9Zm9yKGxldCBhPTA7YTx0OysrYSwrK2YpZVtmXT1lW2YtaV19fX10LkZsYXRlU3RyZWFtPUZsYXRlU3RyZWFtfSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuSmJpZzJTdHJlYW09dm9pZCAwO3ZhciByPWEoNyksbj1hKDE5KSxpPWEoNSkscz1hKDI1KSxvPWEoMik7Y2xhc3MgSmJpZzJTdHJlYW0gZXh0ZW5kcyBuLkRlY29kZVN0cmVhbXtjb25zdHJ1Y3RvcihlLHQsYSl7c3VwZXIodCk7dGhpcy5zdHJlYW09ZTt0aGlzLmRpY3Q9ZS5kaWN0O3RoaXMubWF5YmVMZW5ndGg9dDt0aGlzLnBhcmFtcz1hfWdldCBieXRlcygpe3JldHVybigwLG8uc2hhZG93KSh0aGlzLCJieXRlcyIsdGhpcy5zdHJlYW0uZ2V0Qnl0ZXModGhpcy5tYXliZUxlbmd0aCkpfWVuc3VyZUJ1ZmZlcihlKXt9cmVhZEJsb2NrKCl7aWYodGhpcy5lb2YpcmV0dXJuO2NvbnN0IGU9bmV3IHMuSmJpZzJJbWFnZSx0PVtdO2lmKHRoaXMucGFyYW1zIGluc3RhbmNlb2YgaS5EaWN0KXtjb25zdCBlPXRoaXMucGFyYW1zLmdldCgiSkJJRzJHbG9iYWxzIik7aWYoZSBpbnN0YW5jZW9mIHIuQmFzZVN0cmVhbSl7Y29uc3QgYT1lLmdldEJ5dGVzKCk7dC5wdXNoKHtkYXRhOmEsc3RhcnQ6MCxlbmQ6YS5sZW5ndGh9KX19dC5wdXNoKHtkYXRhOnRoaXMuYnl0ZXMsc3RhcnQ6MCxlbmQ6dGhpcy5ieXRlcy5sZW5ndGh9KTtjb25zdCBhPWUucGFyc2VDaHVua3ModCksbj1hLmxlbmd0aDtmb3IobGV0IGU9MDtlPG47ZSsrKWFbZV1ePTI1NTt0aGlzLmJ1ZmZlcj1hO3RoaXMuYnVmZmVyTGVuZ3RoPW47dGhpcy5lb2Y9ITB9fXQuSmJpZzJTdHJlYW09SmJpZzJTdHJlYW19LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5KYmlnMkltYWdlPXZvaWQgMDt2YXIgcj1hKDIpLG49YSg2KSxpPWEoMjYpLHM9YSgyMik7Y2xhc3MgSmJpZzJFcnJvciBleHRlbmRzIHIuQmFzZUV4Y2VwdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihgSkJJRzIgZXJyb3I6ICR7ZX1gLCJKYmlnMkVycm9yIil9fWNsYXNzIENvbnRleHRDYWNoZXtnZXRDb250ZXh0cyhlKXtyZXR1cm4gZSBpbiB0aGlzP3RoaXNbZV06dGhpc1tlXT1uZXcgSW50OEFycmF5KDY1NTM2KX19Y2xhc3MgRGVjb2RpbmdDb250ZXh0e2NvbnN0cnVjdG9yKGUsdCxhKXt0aGlzLmRhdGE9ZTt0aGlzLnN0YXJ0PXQ7dGhpcy5lbmQ9YX1nZXQgZGVjb2Rlcigpe2NvbnN0IGU9bmV3IGkuQXJpdGhtZXRpY0RlY29kZXIodGhpcy5kYXRhLHRoaXMuc3RhcnQsdGhpcy5lbmQpO3JldHVybigwLHIuc2hhZG93KSh0aGlzLCJkZWNvZGVyIixlKX1nZXQgY29udGV4dENhY2hlKCl7Y29uc3QgZT1uZXcgQ29udGV4dENhY2hlO3JldHVybigwLHIuc2hhZG93KSh0aGlzLCJjb250ZXh0Q2FjaGUiLGUpfX1mdW5jdGlvbiBkZWNvZGVJbnRlZ2VyKGUsdCxhKXtjb25zdCByPWUuZ2V0Q29udGV4dHModCk7bGV0IG49MTtmdW5jdGlvbiByZWFkQml0cyhlKXtsZXQgdD0wO2ZvcihsZXQgaT0wO2k8ZTtpKyspe2NvbnN0IGU9YS5yZWFkQml0KHIsbik7bj1uPDI1Nj9uPDwxfGU6NTExJihuPDwxfGUpfDI1Njt0PXQ8PDF8ZX1yZXR1cm4gdD4+PjB9Y29uc3QgaT1yZWFkQml0cygxKSxzPXJlYWRCaXRzKDEpP3JlYWRCaXRzKDEpP3JlYWRCaXRzKDEpP3JlYWRCaXRzKDEpP3JlYWRCaXRzKDEpP3JlYWRCaXRzKDMyKSs0NDM2OnJlYWRCaXRzKDEyKSszNDA6cmVhZEJpdHMoOCkrODQ6cmVhZEJpdHMoNikrMjA6cmVhZEJpdHMoNCkrNDpyZWFkQml0cygyKTtyZXR1cm4gMD09PWk/czpzPjA/LXM6bnVsbH1mdW5jdGlvbiBkZWNvZGVJQUlEKGUsdCxhKXtjb25zdCByPWUuZ2V0Q29udGV4dHMoIklBSUQiKTtsZXQgbj0xO2ZvcihsZXQgZT0wO2U8YTtlKyspe249bjw8MXx0LnJlYWRCaXQocixuKX1yZXR1cm4gYTwzMT9uJigxPDxhKS0xOjIxNDc0ODM2NDcmbn1jb25zdCBvPVsiU3ltYm9sRGljdGlvbmFyeSIsbnVsbCxudWxsLG51bGwsIkludGVybWVkaWF0ZVRleHRSZWdpb24iLG51bGwsIkltbWVkaWF0ZVRleHRSZWdpb24iLCJJbW1lZGlhdGVMb3NzbGVzc1RleHRSZWdpb24iLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCwiUGF0dGVybkRpY3Rpb25hcnkiLG51bGwsbnVsbCxudWxsLCJJbnRlcm1lZGlhdGVIYWxmdG9uZVJlZ2lvbiIsbnVsbCwiSW1tZWRpYXRlSGFsZnRvbmVSZWdpb24iLCJJbW1lZGlhdGVMb3NzbGVzc0hhbGZ0b25lUmVnaW9uIixudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCwiSW50ZXJtZWRpYXRlR2VuZXJpY1JlZ2lvbiIsbnVsbCwiSW1tZWRpYXRlR2VuZXJpY1JlZ2lvbiIsIkltbWVkaWF0ZUxvc3NsZXNzR2VuZXJpY1JlZ2lvbiIsIkludGVybWVkaWF0ZUdlbmVyaWNSZWZpbmVtZW50UmVnaW9uIixudWxsLCJJbW1lZGlhdGVHZW5lcmljUmVmaW5lbWVudFJlZ2lvbiIsIkltbWVkaWF0ZUxvc3NsZXNzR2VuZXJpY1JlZmluZW1lbnRSZWdpb24iLG51bGwsbnVsbCxudWxsLG51bGwsIlBhZ2VJbmZvcm1hdGlvbiIsIkVuZE9mUGFnZSIsIkVuZE9mU3RyaXBlIiwiRW5kT2ZGaWxlIiwiUHJvZmlsZXMiLCJUYWJsZXMiLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCwiRXh0ZW5zaW9uIl0sYz1bW3t4Oi0xLHk6LTJ9LHt4OjAseTotMn0se3g6MSx5Oi0yfSx7eDotMix5Oi0xfSx7eDotMSx5Oi0xfSx7eDowLHk6LTF9LHt4OjEseTotMX0se3g6Mix5Oi0xfSx7eDotNCx5OjB9LHt4Oi0zLHk6MH0se3g6LTIseTowfSx7eDotMSx5OjB9XSxbe3g6LTEseTotMn0se3g6MCx5Oi0yfSx7eDoxLHk6LTJ9LHt4OjIseTotMn0se3g6LTIseTotMX0se3g6LTEseTotMX0se3g6MCx5Oi0xfSx7eDoxLHk6LTF9LHt4OjIseTotMX0se3g6LTMseTowfSx7eDotMix5OjB9LHt4Oi0xLHk6MH1dLFt7eDotMSx5Oi0yfSx7eDowLHk6LTJ9LHt4OjEseTotMn0se3g6LTIseTotMX0se3g6LTEseTotMX0se3g6MCx5Oi0xfSx7eDoxLHk6LTF9LHt4Oi0yLHk6MH0se3g6LTEseTowfV0sW3t4Oi0zLHk6LTF9LHt4Oi0yLHk6LTF9LHt4Oi0xLHk6LTF9LHt4OjAseTotMX0se3g6MSx5Oi0xfSx7eDotNCx5OjB9LHt4Oi0zLHk6MH0se3g6LTIseTowfSx7eDotMSx5OjB9XV0sbD1be2NvZGluZzpbe3g6MCx5Oi0xfSx7eDoxLHk6LTF9LHt4Oi0xLHk6MH1dLHJlZmVyZW5jZTpbe3g6MCx5Oi0xfSx7eDoxLHk6LTF9LHt4Oi0xLHk6MH0se3g6MCx5OjB9LHt4OjEseTowfSx7eDotMSx5OjF9LHt4OjAseToxfSx7eDoxLHk6MX1dfSx7Y29kaW5nOlt7eDotMSx5Oi0xfSx7eDowLHk6LTF9LHt4OjEseTotMX0se3g6LTEseTowfV0scmVmZXJlbmNlOlt7eDowLHk6LTF9LHt4Oi0xLHk6MH0se3g6MCx5OjB9LHt4OjEseTowfSx7eDowLHk6MX0se3g6MSx5OjF9XX1dLGg9WzM5NzE3LDE5NDEsMjI5LDQwNV0sdT1bMzIsOF07ZnVuY3Rpb24gZGVjb2RlQml0bWFwKGUsdCxhLHIsbixpLHMsbyl7aWYoZSl7cmV0dXJuIGRlY29kZU1NUkJpdG1hcChuZXcgUmVhZGVyKG8uZGF0YSxvLnN0YXJ0LG8uZW5kKSx0LGEsITEpfWlmKDA9PT1yJiYhaSYmIW4mJjQ9PT1zLmxlbmd0aCYmMz09PXNbMF0ueCYmLTE9PT1zWzBdLnkmJi0zPT09c1sxXS54JiYtMT09PXNbMV0ueSYmMj09PXNbMl0ueCYmLTI9PT1zWzJdLnkmJi0yPT09c1szXS54JiYtMj09PXNbM10ueSlyZXR1cm4gZnVuY3Rpb24gZGVjb2RlQml0bWFwVGVtcGxhdGUwKGUsdCxhKXtjb25zdCByPWEuZGVjb2RlcixuPWEuY29udGV4dENhY2hlLmdldENvbnRleHRzKCJHQiIpLGk9W107bGV0IHMsbyxjLGwsaCx1LGQ7Zm9yKG89MDtvPHQ7bysrKXtoPWlbb109bmV3IFVpbnQ4QXJyYXkoZSk7dT1vPDE/aDppW28tMV07ZD1vPDI/aDppW28tMl07cz1kWzBdPDwxM3xkWzFdPDwxMnxkWzJdPDwxMXx1WzBdPDw3fHVbMV08PDZ8dVsyXTw8NXx1WzNdPDw0O2ZvcihjPTA7YzxlO2MrKyl7aFtjXT1sPXIucmVhZEJpdChuLHMpO3M9KDMxNzM1JnMpPDwxfChjKzM8ZT9kW2MrM108PDExOjApfChjKzQ8ZT91W2MrNF08PDQ6MCl8bH19cmV0dXJuIGl9KHQsYSxvKTtjb25zdCBsPSEhaSx1PWNbcl0uY29uY2F0KHMpO3Uuc29ydCgoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS55LXQueXx8ZS54LXQueH0pKTtjb25zdCBkPXUubGVuZ3RoLGY9bmV3IEludDhBcnJheShkKSxnPW5ldyBJbnQ4QXJyYXkoZCkscD1bXTtsZXQgbSxiLHk9MCx3PTAsUz0wLHg9MDtmb3IoYj0wO2I8ZDtiKyspe2ZbYl09dVtiXS54O2dbYl09dVtiXS55O3c9TWF0aC5taW4odyx1W2JdLngpO1M9TWF0aC5tYXgoUyx1W2JdLngpO3g9TWF0aC5taW4oeCx1W2JdLnkpO2I8ZC0xJiZ1W2JdLnk9PT11W2IrMV0ueSYmdVtiXS54PT09dVtiKzFdLngtMT95fD0xPDxkLTEtYjpwLnB1c2goYil9Y29uc3Qgaz1wLmxlbmd0aCxDPW5ldyBJbnQ4QXJyYXkoayksdj1uZXcgSW50OEFycmF5KGspLEY9bmV3IFVpbnQxNkFycmF5KGspO2ZvcihtPTA7bTxrO20rKyl7Yj1wW21dO0NbbV09dVtiXS54O3ZbbV09dVtiXS55O0ZbbV09MTw8ZC0xLWJ9Y29uc3QgTz0tdyxUPS14LE09dC1TLEU9aFtyXTtsZXQgRD1uZXcgVWludDhBcnJheSh0KTtjb25zdCBOPVtdLFI9by5kZWNvZGVyLEw9by5jb250ZXh0Q2FjaGUuZ2V0Q29udGV4dHMoIkdCIik7bGV0IGosJCxfLFUsWCxIPTAscT0wO2ZvcihsZXQgZT0wO2U8YTtlKyspe2lmKG4pe0hePVIucmVhZEJpdChMLEUpO2lmKEgpe04ucHVzaChEKTtjb250aW51ZX19RD1uZXcgVWludDhBcnJheShEKTtOLnB1c2goRCk7Zm9yKGo9MDtqPHQ7aisrKXtpZihsJiZpW2VdW2pdKXtEW2pdPTA7Y29udGludWV9aWYoaj49TyYmajxNJiZlPj1UKXtxPXE8PDEmeTtmb3IoYj0wO2I8aztiKyspeyQ9ZSt2W2JdO189aitDW2JdO1U9TlskXVtfXTtpZihVKXtVPUZbYl07cXw9VX19fWVsc2V7cT0wO1g9ZC0xO2ZvcihiPTA7YjxkO2IrKyxYLS0pe189aitmW2JdO2lmKF8+PTAmJl88dCl7JD1lK2dbYl07aWYoJD49MCl7VT1OWyRdW19dO1UmJihxfD1VPDxYKX19fX1jb25zdCBhPVIucmVhZEJpdChMLHEpO0Rbal09YX19cmV0dXJuIE59ZnVuY3Rpb24gZGVjb2RlUmVmaW5lbWVudChlLHQsYSxyLG4saSxzLG8sYyl7bGV0IGg9bFthXS5jb2Rpbmc7MD09PWEmJihoPWguY29uY2F0KFtvWzBdXSkpO2NvbnN0IGQ9aC5sZW5ndGgsZj1uZXcgSW50MzJBcnJheShkKSxnPW5ldyBJbnQzMkFycmF5KGQpO2xldCBwO2ZvcihwPTA7cDxkO3ArKyl7ZltwXT1oW3BdLng7Z1twXT1oW3BdLnl9bGV0IG09bFthXS5yZWZlcmVuY2U7MD09PWEmJihtPW0uY29uY2F0KFtvWzFdXSkpO2NvbnN0IGI9bS5sZW5ndGgseT1uZXcgSW50MzJBcnJheShiKSx3PW5ldyBJbnQzMkFycmF5KGIpO2ZvcihwPTA7cDxiO3ArKyl7eVtwXT1tW3BdLng7d1twXT1tW3BdLnl9Y29uc3QgUz1yWzBdLmxlbmd0aCx4PXIubGVuZ3RoLGs9dVthXSxDPVtdLHY9Yy5kZWNvZGVyLEY9Yy5jb250ZXh0Q2FjaGUuZ2V0Q29udGV4dHMoIkdSIik7bGV0IE89MDtmb3IobGV0IGE9MDthPHQ7YSsrKXtpZihzKXtPXj12LnJlYWRCaXQoRixrKTtpZihPKXRocm93IG5ldyBKYmlnMkVycm9yKCJwcmVkaWN0aW9uIGlzIG5vdCBzdXBwb3J0ZWQiKX1jb25zdCB0PW5ldyBVaW50OEFycmF5KGUpO0MucHVzaCh0KTtmb3IobGV0IHM9MDtzPGU7cysrKXtsZXQgbyxjLGw9MDtmb3IocD0wO3A8ZDtwKyspe289YStnW3BdO2M9cytmW3BdO288MHx8YzwwfHxjPj1lP2w8PD0xOmw9bDw8MXxDW29dW2NdfWZvcihwPTA7cDxiO3ArKyl7bz1hK3dbcF0taTtjPXMreVtwXS1uO288MHx8bz49eHx8YzwwfHxjPj1TP2w8PD0xOmw9bDw8MXxyW29dW2NdfWNvbnN0IGg9di5yZWFkQml0KEYsbCk7dFtzXT1ofX1yZXR1cm4gQ31mdW5jdGlvbiBkZWNvZGVUZXh0UmVnaW9uKGUsdCxhLHIsbixpLHMsbyxjLGwsaCx1LGQsZixnLHAsbSxiLHkpe2lmKGUmJnQpdGhyb3cgbmV3IEpiaWcyRXJyb3IoInJlZmluZW1lbnQgd2l0aCBIdWZmbWFuIGlzIG5vdCBzdXBwb3J0ZWQiKTtjb25zdCB3PVtdO2xldCBTLHg7Zm9yKFM9MDtTPHI7UysrKXt4PW5ldyBVaW50OEFycmF5KGEpO2lmKG4pZm9yKGxldCBlPTA7ZTxhO2UrKyl4W2VdPW47dy5wdXNoKHgpfWNvbnN0IGs9bS5kZWNvZGVyLEM9bS5jb250ZXh0Q2FjaGU7bGV0IHY9ZT8tZi50YWJsZURlbHRhVC5kZWNvZGUoeSk6LWRlY29kZUludGVnZXIoQywiSUFEVCIsayksRj0wO1M9MDtmb3IoO1M8aTspe3YrPWU/Zi50YWJsZURlbHRhVC5kZWNvZGUoeSk6ZGVjb2RlSW50ZWdlcihDLCJJQURUIixrKTtGKz1lP2YudGFibGVGaXJzdFMuZGVjb2RlKHkpOmRlY29kZUludGVnZXIoQywiSUFGUyIsayk7bGV0IHI9Rjtmb3IoOzspe2xldCBuPTA7cz4xJiYobj1lP3kucmVhZEJpdHMoYik6ZGVjb2RlSW50ZWdlcihDLCJJQUlUIixrKSk7Y29uc3QgaT1zKnYrbixGPWU/Zi5zeW1ib2xJRFRhYmxlLmRlY29kZSh5KTpkZWNvZGVJQUlEKEMsayxjKSxPPXQmJihlP3kucmVhZEJpdCgpOmRlY29kZUludGVnZXIoQywiSUFSSSIsaykpO2xldCBUPW9bRl0sTT1UWzBdLmxlbmd0aCxFPVQubGVuZ3RoO2lmKE8pe2NvbnN0IGU9ZGVjb2RlSW50ZWdlcihDLCJJQVJEVyIsayksdD1kZWNvZGVJbnRlZ2VyKEMsIklBUkRIIixrKSxhPWRlY29kZUludGVnZXIoQywiSUFSRFgiLGspLHI9ZGVjb2RlSW50ZWdlcihDLCJJQVJEWSIsayk7TSs9ZTtFKz10O1Q9ZGVjb2RlUmVmaW5lbWVudChNLEUsZyxULChlPj4xKSthLCh0Pj4xKStyLCExLHAsbSl9Y29uc3QgRD1pLSgxJnU/MDpFLTEpLE49ci0oMiZ1P00tMTowKTtsZXQgUixMLGo7aWYobCl7Zm9yKFI9MDtSPEU7UisrKXt4PXdbTitSXTtpZigheCljb250aW51ZTtqPVRbUl07Y29uc3QgZT1NYXRoLm1pbihhLUQsTSk7c3dpdGNoKGQpe2Nhc2UgMDpmb3IoTD0wO0w8ZTtMKyspeFtEK0xdfD1qW0xdO2JyZWFrO2Nhc2UgMjpmb3IoTD0wO0w8ZTtMKyspeFtEK0xdXj1qW0xdO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEpiaWcyRXJyb3IoYG9wZXJhdG9yICR7ZH0gaXMgbm90IHN1cHBvcnRlZGApfX1yKz1FLTF9ZWxzZXtmb3IoTD0wO0w8RTtMKyspe3g9d1tEK0xdO2lmKHgpe2o9VFtMXTtzd2l0Y2goZCl7Y2FzZSAwOmZvcihSPTA7UjxNO1IrKyl4W04rUl18PWpbUl07YnJlYWs7Y2FzZSAyOmZvcihSPTA7UjxNO1IrKyl4W04rUl1ePWpbUl07YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgSmJpZzJFcnJvcihgb3BlcmF0b3IgJHtkfSBpcyBub3Qgc3VwcG9ydGVkYCl9fX1yKz1NLTF9UysrO2NvbnN0ICQ9ZT9mLnRhYmxlRGVsdGFTLmRlY29kZSh5KTpkZWNvZGVJbnRlZ2VyKEMsIklBRFMiLGspO2lmKG51bGw9PT0kKWJyZWFrO3IrPSQraH19cmV0dXJuIHd9ZnVuY3Rpb24gcmVhZFNlZ21lbnRIZWFkZXIoZSx0KXtjb25zdCBhPXt9O2EubnVtYmVyPSgwLG4ucmVhZFVpbnQzMikoZSx0KTtjb25zdCByPWVbdCs0XSxpPTYzJnI7aWYoIW9baV0pdGhyb3cgbmV3IEpiaWcyRXJyb3IoImludmFsaWQgc2VnbWVudCB0eXBlOiAiK2kpO2EudHlwZT1pO2EudHlwZU5hbWU9b1tpXTthLmRlZmVycmVkTm9uUmV0YWluPSEhKDEyOCZyKTtjb25zdCBzPSEhKDY0JnIpLGM9ZVt0KzVdO2xldCBsPWM+PjUmNztjb25zdCBoPVszMSZjXTtsZXQgdT10KzY7aWYoNz09PWMpe2w9NTM2ODcwOTExJigwLG4ucmVhZFVpbnQzMikoZSx1LTEpO3UrPTM7bGV0IHQ9bCs3Pj4zO2hbMF09ZVt1KytdO2Zvcig7LS10PjA7KWgucHVzaChlW3UrK10pfWVsc2UgaWYoNT09PWN8fDY9PT1jKXRocm93IG5ldyBKYmlnMkVycm9yKCJpbnZhbGlkIHJlZmVycmVkLXRvIGZsYWdzIik7YS5yZXRhaW5CaXRzPWg7bGV0IGY9NDthLm51bWJlcjw9MjU2P2Y9MTphLm51bWJlcjw9NjU1MzYmJihmPTIpO2NvbnN0IGc9W107bGV0IHAsbTtmb3IocD0wO3A8bDtwKyspe2xldCB0O3Q9MT09PWY/ZVt1XToyPT09Zj8oMCxuLnJlYWRVaW50MTYpKGUsdSk6KDAsbi5yZWFkVWludDMyKShlLHUpO2cucHVzaCh0KTt1Kz1mfWEucmVmZXJyZWRUbz1nO2lmKHMpe2EucGFnZUFzc29jaWF0aW9uPSgwLG4ucmVhZFVpbnQzMikoZSx1KTt1Kz00fWVsc2UgYS5wYWdlQXNzb2NpYXRpb249ZVt1KytdO2EubGVuZ3RoPSgwLG4ucmVhZFVpbnQzMikoZSx1KTt1Kz00O2lmKDQyOTQ5NjcyOTU9PT1hLmxlbmd0aCl7aWYoMzghPT1pKXRocm93IG5ldyBKYmlnMkVycm9yKCJpbnZhbGlkIHVua25vd24gc2VnbWVudCBsZW5ndGgiKTt7Y29uc3QgdD1yZWFkUmVnaW9uU2VnbWVudEluZm9ybWF0aW9uKGUsdSkscj0hISgxJmVbdStkXSksbj02LGk9bmV3IFVpbnQ4QXJyYXkobik7aWYoIXIpe2lbMF09MjU1O2lbMV09MTcyfWlbMl09dC5oZWlnaHQ+Pj4yNCYyNTU7aVszXT10LmhlaWdodD4+MTYmMjU1O2lbNF09dC5oZWlnaHQ+PjgmMjU1O2lbNV09MjU1JnQuaGVpZ2h0O2ZvcihwPXUsbT1lLmxlbmd0aDtwPG07cCsrKXtsZXQgdD0wO2Zvcig7dDxuJiZpW3RdPT09ZVtwK3RdOyl0Kys7aWYodD09PW4pe2EubGVuZ3RoPXArbjticmVha319aWYoNDI5NDk2NzI5NT09PWEubGVuZ3RoKXRocm93IG5ldyBKYmlnMkVycm9yKCJzZWdtZW50IGVuZCB3YXMgbm90IGZvdW5kIil9fWEuaGVhZGVyRW5kPXU7cmV0dXJuIGF9ZnVuY3Rpb24gcmVhZFNlZ21lbnRzKGUsdCxhLHIpe2NvbnN0IG49W107bGV0IGk9YTtmb3IoO2k8cjspe2NvbnN0IGE9cmVhZFNlZ21lbnRIZWFkZXIodCxpKTtpPWEuaGVhZGVyRW5kO2NvbnN0IHI9e2hlYWRlcjphLGRhdGE6dH07aWYoIWUucmFuZG9tQWNjZXNzKXtyLnN0YXJ0PWk7aSs9YS5sZW5ndGg7ci5lbmQ9aX1uLnB1c2gocik7aWYoNTE9PT1hLnR5cGUpYnJlYWt9aWYoZS5yYW5kb21BY2Nlc3MpZm9yKGxldCBlPTAsdD1uLmxlbmd0aDtlPHQ7ZSsrKXtuW2VdLnN0YXJ0PWk7aSs9bltlXS5oZWFkZXIubGVuZ3RoO25bZV0uZW5kPWl9cmV0dXJuIG59ZnVuY3Rpb24gcmVhZFJlZ2lvblNlZ21lbnRJbmZvcm1hdGlvbihlLHQpe3JldHVybnt3aWR0aDooMCxuLnJlYWRVaW50MzIpKGUsdCksaGVpZ2h0OigwLG4ucmVhZFVpbnQzMikoZSx0KzQpLHg6KDAsbi5yZWFkVWludDMyKShlLHQrOCkseTooMCxuLnJlYWRVaW50MzIpKGUsdCsxMiksY29tYmluYXRpb25PcGVyYXRvcjo3JmVbdCsxNl19fWNvbnN0IGQ9MTc7ZnVuY3Rpb24gcHJvY2Vzc1NlZ21lbnQoZSx0KXtjb25zdCBhPWUuaGVhZGVyLHI9ZS5kYXRhLGk9ZS5lbmQ7bGV0IHMsbyxjLGwsaD1lLnN0YXJ0O3N3aXRjaChhLnR5cGUpe2Nhc2UgMDpjb25zdCBlPXt9LHQ9KDAsbi5yZWFkVWludDE2KShyLGgpO2UuaHVmZm1hbj0hISgxJnQpO2UucmVmaW5lbWVudD0hISgyJnQpO2UuaHVmZm1hbkRIU2VsZWN0b3I9dD4+MiYzO2UuaHVmZm1hbkRXU2VsZWN0b3I9dD4+NCYzO2UuYml0bWFwU2l6ZVNlbGVjdG9yPXQ+PjYmMTtlLmFnZ3JlZ2F0aW9uSW5zdGFuY2VzU2VsZWN0b3I9dD4+NyYxO2UuYml0bWFwQ29kaW5nQ29udGV4dFVzZWQ9ISEoMjU2JnQpO2UuYml0bWFwQ29kaW5nQ29udGV4dFJldGFpbmVkPSEhKDUxMiZ0KTtlLnRlbXBsYXRlPXQ+PjEwJjM7ZS5yZWZpbmVtZW50VGVtcGxhdGU9dD4+MTImMTtoKz0yO2lmKCFlLmh1ZmZtYW4pe2w9MD09PWUudGVtcGxhdGU/NDoxO289W107Zm9yKGM9MDtjPGw7YysrKXtvLnB1c2goe3g6KDAsbi5yZWFkSW50OCkocixoKSx5OigwLG4ucmVhZEludDgpKHIsaCsxKX0pO2grPTJ9ZS5hdD1vfWlmKGUucmVmaW5lbWVudCYmIWUucmVmaW5lbWVudFRlbXBsYXRlKXtvPVtdO2ZvcihjPTA7YzwyO2MrKyl7by5wdXNoKHt4OigwLG4ucmVhZEludDgpKHIsaCkseTooMCxuLnJlYWRJbnQ4KShyLGgrMSl9KTtoKz0yfWUucmVmaW5lbWVudEF0PW99ZS5udW1iZXJPZkV4cG9ydGVkU3ltYm9scz0oMCxuLnJlYWRVaW50MzIpKHIsaCk7aCs9NDtlLm51bWJlck9mTmV3U3ltYm9scz0oMCxuLnJlYWRVaW50MzIpKHIsaCk7aCs9NDtzPVtlLGEubnVtYmVyLGEucmVmZXJyZWRUbyxyLGgsaV07YnJlYWs7Y2FzZSA2OmNhc2UgNzpjb25zdCB1PXt9O3UuaW5mbz1yZWFkUmVnaW9uU2VnbWVudEluZm9ybWF0aW9uKHIsaCk7aCs9ZDtjb25zdCBmPSgwLG4ucmVhZFVpbnQxNikocixoKTtoKz0yO3UuaHVmZm1hbj0hISgxJmYpO3UucmVmaW5lbWVudD0hISgyJmYpO3UubG9nU3RyaXBTaXplPWY+PjImMzt1LnN0cmlwU2l6ZT0xPDx1LmxvZ1N0cmlwU2l6ZTt1LnJlZmVyZW5jZUNvcm5lcj1mPj40JjM7dS50cmFuc3Bvc2VkPSEhKDY0JmYpO3UuY29tYmluYXRpb25PcGVyYXRvcj1mPj43JjM7dS5kZWZhdWx0UGl4ZWxWYWx1ZT1mPj45JjE7dS5kc09mZnNldD1mPDwxNz4+Mjc7dS5yZWZpbmVtZW50VGVtcGxhdGU9Zj4+MTUmMTtpZih1Lmh1ZmZtYW4pe2NvbnN0IGU9KDAsbi5yZWFkVWludDE2KShyLGgpO2grPTI7dS5odWZmbWFuRlM9MyZlO3UuaHVmZm1hbkRTPWU+PjImMzt1Lmh1ZmZtYW5EVD1lPj40JjM7dS5odWZmbWFuUmVmaW5lbWVudERXPWU+PjYmMzt1Lmh1ZmZtYW5SZWZpbmVtZW50REg9ZT4+OCYzO3UuaHVmZm1hblJlZmluZW1lbnREWD1lPj4xMCYzO3UuaHVmZm1hblJlZmluZW1lbnREWT1lPj4xMiYzO3UuaHVmZm1hblJlZmluZW1lbnRTaXplU2VsZWN0b3I9ISEoMTYzODQmZSl9aWYodS5yZWZpbmVtZW50JiYhdS5yZWZpbmVtZW50VGVtcGxhdGUpe289W107Zm9yKGM9MDtjPDI7YysrKXtvLnB1c2goe3g6KDAsbi5yZWFkSW50OCkocixoKSx5OigwLG4ucmVhZEludDgpKHIsaCsxKX0pO2grPTJ9dS5yZWZpbmVtZW50QXQ9b311Lm51bWJlck9mU3ltYm9sSW5zdGFuY2VzPSgwLG4ucmVhZFVpbnQzMikocixoKTtoKz00O3M9W3UsYS5yZWZlcnJlZFRvLHIsaCxpXTticmVhaztjYXNlIDE2OmNvbnN0IGc9e30scD1yW2grK107Zy5tbXI9ISEoMSZwKTtnLnRlbXBsYXRlPXA+PjEmMztnLnBhdHRlcm5XaWR0aD1yW2grK107Zy5wYXR0ZXJuSGVpZ2h0PXJbaCsrXTtnLm1heFBhdHRlcm5JbmRleD0oMCxuLnJlYWRVaW50MzIpKHIsaCk7aCs9NDtzPVtnLGEubnVtYmVyLHIsaCxpXTticmVhaztjYXNlIDIyOmNhc2UgMjM6Y29uc3QgbT17fTttLmluZm89cmVhZFJlZ2lvblNlZ21lbnRJbmZvcm1hdGlvbihyLGgpO2grPWQ7Y29uc3QgYj1yW2grK107bS5tbXI9ISEoMSZiKTttLnRlbXBsYXRlPWI+PjEmMzttLmVuYWJsZVNraXA9ISEoOCZiKTttLmNvbWJpbmF0aW9uT3BlcmF0b3I9Yj4+NCY3O20uZGVmYXVsdFBpeGVsVmFsdWU9Yj4+NyYxO20uZ3JpZFdpZHRoPSgwLG4ucmVhZFVpbnQzMikocixoKTtoKz00O20uZ3JpZEhlaWdodD0oMCxuLnJlYWRVaW50MzIpKHIsaCk7aCs9NDttLmdyaWRPZmZzZXRYPTQyOTQ5NjcyOTUmKDAsbi5yZWFkVWludDMyKShyLGgpO2grPTQ7bS5ncmlkT2Zmc2V0WT00Mjk0OTY3Mjk1JigwLG4ucmVhZFVpbnQzMikocixoKTtoKz00O20uZ3JpZFZlY3Rvclg9KDAsbi5yZWFkVWludDE2KShyLGgpO2grPTI7bS5ncmlkVmVjdG9yWT0oMCxuLnJlYWRVaW50MTYpKHIsaCk7aCs9MjtzPVttLGEucmVmZXJyZWRUbyxyLGgsaV07YnJlYWs7Y2FzZSAzODpjYXNlIDM5OmNvbnN0IHk9e307eS5pbmZvPXJlYWRSZWdpb25TZWdtZW50SW5mb3JtYXRpb24ocixoKTtoKz1kO2NvbnN0IHc9cltoKytdO3kubW1yPSEhKDEmdyk7eS50ZW1wbGF0ZT13Pj4xJjM7eS5wcmVkaWN0aW9uPSEhKDgmdyk7aWYoIXkubW1yKXtsPTA9PT15LnRlbXBsYXRlPzQ6MTtvPVtdO2ZvcihjPTA7YzxsO2MrKyl7by5wdXNoKHt4OigwLG4ucmVhZEludDgpKHIsaCkseTooMCxuLnJlYWRJbnQ4KShyLGgrMSl9KTtoKz0yfXkuYXQ9b31zPVt5LHIsaCxpXTticmVhaztjYXNlIDQ4OmNvbnN0IFM9e3dpZHRoOigwLG4ucmVhZFVpbnQzMikocixoKSxoZWlnaHQ6KDAsbi5yZWFkVWludDMyKShyLGgrNCkscmVzb2x1dGlvblg6KDAsbi5yZWFkVWludDMyKShyLGgrOCkscmVzb2x1dGlvblk6KDAsbi5yZWFkVWludDMyKShyLGgrMTIpfTs0Mjk0OTY3Mjk1PT09Uy5oZWlnaHQmJmRlbGV0ZSBTLmhlaWdodDtjb25zdCB4PXJbaCsxNl07KDAsbi5yZWFkVWludDE2KShyLGgrMTcpO1MubG9zc2xlc3M9ISEoMSZ4KTtTLnJlZmluZW1lbnQ9ISEoMiZ4KTtTLmRlZmF1bHRQaXhlbFZhbHVlPXg+PjImMTtTLmNvbWJpbmF0aW9uT3BlcmF0b3I9eD4+MyYzO1MucmVxdWlyZXNCdWZmZXI9ISEoMzImeCk7Uy5jb21iaW5hdGlvbk9wZXJhdG9yT3ZlcnJpZGU9ISEoNjQmeCk7cz1bU107YnJlYWs7Y2FzZSA0OTpjYXNlIDUwOmNhc2UgNTE6Y2FzZSA2MjpicmVhaztjYXNlIDUzOnM9W2EubnVtYmVyLHIsaCxpXTticmVhaztkZWZhdWx0OnRocm93IG5ldyBKYmlnMkVycm9yKGBzZWdtZW50IHR5cGUgJHthLnR5cGVOYW1lfSgke2EudHlwZX0pIGlzIG5vdCBpbXBsZW1lbnRlZGApfWNvbnN0IHU9Im9uIithLnR5cGVOYW1lO3UgaW4gdCYmdFt1XS5hcHBseSh0LHMpfWZ1bmN0aW9uIHByb2Nlc3NTZWdtZW50cyhlLHQpe2ZvcihsZXQgYT0wLHI9ZS5sZW5ndGg7YTxyO2ErKylwcm9jZXNzU2VnbWVudChlW2FdLHQpfWNsYXNzIFNpbXBsZVNlZ21lbnRWaXNpdG9ye29uUGFnZUluZm9ybWF0aW9uKGUpe3RoaXMuY3VycmVudFBhZ2VJbmZvPWU7Y29uc3QgdD1lLndpZHRoKzc+PjMsYT1uZXcgVWludDhDbGFtcGVkQXJyYXkodCplLmhlaWdodCk7ZS5kZWZhdWx0UGl4ZWxWYWx1ZSYmYS5maWxsKDI1NSk7dGhpcy5idWZmZXI9YX1kcmF3Qml0bWFwKGUsdCl7Y29uc3QgYT10aGlzLmN1cnJlbnRQYWdlSW5mbyxyPWUud2lkdGgsbj1lLmhlaWdodCxpPWEud2lkdGgrNz4+MyxzPWEuY29tYmluYXRpb25PcGVyYXRvck92ZXJyaWRlP2UuY29tYmluYXRpb25PcGVyYXRvcjphLmNvbWJpbmF0aW9uT3BlcmF0b3Isbz10aGlzLmJ1ZmZlcixjPTEyOD4+KDcmZS54KTtsZXQgbCxoLHUsZCxmPWUueSppKyhlLng+PjMpO3N3aXRjaChzKXtjYXNlIDA6Zm9yKGw9MDtsPG47bCsrKXt1PWM7ZD1mO2ZvcihoPTA7aDxyO2grKyl7dFtsXVtoXSYmKG9bZF18PXUpO3U+Pj0xO2lmKCF1KXt1PTEyODtkKyt9fWYrPWl9YnJlYWs7Y2FzZSAyOmZvcihsPTA7bDxuO2wrKyl7dT1jO2Q9Zjtmb3IoaD0wO2g8cjtoKyspe3RbbF1baF0mJihvW2RdXj11KTt1Pj49MTtpZighdSl7dT0xMjg7ZCsrfX1mKz1pfWJyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEpiaWcyRXJyb3IoYG9wZXJhdG9yICR7c30gaXMgbm90IHN1cHBvcnRlZGApfX1vbkltbWVkaWF0ZUdlbmVyaWNSZWdpb24oZSx0LGEscil7Y29uc3Qgbj1lLmluZm8saT1uZXcgRGVjb2RpbmdDb250ZXh0KHQsYSxyKSxzPWRlY29kZUJpdG1hcChlLm1tcixuLndpZHRoLG4uaGVpZ2h0LGUudGVtcGxhdGUsZS5wcmVkaWN0aW9uLG51bGwsZS5hdCxpKTt0aGlzLmRyYXdCaXRtYXAobixzKX1vbkltbWVkaWF0ZUxvc3NsZXNzR2VuZXJpY1JlZ2lvbigpe3RoaXMub25JbW1lZGlhdGVHZW5lcmljUmVnaW9uKC4uLmFyZ3VtZW50cyl9b25TeW1ib2xEaWN0aW9uYXJ5KGUsdCxhLHIsaSxzKXtsZXQgbyxjO2lmKGUuaHVmZm1hbil7bz1mdW5jdGlvbiBnZXRTeW1ib2xEaWN0aW9uYXJ5SHVmZm1hblRhYmxlcyhlLHQsYSl7bGV0IHIsbixpLHMsbz0wO3N3aXRjaChlLmh1ZmZtYW5ESFNlbGVjdG9yKXtjYXNlIDA6Y2FzZSAxOnI9Z2V0U3RhbmRhcmRUYWJsZShlLmh1ZmZtYW5ESFNlbGVjdG9yKzQpO2JyZWFrO2Nhc2UgMzpyPWdldEN1c3RvbUh1ZmZtYW5UYWJsZShvLHQsYSk7bysrO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEpiaWcyRXJyb3IoImludmFsaWQgSHVmZm1hbiBESCBzZWxlY3RvciIpfXN3aXRjaChlLmh1ZmZtYW5EV1NlbGVjdG9yKXtjYXNlIDA6Y2FzZSAxOm49Z2V0U3RhbmRhcmRUYWJsZShlLmh1ZmZtYW5EV1NlbGVjdG9yKzIpO2JyZWFrO2Nhc2UgMzpuPWdldEN1c3RvbUh1ZmZtYW5UYWJsZShvLHQsYSk7bysrO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEpiaWcyRXJyb3IoImludmFsaWQgSHVmZm1hbiBEVyBzZWxlY3RvciIpfWlmKGUuYml0bWFwU2l6ZVNlbGVjdG9yKXtpPWdldEN1c3RvbUh1ZmZtYW5UYWJsZShvLHQsYSk7bysrfWVsc2UgaT1nZXRTdGFuZGFyZFRhYmxlKDEpO3M9ZS5hZ2dyZWdhdGlvbkluc3RhbmNlc1NlbGVjdG9yP2dldEN1c3RvbUh1ZmZtYW5UYWJsZShvLHQsYSk6Z2V0U3RhbmRhcmRUYWJsZSgxKTtyZXR1cm57dGFibGVEZWx0YUhlaWdodDpyLHRhYmxlRGVsdGFXaWR0aDpuLHRhYmxlQml0bWFwU2l6ZTppLHRhYmxlQWdncmVnYXRlSW5zdGFuY2VzOnN9fShlLGEsdGhpcy5jdXN0b21UYWJsZXMpO2M9bmV3IFJlYWRlcihyLGkscyl9bGV0IGw9dGhpcy5zeW1ib2xzO2x8fCh0aGlzLnN5bWJvbHM9bD17fSk7Y29uc3QgaD1bXTtmb3IoY29uc3QgZSBvZiBhKXtjb25zdCB0PWxbZV07dCYmaC5wdXNoKC4uLnQpfWNvbnN0IHU9bmV3IERlY29kaW5nQ29udGV4dChyLGkscyk7bFt0XT1mdW5jdGlvbiBkZWNvZGVTeW1ib2xEaWN0aW9uYXJ5KGUsdCxhLHIsaSxzLG8sYyxsLGgsdSxkKXtpZihlJiZ0KXRocm93IG5ldyBKYmlnMkVycm9yKCJzeW1ib2wgcmVmaW5lbWVudCB3aXRoIEh1ZmZtYW4gaXMgbm90IHN1cHBvcnRlZCIpO2NvbnN0IGY9W107bGV0IGc9MCxwPSgwLG4ubG9nMikoYS5sZW5ndGgrcik7Y29uc3QgbT11LmRlY29kZXIsYj11LmNvbnRleHRDYWNoZTtsZXQgeSx3O2lmKGUpe3k9Z2V0U3RhbmRhcmRUYWJsZSgxKTt3PVtdO3A9TWF0aC5tYXgocCwxKX1mb3IoO2YubGVuZ3RoPHI7KXtnKz1lP3MudGFibGVEZWx0YUhlaWdodC5kZWNvZGUoZCk6ZGVjb2RlSW50ZWdlcihiLCJJQURIIixtKTtsZXQgcj0wLG49MDtjb25zdCBpPWU/dy5sZW5ndGg6MDtmb3IoOzspe2NvbnN0IGk9ZT9zLnRhYmxlRGVsdGFXaWR0aC5kZWNvZGUoZCk6ZGVjb2RlSW50ZWdlcihiLCJJQURXIixtKTtpZihudWxsPT09aSlicmVhaztyKz1pO24rPXI7bGV0IHk7aWYodCl7Y29uc3Qgbj1kZWNvZGVJbnRlZ2VyKGIsIklBQUkiLG0pO2lmKG4+MSl5PWRlY29kZVRleHRSZWdpb24oZSx0LHIsZywwLG4sMSxhLmNvbmNhdChmKSxwLDAsMCwxLDAscyxsLGgsdSwwLGQpO2Vsc2V7Y29uc3QgZT1kZWNvZGVJQUlEKGIsbSxwKSx0PWRlY29kZUludGVnZXIoYiwiSUFSRFgiLG0pLG49ZGVjb2RlSW50ZWdlcihiLCJJQVJEWSIsbSk7eT1kZWNvZGVSZWZpbmVtZW50KHIsZyxsLGU8YS5sZW5ndGg/YVtlXTpmW2UtYS5sZW5ndGhdLHQsbiwhMSxoLHUpfWYucHVzaCh5KX1lbHNlIGlmKGUpdy5wdXNoKHIpO2Vsc2V7eT1kZWNvZGVCaXRtYXAoITEscixnLG8sITEsbnVsbCxjLHUpO2YucHVzaCh5KX19aWYoZSYmIXQpe2NvbnN0IGU9cy50YWJsZUJpdG1hcFNpemUuZGVjb2RlKGQpO2QuYnl0ZUFsaWduKCk7bGV0IHQ7aWYoMD09PWUpdD1yZWFkVW5jb21wcmVzc2VkQml0bWFwKGQsbixnKTtlbHNle2NvbnN0IGE9ZC5lbmQscj1kLnBvc2l0aW9uK2U7ZC5lbmQ9cjt0PWRlY29kZU1NUkJpdG1hcChkLG4sZywhMSk7ZC5lbmQ9YTtkLnBvc2l0aW9uPXJ9Y29uc3QgYT13Lmxlbmd0aDtpZihpPT09YS0xKWYucHVzaCh0KTtlbHNle2xldCBlLHIsbixzLG8sYz0wO2ZvcihlPWk7ZTxhO2UrKyl7cz13W2VdO249YytzO289W107Zm9yKHI9MDtyPGc7cisrKW8ucHVzaCh0W3JdLnN1YmFycmF5KGMsbikpO2YucHVzaChvKTtjPW59fX19Y29uc3QgUz1bXSx4PVtdO2xldCBrLEMsdj0hMTtjb25zdCBGPWEubGVuZ3RoK3I7Zm9yKDt4Lmxlbmd0aDxGOyl7bGV0IHQ9ZT95LmRlY29kZShkKTpkZWNvZGVJbnRlZ2VyKGIsIklBRVgiLG0pO2Zvcig7dC0tOyl4LnB1c2godik7dj0hdn1mb3Ioaz0wLEM9YS5sZW5ndGg7azxDO2srKyl4W2tdJiZTLnB1c2goYVtrXSk7Zm9yKGxldCBlPTA7ZTxyO2srKyxlKyspeFtrXSYmUy5wdXNoKGZbZV0pO3JldHVybiBTfShlLmh1ZmZtYW4sZS5yZWZpbmVtZW50LGgsZS5udW1iZXJPZk5ld1N5bWJvbHMsZS5udW1iZXJPZkV4cG9ydGVkU3ltYm9scyxvLGUudGVtcGxhdGUsZS5hdCxlLnJlZmluZW1lbnRUZW1wbGF0ZSxlLnJlZmluZW1lbnRBdCx1LGMpfW9uSW1tZWRpYXRlVGV4dFJlZ2lvbihlLHQsYSxyLGkpe2NvbnN0IHM9ZS5pbmZvO2xldCBvLGM7Y29uc3QgbD10aGlzLnN5bWJvbHMsaD1bXTtmb3IoY29uc3QgZSBvZiB0KXtjb25zdCB0PWxbZV07dCYmaC5wdXNoKC4uLnQpfWNvbnN0IHU9KDAsbi5sb2cyKShoLmxlbmd0aCk7aWYoZS5odWZmbWFuKXtjPW5ldyBSZWFkZXIoYSxyLGkpO289ZnVuY3Rpb24gZ2V0VGV4dFJlZ2lvbkh1ZmZtYW5UYWJsZXMoZSx0LGEscixuKXtjb25zdCBpPVtdO2ZvcihsZXQgZT0wO2U8PTM0O2UrKyl7Y29uc3QgdD1uLnJlYWRCaXRzKDQpO2kucHVzaChuZXcgSHVmZm1hbkxpbmUoW2UsdCwwLDBdKSl9Y29uc3Qgcz1uZXcgSHVmZm1hblRhYmxlKGksITEpO2kubGVuZ3RoPTA7Zm9yKGxldCBlPTA7ZTxyOyl7Y29uc3QgdD1zLmRlY29kZShuKTtpZih0Pj0zMil7bGV0IGEscixzO3N3aXRjaCh0KXtjYXNlIDMyOmlmKDA9PT1lKXRocm93IG5ldyBKYmlnMkVycm9yKCJubyBwcmV2aW91cyB2YWx1ZSBpbiBzeW1ib2wgSUQgdGFibGUiKTtyPW4ucmVhZEJpdHMoMikrMzthPWlbZS0xXS5wcmVmaXhMZW5ndGg7YnJlYWs7Y2FzZSAzMzpyPW4ucmVhZEJpdHMoMykrMzthPTA7YnJlYWs7Y2FzZSAzNDpyPW4ucmVhZEJpdHMoNykrMTE7YT0wO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEpiaWcyRXJyb3IoImludmFsaWQgY29kZSBsZW5ndGggaW4gc3ltYm9sIElEIHRhYmxlIil9Zm9yKHM9MDtzPHI7cysrKXtpLnB1c2gobmV3IEh1ZmZtYW5MaW5lKFtlLGEsMCwwXSkpO2UrK319ZWxzZXtpLnB1c2gobmV3IEh1ZmZtYW5MaW5lKFtlLHQsMCwwXSkpO2UrK319bi5ieXRlQWxpZ24oKTtjb25zdCBvPW5ldyBIdWZmbWFuVGFibGUoaSwhMSk7bGV0IGMsbCxoLHU9MDtzd2l0Y2goZS5odWZmbWFuRlMpe2Nhc2UgMDpjYXNlIDE6Yz1nZXRTdGFuZGFyZFRhYmxlKGUuaHVmZm1hbkZTKzYpO2JyZWFrO2Nhc2UgMzpjPWdldEN1c3RvbUh1ZmZtYW5UYWJsZSh1LHQsYSk7dSsrO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEpiaWcyRXJyb3IoImludmFsaWQgSHVmZm1hbiBGUyBzZWxlY3RvciIpfXN3aXRjaChlLmh1ZmZtYW5EUyl7Y2FzZSAwOmNhc2UgMTpjYXNlIDI6bD1nZXRTdGFuZGFyZFRhYmxlKGUuaHVmZm1hbkRTKzgpO2JyZWFrO2Nhc2UgMzpsPWdldEN1c3RvbUh1ZmZtYW5UYWJsZSh1LHQsYSk7dSsrO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEpiaWcyRXJyb3IoImludmFsaWQgSHVmZm1hbiBEUyBzZWxlY3RvciIpfXN3aXRjaChlLmh1ZmZtYW5EVCl7Y2FzZSAwOmNhc2UgMTpjYXNlIDI6aD1nZXRTdGFuZGFyZFRhYmxlKGUuaHVmZm1hbkRUKzExKTticmVhaztjYXNlIDM6aD1nZXRDdXN0b21IdWZmbWFuVGFibGUodSx0LGEpO3UrKzticmVhaztkZWZhdWx0OnRocm93IG5ldyBKYmlnMkVycm9yKCJpbnZhbGlkIEh1ZmZtYW4gRFQgc2VsZWN0b3IiKX1pZihlLnJlZmluZW1lbnQpdGhyb3cgbmV3IEpiaWcyRXJyb3IoInJlZmluZW1lbnQgd2l0aCBIdWZmbWFuIGlzIG5vdCBzdXBwb3J0ZWQiKTtyZXR1cm57c3ltYm9sSURUYWJsZTpvLHRhYmxlRmlyc3RTOmMsdGFibGVEZWx0YVM6bCx0YWJsZURlbHRhVDpofX0oZSx0LHRoaXMuY3VzdG9tVGFibGVzLGgubGVuZ3RoLGMpfWNvbnN0IGQ9bmV3IERlY29kaW5nQ29udGV4dChhLHIsaSksZj1kZWNvZGVUZXh0UmVnaW9uKGUuaHVmZm1hbixlLnJlZmluZW1lbnQscy53aWR0aCxzLmhlaWdodCxlLmRlZmF1bHRQaXhlbFZhbHVlLGUubnVtYmVyT2ZTeW1ib2xJbnN0YW5jZXMsZS5zdHJpcFNpemUsaCx1LGUudHJhbnNwb3NlZCxlLmRzT2Zmc2V0LGUucmVmZXJlbmNlQ29ybmVyLGUuY29tYmluYXRpb25PcGVyYXRvcixvLGUucmVmaW5lbWVudFRlbXBsYXRlLGUucmVmaW5lbWVudEF0LGQsZS5sb2dTdHJpcFNpemUsYyk7dGhpcy5kcmF3Qml0bWFwKHMsZil9b25JbW1lZGlhdGVMb3NzbGVzc1RleHRSZWdpb24oKXt0aGlzLm9uSW1tZWRpYXRlVGV4dFJlZ2lvbiguLi5hcmd1bWVudHMpfW9uUGF0dGVybkRpY3Rpb25hcnkoZSx0LGEscixuKXtsZXQgaT10aGlzLnBhdHRlcm5zO2l8fCh0aGlzLnBhdHRlcm5zPWk9e30pO2NvbnN0IHM9bmV3IERlY29kaW5nQ29udGV4dChhLHIsbik7aVt0XT1mdW5jdGlvbiBkZWNvZGVQYXR0ZXJuRGljdGlvbmFyeShlLHQsYSxyLG4saSl7Y29uc3Qgcz1bXTtpZighZSl7cy5wdXNoKHt4Oi10LHk6MH0pOzA9PT1uJiZzLnB1c2goe3g6LTMseTotMX0se3g6Mix5Oi0yfSx7eDotMix5Oi0yfSl9Y29uc3Qgbz1kZWNvZGVCaXRtYXAoZSwocisxKSp0LGEsbiwhMSxudWxsLHMsaSksYz1bXTtmb3IobGV0IGU9MDtlPD1yO2UrKyl7Y29uc3Qgcj1bXSxuPXQqZSxpPW4rdDtmb3IobGV0IGU9MDtlPGE7ZSsrKXIucHVzaChvW2VdLnN1YmFycmF5KG4saSkpO2MucHVzaChyKX1yZXR1cm4gY30oZS5tbXIsZS5wYXR0ZXJuV2lkdGgsZS5wYXR0ZXJuSGVpZ2h0LGUubWF4UGF0dGVybkluZGV4LGUudGVtcGxhdGUscyl9b25JbW1lZGlhdGVIYWxmdG9uZVJlZ2lvbihlLHQsYSxyLGkpe2NvbnN0IHM9dGhpcy5wYXR0ZXJuc1t0WzBdXSxvPWUuaW5mbyxjPW5ldyBEZWNvZGluZ0NvbnRleHQoYSxyLGkpLGw9ZnVuY3Rpb24gZGVjb2RlSGFsZnRvbmVSZWdpb24oZSx0LGEscixpLHMsbyxjLGwsaCx1LGQsZixnLHApe2lmKG8pdGhyb3cgbmV3IEpiaWcyRXJyb3IoInNraXAgaXMgbm90IHN1cHBvcnRlZCIpO2lmKDAhPT1jKXRocm93IG5ldyBKYmlnMkVycm9yKGBvcGVyYXRvciAiJHtjfSIgaXMgbm90IHN1cHBvcnRlZCBpbiBoYWxmdG9uZSByZWdpb25gKTtjb25zdCBtPVtdO2xldCBiLHksdztmb3IoYj0wO2I8aTtiKyspe3c9bmV3IFVpbnQ4QXJyYXkocik7aWYocylmb3IoeT0wO3k8cjt5Kyspd1t5XT1zO20ucHVzaCh3KX1jb25zdCBTPXQubGVuZ3RoLHg9dFswXSxrPXhbMF0ubGVuZ3RoLEM9eC5sZW5ndGgsdj0oMCxuLmxvZzIpKFMpLEY9W107aWYoIWUpe0YucHVzaCh7eDphPD0xPzM6Mix5Oi0xfSk7MD09PWEmJkYucHVzaCh7eDotMyx5Oi0xfSx7eDoyLHk6LTJ9LHt4Oi0yLHk6LTJ9KX1jb25zdCBPPVtdO2xldCBULE0sRSxELE4sUixMLGosJCxfLFU7ZSYmKFQ9bmV3IFJlYWRlcihwLmRhdGEscC5zdGFydCxwLmVuZCkpO2ZvcihiPXYtMTtiPj0wO2ItLSl7TT1lP2RlY29kZU1NUkJpdG1hcChULGwsaCwhMCk6ZGVjb2RlQml0bWFwKCExLGwsaCxhLCExLG51bGwsRixwKTtPW2JdPU19Zm9yKEU9MDtFPGg7RSsrKWZvcihEPTA7RDxsO0QrKyl7Tj0wO1I9MDtmb3IoeT12LTE7eT49MDt5LS0pe05ePU9beV1bRV1bRF07Unw9Tjw8eX1MPXRbUl07aj11K0UqZytEKmY+Pjg7JD1kK0UqZi1EKmc+Pjg7aWYoaj49MCYmaitrPD1yJiYkPj0wJiYkK0M8PWkpZm9yKGI9MDtiPEM7YisrKXtVPW1bJCtiXTtfPUxbYl07Zm9yKHk9MDt5PGs7eSsrKVVbait5XXw9X1t5XX1lbHNle2xldCBlLHQ7Zm9yKGI9MDtiPEM7YisrKXt0PSQrYjtpZighKHQ8MHx8dD49aSkpe1U9bVt0XTtfPUxbYl07Zm9yKHk9MDt5PGs7eSsrKXtlPWoreTtlPj0wJiZlPHImJihVW2VdfD1fW3ldKX19fX19cmV0dXJuIG19KGUubW1yLHMsZS50ZW1wbGF0ZSxvLndpZHRoLG8uaGVpZ2h0LGUuZGVmYXVsdFBpeGVsVmFsdWUsZS5lbmFibGVTa2lwLGUuY29tYmluYXRpb25PcGVyYXRvcixlLmdyaWRXaWR0aCxlLmdyaWRIZWlnaHQsZS5ncmlkT2Zmc2V0WCxlLmdyaWRPZmZzZXRZLGUuZ3JpZFZlY3RvclgsZS5ncmlkVmVjdG9yWSxjKTt0aGlzLmRyYXdCaXRtYXAobyxsKX1vbkltbWVkaWF0ZUxvc3NsZXNzSGFsZnRvbmVSZWdpb24oKXt0aGlzLm9uSW1tZWRpYXRlSGFsZnRvbmVSZWdpb24oLi4uYXJndW1lbnRzKX1vblRhYmxlcyhlLHQsYSxyKXtsZXQgaT10aGlzLmN1c3RvbVRhYmxlcztpfHwodGhpcy5jdXN0b21UYWJsZXM9aT17fSk7aVtlXT1mdW5jdGlvbiBkZWNvZGVUYWJsZXNTZWdtZW50KGUsdCxhKXtjb25zdCByPWVbdF0saT00Mjk0OTY3Mjk1JigwLG4ucmVhZFVpbnQzMikoZSx0KzEpLHM9NDI5NDk2NzI5NSYoMCxuLnJlYWRVaW50MzIpKGUsdCs1KSxvPW5ldyBSZWFkZXIoZSx0KzksYSksYz0xKyhyPj4xJjcpLGw9MSsocj4+NCY3KSxoPVtdO2xldCB1LGQsZj1pO2Rve3U9by5yZWFkQml0cyhjKTtkPW8ucmVhZEJpdHMobCk7aC5wdXNoKG5ldyBIdWZmbWFuTGluZShbZix1LGQsMF0pKTtmKz0xPDxkfXdoaWxlKGY8cyk7dT1vLnJlYWRCaXRzKGMpO2gucHVzaChuZXcgSHVmZm1hbkxpbmUoW2ktMSx1LDMyLDAsImxvd2VyIl0pKTt1PW8ucmVhZEJpdHMoYyk7aC5wdXNoKG5ldyBIdWZmbWFuTGluZShbcyx1LDMyLDBdKSk7aWYoMSZyKXt1PW8ucmVhZEJpdHMoYyk7aC5wdXNoKG5ldyBIdWZmbWFuTGluZShbdSwwXSkpfXJldHVybiBuZXcgSHVmZm1hblRhYmxlKGgsITEpfSh0LGEscil9fWNsYXNzIEh1ZmZtYW5MaW5le2NvbnN0cnVjdG9yKGUpe2lmKDI9PT1lLmxlbmd0aCl7dGhpcy5pc09PQj0hMDt0aGlzLnJhbmdlTG93PTA7dGhpcy5wcmVmaXhMZW5ndGg9ZVswXTt0aGlzLnJhbmdlTGVuZ3RoPTA7dGhpcy5wcmVmaXhDb2RlPWVbMV07dGhpcy5pc0xvd2VyUmFuZ2U9ITF9ZWxzZXt0aGlzLmlzT09CPSExO3RoaXMucmFuZ2VMb3c9ZVswXTt0aGlzLnByZWZpeExlbmd0aD1lWzFdO3RoaXMucmFuZ2VMZW5ndGg9ZVsyXTt0aGlzLnByZWZpeENvZGU9ZVszXTt0aGlzLmlzTG93ZXJSYW5nZT0ibG93ZXIiPT09ZVs0XX19fWNsYXNzIEh1ZmZtYW5UcmVlTm9kZXtjb25zdHJ1Y3RvcihlKXt0aGlzLmNoaWxkcmVuPVtdO2lmKGUpe3RoaXMuaXNMZWFmPSEwO3RoaXMucmFuZ2VMZW5ndGg9ZS5yYW5nZUxlbmd0aDt0aGlzLnJhbmdlTG93PWUucmFuZ2VMb3c7dGhpcy5pc0xvd2VyUmFuZ2U9ZS5pc0xvd2VyUmFuZ2U7dGhpcy5pc09PQj1lLmlzT09CfWVsc2UgdGhpcy5pc0xlYWY9ITF9YnVpbGRUcmVlKGUsdCl7Y29uc3QgYT1lLnByZWZpeENvZGU+PnQmMTtpZih0PD0wKXRoaXMuY2hpbGRyZW5bYV09bmV3IEh1ZmZtYW5UcmVlTm9kZShlKTtlbHNle2xldCByPXRoaXMuY2hpbGRyZW5bYV07cnx8KHRoaXMuY2hpbGRyZW5bYV09cj1uZXcgSHVmZm1hblRyZWVOb2RlKG51bGwpKTtyLmJ1aWxkVHJlZShlLHQtMSl9fWRlY29kZU5vZGUoZSl7aWYodGhpcy5pc0xlYWYpe2lmKHRoaXMuaXNPT0IpcmV0dXJuIG51bGw7Y29uc3QgdD1lLnJlYWRCaXRzKHRoaXMucmFuZ2VMZW5ndGgpO3JldHVybiB0aGlzLnJhbmdlTG93Kyh0aGlzLmlzTG93ZXJSYW5nZT8tdDp0KX1jb25zdCB0PXRoaXMuY2hpbGRyZW5bZS5yZWFkQml0KCldO2lmKCF0KXRocm93IG5ldyBKYmlnMkVycm9yKCJpbnZhbGlkIEh1ZmZtYW4gZGF0YSIpO3JldHVybiB0LmRlY29kZU5vZGUoZSl9fWNsYXNzIEh1ZmZtYW5UYWJsZXtjb25zdHJ1Y3RvcihlLHQpe3R8fHRoaXMuYXNzaWduUHJlZml4Q29kZXMoZSk7dGhpcy5yb290Tm9kZT1uZXcgSHVmZm1hblRyZWVOb2RlKG51bGwpO2ZvcihsZXQgdD0wLGE9ZS5sZW5ndGg7dDxhO3QrKyl7Y29uc3QgYT1lW3RdO2EucHJlZml4TGVuZ3RoPjAmJnRoaXMucm9vdE5vZGUuYnVpbGRUcmVlKGEsYS5wcmVmaXhMZW5ndGgtMSl9fWRlY29kZShlKXtyZXR1cm4gdGhpcy5yb290Tm9kZS5kZWNvZGVOb2RlKGUpfWFzc2lnblByZWZpeENvZGVzKGUpe2NvbnN0IHQ9ZS5sZW5ndGg7bGV0IGE9MDtmb3IobGV0IHI9MDtyPHQ7cisrKWE9TWF0aC5tYXgoYSxlW3JdLnByZWZpeExlbmd0aCk7Y29uc3Qgcj1uZXcgVWludDMyQXJyYXkoYSsxKTtmb3IobGV0IGE9MDthPHQ7YSsrKXJbZVthXS5wcmVmaXhMZW5ndGhdKys7bGV0IG4saSxzLG89MSxjPTA7clswXT0wO2Zvcig7bzw9YTspe2M9YytyW28tMV08PDE7bj1jO2k9MDtmb3IoO2k8dDspe3M9ZVtpXTtpZihzLnByZWZpeExlbmd0aD09PW8pe3MucHJlZml4Q29kZT1uO24rK31pKyt9bysrfX19Y29uc3QgZj17fTtmdW5jdGlvbiBnZXRTdGFuZGFyZFRhYmxlKGUpe2xldCB0LGE9ZltlXTtpZihhKXJldHVybiBhO3N3aXRjaChlKXtjYXNlIDE6dD1bWzAsMSw0LDBdLFsxNiwyLDgsMl0sWzI3MiwzLDE2LDZdLFs2NTgwOCwzLDMyLDddXTticmVhaztjYXNlIDI6dD1bWzAsMSwwLDBdLFsxLDIsMCwyXSxbMiwzLDAsNl0sWzMsNCwzLDE0XSxbMTEsNSw2LDMwXSxbNzUsNiwzMiw2Ml0sWzYsNjNdXTticmVhaztjYXNlIDM6dD1bWy0yNTYsOCw4LDI1NF0sWzAsMSwwLDBdLFsxLDIsMCwyXSxbMiwzLDAsNl0sWzMsNCwzLDE0XSxbMTEsNSw2LDMwXSxbLTI1Nyw4LDMyLDI1NSwibG93ZXIiXSxbNzUsNywzMiwxMjZdLFs2LDYyXV07YnJlYWs7Y2FzZSA0OnQ9W1sxLDEsMCwwXSxbMiwyLDAsMl0sWzMsMywwLDZdLFs0LDQsMywxNF0sWzEyLDUsNiwzMF0sWzc2LDUsMzIsMzFdXTticmVhaztjYXNlIDU6dD1bWy0yNTUsNyw4LDEyNl0sWzEsMSwwLDBdLFsyLDIsMCwyXSxbMywzLDAsNl0sWzQsNCwzLDE0XSxbMTIsNSw2LDMwXSxbLTI1Niw3LDMyLDEyNywibG93ZXIiXSxbNzYsNiwzMiw2Ml1dO2JyZWFrO2Nhc2UgNjp0PVtbLTIwNDgsNSwxMCwyOF0sWy0xMDI0LDQsOSw4XSxbLTUxMiw0LDgsOV0sWy0yNTYsNCw3LDEwXSxbLTEyOCw1LDYsMjldLFstNjQsNSw1LDMwXSxbLTMyLDQsNSwxMV0sWzAsMiw3LDBdLFsxMjgsMyw3LDJdLFsyNTYsMyw4LDNdLFs1MTIsNCw5LDEyXSxbMTAyNCw0LDEwLDEzXSxbLTIwNDksNiwzMiw2MiwibG93ZXIiXSxbMjA0OCw2LDMyLDYzXV07YnJlYWs7Y2FzZSA3OnQ9W1stMTAyNCw0LDksOF0sWy01MTIsMyw4LDBdLFstMjU2LDQsNyw5XSxbLTEyOCw1LDYsMjZdLFstNjQsNSw1LDI3XSxbLTMyLDQsNSwxMF0sWzAsNCw1LDExXSxbMzIsNSw1LDI4XSxbNjQsNSw2LDI5XSxbMTI4LDQsNywxMl0sWzI1NiwzLDgsMV0sWzUxMiwzLDksMl0sWzEwMjQsMywxMCwzXSxbLTEwMjUsNSwzMiwzMCwibG93ZXIiXSxbMjA0OCw1LDMyLDMxXV07YnJlYWs7Y2FzZSA4OnQ9W1stMTUsOCwzLDI1Ml0sWy03LDksMSw1MDhdLFstNSw4LDEsMjUzXSxbLTMsOSwwLDUwOV0sWy0yLDcsMCwxMjRdLFstMSw0LDAsMTBdLFswLDIsMSwwXSxbMiw1LDAsMjZdLFszLDYsMCw1OF0sWzQsMyw0LDRdLFsyMCw2LDEsNTldLFsyMiw0LDQsMTFdLFszOCw0LDUsMTJdLFs3MCw1LDYsMjddLFsxMzQsNSw3LDI4XSxbMjYyLDYsNyw2MF0sWzM5MCw3LDgsMTI1XSxbNjQ2LDYsMTAsNjFdLFstMTYsOSwzMiw1MTAsImxvd2VyIl0sWzE2NzAsOSwzMiw1MTFdLFsyLDFdXTticmVhaztjYXNlIDk6dD1bWy0zMSw4LDQsMjUyXSxbLTE1LDksMiw1MDhdLFstMTEsOCwyLDI1M10sWy03LDksMSw1MDldLFstNSw3LDEsMTI0XSxbLTMsNCwxLDEwXSxbLTEsMywxLDJdLFsxLDMsMSwzXSxbMyw1LDEsMjZdLFs1LDYsMSw1OF0sWzcsMyw1LDRdLFszOSw2LDIsNTldLFs0Myw0LDUsMTFdLFs3NSw0LDYsMTJdLFsxMzksNSw3LDI3XSxbMjY3LDUsOCwyOF0sWzUyMyw2LDgsNjBdLFs3NzksNyw5LDEyNV0sWzEyOTEsNiwxMSw2MV0sWy0zMiw5LDMyLDUxMCwibG93ZXIiXSxbMzMzOSw5LDMyLDUxMV0sWzIsMF1dO2JyZWFrO2Nhc2UgMTA6dD1bWy0yMSw3LDQsMTIyXSxbLTUsOCwwLDI1Ml0sWy00LDcsMCwxMjNdLFstMyw1LDAsMjRdLFstMiwyLDIsMF0sWzIsNSwwLDI1XSxbMyw2LDAsNTRdLFs0LDcsMCwxMjRdLFs1LDgsMCwyNTNdLFs2LDIsNiwxXSxbNzAsNSw1LDI2XSxbMTAyLDYsNSw1NV0sWzEzNCw2LDYsNTZdLFsxOTgsNiw3LDU3XSxbMzI2LDYsOCw1OF0sWzU4Miw2LDksNTldLFsxMDk0LDYsMTAsNjBdLFsyMTE4LDcsMTEsMTI1XSxbLTIyLDgsMzIsMjU0LCJsb3dlciJdLFs0MTY2LDgsMzIsMjU1XSxbMiwyXV07YnJlYWs7Y2FzZSAxMTp0PVtbMSwxLDAsMF0sWzIsMiwxLDJdLFs0LDQsMCwxMl0sWzUsNCwxLDEzXSxbNyw1LDEsMjhdLFs5LDUsMiwyOV0sWzEzLDYsMiw2MF0sWzE3LDcsMiwxMjJdLFsyMSw3LDMsMTIzXSxbMjksNyw0LDEyNF0sWzQ1LDcsNSwxMjVdLFs3Nyw3LDYsMTI2XSxbMTQxLDcsMzIsMTI3XV07YnJlYWs7Y2FzZSAxMjp0PVtbMSwxLDAsMF0sWzIsMiwwLDJdLFszLDMsMSw2XSxbNSw1LDAsMjhdLFs2LDUsMSwyOV0sWzgsNiwxLDYwXSxbMTAsNywwLDEyMl0sWzExLDcsMSwxMjNdLFsxMyw3LDIsMTI0XSxbMTcsNywzLDEyNV0sWzI1LDcsNCwxMjZdLFs0MSw4LDUsMjU0XSxbNzMsOCwzMiwyNTVdXTticmVhaztjYXNlIDEzOnQ9W1sxLDEsMCwwXSxbMiwzLDAsNF0sWzMsNCwwLDEyXSxbNCw1LDAsMjhdLFs1LDQsMSwxM10sWzcsMywzLDVdLFsxNSw2LDEsNThdLFsxNyw2LDIsNTldLFsyMSw2LDMsNjBdLFsyOSw2LDQsNjFdLFs0NSw2LDUsNjJdLFs3Nyw3LDYsMTI2XSxbMTQxLDcsMzIsMTI3XV07YnJlYWs7Y2FzZSAxNDp0PVtbLTIsMywwLDRdLFstMSwzLDAsNV0sWzAsMSwwLDBdLFsxLDMsMCw2XSxbMiwzLDAsN11dO2JyZWFrO2Nhc2UgMTU6dD1bWy0yNCw3LDQsMTI0XSxbLTgsNiwyLDYwXSxbLTQsNSwxLDI4XSxbLTIsNCwwLDEyXSxbLTEsMywwLDRdLFswLDEsMCwwXSxbMSwzLDAsNV0sWzIsNCwwLDEzXSxbMyw1LDEsMjldLFs1LDYsMiw2MV0sWzksNyw0LDEyNV0sWy0yNSw3LDMyLDEyNiwibG93ZXIiXSxbMjUsNywzMiwxMjddXTticmVhaztkZWZhdWx0OnRocm93IG5ldyBKYmlnMkVycm9yKGBzdGFuZGFyZCB0YWJsZSBCLiR7ZX0gZG9lcyBub3QgZXhpc3RgKX1mb3IobGV0IGU9MCxhPXQubGVuZ3RoO2U8YTtlKyspdFtlXT1uZXcgSHVmZm1hbkxpbmUodFtlXSk7YT1uZXcgSHVmZm1hblRhYmxlKHQsITApO2ZbZV09YTtyZXR1cm4gYX1jbGFzcyBSZWFkZXJ7Y29uc3RydWN0b3IoZSx0LGEpe3RoaXMuZGF0YT1lO3RoaXMuc3RhcnQ9dDt0aGlzLmVuZD1hO3RoaXMucG9zaXRpb249dDt0aGlzLnNoaWZ0PS0xO3RoaXMuY3VycmVudEJ5dGU9MH1yZWFkQml0KCl7aWYodGhpcy5zaGlmdDwwKXtpZih0aGlzLnBvc2l0aW9uPj10aGlzLmVuZCl0aHJvdyBuZXcgSmJpZzJFcnJvcigiZW5kIG9mIGRhdGEgd2hpbGUgcmVhZGluZyBiaXQiKTt0aGlzLmN1cnJlbnRCeXRlPXRoaXMuZGF0YVt0aGlzLnBvc2l0aW9uKytdO3RoaXMuc2hpZnQ9N31jb25zdCBlPXRoaXMuY3VycmVudEJ5dGU+PnRoaXMuc2hpZnQmMTt0aGlzLnNoaWZ0LS07cmV0dXJuIGV9cmVhZEJpdHMoZSl7bGV0IHQsYT0wO2Zvcih0PWUtMTt0Pj0wO3QtLSlhfD10aGlzLnJlYWRCaXQoKTw8dDtyZXR1cm4gYX1ieXRlQWxpZ24oKXt0aGlzLnNoaWZ0PS0xfW5leHQoKXtyZXR1cm4gdGhpcy5wb3NpdGlvbj49dGhpcy5lbmQ/LTE6dGhpcy5kYXRhW3RoaXMucG9zaXRpb24rK119fWZ1bmN0aW9uIGdldEN1c3RvbUh1ZmZtYW5UYWJsZShlLHQsYSl7bGV0IHI9MDtmb3IobGV0IG49MCxpPXQubGVuZ3RoO248aTtuKyspe2NvbnN0IGk9YVt0W25dXTtpZihpKXtpZihlPT09cilyZXR1cm4gaTtyKyt9fXRocm93IG5ldyBKYmlnMkVycm9yKCJjYW4ndCBmaW5kIGN1c3RvbSBIdWZmbWFuIHRhYmxlIil9ZnVuY3Rpb24gcmVhZFVuY29tcHJlc3NlZEJpdG1hcChlLHQsYSl7Y29uc3Qgcj1bXTtmb3IobGV0IG49MDtuPGE7bisrKXtjb25zdCBhPW5ldyBVaW50OEFycmF5KHQpO3IucHVzaChhKTtmb3IobGV0IHI9MDtyPHQ7cisrKWFbcl09ZS5yZWFkQml0KCk7ZS5ieXRlQWxpZ24oKX1yZXR1cm4gcn1mdW5jdGlvbiBkZWNvZGVNTVJCaXRtYXAoZSx0LGEscil7Y29uc3Qgbj17SzotMSxDb2x1bW5zOnQsUm93czphLEJsYWNrSXMxOiEwLEVuZE9mQmxvY2s6cn0saT1uZXcgcy5DQ0lUVEZheERlY29kZXIoZSxuKSxvPVtdO2xldCBjLGw9ITE7Zm9yKGxldCBlPTA7ZTxhO2UrKyl7Y29uc3QgZT1uZXcgVWludDhBcnJheSh0KTtvLnB1c2goZSk7bGV0IGE9LTE7Zm9yKGxldCByPTA7cjx0O3IrKyl7aWYoYTwwKXtjPWkucmVhZE5leHRDaGFyKCk7aWYoLTE9PT1jKXtjPTA7bD0hMH1hPTd9ZVtyXT1jPj5hJjE7YS0tfX1pZihyJiYhbCl7Y29uc3QgZT01O2ZvcihsZXQgdD0wO3Q8ZSYmLTEhPT1pLnJlYWROZXh0Q2hhcigpO3QrKyk7fXJldHVybiBvfXQuSmJpZzJJbWFnZT1jbGFzcyBKYmlnMkltYWdle3BhcnNlQ2h1bmtzKGUpe3JldHVybiBmdW5jdGlvbiBwYXJzZUpiaWcyQ2h1bmtzKGUpe2NvbnN0IHQ9bmV3IFNpbXBsZVNlZ21lbnRWaXNpdG9yO2ZvcihsZXQgYT0wLHI9ZS5sZW5ndGg7YTxyO2ErKyl7Y29uc3Qgcj1lW2FdO3Byb2Nlc3NTZWdtZW50cyhyZWFkU2VnbWVudHMoe30sci5kYXRhLHIuc3RhcnQsci5lbmQpLHQpfXJldHVybiB0LmJ1ZmZlcn0oZSl9cGFyc2UoZSl7dGhyb3cgbmV3IEVycm9yKCJOb3QgaW1wbGVtZW50ZWQ6IEpiaWcySW1hZ2UucGFyc2UiKX19fSwoZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LkFyaXRobWV0aWNEZWNvZGVyPXZvaWQgMDtjb25zdCBhPVt7cWU6MjIwMTcsbm1wczoxLG5scHM6MSxzd2l0Y2hGbGFnOjF9LHtxZToxMzMxMyxubXBzOjIsbmxwczo2LHN3aXRjaEZsYWc6MH0se3FlOjYxNDUsbm1wczozLG5scHM6OSxzd2l0Y2hGbGFnOjB9LHtxZToyNzUzLG5tcHM6NCxubHBzOjEyLHN3aXRjaEZsYWc6MH0se3FlOjEzMTMsbm1wczo1LG5scHM6Mjksc3dpdGNoRmxhZzowfSx7cWU6NTQ1LG5tcHM6MzgsbmxwczozMyxzd2l0Y2hGbGFnOjB9LHtxZToyMjAxNyxubXBzOjcsbmxwczo2LHN3aXRjaEZsYWc6MX0se3FlOjIxNTA1LG5tcHM6OCxubHBzOjE0LHN3aXRjaEZsYWc6MH0se3FlOjE4NDMzLG5tcHM6OSxubHBzOjE0LHN3aXRjaEZsYWc6MH0se3FlOjE0MzM3LG5tcHM6MTAsbmxwczoxNCxzd2l0Y2hGbGFnOjB9LHtxZToxMjI4OSxubXBzOjExLG5scHM6MTcsc3dpdGNoRmxhZzowfSx7cWU6OTIxNyxubXBzOjEyLG5scHM6MTgsc3dpdGNoRmxhZzowfSx7cWU6NzE2OSxubXBzOjEzLG5scHM6MjAsc3dpdGNoRmxhZzowfSx7cWU6NTYzMyxubXBzOjI5LG5scHM6MjEsc3dpdGNoRmxhZzowfSx7cWU6MjIwMTcsbm1wczoxNSxubHBzOjE0LHN3aXRjaEZsYWc6MX0se3FlOjIxNTA1LG5tcHM6MTYsbmxwczoxNCxzd2l0Y2hGbGFnOjB9LHtxZToyMDczNyxubXBzOjE3LG5scHM6MTUsc3dpdGNoRmxhZzowfSx7cWU6MTg0MzMsbm1wczoxOCxubHBzOjE2LHN3aXRjaEZsYWc6MH0se3FlOjE0MzM3LG5tcHM6MTksbmxwczoxNyxzd2l0Y2hGbGFnOjB9LHtxZToxMzMxMyxubXBzOjIwLG5scHM6MTgsc3dpdGNoRmxhZzowfSx7cWU6MTIyODksbm1wczoyMSxubHBzOjE5LHN3aXRjaEZsYWc6MH0se3FlOjEwMjQxLG5tcHM6MjIsbmxwczoxOSxzd2l0Y2hGbGFnOjB9LHtxZTo5MjE3LG5tcHM6MjMsbmxwczoyMCxzd2l0Y2hGbGFnOjB9LHtxZTo4NzA1LG5tcHM6MjQsbmxwczoyMSxzd2l0Y2hGbGFnOjB9LHtxZTo3MTY5LG5tcHM6MjUsbmxwczoyMixzd2l0Y2hGbGFnOjB9LHtxZTo2MTQ1LG5tcHM6MjYsbmxwczoyMyxzd2l0Y2hGbGFnOjB9LHtxZTo1NjMzLG5tcHM6MjcsbmxwczoyNCxzd2l0Y2hGbGFnOjB9LHtxZTo1MTIxLG5tcHM6MjgsbmxwczoyNSxzd2l0Y2hGbGFnOjB9LHtxZTo0NjA5LG5tcHM6MjksbmxwczoyNixzd2l0Y2hGbGFnOjB9LHtxZTo0MzUzLG5tcHM6MzAsbmxwczoyNyxzd2l0Y2hGbGFnOjB9LHtxZToyNzUzLG5tcHM6MzEsbmxwczoyOCxzd2l0Y2hGbGFnOjB9LHtxZToyNDk3LG5tcHM6MzIsbmxwczoyOSxzd2l0Y2hGbGFnOjB9LHtxZToyMjA5LG5tcHM6MzMsbmxwczozMCxzd2l0Y2hGbGFnOjB9LHtxZToxMzEzLG5tcHM6MzQsbmxwczozMSxzd2l0Y2hGbGFnOjB9LHtxZToxMDg5LG5tcHM6MzUsbmxwczozMixzd2l0Y2hGbGFnOjB9LHtxZTo2NzMsbm1wczozNixubHBzOjMzLHN3aXRjaEZsYWc6MH0se3FlOjU0NSxubXBzOjM3LG5scHM6MzQsc3dpdGNoRmxhZzowfSx7cWU6MzIxLG5tcHM6MzgsbmxwczozNSxzd2l0Y2hGbGFnOjB9LHtxZToyNzMsbm1wczozOSxubHBzOjM2LHN3aXRjaEZsYWc6MH0se3FlOjEzMyxubXBzOjQwLG5scHM6Mzcsc3dpdGNoRmxhZzowfSx7cWU6NzMsbm1wczo0MSxubHBzOjM4LHN3aXRjaEZsYWc6MH0se3FlOjM3LG5tcHM6NDIsbmxwczozOSxzd2l0Y2hGbGFnOjB9LHtxZToyMSxubXBzOjQzLG5scHM6NDAsc3dpdGNoRmxhZzowfSx7cWU6OSxubXBzOjQ0LG5scHM6NDEsc3dpdGNoRmxhZzowfSx7cWU6NSxubXBzOjQ1LG5scHM6NDIsc3dpdGNoRmxhZzowfSx7cWU6MSxubXBzOjQ1LG5scHM6NDMsc3dpdGNoRmxhZzowfSx7cWU6MjIwMTcsbm1wczo0NixubHBzOjQ2LHN3aXRjaEZsYWc6MH1dO3QuQXJpdGhtZXRpY0RlY29kZXI9Y2xhc3MgQXJpdGhtZXRpY0RlY29kZXJ7Y29uc3RydWN0b3IoZSx0LGEpe3RoaXMuZGF0YT1lO3RoaXMuYnA9dDt0aGlzLmRhdGFFbmQ9YTt0aGlzLmNoaWdoPWVbdF07dGhpcy5jbG93PTA7dGhpcy5ieXRlSW4oKTt0aGlzLmNoaWdoPXRoaXMuY2hpZ2g8PDcmNjU1MzV8dGhpcy5jbG93Pj45JjEyNzt0aGlzLmNsb3c9dGhpcy5jbG93PDw3JjY1NTM1O3RoaXMuY3QtPTc7dGhpcy5hPTMyNzY4fWJ5dGVJbigpe2NvbnN0IGU9dGhpcy5kYXRhO2xldCB0PXRoaXMuYnA7aWYoMjU1PT09ZVt0XSlpZihlW3QrMV0+MTQzKXt0aGlzLmNsb3crPTY1MjgwO3RoaXMuY3Q9OH1lbHNle3QrKzt0aGlzLmNsb3crPWVbdF08PDk7dGhpcy5jdD03O3RoaXMuYnA9dH1lbHNle3QrKzt0aGlzLmNsb3crPXQ8dGhpcy5kYXRhRW5kP2VbdF08PDg6NjUyODA7dGhpcy5jdD04O3RoaXMuYnA9dH1pZih0aGlzLmNsb3c+NjU1MzUpe3RoaXMuY2hpZ2grPXRoaXMuY2xvdz4+MTY7dGhpcy5jbG93Jj02NTUzNX19cmVhZEJpdChlLHQpe2xldCByPWVbdF0+PjEsbj0xJmVbdF07Y29uc3QgaT1hW3JdLHM9aS5xZTtsZXQgbyxjPXRoaXMuYS1zO2lmKHRoaXMuY2hpZ2g8cylpZihjPHMpe2M9cztvPW47cj1pLm5tcHN9ZWxzZXtjPXM7bz0xXm47MT09PWkuc3dpdGNoRmxhZyYmKG49byk7cj1pLm5scHN9ZWxzZXt0aGlzLmNoaWdoLT1zO2lmKDAhPSgzMjc2OCZjKSl7dGhpcy5hPWM7cmV0dXJuIG59aWYoYzxzKXtvPTFebjsxPT09aS5zd2l0Y2hGbGFnJiYobj1vKTtyPWkubmxwc31lbHNle289bjtyPWkubm1wc319ZG97MD09PXRoaXMuY3QmJnRoaXMuYnl0ZUluKCk7Yzw8PTE7dGhpcy5jaGlnaD10aGlzLmNoaWdoPDwxJjY1NTM1fHRoaXMuY2xvdz4+MTUmMTt0aGlzLmNsb3c9dGhpcy5jbG93PDwxJjY1NTM1O3RoaXMuY3QtLX13aGlsZSgwPT0oMzI3NjgmYykpO3RoaXMuYT1jO2VbdF09cjw8MXxuO3JldHVybiBvfX19LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5KcGVnU3RyZWFtPXZvaWQgMDt2YXIgcj1hKDE5KSxuPWEoNSksaT1hKDI4KSxzPWEoMik7Y2xhc3MgSnBlZ1N0cmVhbSBleHRlbmRzIHIuRGVjb2RlU3RyZWFte2NvbnN0cnVjdG9yKGUsdCxhKXtsZXQgcjtmb3IoOy0xIT09KHI9ZS5nZXRCeXRlKCkpOylpZigyNTU9PT1yKXtlLnNraXAoLTEpO2JyZWFrfXN1cGVyKHQpO3RoaXMuc3RyZWFtPWU7dGhpcy5kaWN0PWUuZGljdDt0aGlzLm1heWJlTGVuZ3RoPXQ7dGhpcy5wYXJhbXM9YX1nZXQgYnl0ZXMoKXtyZXR1cm4oMCxzLnNoYWRvdykodGhpcywiYnl0ZXMiLHRoaXMuc3RyZWFtLmdldEJ5dGVzKHRoaXMubWF5YmVMZW5ndGgpKX1lbnN1cmVCdWZmZXIoZSl7fXJlYWRCbG9jaygpe2lmKHRoaXMuZW9mKXJldHVybjtjb25zdCBlPXtkZWNvZGVUcmFuc2Zvcm06dm9pZCAwLGNvbG9yVHJhbnNmb3JtOnZvaWQgMH0sdD10aGlzLmRpY3QuZ2V0QXJyYXkoIkQiLCJEZWNvZGUiKTtpZih0aGlzLmZvcmNlUkdCJiZBcnJheS5pc0FycmF5KHQpKXtjb25zdCBhPXRoaXMuZGljdC5nZXQoIkJQQyIsIkJpdHNQZXJDb21wb25lbnQiKXx8OCxyPXQubGVuZ3RoLG49bmV3IEludDMyQXJyYXkocik7bGV0IGk9ITE7Y29uc3Qgcz0oMTw8YSktMTtmb3IobGV0IGU9MDtlPHI7ZSs9Mil7bltlXT0yNTYqKHRbZSsxXS10W2VdKXwwO25bZSsxXT10W2VdKnN8MDsyNTY9PT1uW2VdJiYwPT09bltlKzFdfHwoaT0hMCl9aSYmKGUuZGVjb2RlVHJhbnNmb3JtPW4pfWlmKHRoaXMucGFyYW1zIGluc3RhbmNlb2Ygbi5EaWN0KXtjb25zdCB0PXRoaXMucGFyYW1zLmdldCgiQ29sb3JUcmFuc2Zvcm0iKTtOdW1iZXIuaXNJbnRlZ2VyKHQpJiYoZS5jb2xvclRyYW5zZm9ybT10KX1jb25zdCBhPW5ldyBpLkpwZWdJbWFnZShlKTthLnBhcnNlKHRoaXMuYnl0ZXMpO2NvbnN0IHI9YS5nZXREYXRhKHt3aWR0aDp0aGlzLmRyYXdXaWR0aCxoZWlnaHQ6dGhpcy5kcmF3SGVpZ2h0LGZvcmNlUkdCOnRoaXMuZm9yY2VSR0IsaXNTb3VyY2VQREY6ITB9KTt0aGlzLmJ1ZmZlcj1yO3RoaXMuYnVmZmVyTGVuZ3RoPXIubGVuZ3RoO3RoaXMuZW9mPSEwfX10LkpwZWdTdHJlYW09SnBlZ1N0cmVhbX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LkpwZWdJbWFnZT12b2lkIDA7dmFyIHI9YSgyKSxuPWEoNik7Y2xhc3MgSnBlZ0Vycm9yIGV4dGVuZHMgci5CYXNlRXhjZXB0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGBKUEVHIGVycm9yOiAke2V9YCwiSnBlZ0Vycm9yIil9fWNsYXNzIEROTE1hcmtlckVycm9yIGV4dGVuZHMgci5CYXNlRXhjZXB0aW9ue2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoZSwiRE5MTWFya2VyRXJyb3IiKTt0aGlzLnNjYW5MaW5lcz10fX1jbGFzcyBFT0lNYXJrZXJFcnJvciBleHRlbmRzIHIuQmFzZUV4Y2VwdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlLCJFT0lNYXJrZXJFcnJvciIpfX1jb25zdCBpPW5ldyBVaW50OEFycmF5KFswLDEsOCwxNiw5LDIsMywxMCwxNywyNCwzMiwyNSwxOCwxMSw0LDUsMTIsMTksMjYsMzMsNDAsNDgsNDEsMzQsMjcsMjAsMTMsNiw3LDE0LDIxLDI4LDM1LDQyLDQ5LDU2LDU3LDUwLDQzLDM2LDI5LDIyLDE1LDIzLDMwLDM3LDQ0LDUxLDU4LDU5LDUyLDQ1LDM4LDMxLDM5LDQ2LDUzLDYwLDYxLDU0LDQ3LDU1LDYyLDYzXSkscz00MDE3LG89Nzk5LGM9MzQwNixsPTIyNzYsaD0xNTY3LHU9Mzc4NCxkPTU3OTMsZj0yODk2O2Z1bmN0aW9uIGJ1aWxkSHVmZm1hblRhYmxlKGUsdCl7bGV0IGEscixuPTAsaT0xNjtmb3IoO2k+MCYmIWVbaS0xXTspaS0tO2NvbnN0IHM9W3tjaGlsZHJlbjpbXSxpbmRleDowfV07bGV0IG8sYz1zWzBdO2ZvcihhPTA7YTxpO2ErKyl7Zm9yKHI9MDtyPGVbYV07cisrKXtjPXMucG9wKCk7Yy5jaGlsZHJlbltjLmluZGV4XT10W25dO2Zvcig7Yy5pbmRleD4wOyljPXMucG9wKCk7Yy5pbmRleCsrO3MucHVzaChjKTtmb3IoO3MubGVuZ3RoPD1hOyl7cy5wdXNoKG89e2NoaWxkcmVuOltdLGluZGV4OjB9KTtjLmNoaWxkcmVuW2MuaW5kZXhdPW8uY2hpbGRyZW47Yz1vfW4rK31pZihhKzE8aSl7cy5wdXNoKG89e2NoaWxkcmVuOltdLGluZGV4OjB9KTtjLmNoaWxkcmVuW2MuaW5kZXhdPW8uY2hpbGRyZW47Yz1vfX1yZXR1cm4gc1swXS5jaGlsZHJlbn1mdW5jdGlvbiBnZXRCbG9ja0J1ZmZlck9mZnNldChlLHQsYSl7cmV0dXJuIDY0KigoZS5ibG9ja3NQZXJMaW5lKzEpKnQrYSl9ZnVuY3Rpb24gZGVjb2RlU2NhbihlLHQsYSxzLG8sYyxsLGgsdSxkPSExKXtjb25zdCBmPWEubWN1c1BlckxpbmUsZz1hLnByb2dyZXNzaXZlLHA9dDtsZXQgbT0wLGI9MDtmdW5jdGlvbiByZWFkQml0KCl7aWYoYj4wKXtiLS07cmV0dXJuIG0+PmImMX1tPWVbdCsrXTtpZigyNTU9PT1tKXtjb25zdCByPWVbdCsrXTtpZihyKXtpZigyMjA9PT1yJiZkKXt0Kz0yO2NvbnN0IHI9KDAsbi5yZWFkVWludDE2KShlLHQpO3QrPTI7aWYocj4wJiZyIT09YS5zY2FuTGluZXMpdGhyb3cgbmV3IEROTE1hcmtlckVycm9yKCJGb3VuZCBETkwgbWFya2VyICgweEZGREMpIHdoaWxlIHBhcnNpbmcgc2NhbiBkYXRhIixyKX1lbHNlIGlmKDIxNz09PXIpe2lmKGQpe2NvbnN0IGU9eCooOD09PWEucHJlY2lzaW9uPzg6MCk7aWYoZT4wJiZNYXRoLnJvdW5kKGEuc2NhbkxpbmVzL2UpPj0xMCl0aHJvdyBuZXcgRE5MTWFya2VyRXJyb3IoIkZvdW5kIEVPSSBtYXJrZXIgKDB4RkZEOSkgd2hpbGUgcGFyc2luZyBzY2FuIGRhdGEsIHBvc3NpYmx5IGNhdXNlZCBieSBpbmNvcnJlY3QgYHNjYW5MaW5lc2AgcGFyYW1ldGVyIixlKX10aHJvdyBuZXcgRU9JTWFya2VyRXJyb3IoIkZvdW5kIEVPSSBtYXJrZXIgKDB4RkZEOSkgd2hpbGUgcGFyc2luZyBzY2FuIGRhdGEiKX10aHJvdyBuZXcgSnBlZ0Vycm9yKGB1bmV4cGVjdGVkIG1hcmtlciAkeyhtPDw4fHIpLnRvU3RyaW5nKDE2KX1gKX19Yj03O3JldHVybiBtPj4+N31mdW5jdGlvbiBkZWNvZGVIdWZmbWFuKGUpe2xldCB0PWU7Zm9yKDs7KXt0PXRbcmVhZEJpdCgpXTtzd2l0Y2godHlwZW9mIHQpe2Nhc2UibnVtYmVyIjpyZXR1cm4gdDtjYXNlIm9iamVjdCI6Y29udGludWV9dGhyb3cgbmV3IEpwZWdFcnJvcigiaW52YWxpZCBodWZmbWFuIHNlcXVlbmNlIil9fWZ1bmN0aW9uIHJlY2VpdmUoZSl7bGV0IHQ9MDtmb3IoO2U+MDspe3Q9dDw8MXxyZWFkQml0KCk7ZS0tfXJldHVybiB0fWZ1bmN0aW9uIHJlY2VpdmVBbmRFeHRlbmQoZSl7aWYoMT09PWUpcmV0dXJuIDE9PT1yZWFkQml0KCk/MTotMTtjb25zdCB0PXJlY2VpdmUoZSk7cmV0dXJuIHQ+PTE8PGUtMT90OnQrKC0xPDxlKSsxfWxldCB5PTA7bGV0IHcsUz0wO2xldCB4PTA7ZnVuY3Rpb24gZGVjb2RlTWN1KGUsdCxhLHIsbil7Y29uc3QgaT1hJWY7eD0oYS9mfDApKmUudityO2NvbnN0IHM9aSplLmgrbjt0KGUsZ2V0QmxvY2tCdWZmZXJPZmZzZXQoZSx4LHMpKX1mdW5jdGlvbiBkZWNvZGVCbG9jayhlLHQsYSl7eD1hL2UuYmxvY2tzUGVyTGluZXwwO2NvbnN0IHI9YSVlLmJsb2Nrc1BlckxpbmU7dChlLGdldEJsb2NrQnVmZmVyT2Zmc2V0KGUseCxyKSl9Y29uc3Qgaz1zLmxlbmd0aDtsZXQgQyx2LEYsTyxULE07TT1nPzA9PT1jPzA9PT1oP2Z1bmN0aW9uIGRlY29kZURDRmlyc3QoZSx0KXtjb25zdCBhPWRlY29kZUh1ZmZtYW4oZS5odWZmbWFuVGFibGVEQykscj0wPT09YT8wOnJlY2VpdmVBbmRFeHRlbmQoYSk8PHU7ZS5ibG9ja0RhdGFbdF09ZS5wcmVkKz1yfTpmdW5jdGlvbiBkZWNvZGVEQ1N1Y2Nlc3NpdmUoZSx0KXtlLmJsb2NrRGF0YVt0XXw9cmVhZEJpdCgpPDx1fTowPT09aD9mdW5jdGlvbiBkZWNvZGVBQ0ZpcnN0KGUsdCl7aWYoeT4wKXt5LS07cmV0dXJufWxldCBhPWM7Y29uc3Qgcj1sO2Zvcig7YTw9cjspe2NvbnN0IHI9ZGVjb2RlSHVmZm1hbihlLmh1ZmZtYW5UYWJsZUFDKSxuPTE1JnIscz1yPj40O2lmKDA9PT1uKXtpZihzPDE1KXt5PXJlY2VpdmUocykrKDE8PHMpLTE7YnJlYWt9YSs9MTY7Y29udGludWV9YSs9cztjb25zdCBvPWlbYV07ZS5ibG9ja0RhdGFbdCtvXT1yZWNlaXZlQW5kRXh0ZW5kKG4pKigxPDx1KTthKyt9fTpmdW5jdGlvbiBkZWNvZGVBQ1N1Y2Nlc3NpdmUoZSx0KXtsZXQgYT1jO2NvbnN0IHI9bDtsZXQgbixzLG89MDtmb3IoO2E8PXI7KXtjb25zdCByPXQraVthXSxjPWUuYmxvY2tEYXRhW3JdPDA/LTE6MTtzd2l0Y2goUyl7Y2FzZSAwOnM9ZGVjb2RlSHVmZm1hbihlLmh1ZmZtYW5UYWJsZUFDKTtuPTE1JnM7bz1zPj40O2lmKDA9PT1uKWlmKG88MTUpe3k9cmVjZWl2ZShvKSsoMTw8byk7Uz00fWVsc2V7bz0xNjtTPTF9ZWxzZXtpZigxIT09bil0aHJvdyBuZXcgSnBlZ0Vycm9yKCJpbnZhbGlkIEFDbiBlbmNvZGluZyIpO3c9cmVjZWl2ZUFuZEV4dGVuZChuKTtTPW8/MjozfWNvbnRpbnVlO2Nhc2UgMTpjYXNlIDI6aWYoZS5ibG9ja0RhdGFbcl0pZS5ibG9ja0RhdGFbcl0rPWMqKHJlYWRCaXQoKTw8dSk7ZWxzZXtvLS07MD09PW8mJihTPTI9PT1TPzM6MCl9YnJlYWs7Y2FzZSAzOmlmKGUuYmxvY2tEYXRhW3JdKWUuYmxvY2tEYXRhW3JdKz1jKihyZWFkQml0KCk8PHUpO2Vsc2V7ZS5ibG9ja0RhdGFbcl09dzw8dTtTPTB9YnJlYWs7Y2FzZSA0OmUuYmxvY2tEYXRhW3JdJiYoZS5ibG9ja0RhdGFbcl0rPWMqKHJlYWRCaXQoKTw8dSkpfWErK31pZig0PT09Uyl7eS0tOzA9PT15JiYoUz0wKX19OmZ1bmN0aW9uIGRlY29kZUJhc2VsaW5lKGUsdCl7Y29uc3QgYT1kZWNvZGVIdWZmbWFuKGUuaHVmZm1hblRhYmxlREMpLHI9MD09PWE/MDpyZWNlaXZlQW5kRXh0ZW5kKGEpO2UuYmxvY2tEYXRhW3RdPWUucHJlZCs9cjtsZXQgbj0xO2Zvcig7bjw2NDspe2NvbnN0IGE9ZGVjb2RlSHVmZm1hbihlLmh1ZmZtYW5UYWJsZUFDKSxyPTE1JmEscz1hPj40O2lmKDA9PT1yKXtpZihzPDE1KWJyZWFrO24rPTE2O2NvbnRpbnVlfW4rPXM7Y29uc3Qgbz1pW25dO2UuYmxvY2tEYXRhW3Qrb109cmVjZWl2ZUFuZEV4dGVuZChyKTtuKyt9fTtsZXQgRSxELE4sUixMPTA7RD0xPT09az9zWzBdLmJsb2Nrc1BlckxpbmUqc1swXS5ibG9ja3NQZXJDb2x1bW46ZiphLm1jdXNQZXJDb2x1bW47Zm9yKDtMPD1EOyl7Y29uc3QgYT1vP01hdGgubWluKEQtTCxvKTpEO2lmKGE+MCl7Zm9yKHY9MDt2PGs7disrKXNbdl0ucHJlZD0wO3k9MDtpZigxPT09ayl7Qz1zWzBdO2ZvcihUPTA7VDxhO1QrKyl7ZGVjb2RlQmxvY2soQyxNLEwpO0wrK319ZWxzZSBmb3IoVD0wO1Q8YTtUKyspe2Zvcih2PTA7djxrO3YrKyl7Qz1zW3ZdO049Qy5oO1I9Qy52O2ZvcihGPTA7RjxSO0YrKylmb3IoTz0wO088TjtPKyspZGVjb2RlTWN1KEMsTSxMLEYsTyl9TCsrfX1iPTA7RT1maW5kTmV4dEZpbGVNYXJrZXIoZSx0KTtpZighRSlicmVhaztpZihFLmludmFsaWQpe2NvbnN0IGU9YT4wPyJ1bmV4cGVjdGVkIjoiZXhjZXNzaXZlIjsoMCxyLndhcm4pKGBkZWNvZGVTY2FuIC0gJHtlfSBNQ1UgZGF0YSwgY3VycmVudCBtYXJrZXIgaXM6ICR7RS5pbnZhbGlkfWApO3Q9RS5vZmZzZXR9aWYoIShFLm1hcmtlcj49NjU0ODgmJkUubWFya2VyPD02NTQ5NSkpYnJlYWs7dCs9Mn1yZXR1cm4gdC1wfWZ1bmN0aW9uIHF1YW50aXplQW5kSW52ZXJzZShlLHQsYSl7Y29uc3Qgcj1lLnF1YW50aXphdGlvblRhYmxlLG49ZS5ibG9ja0RhdGE7bGV0IGksZyxwLG0sYix5LHcsUyx4LGssQyx2LEYsTyxULE0sRTtpZighcil0aHJvdyBuZXcgSnBlZ0Vycm9yKCJtaXNzaW5nIHJlcXVpcmVkIFF1YW50aXphdGlvbiBUYWJsZS4iKTtmb3IobGV0IGU9MDtlPDY0O2UrPTgpe3g9blt0K2VdO2s9blt0K2UrMV07Qz1uW3QrZSsyXTt2PW5bdCtlKzNdO0Y9blt0K2UrNF07Tz1uW3QrZSs1XTtUPW5bdCtlKzZdO009blt0K2UrN107eCo9cltlXTtpZigwIT0oa3xDfHZ8RnxPfFR8TSkpe2sqPXJbZSsxXTtDKj1yW2UrMl07dio9cltlKzNdO0YqPXJbZSs0XTtPKj1yW2UrNV07VCo9cltlKzZdO00qPXJbZSs3XTtpPWQqeCsxMjg+Pjg7Zz1kKkYrMTI4Pj44O3A9QzttPVQ7Yj1mKihrLU0pKzEyOD4+ODtTPWYqKGsrTSkrMTI4Pj44O3k9djw8NDt3PU88PDQ7aT1pK2crMT4+MTtnPWktZztFPXAqdSttKmgrMTI4Pj44O3A9cCpoLW0qdSsxMjg+Pjg7bT1FO2I9Yit3KzE+PjE7dz1iLXc7Uz1TK3krMT4+MTt5PVMteTtpPWkrbSsxPj4xO209aS1tO2c9ZytwKzE+PjE7cD1nLXA7RT1iKmwrUypjKzIwNDg+PjEyO2I9YipjLVMqbCsyMDQ4Pj4xMjtTPUU7RT15Km8rdypzKzIwNDg+PjEyO3k9eSpzLXcqbysyMDQ4Pj4xMjt3PUU7YVtlXT1pK1M7YVtlKzddPWktUzthW2UrMV09Zyt3O2FbZSs2XT1nLXc7YVtlKzJdPXAreTthW2UrNV09cC15O2FbZSszXT1tK2I7YVtlKzRdPW0tYn1lbHNle0U9ZCp4KzUxMj4+MTA7YVtlXT1FO2FbZSsxXT1FO2FbZSsyXT1FO2FbZSszXT1FO2FbZSs0XT1FO2FbZSs1XT1FO2FbZSs2XT1FO2FbZSs3XT1FfX1mb3IobGV0IGU9MDtlPDg7KytlKXt4PWFbZV07az1hW2UrOF07Qz1hW2UrMTZdO3Y9YVtlKzI0XTtGPWFbZSszMl07Tz1hW2UrNDBdO1Q9YVtlKzQ4XTtNPWFbZSs1Nl07aWYoMCE9KGt8Q3x2fEZ8T3xUfE0pKXtpPWQqeCsyMDQ4Pj4xMjtnPWQqRisyMDQ4Pj4xMjtwPUM7bT1UO2I9Ziooay1NKSsyMDQ4Pj4xMjtTPWYqKGsrTSkrMjA0OD4+MTI7eT12O3c9TztpPTQxMTIrKGkrZysxPj4xKTtnPWktZztFPXAqdSttKmgrMjA0OD4+MTI7cD1wKmgtbSp1KzIwNDg+PjEyO209RTtiPWIrdysxPj4xO3c9Yi13O1M9Uyt5KzE+PjE7eT1TLXk7aT1pK20rMT4+MTttPWktbTtnPWcrcCsxPj4xO3A9Zy1wO0U9YipsK1MqYysyMDQ4Pj4xMjtiPWIqYy1TKmwrMjA0OD4+MTI7Uz1FO0U9eSpvK3cqcysyMDQ4Pj4xMjt5PXkqcy13Km8rMjA0OD4+MTI7dz1FO3g9aStTO009aS1TO2s9Zyt3O1Q9Zy13O0M9cCt5O089cC15O3Y9bStiO0Y9bS1iO3g8MTY/eD0wOng+PTQwODA/eD0yNTU6eD4+PTQ7azwxNj9rPTA6az49NDA4MD9rPTI1NTprPj49NDtDPDE2P0M9MDpDPj00MDgwP0M9MjU1OkM+Pj00O3Y8MTY/dj0wOnY+PTQwODA/dj0yNTU6dj4+PTQ7RjwxNj9GPTA6Rj49NDA4MD9GPTI1NTpGPj49NDtPPDE2P089MDpPPj00MDgwP089MjU1Ok8+Pj00O1Q8MTY/VD0wOlQ+PTQwODA/VD0yNTU6VD4+PTQ7TTwxNj9NPTA6TT49NDA4MD9NPTI1NTpNPj49NDtuW3QrZV09eDtuW3QrZSs4XT1rO25bdCtlKzE2XT1DO25bdCtlKzI0XT12O25bdCtlKzMyXT1GO25bdCtlKzQwXT1PO25bdCtlKzQ4XT1UO25bdCtlKzU2XT1NfWVsc2V7RT1kKngrODE5Mj4+MTQ7RT1FPC0yMDQwPzA6RT49MjAyND8yNTU6RSsyMDU2Pj40O25bdCtlXT1FO25bdCtlKzhdPUU7blt0K2UrMTZdPUU7blt0K2UrMjRdPUU7blt0K2UrMzJdPUU7blt0K2UrNDBdPUU7blt0K2UrNDhdPUU7blt0K2UrNTZdPUV9fX1mdW5jdGlvbiBidWlsZENvbXBvbmVudERhdGEoZSx0KXtjb25zdCBhPXQuYmxvY2tzUGVyTGluZSxyPXQuYmxvY2tzUGVyQ29sdW1uLG49bmV3IEludDE2QXJyYXkoNjQpO2ZvcihsZXQgZT0wO2U8cjtlKyspZm9yKGxldCByPTA7cjxhO3IrKyl7cXVhbnRpemVBbmRJbnZlcnNlKHQsZ2V0QmxvY2tCdWZmZXJPZmZzZXQodCxlLHIpLG4pfXJldHVybiB0LmJsb2NrRGF0YX1mdW5jdGlvbiBmaW5kTmV4dEZpbGVNYXJrZXIoZSx0LGE9dCl7Y29uc3Qgcj1lLmxlbmd0aC0xO2xldCBpPWE8dD9hOnQ7aWYodD49cilyZXR1cm4gbnVsbDtjb25zdCBzPSgwLG4ucmVhZFVpbnQxNikoZSx0KTtpZihzPj02NTQ3MiYmczw9NjU1MzQpcmV0dXJue2ludmFsaWQ6bnVsbCxtYXJrZXI6cyxvZmZzZXQ6dH07bGV0IG89KDAsbi5yZWFkVWludDE2KShlLGkpO2Zvcig7IShvPj02NTQ3MiYmbzw9NjU1MzQpOyl7aWYoKytpPj1yKXJldHVybiBudWxsO289KDAsbi5yZWFkVWludDE2KShlLGkpfXJldHVybntpbnZhbGlkOnMudG9TdHJpbmcoMTYpLG1hcmtlcjpvLG9mZnNldDppfX10LkpwZWdJbWFnZT1jbGFzcyBKcGVnSW1hZ2V7Y29uc3RydWN0b3Ioe2RlY29kZVRyYW5zZm9ybTplPW51bGwsY29sb3JUcmFuc2Zvcm06dD0tMX09e30pe3RoaXMuX2RlY29kZVRyYW5zZm9ybT1lO3RoaXMuX2NvbG9yVHJhbnNmb3JtPXR9cGFyc2UoZSx7ZG5sU2NhbkxpbmVzOnQ9bnVsbH09e30pe2Z1bmN0aW9uIHJlYWREYXRhQmxvY2soKXtjb25zdCB0PSgwLG4ucmVhZFVpbnQxNikoZSxvKTtvKz0yO2xldCBhPW8rdC0yO2NvbnN0IGk9ZmluZE5leHRGaWxlTWFya2VyKGUsYSxvKTtpZihpJiZpLmludmFsaWQpeygwLHIud2FybikoInJlYWREYXRhQmxvY2sgLSBpbmNvcnJlY3QgbGVuZ3RoLCBjdXJyZW50IG1hcmtlciBpczogIitpLmludmFsaWQpO2E9aS5vZmZzZXR9Y29uc3Qgcz1lLnN1YmFycmF5KG8sYSk7bys9cy5sZW5ndGg7cmV0dXJuIHN9ZnVuY3Rpb24gcHJlcGFyZUNvbXBvbmVudHMoZSl7Y29uc3QgdD1NYXRoLmNlaWwoZS5zYW1wbGVzUGVyTGluZS84L2UubWF4SCksYT1NYXRoLmNlaWwoZS5zY2FuTGluZXMvOC9lLm1heFYpO2ZvcihsZXQgcj0wLG49ZS5jb21wb25lbnRzLmxlbmd0aDtyPG47cisrKXtjb25zdCBuPWUuY29tcG9uZW50c1tyXSxpPU1hdGguY2VpbChNYXRoLmNlaWwoZS5zYW1wbGVzUGVyTGluZS84KSpuLmgvZS5tYXhIKSxzPU1hdGguY2VpbChNYXRoLmNlaWwoZS5zY2FuTGluZXMvOCkqbi52L2UubWF4Viksbz10Km4uaCxjPTY0KihhKm4udikqKG8rMSk7bi5ibG9ja0RhdGE9bmV3IEludDE2QXJyYXkoYyk7bi5ibG9ja3NQZXJMaW5lPWk7bi5ibG9ja3NQZXJDb2x1bW49c31lLm1jdXNQZXJMaW5lPXQ7ZS5tY3VzUGVyQ29sdW1uPWF9bGV0IGEscyxvPTAsYz1udWxsLGw9bnVsbCxoPTA7Y29uc3QgdT1bXSxkPVtdLGY9W107bGV0IGc9KDAsbi5yZWFkVWludDE2KShlLG8pO28rPTI7aWYoNjU0OTYhPT1nKXRocm93IG5ldyBKcGVnRXJyb3IoIlNPSSBub3QgZm91bmQiKTtnPSgwLG4ucmVhZFVpbnQxNikoZSxvKTtvKz0yO2U6Zm9yKDs2NTQ5NyE9PWc7KXtsZXQgcCxtLGI7c3dpdGNoKGcpe2Nhc2UgNjU1MDQ6Y2FzZSA2NTUwNTpjYXNlIDY1NTA2OmNhc2UgNjU1MDc6Y2FzZSA2NTUwODpjYXNlIDY1NTA5OmNhc2UgNjU1MTA6Y2FzZSA2NTUxMTpjYXNlIDY1NTEyOmNhc2UgNjU1MTM6Y2FzZSA2NTUxNDpjYXNlIDY1NTE1OmNhc2UgNjU1MTY6Y2FzZSA2NTUxNzpjYXNlIDY1NTE4OmNhc2UgNjU1MTk6Y2FzZSA2NTUzNDpjb25zdCB5PXJlYWREYXRhQmxvY2soKTs2NTUwND09PWcmJjc0PT09eVswXSYmNzA9PT15WzFdJiY3Mz09PXlbMl0mJjcwPT09eVszXSYmMD09PXlbNF0mJihjPXt2ZXJzaW9uOnttYWpvcjp5WzVdLG1pbm9yOnlbNl19LGRlbnNpdHlVbml0czp5WzddLHhEZW5zaXR5OnlbOF08PDh8eVs5XSx5RGVuc2l0eTp5WzEwXTw8OHx5WzExXSx0aHVtYldpZHRoOnlbMTJdLHRodW1iSGVpZ2h0OnlbMTNdLHRodW1iRGF0YTp5LnN1YmFycmF5KDE0LDE0KzMqeVsxMl0qeVsxM10pfSk7NjU1MTg9PT1nJiY2NT09PXlbMF0mJjEwMD09PXlbMV0mJjExMT09PXlbMl0mJjk4PT09eVszXSYmMTAxPT09eVs0XSYmKGw9e3ZlcnNpb246eVs1XTw8OHx5WzZdLGZsYWdzMDp5WzddPDw4fHlbOF0sZmxhZ3MxOnlbOV08PDh8eVsxMF0sdHJhbnNmb3JtQ29kZTp5WzExXX0pO2JyZWFrO2Nhc2UgNjU0OTk6Y29uc3Qgdz0oMCxuLnJlYWRVaW50MTYpKGUsbyk7bys9Mjtjb25zdCBTPXcrby0yO2xldCB4O2Zvcig7bzxTOyl7Y29uc3QgdD1lW28rK10sYT1uZXcgVWludDE2QXJyYXkoNjQpO2lmKHQ+PjQ9PTApZm9yKG09MDttPDY0O20rKyl7eD1pW21dO2FbeF09ZVtvKytdfWVsc2V7aWYodD4+NCE9MSl0aHJvdyBuZXcgSnBlZ0Vycm9yKCJEUVQgLSBpbnZhbGlkIHRhYmxlIHNwZWMiKTtmb3IobT0wO208NjQ7bSsrKXt4PWlbbV07YVt4XT0oMCxuLnJlYWRVaW50MTYpKGUsbyk7bys9Mn19dVsxNSZ0XT1hfWJyZWFrO2Nhc2UgNjU0NzI6Y2FzZSA2NTQ3MzpjYXNlIDY1NDc0OmlmKGEpdGhyb3cgbmV3IEpwZWdFcnJvcigiT25seSBzaW5nbGUgZnJhbWUgSlBFR3Mgc3VwcG9ydGVkIik7bys9MjthPXt9O2EuZXh0ZW5kZWQ9NjU0NzM9PT1nO2EucHJvZ3Jlc3NpdmU9NjU0NzQ9PT1nO2EucHJlY2lzaW9uPWVbbysrXTtjb25zdCBrPSgwLG4ucmVhZFVpbnQxNikoZSxvKTtvKz0yO2Euc2NhbkxpbmVzPXR8fGs7YS5zYW1wbGVzUGVyTGluZT0oMCxuLnJlYWRVaW50MTYpKGUsbyk7bys9MjthLmNvbXBvbmVudHM9W107YS5jb21wb25lbnRJZHM9e307Y29uc3QgQz1lW28rK107bGV0IHY9MCxGPTA7Zm9yKHA9MDtwPEM7cCsrKXtjb25zdCB0PWVbb10scj1lW28rMV0+PjQsbj0xNSZlW28rMV07djxyJiYodj1yKTtGPG4mJihGPW4pO2NvbnN0IGk9ZVtvKzJdO2I9YS5jb21wb25lbnRzLnB1c2goe2g6cix2Om4scXVhbnRpemF0aW9uSWQ6aSxxdWFudGl6YXRpb25UYWJsZTpudWxsfSk7YS5jb21wb25lbnRJZHNbdF09Yi0xO28rPTN9YS5tYXhIPXY7YS5tYXhWPUY7cHJlcGFyZUNvbXBvbmVudHMoYSk7YnJlYWs7Y2FzZSA2NTQ3Njpjb25zdCBPPSgwLG4ucmVhZFVpbnQxNikoZSxvKTtvKz0yO2ZvcihwPTI7cDxPOyl7Y29uc3QgdD1lW28rK10sYT1uZXcgVWludDhBcnJheSgxNik7bGV0IHI9MDtmb3IobT0wO208MTY7bSsrLG8rKylyKz1hW21dPWVbb107Y29uc3Qgbj1uZXcgVWludDhBcnJheShyKTtmb3IobT0wO208cjttKyssbysrKW5bbV09ZVtvXTtwKz0xNytyOyh0Pj40PT0wP2Y6ZClbMTUmdF09YnVpbGRIdWZmbWFuVGFibGUoYSxuKX1icmVhaztjYXNlIDY1NTAxOm8rPTI7cz0oMCxuLnJlYWRVaW50MTYpKGUsbyk7bys9MjticmVhaztjYXNlIDY1NDk4OmNvbnN0IFQ9MT09KytoJiYhdDtvKz0yO2NvbnN0IE09ZVtvKytdLEU9W107Zm9yKHA9MDtwPE07cCsrKXtjb25zdCB0PWVbbysrXSxyPWEuY29tcG9uZW50SWRzW3RdLG49YS5jb21wb25lbnRzW3JdO24uaW5kZXg9dDtjb25zdCBpPWVbbysrXTtuLmh1ZmZtYW5UYWJsZURDPWZbaT4+NF07bi5odWZmbWFuVGFibGVBQz1kWzE1JmldO0UucHVzaChuKX1jb25zdCBEPWVbbysrXSxOPWVbbysrXSxSPWVbbysrXTt0cnl7Y29uc3QgdD1kZWNvZGVTY2FuKGUsbyxhLEUscyxELE4sUj4+NCwxNSZSLFQpO28rPXR9Y2F0Y2godCl7aWYodCBpbnN0YW5jZW9mIEROTE1hcmtlckVycm9yKXsoMCxyLndhcm4pKGAke3QubWVzc2FnZX0gLS0gYXR0ZW1wdGluZyB0byByZS1wYXJzZSB0aGUgSlBFRyBpbWFnZS5gKTtyZXR1cm4gdGhpcy5wYXJzZShlLHtkbmxTY2FuTGluZXM6dC5zY2FuTGluZXN9KX1pZih0IGluc3RhbmNlb2YgRU9JTWFya2VyRXJyb3IpeygwLHIud2FybikoYCR7dC5tZXNzYWdlfSAtLSBpZ25vcmluZyB0aGUgcmVzdCBvZiB0aGUgaW1hZ2UgZGF0YS5gKTticmVhayBlfXRocm93IHR9YnJlYWs7Y2FzZSA2NTUwMDpvKz00O2JyZWFrO2Nhc2UgNjU1MzU6MjU1IT09ZVtvXSYmby0tO2JyZWFrO2RlZmF1bHQ6Y29uc3QgTD1maW5kTmV4dEZpbGVNYXJrZXIoZSxvLTIsby0zKTtpZihMJiZMLmludmFsaWQpeygwLHIud2FybikoIkpwZWdJbWFnZS5wYXJzZSAtIHVuZXhwZWN0ZWQgZGF0YSwgY3VycmVudCBtYXJrZXIgaXM6ICIrTC5pbnZhbGlkKTtvPUwub2Zmc2V0O2JyZWFrfWlmKCFMfHxvPj1lLmxlbmd0aC0xKXsoMCxyLndhcm4pKCJKcGVnSW1hZ2UucGFyc2UgLSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGltYWdlIGRhdGEgd2l0aG91dCBmaW5kaW5nIGFuIEVPSSBtYXJrZXIgKDB4RkZEOSkuIik7YnJlYWsgZX10aHJvdyBuZXcgSnBlZ0Vycm9yKCJKcGVnSW1hZ2UucGFyc2UgLSB1bmtub3duIG1hcmtlcjogIitnLnRvU3RyaW5nKDE2KSl9Zz0oMCxuLnJlYWRVaW50MTYpKGUsbyk7bys9Mn10aGlzLndpZHRoPWEuc2FtcGxlc1BlckxpbmU7dGhpcy5oZWlnaHQ9YS5zY2FuTGluZXM7dGhpcy5qZmlmPWM7dGhpcy5hZG9iZT1sO3RoaXMuY29tcG9uZW50cz1bXTtmb3IobGV0IGU9MCx0PWEuY29tcG9uZW50cy5sZW5ndGg7ZTx0O2UrKyl7Y29uc3QgdD1hLmNvbXBvbmVudHNbZV0scj11W3QucXVhbnRpemF0aW9uSWRdO3ImJih0LnF1YW50aXphdGlvblRhYmxlPXIpO3RoaXMuY29tcG9uZW50cy5wdXNoKHtpbmRleDp0LmluZGV4LG91dHB1dDpidWlsZENvbXBvbmVudERhdGEoMCx0KSxzY2FsZVg6dC5oL2EubWF4SCxzY2FsZVk6dC52L2EubWF4VixibG9ja3NQZXJMaW5lOnQuYmxvY2tzUGVyTGluZSxibG9ja3NQZXJDb2x1bW46dC5ibG9ja3NQZXJDb2x1bW59KX10aGlzLm51bUNvbXBvbmVudHM9dGhpcy5jb21wb25lbnRzLmxlbmd0aH1fZ2V0TGluZWFyaXplZEJsb2NrRGF0YShlLHQsYT0hMSl7Y29uc3Qgcj10aGlzLndpZHRoL2Usbj10aGlzLmhlaWdodC90O2xldCBpLHMsbyxjLGwsaCx1LGQsZixnLHAsbT0wO2NvbnN0IGI9dGhpcy5jb21wb25lbnRzLmxlbmd0aCx5PWUqdCpiLHc9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHkpLFM9bmV3IFVpbnQzMkFycmF5KGUpLHg9NDI5NDk2NzI4ODtsZXQgaztmb3IodT0wO3U8Yjt1Kyspe2k9dGhpcy5jb21wb25lbnRzW3VdO3M9aS5zY2FsZVgqcjtvPWkuc2NhbGVZKm47bT11O3A9aS5vdXRwdXQ7Yz1pLmJsb2Nrc1BlckxpbmUrMTw8MztpZihzIT09ayl7Zm9yKGw9MDtsPGU7bCsrKXtkPTB8bCpzO1NbbF09KGQmeCk8PDN8NyZkfWs9c31mb3IoaD0wO2g8dDtoKyspe2Q9MHxoKm87Zz1jKihkJngpfCg3JmQpPDwzO2ZvcihsPTA7bDxlO2wrKyl7d1ttXT1wW2crU1tsXV07bSs9Yn19fWxldCBDPXRoaXMuX2RlY29kZVRyYW5zZm9ybTthfHw0IT09Ynx8Q3x8KEM9bmV3IEludDMyQXJyYXkoWy0yNTYsMjU1LC0yNTYsMjU1LC0yNTYsMjU1LC0yNTYsMjU1XSkpO2lmKEMpZm9yKHU9MDt1PHk7KWZvcihkPTAsZj0wO2Q8YjtkKyssdSsrLGYrPTIpd1t1XT0od1t1XSpDW2ZdPj44KStDW2YrMV07cmV0dXJuIHd9Z2V0IF9pc0NvbG9yQ29udmVyc2lvbk5lZWRlZCgpe3JldHVybiB0aGlzLmFkb2JlPyEhdGhpcy5hZG9iZS50cmFuc2Zvcm1Db2RlOjM9PT10aGlzLm51bUNvbXBvbmVudHM/MCE9PXRoaXMuX2NvbG9yVHJhbnNmb3JtJiYoODIhPT10aGlzLmNvbXBvbmVudHNbMF0uaW5kZXh8fDcxIT09dGhpcy5jb21wb25lbnRzWzFdLmluZGV4fHw2NiE9PXRoaXMuY29tcG9uZW50c1syXS5pbmRleCk6MT09PXRoaXMuX2NvbG9yVHJhbnNmb3JtfV9jb252ZXJ0WWNjVG9SZ2IoZSl7bGV0IHQsYSxyO2ZvcihsZXQgbj0wLGk9ZS5sZW5ndGg7bjxpO24rPTMpe3Q9ZVtuXTthPWVbbisxXTtyPWVbbisyXTtlW25dPXQtMTc5LjQ1NisxLjQwMipyO2VbbisxXT10KzEzNS40NTktLjM0NCphLS43MTQqcjtlW24rMl09dC0yMjYuODE2KzEuNzcyKmF9cmV0dXJuIGV9X2NvbnZlcnRZY2NrVG9SZ2IoZSl7bGV0IHQsYSxyLG4saT0wO2ZvcihsZXQgcz0wLG89ZS5sZW5ndGg7czxvO3MrPTQpe3Q9ZVtzXTthPWVbcysxXTtyPWVbcysyXTtuPWVbcyszXTtlW2krK109YSooLTY2MDYzNTY2OTQyMDM2NGUtMTkqYSsuMDAwNDM3MTMwNDc1OTI2MjMyKnItNTQwODA2MTAwNjQ1OTllLTE4KnQrLjAwMDQ4NDQ5Nzk3MTIwMjgxKm4tLjE1NDM2MjE1MTg3MTEyNiktMTIyLjY3MTk1NDA2ODk0K3IqKC0uMDAwOTU3OTY0Mzc4NDQ1NzczKnIrLjAwMDgxNzA3NjkxMTM0NjYyNSp0LS4wMDQ3NzI3MTQwNTQwODc0NypuKzEuNTMzODAyNTMyMjE3MzQpK3QqKC4wMDA5NjEyNTAxODQxMzA2ODgqdC0uMDAyNjYyNTczMzIyODM5MzMqbisuNDgzNTcwODg0NTEyNjUpK24qKC0uMDAwMzM2MTk3MTc3NjE4Mzk0Km4rLjQ4NDc5MTU2MTQ5MDc3Nik7ZVtpKytdPTEwNy4yNjgwMzkzOTc3MjQrYSooMjE5OTI3MTA0NTI1NzQxZS0xOSphLS4wMDA2NDA5OTIwMTgyOTc5NDUqcisuMDAwNjU5Mzk3MDAxMjQ1NTc3KnQrLjAwMDQyNjEwNTY1MjkzODgzNypuLS4xNzY0OTE3OTI0NjI4NzUpK3IqKC0uMDAwNzc4MjY5OTQxNTEzNjgzKnIrLjAwMTMwODcyMjYxNDA4Mjc1KnQrLjAwMDc3MDQ4MjYzMTgwMTEzMipuLS4xNTEwNTE0OTI3NzU1NjIpK3QqKC4wMDEyNjkzNTM2ODExNDg0Myp0LS4wMDI2NTA5MDE4OTAxMDg5OCpuKy4yNTgwMjkxMDIwNjg0NSkrbiooLS4wMDAzMTg5MTMxMTc1ODgzMjgqbi0uMjEzNzQyNDAwMzIzNjY1KTtlW2krK109YSooLS4wMDA1NzAxMTUxOTY5NzM2NzcqYS0yNjM0MDkwNTEwMDQ1ODllLTE5KnIrLjAwMjA3NDEwODgxMTUwMTIqdC0uMDAyODgyNjAyMzY4NTM0NDIqbisuODE0MjcyOTY4MzU5Mjk1KS0yMC44MTAwMTI1NDY5NDcrciooLTE1MzQ5NjA1NzQ0MDk3NWUtMTkqci0uMDAwMTMyNjg5MDQzOTYxNDQ2KnQrLjAwMDU2MDgzMzY5MTI0MjgxMipuLS4xOTUxNTIwMjc1MzQwNDkpK3QqKC4wMDE3NDQxODEzMjkyNzU4Mip0LS4wMDI1NTI0MzMyMTQzOTM0NypuKy4xMTY5MzUwMjA0NjUxNDUpK24qKC0uMDAwMzQzNTMxOTk2NTEwNTU1Km4rLjI0MTY1MjYwMjMyNDA3KX1yZXR1cm4gZS5zdWJhcnJheSgwLGkpfV9jb252ZXJ0WWNja1RvQ215ayhlKXtsZXQgdCxhLHI7Zm9yKGxldCBuPTAsaT1lLmxlbmd0aDtuPGk7bis9NCl7dD1lW25dO2E9ZVtuKzFdO3I9ZVtuKzJdO2Vbbl09NDM0LjQ1Ni10LTEuNDAyKnI7ZVtuKzFdPTExOS41NDEtdCsuMzQ0KmErLjcxNCpyO2VbbisyXT00ODEuODE2LXQtMS43NzIqYX1yZXR1cm4gZX1fY29udmVydENteWtUb1JnYihlKXtsZXQgdCxhLHIsbixpPTA7Zm9yKGxldCBzPTAsbz1lLmxlbmd0aDtzPG87cys9NCl7dD1lW3NdO2E9ZVtzKzFdO3I9ZVtzKzJdO249ZVtzKzNdO2VbaSsrXT0yNTUrdCooLTY3NDcxNDcwNzM2MDI0NDFlLTIwKnQrLjAwMDgzNzkyNjIxMjEwMTM3MjcqYSsuMDAwMjg5NDcxODE4ODY0MzI5NCpyKy4wMDMyNjQyMzEwNTc1Mzc4MDYqbi0xLjExODU2MTE4NjcyMDM5MzcpK2EqKDI2Mzc0MTA3NjE2MDg5NDA1ZS0yMSphLTg2MjY5NDkxNTg2Mzg1NzJlLTIwKnItLjAwMDI3NDg3NjkwNjc0OTk0OTEqbi0uMDIxNTU2ODg3OTQ5Nzg5NjcpK3IqKC0zODc4MDk5MjEyODY5MzYzZS0yMCpyLS4wMDAzMjY3ODA4Mjc5NDg1Mjg2Km4rLjA2ODY3NDIyMzg1OTUzNDUpLW4qKC4wMDAzMzYxOTcxNzc2MTgzOTM3Km4rLjc0MzA2NTkxNTEzNDIyNTQpO2VbaSsrXT0yNTUrdCooLjAwMDEzNTk2MzcyODEzNTg4ODQ4KnQrLjAwMDkyNDUzNzEzMjU3MzU4NSphKy4wMDAxMDU2NzM1OTYxODY4MzU5MypyKy4wMDA0NzkxODY0Njg3NDM2NTEyKm4tLjMxMDk2ODk1ODc1MTU4NzUpK2EqKC0uMDAwMjM1NDUzNDYxMDgzNzAzNDQqYSsuMDAwMjcwMjg0NTI1MzUzNDcxNCpyKy4wMDIwMjAwMzA4OTc3MzA3MTU2Km4tLjc0ODgwNTIxNjcwMTU0OTQpK3IqKDY4MzQ4MTU5OTgyMzU2NjJlLTIwKnIrLjAwMDE1MTY4NDUyMzYzNDYwOTczKm4tLjA5NzUxOTI3Nzc0NzI4OTMzKS1uKiguMDAwMzE4OTEzMTE3NTg4MzI4MSpuKy43MzY0ODgzODA3NzMzMTY4KTtlW2krK109MjU1K3QqKDEzNTk4NjUwNDExMzg1MzA3ZS0yMSp0Ky4wMDAxMjQyMzk1NjE3NTQ5MDg1MSphKy4wMDA0NzUxOTg1MDk3NTgzNTg5KnItMzY3MjkzMTc0NzY2MzA0MjJlLTIyKm4tLjA1NTYyMTg2OTgwMjY0MDM0KSthKiguMDAwMTYxNDEzODA1OTg3MjQ2NzYqYSsuMDAwOTY5MjIzOTEzMDcyNTE4NipyKy4wMDA3NzgyNjkyNDUwMDM2MjUzKm4tLjQ0MDE1MjMyMzY3NTI2NDYzKStyKig1LjA2ODg4MjkxNDA2ODc2OWUtNypyKy4wMDE3Nzc4MzY5MDExMzc1MDcxKm4tLjc1OTE0NTQ2NDk3NDk2MDkpLW4qKC4wMDAzNDM1MzE5OTY1MTA1NTUzKm4rLjcwNjM3NzAxODYxNjAxNDQpfXJldHVybiBlLnN1YmFycmF5KDAsaSl9Z2V0RGF0YSh7d2lkdGg6ZSxoZWlnaHQ6dCxmb3JjZVJHQjphPSExLGlzU291cmNlUERGOnI9ITF9KXtpZih0aGlzLm51bUNvbXBvbmVudHM+NCl0aHJvdyBuZXcgSnBlZ0Vycm9yKCJVbnN1cHBvcnRlZCBjb2xvciBtb2RlIik7Y29uc3Qgbj10aGlzLl9nZXRMaW5lYXJpemVkQmxvY2tEYXRhKGUsdCxyKTtpZigxPT09dGhpcy5udW1Db21wb25lbnRzJiZhKXtjb25zdCBlPW4ubGVuZ3RoLHQ9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDMqZSk7bGV0IGE9MDtmb3IobGV0IHI9MDtyPGU7cisrKXtjb25zdCBlPW5bcl07dFthKytdPWU7dFthKytdPWU7dFthKytdPWV9cmV0dXJuIHR9aWYoMz09PXRoaXMubnVtQ29tcG9uZW50cyYmdGhpcy5faXNDb2xvckNvbnZlcnNpb25OZWVkZWQpcmV0dXJuIHRoaXMuX2NvbnZlcnRZY2NUb1JnYihuKTtpZig0PT09dGhpcy5udW1Db21wb25lbnRzKXtpZih0aGlzLl9pc0NvbG9yQ29udmVyc2lvbk5lZWRlZClyZXR1cm4gYT90aGlzLl9jb252ZXJ0WWNja1RvUmdiKG4pOnRoaXMuX2NvbnZlcnRZY2NrVG9DbXlrKG4pO2lmKGEpcmV0dXJuIHRoaXMuX2NvbnZlcnRDbXlrVG9SZ2Iobil9cmV0dXJuIG59fX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LkpweFN0cmVhbT12b2lkIDA7dmFyIHI9YSgxOSksbj1hKDMwKSxpPWEoMik7Y2xhc3MgSnB4U3RyZWFtIGV4dGVuZHMgci5EZWNvZGVTdHJlYW17Y29uc3RydWN0b3IoZSx0LGEpe3N1cGVyKHQpO3RoaXMuc3RyZWFtPWU7dGhpcy5kaWN0PWUuZGljdDt0aGlzLm1heWJlTGVuZ3RoPXQ7dGhpcy5wYXJhbXM9YX1nZXQgYnl0ZXMoKXtyZXR1cm4oMCxpLnNoYWRvdykodGhpcywiYnl0ZXMiLHRoaXMuc3RyZWFtLmdldEJ5dGVzKHRoaXMubWF5YmVMZW5ndGgpKX1lbnN1cmVCdWZmZXIoZSl7fXJlYWRCbG9jaygpe2lmKHRoaXMuZW9mKXJldHVybjtjb25zdCBlPW5ldyBuLkpweEltYWdlO2UucGFyc2UodGhpcy5ieXRlcyk7Y29uc3QgdD1lLndpZHRoLGE9ZS5oZWlnaHQscj1lLmNvbXBvbmVudHNDb3VudCxpPWUudGlsZXMubGVuZ3RoO2lmKDE9PT1pKXRoaXMuYnVmZmVyPWUudGlsZXNbMF0uaXRlbXM7ZWxzZXtjb25zdCBuPW5ldyBVaW50OENsYW1wZWRBcnJheSh0KmEqcik7Zm9yKGxldCBhPTA7YTxpO2ErKyl7Y29uc3QgaT1lLnRpbGVzW2FdLHM9aS53aWR0aCxvPWkuaGVpZ2h0LGM9aS5sZWZ0LGw9aS50b3AsaD1pLml0ZW1zO2xldCB1PTAsZD0odCpsK2MpKnI7Y29uc3QgZj10KnIsZz1zKnI7Zm9yKGxldCBlPTA7ZTxvO2UrKyl7Y29uc3QgZT1oLnN1YmFycmF5KHUsdStnKTtuLnNldChlLGQpO3UrPWc7ZCs9Zn19dGhpcy5idWZmZXI9bn10aGlzLmJ1ZmZlckxlbmd0aD10aGlzLmJ1ZmZlci5sZW5ndGg7dGhpcy5lb2Y9ITB9fXQuSnB4U3RyZWFtPUpweFN0cmVhbX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LkpweEltYWdlPXZvaWQgMDt2YXIgcj1hKDIpLG49YSg2KSxpPWEoMjYpO2NsYXNzIEpweEVycm9yIGV4dGVuZHMgci5CYXNlRXhjZXB0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGBKUFggZXJyb3I6ICR7ZX1gLCJKcHhFcnJvciIpfX1jb25zdCBzPXtMTDowLExIOjEsSEw6MSxISDoyfTt0LkpweEltYWdlPWNsYXNzIEpweEltYWdle2NvbnN0cnVjdG9yKCl7dGhpcy5mYWlsT25Db3JydXB0ZWRJbWFnZT0hMX1wYXJzZShlKXtpZig2NTM1OT09PSgwLG4ucmVhZFVpbnQxNikoZSwwKSl7dGhpcy5wYXJzZUNvZGVzdHJlYW0oZSwwLGUubGVuZ3RoKTtyZXR1cm59Y29uc3QgdD1lLmxlbmd0aDtsZXQgYT0wO2Zvcig7YTx0Oyl7bGV0IGk9OCxzPSgwLG4ucmVhZFVpbnQzMikoZSxhKTtjb25zdCBvPSgwLG4ucmVhZFVpbnQzMikoZSxhKzQpO2ErPWk7aWYoMT09PXMpe3M9NDI5NDk2NzI5NiooMCxuLnJlYWRVaW50MzIpKGUsYSkrKDAsbi5yZWFkVWludDMyKShlLGErNCk7YSs9ODtpKz04fTA9PT1zJiYocz10LWEraSk7aWYoczxpKXRocm93IG5ldyBKcHhFcnJvcigiSW52YWxpZCBib3ggZmllbGQgc2l6ZSIpO2NvbnN0IGM9cy1pO2xldCBsPSEwO3N3aXRjaChvKXtjYXNlIDE3ODU3Mzc4MzI6bD0hMTticmVhaztjYXNlIDE2NjgyNDY2NDI6Y29uc3QgdD1lW2FdO2lmKDE9PT10KXtjb25zdCB0PSgwLG4ucmVhZFVpbnQzMikoZSxhKzMpO3N3aXRjaCh0KXtjYXNlIDE2OmNhc2UgMTc6Y2FzZSAxODpicmVhaztkZWZhdWx0OigwLHIud2FybikoIlVua25vd24gY29sb3JzcGFjZSAiK3QpfX1lbHNlIDI9PT10JiYoMCxyLmluZm8pKCJJQ0MgcHJvZmlsZSBub3Qgc3VwcG9ydGVkIik7YnJlYWs7Y2FzZSAxNzg1NzM3ODI3OnRoaXMucGFyc2VDb2Rlc3RyZWFtKGUsYSxhK2MpO2JyZWFrO2Nhc2UgMTc4MzYzNmUzOjIxODc5MzczOCE9PSgwLG4ucmVhZFVpbnQzMikoZSxhKSYmKDAsci53YXJuKSgiSW52YWxpZCBKUDIgc2lnbmF0dXJlIik7YnJlYWs7Y2FzZSAxNzgzNjM0NDU4OmNhc2UgMTcxODkwOTI5NjpjYXNlIDE5MjAwOTk2OTc6Y2FzZSAxOTE5MjUxMjMyOmNhc2UgMTc2ODQ0OTEzODpicmVhaztkZWZhdWx0OmNvbnN0IGk9U3RyaW5nLmZyb21DaGFyQ29kZShvPj4yNCYyNTUsbz4+MTYmMjU1LG8+PjgmMjU1LDI1NSZvKTsoMCxyLndhcm4pKGBVbnN1cHBvcnRlZCBoZWFkZXIgdHlwZSAke299ICgke2l9KS5gKX1sJiYoYSs9Yyl9fXBhcnNlSW1hZ2VQcm9wZXJ0aWVzKGUpe2xldCB0PWUuZ2V0Qnl0ZSgpO2Zvcig7dD49MDspe2NvbnN0IGE9dDt0PWUuZ2V0Qnl0ZSgpO2lmKDY1MzYxPT09KGE8PDh8dCkpe2Uuc2tpcCg0KTtjb25zdCB0PWUuZ2V0SW50MzIoKT4+PjAsYT1lLmdldEludDMyKCk+Pj4wLHI9ZS5nZXRJbnQzMigpPj4+MCxuPWUuZ2V0SW50MzIoKT4+PjA7ZS5za2lwKDE2KTtjb25zdCBpPWUuZ2V0VWludDE2KCk7dGhpcy53aWR0aD10LXI7dGhpcy5oZWlnaHQ9YS1uO3RoaXMuY29tcG9uZW50c0NvdW50PWk7dGhpcy5iaXRzUGVyQ29tcG9uZW50PTg7cmV0dXJufX10aHJvdyBuZXcgSnB4RXJyb3IoIk5vIHNpemUgbWFya2VyIGZvdW5kIGluIEpQWCBzdHJlYW0iKX1wYXJzZUNvZGVzdHJlYW0oZSx0LGEpe2NvbnN0IGk9e307bGV0IHM9ITE7dHJ5e2xldCBvPXQ7Zm9yKDtvKzE8YTspe2NvbnN0IHQ9KDAsbi5yZWFkVWludDE2KShlLG8pO28rPTI7bGV0IGEsYyxsLGgsdSxkLGY9MDtzd2l0Y2godCl7Y2FzZSA2NTM1OTppLm1haW5IZWFkZXI9ITA7YnJlYWs7Y2FzZSA2NTQ5NzpicmVhaztjYXNlIDY1MzYxOmY9KDAsbi5yZWFkVWludDE2KShlLG8pO2NvbnN0IGc9e307Zy5Yc2l6PSgwLG4ucmVhZFVpbnQzMikoZSxvKzQpO2cuWXNpej0oMCxuLnJlYWRVaW50MzIpKGUsbys4KTtnLlhPc2l6PSgwLG4ucmVhZFVpbnQzMikoZSxvKzEyKTtnLllPc2l6PSgwLG4ucmVhZFVpbnQzMikoZSxvKzE2KTtnLlhUc2l6PSgwLG4ucmVhZFVpbnQzMikoZSxvKzIwKTtnLllUc2l6PSgwLG4ucmVhZFVpbnQzMikoZSxvKzI0KTtnLlhUT3Npej0oMCxuLnJlYWRVaW50MzIpKGUsbysyOCk7Zy5ZVE9zaXo9KDAsbi5yZWFkVWludDMyKShlLG8rMzIpO2NvbnN0IHA9KDAsbi5yZWFkVWludDE2KShlLG8rMzYpO2cuQ3Npej1wO2NvbnN0IG09W107YT1vKzM4O2ZvcihsZXQgdD0wO3Q8cDt0Kyspe2NvbnN0IHQ9e3ByZWNpc2lvbjoxKygxMjcmZVthXSksaXNTaWduZWQ6ISEoMTI4JmVbYV0pLFhSc2l6OmVbYSsxXSxZUnNpejplW2ErMl19O2ErPTM7Y2FsY3VsYXRlQ29tcG9uZW50RGltZW5zaW9ucyh0LGcpO20ucHVzaCh0KX1pLlNJWj1nO2kuY29tcG9uZW50cz1tO2NhbGN1bGF0ZVRpbGVHcmlkcyhpLG0pO2kuUUNDPVtdO2kuQ09DPVtdO2JyZWFrO2Nhc2UgNjUzNzI6Zj0oMCxuLnJlYWRVaW50MTYpKGUsbyk7Y29uc3QgYj17fTthPW8rMjtjPWVbYSsrXTtzd2l0Y2goMzEmYyl7Y2FzZSAwOmg9ODt1PSEwO2JyZWFrO2Nhc2UgMTpoPTE2O3U9ITE7YnJlYWs7Y2FzZSAyOmg9MTY7dT0hMDticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiSW52YWxpZCBTUWNkIHZhbHVlICIrYyl9Yi5ub1F1YW50aXphdGlvbj04PT09aDtiLnNjYWxhckV4cG91bmRlZD11O2IuZ3VhcmRCaXRzPWM+PjU7bD1bXTtmb3IoO2E8ZitvOyl7Y29uc3QgdD17fTtpZig4PT09aCl7dC5lcHNpbG9uPWVbYSsrXT4+Mzt0Lm11PTB9ZWxzZXt0LmVwc2lsb249ZVthXT4+Mzt0Lm11PSg3JmVbYV0pPDw4fGVbYSsxXTthKz0yfWwucHVzaCh0KX1iLlNQcWNkcz1sO2lmKGkubWFpbkhlYWRlcilpLlFDRD1iO2Vsc2V7aS5jdXJyZW50VGlsZS5RQ0Q9YjtpLmN1cnJlbnRUaWxlLlFDQz1bXX1icmVhaztjYXNlIDY1MzczOmY9KDAsbi5yZWFkVWludDE2KShlLG8pO2NvbnN0IHk9e307YT1vKzI7bGV0IHc7aWYoaS5TSVouQ3NpejwyNTcpdz1lW2ErK107ZWxzZXt3PSgwLG4ucmVhZFVpbnQxNikoZSxhKTthKz0yfWM9ZVthKytdO3N3aXRjaCgzMSZjKXtjYXNlIDA6aD04O3U9ITA7YnJlYWs7Y2FzZSAxOmg9MTY7dT0hMTticmVhaztjYXNlIDI6aD0xNjt1PSEwO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIFNRY2QgdmFsdWUgIitjKX15Lm5vUXVhbnRpemF0aW9uPTg9PT1oO3kuc2NhbGFyRXhwb3VuZGVkPXU7eS5ndWFyZEJpdHM9Yz4+NTtsPVtdO2Zvcig7YTxmK287KXtjb25zdCB0PXt9O2lmKDg9PT1oKXt0LmVwc2lsb249ZVthKytdPj4zO3QubXU9MH1lbHNle3QuZXBzaWxvbj1lW2FdPj4zO3QubXU9KDcmZVthXSk8PDh8ZVthKzFdO2ErPTJ9bC5wdXNoKHQpfXkuU1BxY2RzPWw7aS5tYWluSGVhZGVyP2kuUUNDW3ddPXk6aS5jdXJyZW50VGlsZS5RQ0Nbd109eTticmVhaztjYXNlIDY1MzYyOmY9KDAsbi5yZWFkVWludDE2KShlLG8pO2NvbnN0IFM9e307YT1vKzI7Y29uc3QgeD1lW2ErK107Uy5lbnRyb3B5Q29kZXJXaXRoQ3VzdG9tUHJlY2luY3RzPSEhKDEmeCk7Uy5zb3BNYXJrZXJVc2VkPSEhKDImeCk7Uy5lcGhNYXJrZXJVc2VkPSEhKDQmeCk7Uy5wcm9ncmVzc2lvbk9yZGVyPWVbYSsrXTtTLmxheWVyc0NvdW50PSgwLG4ucmVhZFVpbnQxNikoZSxhKTthKz0yO1MubXVsdGlwbGVDb21wb25lbnRUcmFuc2Zvcm09ZVthKytdO1MuZGVjb21wb3NpdGlvbkxldmVsc0NvdW50PWVbYSsrXTtTLnhjYj0yKygxNSZlW2ErK10pO1MueWNiPTIrKDE1JmVbYSsrXSk7Y29uc3Qgaz1lW2ErK107Uy5zZWxlY3RpdmVBcml0aG1ldGljQ29kaW5nQnlwYXNzPSEhKDEmayk7Uy5yZXNldENvbnRleHRQcm9iYWJpbGl0aWVzPSEhKDImayk7Uy50ZXJtaW5hdGlvbk9uRWFjaENvZGluZ1Bhc3M9ISEoNCZrKTtTLnZlcnRpY2FsbHlTdHJpcGU9ISEoOCZrKTtTLnByZWRpY3RhYmxlVGVybWluYXRpb249ISEoMTYmayk7Uy5zZWdtZW50YXRpb25TeW1ib2xVc2VkPSEhKDMyJmspO1MucmV2ZXJzaWJsZVRyYW5zZm9ybWF0aW9uPWVbYSsrXTtpZihTLmVudHJvcHlDb2RlcldpdGhDdXN0b21QcmVjaW5jdHMpe2NvbnN0IHQ9W107Zm9yKDthPGYrbzspe2NvbnN0IHI9ZVthKytdO3QucHVzaCh7UFB4OjE1JnIsUFB5OnI+PjR9KX1TLnByZWNpbmN0c1NpemVzPXR9Y29uc3QgQz1bXTtTLnNlbGVjdGl2ZUFyaXRobWV0aWNDb2RpbmdCeXBhc3MmJkMucHVzaCgic2VsZWN0aXZlQXJpdGhtZXRpY0NvZGluZ0J5cGFzcyIpO1MudGVybWluYXRpb25PbkVhY2hDb2RpbmdQYXNzJiZDLnB1c2goInRlcm1pbmF0aW9uT25FYWNoQ29kaW5nUGFzcyIpO1MudmVydGljYWxseVN0cmlwZSYmQy5wdXNoKCJ2ZXJ0aWNhbGx5U3RyaXBlIik7Uy5wcmVkaWN0YWJsZVRlcm1pbmF0aW9uJiZDLnB1c2goInByZWRpY3RhYmxlVGVybWluYXRpb24iKTtpZihDLmxlbmd0aD4wKXtzPSEwOygwLHIud2FybikoYEpQWDogVW5zdXBwb3J0ZWQgQ09EIG9wdGlvbnMgKCR7Qy5qb2luKCIsICIpfSkuYCl9aWYoaS5tYWluSGVhZGVyKWkuQ09EPVM7ZWxzZXtpLmN1cnJlbnRUaWxlLkNPRD1TO2kuY3VycmVudFRpbGUuQ09DPVtdfWJyZWFrO2Nhc2UgNjU0MjQ6Zj0oMCxuLnJlYWRVaW50MTYpKGUsbyk7ZD17fTtkLmluZGV4PSgwLG4ucmVhZFVpbnQxNikoZSxvKzIpO2QubGVuZ3RoPSgwLG4ucmVhZFVpbnQzMikoZSxvKzQpO2QuZGF0YUVuZD1kLmxlbmd0aCtvLTI7ZC5wYXJ0SW5kZXg9ZVtvKzhdO2QucGFydHNDb3VudD1lW28rOV07aS5tYWluSGVhZGVyPSExO2lmKDA9PT1kLnBhcnRJbmRleCl7ZC5DT0Q9aS5DT0Q7ZC5DT0M9aS5DT0Muc2xpY2UoMCk7ZC5RQ0Q9aS5RQ0Q7ZC5RQ0M9aS5RQ0Muc2xpY2UoMCl9aS5jdXJyZW50VGlsZT1kO2JyZWFrO2Nhc2UgNjU0Mjc6ZD1pLmN1cnJlbnRUaWxlO2lmKDA9PT1kLnBhcnRJbmRleCl7aW5pdGlhbGl6ZVRpbGUoaSxkLmluZGV4KTtidWlsZFBhY2tldHMoaSl9Zj1kLmRhdGFFbmQtbztwYXJzZVRpbGVQYWNrZXRzKGksZSxvLGYpO2JyZWFrO2Nhc2UgNjUzNjM6KDAsci53YXJuKSgiSlBYOiBDb2Rlc3RyZWFtIGNvZGUgMHhGRjUzIChDT0MpIGlzIG5vdCBpbXBsZW1lbnRlZC4iKTtjYXNlIDY1MzY1OmNhc2UgNjUzNjc6Y2FzZSA2NTM2ODpjYXNlIDY1MzgwOmY9KDAsbi5yZWFkVWludDE2KShlLG8pO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJVbmtub3duIGNvZGVzdHJlYW0gY29kZTogIit0LnRvU3RyaW5nKDE2KSl9bys9Zn19Y2F0Y2goZSl7aWYoc3x8dGhpcy5mYWlsT25Db3JydXB0ZWRJbWFnZSl0aHJvdyBuZXcgSnB4RXJyb3IoZS5tZXNzYWdlKTsoMCxyLndhcm4pKGBKUFg6IFRyeWluZyB0byByZWNvdmVyIGZyb206ICIke2UubWVzc2FnZX0iLmApfXRoaXMudGlsZXM9ZnVuY3Rpb24gdHJhbnNmb3JtQ29tcG9uZW50cyhlKXtjb25zdCB0PWUuU0laLGE9ZS5jb21wb25lbnRzLHI9dC5Dc2l6LG49W107Zm9yKGxldCB0PTAsaT1lLnRpbGVzLmxlbmd0aDt0PGk7dCsrKXtjb25zdCBpPWUudGlsZXNbdF0scz1bXTtmb3IobGV0IHQ9MDt0PHI7dCsrKXNbdF09dHJhbnNmb3JtVGlsZShlLGksdCk7Y29uc3Qgbz1zWzBdLGM9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KG8uaXRlbXMubGVuZ3RoKnIpLGw9e2xlZnQ6by5sZWZ0LHRvcDpvLnRvcCx3aWR0aDpvLndpZHRoLGhlaWdodDpvLmhlaWdodCxpdGVtczpjfTtsZXQgaCx1LGQsZixnLHAsbSxiPTA7aWYoaS5jb2RpbmdTdHlsZURlZmF1bHRQYXJhbWV0ZXJzLm11bHRpcGxlQ29tcG9uZW50VHJhbnNmb3JtKXtjb25zdCBlPTQ9PT1yLHQ9c1swXS5pdGVtcyxuPXNbMV0uaXRlbXMsbz1zWzJdLml0ZW1zLGw9ZT9zWzNdLml0ZW1zOm51bGw7aD1hWzBdLnByZWNpc2lvbi04O3U9LjUrKDEyODw8aCk7Y29uc3QgeT1pLmNvbXBvbmVudHNbMF0sdz1yLTM7Zj10Lmxlbmd0aDtpZih5LmNvZGluZ1N0eWxlUGFyYW1ldGVycy5yZXZlcnNpYmxlVHJhbnNmb3JtYXRpb24pZm9yKGQ9MDtkPGY7ZCsrLGIrPXcpe2c9dFtkXSt1O3A9bltkXTttPW9bZF07Y29uc3QgZT1nLShtK3A+PjIpO2NbYisrXT1lK20+Pmg7Y1tiKytdPWU+Pmg7Y1tiKytdPWUrcD4+aH1lbHNlIGZvcihkPTA7ZDxmO2QrKyxiKz13KXtnPXRbZF0rdTtwPW5bZF07bT1vW2RdO2NbYisrXT1nKzEuNDAyKm0+Pmg7Y1tiKytdPWctLjM0NDEzKnAtLjcxNDE0Km0+Pmg7Y1tiKytdPWcrMS43NzIqcD4+aH1pZihlKWZvcihkPTAsYj0zO2Q8ZjtkKyssYis9NCljW2JdPWxbZF0rdT4+aH1lbHNlIGZvcihsZXQgZT0wO2U8cjtlKyspe2NvbnN0IHQ9c1tlXS5pdGVtcztoPWFbZV0ucHJlY2lzaW9uLTg7dT0uNSsoMTI4PDxoKTtmb3IoYj1lLGQ9MCxmPXQubGVuZ3RoO2Q8ZjtkKyspe2NbYl09dFtkXSt1Pj5oO2IrPXJ9fW4ucHVzaChsKX1yZXR1cm4gbn0oaSk7dGhpcy53aWR0aD1pLlNJWi5Yc2l6LWkuU0laLlhPc2l6O3RoaXMuaGVpZ2h0PWkuU0laLllzaXotaS5TSVouWU9zaXo7dGhpcy5jb21wb25lbnRzQ291bnQ9aS5TSVouQ3Npen19O2Z1bmN0aW9uIGNhbGN1bGF0ZUNvbXBvbmVudERpbWVuc2lvbnMoZSx0KXtlLngwPU1hdGguY2VpbCh0LlhPc2l6L2UuWFJzaXopO2UueDE9TWF0aC5jZWlsKHQuWHNpei9lLlhSc2l6KTtlLnkwPU1hdGguY2VpbCh0LllPc2l6L2UuWVJzaXopO2UueTE9TWF0aC5jZWlsKHQuWXNpei9lLllSc2l6KTtlLndpZHRoPWUueDEtZS54MDtlLmhlaWdodD1lLnkxLWUueTB9ZnVuY3Rpb24gY2FsY3VsYXRlVGlsZUdyaWRzKGUsdCl7Y29uc3QgYT1lLlNJWixyPVtdO2xldCBuO2NvbnN0IGk9TWF0aC5jZWlsKChhLlhzaXotYS5YVE9zaXopL2EuWFRzaXopLHM9TWF0aC5jZWlsKChhLllzaXotYS5ZVE9zaXopL2EuWVRzaXopO2ZvcihsZXQgZT0wO2U8cztlKyspZm9yKGxldCB0PTA7dDxpO3QrKyl7bj17fTtuLnR4MD1NYXRoLm1heChhLlhUT3Npeit0KmEuWFRzaXosYS5YT3Npeik7bi50eTA9TWF0aC5tYXgoYS5ZVE9zaXorZSphLllUc2l6LGEuWU9zaXopO24udHgxPU1hdGgubWluKGEuWFRPc2l6Kyh0KzEpKmEuWFRzaXosYS5Yc2l6KTtuLnR5MT1NYXRoLm1pbihhLllUT3NpeisoZSsxKSphLllUc2l6LGEuWXNpeik7bi53aWR0aD1uLnR4MS1uLnR4MDtuLmhlaWdodD1uLnR5MS1uLnR5MDtuLmNvbXBvbmVudHM9W107ci5wdXNoKG4pfWUudGlsZXM9cjtmb3IobGV0IGU9MCxpPWEuQ3NpejtlPGk7ZSsrKXtjb25zdCBhPXRbZV07Zm9yKGxldCB0PTAsaT1yLmxlbmd0aDt0PGk7dCsrKXtjb25zdCBpPXt9O249clt0XTtpLnRjeDA9TWF0aC5jZWlsKG4udHgwL2EuWFJzaXopO2kudGN5MD1NYXRoLmNlaWwobi50eTAvYS5ZUnNpeik7aS50Y3gxPU1hdGguY2VpbChuLnR4MS9hLlhSc2l6KTtpLnRjeTE9TWF0aC5jZWlsKG4udHkxL2EuWVJzaXopO2kud2lkdGg9aS50Y3gxLWkudGN4MDtpLmhlaWdodD1pLnRjeTEtaS50Y3kwO24uY29tcG9uZW50c1tlXT1pfX19ZnVuY3Rpb24gZ2V0QmxvY2tzRGltZW5zaW9ucyhlLHQsYSl7Y29uc3Qgcj10LmNvZGluZ1N0eWxlUGFyYW1ldGVycyxuPXt9O2lmKHIuZW50cm9weUNvZGVyV2l0aEN1c3RvbVByZWNpbmN0cyl7bi5QUHg9ci5wcmVjaW5jdHNTaXplc1thXS5QUHg7bi5QUHk9ci5wcmVjaW5jdHNTaXplc1thXS5QUHl9ZWxzZXtuLlBQeD0xNTtuLlBQeT0xNX1uLnhjYl89YT4wP01hdGgubWluKHIueGNiLG4uUFB4LTEpOk1hdGgubWluKHIueGNiLG4uUFB4KTtuLnljYl89YT4wP01hdGgubWluKHIueWNiLG4uUFB5LTEpOk1hdGgubWluKHIueWNiLG4uUFB5KTtyZXR1cm4gbn1mdW5jdGlvbiBidWlsZFByZWNpbmN0cyhlLHQsYSl7Y29uc3Qgcj0xPDxhLlBQeCxuPTE8PGEuUFB5LGk9MD09PXQucmVzTGV2ZWwscz0xPDxhLlBQeCsoaT8wOi0xKSxvPTE8PGEuUFB5KyhpPzA6LTEpLGM9dC50cngxPnQudHJ4MD9NYXRoLmNlaWwodC50cngxL3IpLU1hdGguZmxvb3IodC50cngwL3IpOjAsbD10LnRyeTE+dC50cnkwP01hdGguY2VpbCh0LnRyeTEvbiktTWF0aC5mbG9vcih0LnRyeTAvbik6MCxoPWMqbDt0LnByZWNpbmN0UGFyYW1ldGVycz17cHJlY2luY3RXaWR0aDpyLHByZWNpbmN0SGVpZ2h0Om4sbnVtcHJlY2luY3Rzd2lkZTpjLG51bXByZWNpbmN0c2hpZ2g6bCxudW1wcmVjaW5jdHM6aCxwcmVjaW5jdFdpZHRoSW5TdWJiYW5kOnMscHJlY2luY3RIZWlnaHRJblN1YmJhbmQ6b319ZnVuY3Rpb24gYnVpbGRDb2RlYmxvY2tzKGUsdCxhKXtjb25zdCByPWEueGNiXyxuPWEueWNiXyxpPTE8PHIscz0xPDxuLG89dC50YngwPj5yLGM9dC50YnkwPj5uLGw9dC50YngxK2ktMT4+cixoPXQudGJ5MStzLTE+Pm4sdT10LnJlc29sdXRpb24ucHJlY2luY3RQYXJhbWV0ZXJzLGQ9W10sZj1bXTtsZXQgZyxwLG0sYjtmb3IocD1jO3A8aDtwKyspZm9yKGc9bztnPGw7ZysrKXttPXtjYng6ZyxjYnk6cCx0YngwOmkqZyx0YnkwOnMqcCx0YngxOmkqKGcrMSksdGJ5MTpzKihwKzEpfTttLnRieDBfPU1hdGgubWF4KHQudGJ4MCxtLnRieDApO20udGJ5MF89TWF0aC5tYXgodC50YnkwLG0udGJ5MCk7bS50YngxXz1NYXRoLm1pbih0LnRieDEsbS50YngxKTttLnRieTFfPU1hdGgubWluKHQudGJ5MSxtLnRieTEpO2I9TWF0aC5mbG9vcigobS50YngwXy10LnRieDApL3UucHJlY2luY3RXaWR0aEluU3ViYmFuZCkrTWF0aC5mbG9vcigobS50YnkwXy10LnRieTApL3UucHJlY2luY3RIZWlnaHRJblN1YmJhbmQpKnUubnVtcHJlY2luY3Rzd2lkZTttLnByZWNpbmN0TnVtYmVyPWI7bS5zdWJiYW5kVHlwZT10LnR5cGU7bS5MYmxvY2s9MztpZihtLnRieDFfPD1tLnRieDBffHxtLnRieTFfPD1tLnRieTBfKWNvbnRpbnVlO2QucHVzaChtKTtsZXQgZT1mW2JdO2lmKHZvaWQgMCE9PWUpe2c8ZS5jYnhNaW4/ZS5jYnhNaW49ZzpnPmUuY2J4TWF4JiYoZS5jYnhNYXg9Zyk7cDxlLmNieU1pbj9lLmNieE1pbj1wOnA+ZS5jYnlNYXgmJihlLmNieU1heD1wKX1lbHNlIGZbYl09ZT17Y2J4TWluOmcsY2J5TWluOnAsY2J4TWF4OmcsY2J5TWF4OnB9O20ucHJlY2luY3Q9ZX10LmNvZGVibG9ja1BhcmFtZXRlcnM9e2NvZGVibG9ja1dpZHRoOnIsY29kZWJsb2NrSGVpZ2h0Om4sbnVtY29kZWJsb2Nrd2lkZTpsLW8rMSxudW1jb2RlYmxvY2toaWdoOmgtYysxfTt0LmNvZGVibG9ja3M9ZDt0LnByZWNpbmN0cz1mfWZ1bmN0aW9uIGNyZWF0ZVBhY2tldChlLHQsYSl7Y29uc3Qgcj1bXSxuPWUuc3ViYmFuZHM7Zm9yKGxldCBlPTAsYT1uLmxlbmd0aDtlPGE7ZSsrKXtjb25zdCBhPW5bZV0uY29kZWJsb2Nrcztmb3IobGV0IGU9MCxuPWEubGVuZ3RoO2U8bjtlKyspe2NvbnN0IG49YVtlXTtuLnByZWNpbmN0TnVtYmVyPT09dCYmci5wdXNoKG4pfX1yZXR1cm57bGF5ZXJOdW1iZXI6YSxjb2RlYmxvY2tzOnJ9fWZ1bmN0aW9uIExheWVyUmVzb2x1dGlvbkNvbXBvbmVudFBvc2l0aW9uSXRlcmF0b3IoZSl7Y29uc3QgdD1lLlNJWixhPWUuY3VycmVudFRpbGUuaW5kZXgscj1lLnRpbGVzW2FdLG49ci5jb2RpbmdTdHlsZURlZmF1bHRQYXJhbWV0ZXJzLmxheWVyc0NvdW50LGk9dC5Dc2l6O2xldCBzPTA7Zm9yKGxldCBlPTA7ZTxpO2UrKylzPU1hdGgubWF4KHMsci5jb21wb25lbnRzW2VdLmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQpO2xldCBvPTAsYz0wLGw9MCxoPTA7dGhpcy5uZXh0UGFja2V0PWZ1bmN0aW9uIEpweEltYWdlX25leHRQYWNrZXQoKXtmb3IoO288bjtvKyspe2Zvcig7Yzw9cztjKyspe2Zvcig7bDxpO2wrKyl7Y29uc3QgZT1yLmNvbXBvbmVudHNbbF07aWYoYz5lLmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQpY29udGludWU7Y29uc3QgdD1lLnJlc29sdXRpb25zW2NdLGE9dC5wcmVjaW5jdFBhcmFtZXRlcnMubnVtcHJlY2luY3RzO2Zvcig7aDxhOyl7Y29uc3QgZT1jcmVhdGVQYWNrZXQodCxoLG8pO2grKztyZXR1cm4gZX1oPTB9bD0wfWM9MH10aHJvdyBuZXcgSnB4RXJyb3IoIk91dCBvZiBwYWNrZXRzIil9fWZ1bmN0aW9uIFJlc29sdXRpb25MYXllckNvbXBvbmVudFBvc2l0aW9uSXRlcmF0b3IoZSl7Y29uc3QgdD1lLlNJWixhPWUuY3VycmVudFRpbGUuaW5kZXgscj1lLnRpbGVzW2FdLG49ci5jb2RpbmdTdHlsZURlZmF1bHRQYXJhbWV0ZXJzLmxheWVyc0NvdW50LGk9dC5Dc2l6O2xldCBzPTA7Zm9yKGxldCBlPTA7ZTxpO2UrKylzPU1hdGgubWF4KHMsci5jb21wb25lbnRzW2VdLmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQpO2xldCBvPTAsYz0wLGw9MCxoPTA7dGhpcy5uZXh0UGFja2V0PWZ1bmN0aW9uIEpweEltYWdlX25leHRQYWNrZXQoKXtmb3IoO288PXM7bysrKXtmb3IoO2M8bjtjKyspe2Zvcig7bDxpO2wrKyl7Y29uc3QgZT1yLmNvbXBvbmVudHNbbF07aWYobz5lLmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQpY29udGludWU7Y29uc3QgdD1lLnJlc29sdXRpb25zW29dLGE9dC5wcmVjaW5jdFBhcmFtZXRlcnMubnVtcHJlY2luY3RzO2Zvcig7aDxhOyl7Y29uc3QgZT1jcmVhdGVQYWNrZXQodCxoLGMpO2grKztyZXR1cm4gZX1oPTB9bD0wfWM9MH10aHJvdyBuZXcgSnB4RXJyb3IoIk91dCBvZiBwYWNrZXRzIil9fWZ1bmN0aW9uIFJlc29sdXRpb25Qb3NpdGlvbkNvbXBvbmVudExheWVySXRlcmF0b3IoZSl7Y29uc3QgdD1lLlNJWixhPWUuY3VycmVudFRpbGUuaW5kZXgscj1lLnRpbGVzW2FdLG49ci5jb2RpbmdTdHlsZURlZmF1bHRQYXJhbWV0ZXJzLmxheWVyc0NvdW50LGk9dC5Dc2l6O2xldCBzLG8sYyxsLGg9MDtmb3IoYz0wO2M8aTtjKyspe2NvbnN0IGU9ci5jb21wb25lbnRzW2NdO2g9TWF0aC5tYXgoaCxlLmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQpfWNvbnN0IHU9bmV3IEludDMyQXJyYXkoaCsxKTtmb3Iobz0wO288PWg7KytvKXtsZXQgZT0wO2ZvcihjPTA7YzxpOysrYyl7Y29uc3QgdD1yLmNvbXBvbmVudHNbY10ucmVzb2x1dGlvbnM7bzx0Lmxlbmd0aCYmKGU9TWF0aC5tYXgoZSx0W29dLnByZWNpbmN0UGFyYW1ldGVycy5udW1wcmVjaW5jdHMpKX11W29dPWV9cz0wO289MDtjPTA7bD0wO3RoaXMubmV4dFBhY2tldD1mdW5jdGlvbiBKcHhJbWFnZV9uZXh0UGFja2V0KCl7Zm9yKDtvPD1oO28rKyl7Zm9yKDtsPHVbb107bCsrKXtmb3IoO2M8aTtjKyspe2NvbnN0IGU9ci5jb21wb25lbnRzW2NdO2lmKG8+ZS5jb2RpbmdTdHlsZVBhcmFtZXRlcnMuZGVjb21wb3NpdGlvbkxldmVsc0NvdW50KWNvbnRpbnVlO2NvbnN0IHQ9ZS5yZXNvbHV0aW9uc1tvXSxhPXQucHJlY2luY3RQYXJhbWV0ZXJzLm51bXByZWNpbmN0cztpZighKGw+PWEpKXtmb3IoO3M8bjspe2NvbnN0IGU9Y3JlYXRlUGFja2V0KHQsbCxzKTtzKys7cmV0dXJuIGV9cz0wfX1jPTB9bD0wfXRocm93IG5ldyBKcHhFcnJvcigiT3V0IG9mIHBhY2tldHMiKX19ZnVuY3Rpb24gUG9zaXRpb25Db21wb25lbnRSZXNvbHV0aW9uTGF5ZXJJdGVyYXRvcihlKXtjb25zdCB0PWUuU0laLGE9ZS5jdXJyZW50VGlsZS5pbmRleCxyPWUudGlsZXNbYV0sbj1yLmNvZGluZ1N0eWxlRGVmYXVsdFBhcmFtZXRlcnMubGF5ZXJzQ291bnQsaT10LkNzaXoscz1nZXRQcmVjaW5jdFNpemVzSW5JbWFnZVNjYWxlKHIpLG89cztsZXQgYz0wLGw9MCxoPTAsdT0wLGQ9MDt0aGlzLm5leHRQYWNrZXQ9ZnVuY3Rpb24gSnB4SW1hZ2VfbmV4dFBhY2tldCgpe2Zvcig7ZDxvLm1heE51bUhpZ2g7ZCsrKXtmb3IoO3U8by5tYXhOdW1XaWRlO3UrKyl7Zm9yKDtoPGk7aCsrKXtjb25zdCBlPXIuY29tcG9uZW50c1toXSx0PWUuY29kaW5nU3R5bGVQYXJhbWV0ZXJzLmRlY29tcG9zaXRpb25MZXZlbHNDb3VudDtmb3IoO2w8PXQ7bCsrKXtjb25zdCB0PWUucmVzb2x1dGlvbnNbbF0sYT1zLmNvbXBvbmVudHNbaF0ucmVzb2x1dGlvbnNbbF0scj1nZXRQcmVjaW5jdEluZGV4SWZFeGlzdCh1LGQsYSxvLHQpO2lmKG51bGwhPT1yKXtmb3IoO2M8bjspe2NvbnN0IGU9Y3JlYXRlUGFja2V0KHQscixjKTtjKys7cmV0dXJuIGV9Yz0wfX1sPTB9aD0wfXU9MH10aHJvdyBuZXcgSnB4RXJyb3IoIk91dCBvZiBwYWNrZXRzIil9fWZ1bmN0aW9uIENvbXBvbmVudFBvc2l0aW9uUmVzb2x1dGlvbkxheWVySXRlcmF0b3IoZSl7Y29uc3QgdD1lLlNJWixhPWUuY3VycmVudFRpbGUuaW5kZXgscj1lLnRpbGVzW2FdLG49ci5jb2RpbmdTdHlsZURlZmF1bHRQYXJhbWV0ZXJzLmxheWVyc0NvdW50LGk9dC5Dc2l6LHM9Z2V0UHJlY2luY3RTaXplc0luSW1hZ2VTY2FsZShyKTtsZXQgbz0wLGM9MCxsPTAsaD0wLHU9MDt0aGlzLm5leHRQYWNrZXQ9ZnVuY3Rpb24gSnB4SW1hZ2VfbmV4dFBhY2tldCgpe2Zvcig7bDxpOysrbCl7Y29uc3QgZT1yLmNvbXBvbmVudHNbbF0sdD1zLmNvbXBvbmVudHNbbF0sYT1lLmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQ7Zm9yKDt1PHQubWF4TnVtSGlnaDt1Kyspe2Zvcig7aDx0Lm1heE51bVdpZGU7aCsrKXtmb3IoO2M8PWE7YysrKXtjb25zdCBhPWUucmVzb2x1dGlvbnNbY10scj10LnJlc29sdXRpb25zW2NdLGk9Z2V0UHJlY2luY3RJbmRleElmRXhpc3QoaCx1LHIsdCxhKTtpZihudWxsIT09aSl7Zm9yKDtvPG47KXtjb25zdCBlPWNyZWF0ZVBhY2tldChhLGksbyk7bysrO3JldHVybiBlfW89MH19Yz0wfWg9MH11PTB9dGhyb3cgbmV3IEpweEVycm9yKCJPdXQgb2YgcGFja2V0cyIpfX1mdW5jdGlvbiBnZXRQcmVjaW5jdEluZGV4SWZFeGlzdChlLHQsYSxyLG4pe2NvbnN0IGk9ZSpyLm1pbldpZHRoLHM9dCpyLm1pbkhlaWdodDtpZihpJWEud2lkdGghPTB8fHMlYS5oZWlnaHQhPTApcmV0dXJuIG51bGw7Y29uc3Qgbz1zL2Eud2lkdGgqbi5wcmVjaW5jdFBhcmFtZXRlcnMubnVtcHJlY2luY3Rzd2lkZTtyZXR1cm4gaS9hLmhlaWdodCtvfWZ1bmN0aW9uIGdldFByZWNpbmN0U2l6ZXNJbkltYWdlU2NhbGUoZSl7Y29uc3QgdD1lLmNvbXBvbmVudHMubGVuZ3RoO2xldCBhPU51bWJlci5NQVhfVkFMVUUscj1OdW1iZXIuTUFYX1ZBTFVFLG49MCxpPTA7Y29uc3Qgcz1uZXcgQXJyYXkodCk7Zm9yKGxldCBvPTA7bzx0O28rKyl7Y29uc3QgdD1lLmNvbXBvbmVudHNbb10sYz10LmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQsbD1uZXcgQXJyYXkoYysxKTtsZXQgaD1OdW1iZXIuTUFYX1ZBTFVFLHU9TnVtYmVyLk1BWF9WQUxVRSxkPTAsZj0wLGc9MTtmb3IobGV0IGU9YztlPj0wOy0tZSl7Y29uc3QgYT10LnJlc29sdXRpb25zW2VdLHI9ZyphLnByZWNpbmN0UGFyYW1ldGVycy5wcmVjaW5jdFdpZHRoLG49ZyphLnByZWNpbmN0UGFyYW1ldGVycy5wcmVjaW5jdEhlaWdodDtoPU1hdGgubWluKGgscik7dT1NYXRoLm1pbih1LG4pO2Q9TWF0aC5tYXgoZCxhLnByZWNpbmN0UGFyYW1ldGVycy5udW1wcmVjaW5jdHN3aWRlKTtmPU1hdGgubWF4KGYsYS5wcmVjaW5jdFBhcmFtZXRlcnMubnVtcHJlY2luY3RzaGlnaCk7bFtlXT17d2lkdGg6cixoZWlnaHQ6bn07Zzw8PTF9YT1NYXRoLm1pbihhLGgpO3I9TWF0aC5taW4ocix1KTtuPU1hdGgubWF4KG4sZCk7aT1NYXRoLm1heChpLGYpO3Nbb109e3Jlc29sdXRpb25zOmwsbWluV2lkdGg6aCxtaW5IZWlnaHQ6dSxtYXhOdW1XaWRlOmQsbWF4TnVtSGlnaDpmfX1yZXR1cm57Y29tcG9uZW50czpzLG1pbldpZHRoOmEsbWluSGVpZ2h0OnIsbWF4TnVtV2lkZTpuLG1heE51bUhpZ2g6aX19ZnVuY3Rpb24gYnVpbGRQYWNrZXRzKGUpe2NvbnN0IHQ9ZS5TSVosYT1lLmN1cnJlbnRUaWxlLmluZGV4LHI9ZS50aWxlc1thXSxuPXQuQ3Npejtmb3IobGV0IGU9MDtlPG47ZSsrKXtjb25zdCB0PXIuY29tcG9uZW50c1tlXSxhPXQuY29kaW5nU3R5bGVQYXJhbWV0ZXJzLmRlY29tcG9zaXRpb25MZXZlbHNDb3VudCxuPVtdLGk9W107Zm9yKGxldCBlPTA7ZTw9YTtlKyspe2NvbnN0IHI9Z2V0QmxvY2tzRGltZW5zaW9ucygwLHQsZSkscz17fSxvPTE8PGEtZTtzLnRyeDA9TWF0aC5jZWlsKHQudGN4MC9vKTtzLnRyeTA9TWF0aC5jZWlsKHQudGN5MC9vKTtzLnRyeDE9TWF0aC5jZWlsKHQudGN4MS9vKTtzLnRyeTE9TWF0aC5jZWlsKHQudGN5MS9vKTtzLnJlc0xldmVsPWU7YnVpbGRQcmVjaW5jdHMoMCxzLHIpO24ucHVzaChzKTtsZXQgYztpZigwPT09ZSl7Yz17fTtjLnR5cGU9IkxMIjtjLnRieDA9TWF0aC5jZWlsKHQudGN4MC9vKTtjLnRieTA9TWF0aC5jZWlsKHQudGN5MC9vKTtjLnRieDE9TWF0aC5jZWlsKHQudGN4MS9vKTtjLnRieTE9TWF0aC5jZWlsKHQudGN5MS9vKTtjLnJlc29sdXRpb249cztidWlsZENvZGVibG9ja3MoMCxjLHIpO2kucHVzaChjKTtzLnN1YmJhbmRzPVtjXX1lbHNle2NvbnN0IG49MTw8YS1lKzEsbz1bXTtjPXt9O2MudHlwZT0iSEwiO2MudGJ4MD1NYXRoLmNlaWwodC50Y3gwL24tLjUpO2MudGJ5MD1NYXRoLmNlaWwodC50Y3kwL24pO2MudGJ4MT1NYXRoLmNlaWwodC50Y3gxL24tLjUpO2MudGJ5MT1NYXRoLmNlaWwodC50Y3kxL24pO2MucmVzb2x1dGlvbj1zO2J1aWxkQ29kZWJsb2NrcygwLGMscik7aS5wdXNoKGMpO28ucHVzaChjKTtjPXt9O2MudHlwZT0iTEgiO2MudGJ4MD1NYXRoLmNlaWwodC50Y3gwL24pO2MudGJ5MD1NYXRoLmNlaWwodC50Y3kwL24tLjUpO2MudGJ4MT1NYXRoLmNlaWwodC50Y3gxL24pO2MudGJ5MT1NYXRoLmNlaWwodC50Y3kxL24tLjUpO2MucmVzb2x1dGlvbj1zO2J1aWxkQ29kZWJsb2NrcygwLGMscik7aS5wdXNoKGMpO28ucHVzaChjKTtjPXt9O2MudHlwZT0iSEgiO2MudGJ4MD1NYXRoLmNlaWwodC50Y3gwL24tLjUpO2MudGJ5MD1NYXRoLmNlaWwodC50Y3kwL24tLjUpO2MudGJ4MT1NYXRoLmNlaWwodC50Y3gxL24tLjUpO2MudGJ5MT1NYXRoLmNlaWwodC50Y3kxL24tLjUpO2MucmVzb2x1dGlvbj1zO2J1aWxkQ29kZWJsb2NrcygwLGMscik7aS5wdXNoKGMpO28ucHVzaChjKTtzLnN1YmJhbmRzPW99fXQucmVzb2x1dGlvbnM9bjt0LnN1YmJhbmRzPWl9Y29uc3QgaT1yLmNvZGluZ1N0eWxlRGVmYXVsdFBhcmFtZXRlcnMucHJvZ3Jlc3Npb25PcmRlcjtzd2l0Y2goaSl7Y2FzZSAwOnIucGFja2V0c0l0ZXJhdG9yPW5ldyBMYXllclJlc29sdXRpb25Db21wb25lbnRQb3NpdGlvbkl0ZXJhdG9yKGUpO2JyZWFrO2Nhc2UgMTpyLnBhY2tldHNJdGVyYXRvcj1uZXcgUmVzb2x1dGlvbkxheWVyQ29tcG9uZW50UG9zaXRpb25JdGVyYXRvcihlKTticmVhaztjYXNlIDI6ci5wYWNrZXRzSXRlcmF0b3I9bmV3IFJlc29sdXRpb25Qb3NpdGlvbkNvbXBvbmVudExheWVySXRlcmF0b3IoZSk7YnJlYWs7Y2FzZSAzOnIucGFja2V0c0l0ZXJhdG9yPW5ldyBQb3NpdGlvbkNvbXBvbmVudFJlc29sdXRpb25MYXllckl0ZXJhdG9yKGUpO2JyZWFrO2Nhc2UgNDpyLnBhY2tldHNJdGVyYXRvcj1uZXcgQ29tcG9uZW50UG9zaXRpb25SZXNvbHV0aW9uTGF5ZXJJdGVyYXRvcihlKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBKcHhFcnJvcihgVW5zdXBwb3J0ZWQgcHJvZ3Jlc3Npb24gb3JkZXIgJHtpfWApfX1mdW5jdGlvbiBwYXJzZVRpbGVQYWNrZXRzKGUsdCxhLHIpe2xldCBpLHM9MCxvPTAsYz0hMTtmdW5jdGlvbiByZWFkQml0cyhlKXtmb3IoO288ZTspe2NvbnN0IGU9dFthK3NdO3MrKztpZihjKXtpPWk8PDd8ZTtvKz03O2M9ITF9ZWxzZXtpPWk8PDh8ZTtvKz04fTI1NT09PWUmJihjPSEwKX1vLT1lO3JldHVybiBpPj4+byYoMTw8ZSktMX1mdW5jdGlvbiBza2lwTWFya2VySWZFcXVhbChlKXtpZigyNTU9PT10W2Ercy0xXSYmdFthK3NdPT09ZSl7c2tpcEJ5dGVzKDEpO3JldHVybiEwfWlmKDI1NT09PXRbYStzXSYmdFthK3MrMV09PT1lKXtza2lwQnl0ZXMoMik7cmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gc2tpcEJ5dGVzKGUpe3MrPWV9ZnVuY3Rpb24gYWxpZ25Ub0J5dGUoKXtvPTA7aWYoYyl7cysrO2M9ITF9fWZ1bmN0aW9uIHJlYWRDb2RpbmdwYXNzZXMoKXtpZigwPT09cmVhZEJpdHMoMSkpcmV0dXJuIDE7aWYoMD09PXJlYWRCaXRzKDEpKXJldHVybiAyO2xldCBlPXJlYWRCaXRzKDIpO2lmKGU8MylyZXR1cm4gZSszO2U9cmVhZEJpdHMoNSk7aWYoZTwzMSlyZXR1cm4gZSs2O2U9cmVhZEJpdHMoNyk7cmV0dXJuIGUrMzd9Y29uc3QgbD1lLmN1cnJlbnRUaWxlLmluZGV4LGg9ZS50aWxlc1tsXSx1PWUuQ09ELnNvcE1hcmtlclVzZWQsZD1lLkNPRC5lcGhNYXJrZXJVc2VkLGY9aC5wYWNrZXRzSXRlcmF0b3I7Zm9yKDtzPHI7KXthbGlnblRvQnl0ZSgpO3UmJnNraXBNYXJrZXJJZkVxdWFsKDE0NSkmJnNraXBCeXRlcyg0KTtjb25zdCBlPWYubmV4dFBhY2tldCgpO2lmKCFyZWFkQml0cygxKSljb250aW51ZTtjb25zdCByPWUubGF5ZXJOdW1iZXIsaT1bXTtsZXQgbztmb3IobGV0IHQ9MCxhPWUuY29kZWJsb2Nrcy5sZW5ndGg7dDxhO3QrKyl7bz1lLmNvZGVibG9ja3NbdF07bGV0IGE9by5wcmVjaW5jdDtjb25zdCBzPW8uY2J4LWEuY2J4TWluLGM9by5jYnktYS5jYnlNaW47bGV0IGwsaCx1PSExLGQ9ITE7aWYodm9pZCAwIT09by5pbmNsdWRlZCl1PSEhcmVhZEJpdHMoMSk7ZWxzZXthPW8ucHJlY2luY3Q7bGV0IGU7aWYodm9pZCAwIT09YS5pbmNsdXNpb25UcmVlKWU9YS5pbmNsdXNpb25UcmVlO2Vsc2V7Y29uc3QgdD1hLmNieE1heC1hLmNieE1pbisxLG49YS5jYnlNYXgtYS5jYnlNaW4rMTtlPW5ldyBJbmNsdXNpb25UcmVlKHQsbixyKTtoPW5ldyBUYWdUcmVlKHQsbik7YS5pbmNsdXNpb25UcmVlPWU7YS56ZXJvQml0UGxhbmVzVHJlZT1oO2ZvcihsZXQgZT0wO2U8cjtlKyspaWYoMCE9PXJlYWRCaXRzKDEpKXRocm93IG5ldyBKcHhFcnJvcigiSW52YWxpZCB0YWcgdHJlZSIpfWlmKGUucmVzZXQocyxjLHIpKWZvcig7Oyl7aWYoIXJlYWRCaXRzKDEpKXtlLmluY3JlbWVudFZhbHVlKHIpO2JyZWFrfWw9IWUubmV4dExldmVsKCk7aWYobCl7by5pbmNsdWRlZD0hMDt1PWQ9ITA7YnJlYWt9fX1pZighdSljb250aW51ZTtpZihkKXtoPWEuemVyb0JpdFBsYW5lc1RyZWU7aC5yZXNldChzLGMpO2Zvcig7OylpZihyZWFkQml0cygxKSl7bD0haC5uZXh0TGV2ZWwoKTtpZihsKWJyZWFrfWVsc2UgaC5pbmNyZW1lbnRWYWx1ZSgpO28uemVyb0JpdFBsYW5lcz1oLnZhbHVlfWNvbnN0IGY9cmVhZENvZGluZ3Bhc3NlcygpO2Zvcig7cmVhZEJpdHMoMSk7KW8uTGJsb2NrKys7Y29uc3QgZz0oMCxuLmxvZzIpKGYpLHA9cmVhZEJpdHMoKGY8MTw8Zz9nLTE6Zykrby5MYmxvY2spO2kucHVzaCh7Y29kZWJsb2NrOm8sY29kaW5ncGFzc2VzOmYsZGF0YUxlbmd0aDpwfSl9YWxpZ25Ub0J5dGUoKTtkJiZza2lwTWFya2VySWZFcXVhbCgxNDYpO2Zvcig7aS5sZW5ndGg+MDspe2NvbnN0IGU9aS5zaGlmdCgpO289ZS5jb2RlYmxvY2s7dm9pZCAwPT09by5kYXRhJiYoby5kYXRhPVtdKTtvLmRhdGEucHVzaCh7ZGF0YTp0LHN0YXJ0OmErcyxlbmQ6YStzK2UuZGF0YUxlbmd0aCxjb2RpbmdwYXNzZXM6ZS5jb2RpbmdwYXNzZXN9KTtzKz1lLmRhdGFMZW5ndGh9fXJldHVybiBzfWZ1bmN0aW9uIGNvcHlDb2VmZmljaWVudHMoZSx0LGEscixuLHMsYyxsLGgpe2NvbnN0IHU9ci50YngwLGQ9ci50YnkwLGY9ci50YngxLXIudGJ4MCxnPXIuY29kZWJsb2NrcyxwPSJIIj09PXIudHlwZS5jaGFyQXQoMCk/MTowLG09IkgiPT09ci50eXBlLmNoYXJBdCgxKT90OjA7Zm9yKGxldCBhPTAsYj1nLmxlbmd0aDthPGI7KythKXtjb25zdCBiPWdbYV0seT1iLnRieDFfLWIudGJ4MF8sdz1iLnRieTFfLWIudGJ5MF87aWYoMD09PXl8fDA9PT13KWNvbnRpbnVlO2lmKHZvaWQgMD09PWIuZGF0YSljb250aW51ZTtjb25zdCBTPW5ldyBvKHksdyxiLnN1YmJhbmRUeXBlLGIuemVyb0JpdFBsYW5lcyxzKTtsZXQgeD0yO2NvbnN0IGs9Yi5kYXRhO2xldCBDLHYsRixPPTAsVD0wO2ZvcihDPTAsdj1rLmxlbmd0aDtDPHY7QysrKXtGPWtbQ107Tys9Ri5lbmQtRi5zdGFydDtUKz1GLmNvZGluZ3Bhc3Nlc31jb25zdCBNPW5ldyBVaW50OEFycmF5KE8pO2xldCBFPTA7Zm9yKEM9MCx2PWsubGVuZ3RoO0M8djtDKyspe0Y9a1tDXTtjb25zdCBlPUYuZGF0YS5zdWJhcnJheShGLnN0YXJ0LEYuZW5kKTtNLnNldChlLEUpO0UrPWUubGVuZ3RofWNvbnN0IEQ9bmV3IGkuQXJpdGhtZXRpY0RlY29kZXIoTSwwLE8pO1Muc2V0RGVjb2RlcihEKTtmb3IoQz0wO0M8VDtDKyspe3N3aXRjaCh4KXtjYXNlIDA6Uy5ydW5TaWduaWZpY2FuY2VQcm9wYWdhdGlvblBhc3MoKTticmVhaztjYXNlIDE6Uy5ydW5NYWduaXR1ZGVSZWZpbmVtZW50UGFzcygpO2JyZWFrO2Nhc2UgMjpTLnJ1bkNsZWFudXBQYXNzKCk7bCYmUy5jaGVja1NlZ21lbnRhdGlvblN5bWJvbCgpfWgmJlMucmVzZXQoKTt4PSh4KzEpJTN9bGV0IE49Yi50YngwXy11KyhiLnRieTBfLWQpKmY7Y29uc3QgUj1TLmNvZWZmaWNlbnRzU2lnbixMPVMuY29lZmZpY2VudHNNYWduaXR1ZGUsaj1TLmJpdHNEZWNvZGVkLCQ9Yz8wOi41O2xldCBfLFUsWDtFPTA7Y29uc3QgSD0iTEwiIT09ci50eXBlO2ZvcihDPTA7Qzx3O0MrKyl7Y29uc3QgYT0yKihOL2Z8MCkqKHQtZikrcCttO2ZvcihfPTA7Xzx5O18rKyl7VT1MW0VdO2lmKDAhPT1VKXtVPShVKyQpKm47MCE9PVJbRV0mJihVPS1VKTtYPWpbRV07Y29uc3QgdD1IP2ErKE48PDEpOk47ZVt0XT1jJiZYPj1zP1U6VSooMTw8cy1YKX1OKys7RSsrfU4rPWYteX19fWZ1bmN0aW9uIHRyYW5zZm9ybVRpbGUoZSx0LGEpe2NvbnN0IHI9dC5jb21wb25lbnRzW2FdLG49ci5jb2RpbmdTdHlsZVBhcmFtZXRlcnMsaT1yLnF1YW50aXphdGlvblBhcmFtZXRlcnMsbz1uLmRlY29tcG9zaXRpb25MZXZlbHNDb3VudCxjPWkuU1BxY2RzLGw9aS5zY2FsYXJFeHBvdW5kZWQsaD1pLmd1YXJkQml0cyx1PW4uc2VnbWVudGF0aW9uU3ltYm9sVXNlZCxkPW4ucmVzZXRDb250ZXh0UHJvYmFiaWxpdGllcyxmPWUuY29tcG9uZW50c1thXS5wcmVjaXNpb24sZz1uLnJldmVyc2libGVUcmFuc2Zvcm1hdGlvbixwPWc/bmV3IFJldmVyc2libGVUcmFuc2Zvcm06bmV3IElycmV2ZXJzaWJsZVRyYW5zZm9ybSxtPVtdO2xldCBiPTA7Zm9yKGxldCBlPTA7ZTw9bztlKyspe2NvbnN0IHQ9ci5yZXNvbHV0aW9uc1tlXSxhPXQudHJ4MS10LnRyeDAsbj10LnRyeTEtdC50cnkwLGk9bmV3IEZsb2F0MzJBcnJheShhKm4pO2ZvcihsZXQgcj0wLG49dC5zdWJiYW5kcy5sZW5ndGg7cjxuO3IrKyl7bGV0IG4sbztpZihsKXtuPWNbYl0ubXU7bz1jW2JdLmVwc2lsb247YisrfWVsc2V7bj1jWzBdLm11O289Y1swXS5lcHNpbG9uKyhlPjA/MS1lOjApfWNvbnN0IHA9dC5zdWJiYW5kc1tyXSxtPXNbcC50eXBlXTtjb3B5Q29lZmZpY2llbnRzKGksYSwwLHAsZz8xOjIqKihmK20tbykqKDErbi8yMDQ4KSxoK28tMSxnLHUsZCl9bS5wdXNoKHt3aWR0aDphLGhlaWdodDpuLGl0ZW1zOml9KX1jb25zdCB5PXAuY2FsY3VsYXRlKG0sci50Y3gwLHIudGN5MCk7cmV0dXJue2xlZnQ6ci50Y3gwLHRvcDpyLnRjeTAsd2lkdGg6eS53aWR0aCxoZWlnaHQ6eS5oZWlnaHQsaXRlbXM6eS5pdGVtc319ZnVuY3Rpb24gaW5pdGlhbGl6ZVRpbGUoZSx0KXtjb25zdCBhPWUuU0laLkNzaXoscj1lLnRpbGVzW3RdO2ZvcihsZXQgdD0wO3Q8YTt0Kyspe2NvbnN0IGE9ci5jb21wb25lbnRzW3RdLG49dm9pZCAwIT09ZS5jdXJyZW50VGlsZS5RQ0NbdF0/ZS5jdXJyZW50VGlsZS5RQ0NbdF06ZS5jdXJyZW50VGlsZS5RQ0Q7YS5xdWFudGl6YXRpb25QYXJhbWV0ZXJzPW47Y29uc3QgaT12b2lkIDAhPT1lLmN1cnJlbnRUaWxlLkNPQ1t0XT9lLmN1cnJlbnRUaWxlLkNPQ1t0XTplLmN1cnJlbnRUaWxlLkNPRDthLmNvZGluZ1N0eWxlUGFyYW1ldGVycz1pfXIuY29kaW5nU3R5bGVEZWZhdWx0UGFyYW1ldGVycz1lLmN1cnJlbnRUaWxlLkNPRH1jbGFzcyBUYWdUcmVle2NvbnN0cnVjdG9yKGUsdCl7Y29uc3QgYT0oMCxuLmxvZzIpKE1hdGgubWF4KGUsdCkpKzE7dGhpcy5sZXZlbHM9W107Zm9yKGxldCByPTA7cjxhO3IrKyl7Y29uc3QgYT17d2lkdGg6ZSxoZWlnaHQ6dCxpdGVtczpbXX07dGhpcy5sZXZlbHMucHVzaChhKTtlPU1hdGguY2VpbChlLzIpO3Q9TWF0aC5jZWlsKHQvMil9fXJlc2V0KGUsdCl7bGV0IGEscj0wLG49MDtmb3IoO3I8dGhpcy5sZXZlbHMubGVuZ3RoOyl7YT10aGlzLmxldmVsc1tyXTtjb25zdCBpPWUrdCphLndpZHRoO2lmKHZvaWQgMCE9PWEuaXRlbXNbaV0pe249YS5pdGVtc1tpXTticmVha31hLmluZGV4PWk7ZT4+PTE7dD4+PTE7cisrfXItLTthPXRoaXMubGV2ZWxzW3JdO2EuaXRlbXNbYS5pbmRleF09bjt0aGlzLmN1cnJlbnRMZXZlbD1yO2RlbGV0ZSB0aGlzLnZhbHVlfWluY3JlbWVudFZhbHVlKCl7Y29uc3QgZT10aGlzLmxldmVsc1t0aGlzLmN1cnJlbnRMZXZlbF07ZS5pdGVtc1tlLmluZGV4XSsrfW5leHRMZXZlbCgpe2xldCBlPXRoaXMuY3VycmVudExldmVsLHQ9dGhpcy5sZXZlbHNbZV07Y29uc3QgYT10Lml0ZW1zW3QuaW5kZXhdO2UtLTtpZihlPDApe3RoaXMudmFsdWU9YTtyZXR1cm4hMX10aGlzLmN1cnJlbnRMZXZlbD1lO3Q9dGhpcy5sZXZlbHNbZV07dC5pdGVtc1t0LmluZGV4XT1hO3JldHVybiEwfX1jbGFzcyBJbmNsdXNpb25UcmVle2NvbnN0cnVjdG9yKGUsdCxhKXtjb25zdCByPSgwLG4ubG9nMikoTWF0aC5tYXgoZSx0KSkrMTt0aGlzLmxldmVscz1bXTtmb3IobGV0IG49MDtuPHI7bisrKXtjb25zdCByPW5ldyBVaW50OEFycmF5KGUqdCk7Zm9yKGxldCBlPTAsdD1yLmxlbmd0aDtlPHQ7ZSsrKXJbZV09YTtjb25zdCBuPXt3aWR0aDplLGhlaWdodDp0LGl0ZW1zOnJ9O3RoaXMubGV2ZWxzLnB1c2gobik7ZT1NYXRoLmNlaWwoZS8yKTt0PU1hdGguY2VpbCh0LzIpfX1yZXNldChlLHQsYSl7bGV0IHI9MDtmb3IoO3I8dGhpcy5sZXZlbHMubGVuZ3RoOyl7Y29uc3Qgbj10aGlzLmxldmVsc1tyXSxpPWUrdCpuLndpZHRoO24uaW5kZXg9aTtjb25zdCBzPW4uaXRlbXNbaV07aWYoMjU1PT09cylicmVhaztpZihzPmEpe3RoaXMuY3VycmVudExldmVsPXI7dGhpcy5wcm9wYWdhdGVWYWx1ZXMoKTtyZXR1cm4hMX1lPj49MTt0Pj49MTtyKyt9dGhpcy5jdXJyZW50TGV2ZWw9ci0xO3JldHVybiEwfWluY3JlbWVudFZhbHVlKGUpe2NvbnN0IHQ9dGhpcy5sZXZlbHNbdGhpcy5jdXJyZW50TGV2ZWxdO3QuaXRlbXNbdC5pbmRleF09ZSsxO3RoaXMucHJvcGFnYXRlVmFsdWVzKCl9cHJvcGFnYXRlVmFsdWVzKCl7bGV0IGU9dGhpcy5jdXJyZW50TGV2ZWwsdD10aGlzLmxldmVsc1tlXTtjb25zdCBhPXQuaXRlbXNbdC5pbmRleF07Zm9yKDstLWU+PTA7KXt0PXRoaXMubGV2ZWxzW2VdO3QuaXRlbXNbdC5pbmRleF09YX19bmV4dExldmVsKCl7bGV0IGU9dGhpcy5jdXJyZW50TGV2ZWwsdD10aGlzLmxldmVsc1tlXTtjb25zdCBhPXQuaXRlbXNbdC5pbmRleF07dC5pdGVtc1t0LmluZGV4XT0yNTU7ZS0tO2lmKGU8MClyZXR1cm4hMTt0aGlzLmN1cnJlbnRMZXZlbD1lO3Q9dGhpcy5sZXZlbHNbZV07dC5pdGVtc1t0LmluZGV4XT1hO3JldHVybiEwfX1jb25zdCBvPWZ1bmN0aW9uIEJpdE1vZGVsQ2xvc3VyZSgpe2NvbnN0IGU9MTcsdD1uZXcgVWludDhBcnJheShbMCw1LDgsMCwzLDcsOCwwLDQsNyw4LDAsMCwwLDAsMCwxLDYsOCwwLDMsNyw4LDAsNCw3LDgsMCwwLDAsMCwwLDIsNiw4LDAsMyw3LDgsMCw0LDcsOCwwLDAsMCwwLDAsMiw2LDgsMCwzLDcsOCwwLDQsNyw4LDAsMCwwLDAsMCwyLDYsOCwwLDMsNyw4LDAsNCw3LDhdKSxhPW5ldyBVaW50OEFycmF5KFswLDMsNCwwLDUsNyw3LDAsOCw4LDgsMCwwLDAsMCwwLDEsMyw0LDAsNiw3LDcsMCw4LDgsOCwwLDAsMCwwLDAsMiwzLDQsMCw2LDcsNywwLDgsOCw4LDAsMCwwLDAsMCwyLDMsNCwwLDYsNyw3LDAsOCw4LDgsMCwwLDAsMCwwLDIsMyw0LDAsNiw3LDcsMCw4LDgsOF0pLHI9bmV3IFVpbnQ4QXJyYXkoWzAsMSwyLDAsMSwyLDIsMCwyLDIsMiwwLDAsMCwwLDAsMyw0LDUsMCw0LDUsNSwwLDUsNSw1LDAsMCwwLDAsMCw2LDcsNywwLDcsNyw3LDAsNyw3LDcsMCwwLDAsMCwwLDgsOCw4LDAsOCw4LDgsMCw4LDgsOCwwLDAsMCwwLDAsOCw4LDgsMCw4LDgsOCwwLDgsOCw4XSk7cmV0dXJuIGNsYXNzIEJpdE1vZGVse2NvbnN0cnVjdG9yKGUsbixpLHMsbyl7dGhpcy53aWR0aD1lO3RoaXMuaGVpZ2h0PW47bGV0IGM7Yz0iSEgiPT09aT9yOiJITCI9PT1pP2E6dDt0aGlzLmNvbnRleHRMYWJlbFRhYmxlPWM7Y29uc3QgbD1lKm47dGhpcy5uZWlnaGJvcnNTaWduaWZpY2FuY2U9bmV3IFVpbnQ4QXJyYXkobCk7dGhpcy5jb2VmZmljZW50c1NpZ249bmV3IFVpbnQ4QXJyYXkobCk7bGV0IGg7aD1vPjE0P25ldyBVaW50MzJBcnJheShsKTpvPjY/bmV3IFVpbnQxNkFycmF5KGwpOm5ldyBVaW50OEFycmF5KGwpO3RoaXMuY29lZmZpY2VudHNNYWduaXR1ZGU9aDt0aGlzLnByb2Nlc3NpbmdGbGFncz1uZXcgVWludDhBcnJheShsKTtjb25zdCB1PW5ldyBVaW50OEFycmF5KGwpO2lmKDAhPT1zKWZvcihsZXQgZT0wO2U8bDtlKyspdVtlXT1zO3RoaXMuYml0c0RlY29kZWQ9dTt0aGlzLnJlc2V0KCl9c2V0RGVjb2RlcihlKXt0aGlzLmRlY29kZXI9ZX1yZXNldCgpe3RoaXMuY29udGV4dHM9bmV3IEludDhBcnJheSgxOSk7dGhpcy5jb250ZXh0c1swXT04O3RoaXMuY29udGV4dHNbMTddPTkyO3RoaXMuY29udGV4dHNbMThdPTZ9c2V0TmVpZ2hib3JzU2lnbmlmaWNhbmNlKGUsdCxhKXtjb25zdCByPXRoaXMubmVpZ2hib3JzU2lnbmlmaWNhbmNlLG49dGhpcy53aWR0aCxpPXRoaXMuaGVpZ2h0LHM9dD4wLG89dCsxPG47bGV0IGM7aWYoZT4wKXtjPWEtbjtzJiYocltjLTFdKz0xNik7byYmKHJbYysxXSs9MTYpO3JbY10rPTR9aWYoZSsxPGkpe2M9YStuO3MmJihyW2MtMV0rPTE2KTtvJiYocltjKzFdKz0xNik7cltjXSs9NH1zJiYoclthLTFdKz0xKTtvJiYoclthKzFdKz0xKTtyW2FdfD0xMjh9cnVuU2lnbmlmaWNhbmNlUHJvcGFnYXRpb25QYXNzKCl7Y29uc3QgZT10aGlzLmRlY29kZXIsdD10aGlzLndpZHRoLGE9dGhpcy5oZWlnaHQscj10aGlzLmNvZWZmaWNlbnRzTWFnbml0dWRlLG49dGhpcy5jb2VmZmljZW50c1NpZ24saT10aGlzLm5laWdoYm9yc1NpZ25pZmljYW5jZSxzPXRoaXMucHJvY2Vzc2luZ0ZsYWdzLG89dGhpcy5jb250ZXh0cyxjPXRoaXMuY29udGV4dExhYmVsVGFibGUsbD10aGlzLmJpdHNEZWNvZGVkO2ZvcihsZXQgaD0wO2g8YTtoKz00KWZvcihsZXQgdT0wO3U8dDt1Kyspe2xldCBkPWgqdCt1O2ZvcihsZXQgZj0wO2Y8NDtmKyssZCs9dCl7Y29uc3QgdD1oK2Y7aWYodD49YSlicmVhaztzW2RdJj0tMjtpZihyW2RdfHwhaVtkXSljb250aW51ZTtjb25zdCBnPWNbaVtkXV07aWYoZS5yZWFkQml0KG8sZykpe2NvbnN0IGU9dGhpcy5kZWNvZGVTaWduQml0KHQsdSxkKTtuW2RdPWU7cltkXT0xO3RoaXMuc2V0TmVpZ2hib3JzU2lnbmlmaWNhbmNlKHQsdSxkKTtzW2RdfD0yfWxbZF0rKztzW2RdfD0xfX19ZGVjb2RlU2lnbkJpdChlLHQsYSl7Y29uc3Qgcj10aGlzLndpZHRoLG49dGhpcy5oZWlnaHQsaT10aGlzLmNvZWZmaWNlbnRzTWFnbml0dWRlLHM9dGhpcy5jb2VmZmljZW50c1NpZ247bGV0IG8sYyxsLGgsdSxkO2g9dD4wJiYwIT09aVthLTFdO2lmKHQrMTxyJiYwIT09aVthKzFdKXtsPXNbYSsxXTtpZihoKXtjPXNbYS0xXTtvPTEtbC1jfWVsc2Ugbz0xLWwtbH1lbHNlIGlmKGgpe2M9c1thLTFdO289MS1jLWN9ZWxzZSBvPTA7Y29uc3QgZj0zKm87aD1lPjAmJjAhPT1pW2Etcl07aWYoZSsxPG4mJjAhPT1pW2Ercl0pe2w9c1thK3JdO2lmKGgpe2M9c1thLXJdO289MS1sLWMrZn1lbHNlIG89MS1sLWwrZn1lbHNlIGlmKGgpe2M9c1thLXJdO289MS1jLWMrZn1lbHNlIG89ZjtpZihvPj0wKXt1PTkrbztkPXRoaXMuZGVjb2Rlci5yZWFkQml0KHRoaXMuY29udGV4dHMsdSl9ZWxzZXt1PTktbztkPTFedGhpcy5kZWNvZGVyLnJlYWRCaXQodGhpcy5jb250ZXh0cyx1KX1yZXR1cm4gZH1ydW5NYWduaXR1ZGVSZWZpbmVtZW50UGFzcygpe2NvbnN0IGU9dGhpcy5kZWNvZGVyLHQ9dGhpcy53aWR0aCxhPXRoaXMuaGVpZ2h0LHI9dGhpcy5jb2VmZmljZW50c01hZ25pdHVkZSxuPXRoaXMubmVpZ2hib3JzU2lnbmlmaWNhbmNlLGk9dGhpcy5jb250ZXh0cyxzPXRoaXMuYml0c0RlY29kZWQsbz10aGlzLnByb2Nlc3NpbmdGbGFncyxjPXQqYSxsPTQqdDtmb3IobGV0IGEsaD0wO2g8YztoPWEpe2E9TWF0aC5taW4oYyxoK2wpO2ZvcihsZXQgYz0wO2M8dDtjKyspZm9yKGxldCBsPWgrYztsPGE7bCs9dCl7aWYoIXJbbF18fDAhPSgxJm9bbF0pKWNvbnRpbnVlO2xldCB0PTE2O2lmKDAhPSgyJm9bbF0pKXtvW2xdXj0yO3Q9MD09PSgxMjcmbltsXSk/MTU6MTR9Y29uc3QgYT1lLnJlYWRCaXQoaSx0KTtyW2xdPXJbbF08PDF8YTtzW2xdKys7b1tsXXw9MX19fXJ1bkNsZWFudXBQYXNzKCl7Y29uc3QgdD10aGlzLmRlY29kZXIsYT10aGlzLndpZHRoLHI9dGhpcy5oZWlnaHQsbj10aGlzLm5laWdoYm9yc1NpZ25pZmljYW5jZSxpPXRoaXMuY29lZmZpY2VudHNNYWduaXR1ZGUscz10aGlzLmNvZWZmaWNlbnRzU2lnbixvPXRoaXMuY29udGV4dHMsYz10aGlzLmNvbnRleHRMYWJlbFRhYmxlLGw9dGhpcy5iaXRzRGVjb2RlZCxoPXRoaXMucHJvY2Vzc2luZ0ZsYWdzLHU9YSxkPTIqYSxmPTMqYTtsZXQgZztmb3IobGV0IHA9MDtwPHI7cD1nKXtnPU1hdGgubWluKHArNCxyKTtjb25zdCBtPXAqYSxiPXArMzxyO2ZvcihsZXQgcj0wO3I8YTtyKyspe2NvbnN0IHk9bStyO2xldCB3LFM9MCx4PXksaz1wO2lmKGImJjA9PT1oW3ldJiYwPT09aFt5K3VdJiYwPT09aFt5K2RdJiYwPT09aFt5K2ZdJiYwPT09blt5XSYmMD09PW5beSt1XSYmMD09PW5beStkXSYmMD09PW5beStmXSl7aWYoIXQucmVhZEJpdChvLDE4KSl7bFt5XSsrO2xbeSt1XSsrO2xbeStkXSsrO2xbeStmXSsrO2NvbnRpbnVlfVM9dC5yZWFkQml0KG8sZSk8PDF8dC5yZWFkQml0KG8sZSk7aWYoMCE9PVMpe2s9cCtTO3grPVMqYX13PXRoaXMuZGVjb2RlU2lnbkJpdChrLHIseCk7c1t4XT13O2lbeF09MTt0aGlzLnNldE5laWdoYm9yc1NpZ25pZmljYW5jZShrLHIseCk7aFt4XXw9Mjt4PXk7Zm9yKGxldCBlPXA7ZTw9aztlKysseCs9YSlsW3hdKys7UysrfWZvcihrPXArUztrPGc7aysrLHgrPWEpe2lmKGlbeF18fDAhPSgxJmhbeF0pKWNvbnRpbnVlO2NvbnN0IGU9Y1tuW3hdXTtpZigxPT09dC5yZWFkQml0KG8sZSkpe3c9dGhpcy5kZWNvZGVTaWduQml0KGsscix4KTtzW3hdPXc7aVt4XT0xO3RoaXMuc2V0TmVpZ2hib3JzU2lnbmlmaWNhbmNlKGsscix4KTtoW3hdfD0yfWxbeF0rK319fX1jaGVja1NlZ21lbnRhdGlvblN5bWJvbCgpe2NvbnN0IHQ9dGhpcy5kZWNvZGVyLGE9dGhpcy5jb250ZXh0cztpZigxMCE9PSh0LnJlYWRCaXQoYSxlKTw8M3x0LnJlYWRCaXQoYSxlKTw8Mnx0LnJlYWRCaXQoYSxlKTw8MXx0LnJlYWRCaXQoYSxlKSkpdGhyb3cgbmV3IEpweEVycm9yKCJJbnZhbGlkIHNlZ21lbnRhdGlvbiBzeW1ib2wiKX19fSgpO2NsYXNzIFRyYW5zZm9ybXtjb25zdHJ1Y3Rvcigpe3RoaXMuY29uc3RydWN0b3I9PT1UcmFuc2Zvcm0mJigwLHIudW5yZWFjaGFibGUpKCJDYW5ub3QgaW5pdGlhbGl6ZSBUcmFuc2Zvcm0uIil9Y2FsY3VsYXRlKGUsdCxhKXtsZXQgcj1lWzBdO2ZvcihsZXQgbj0xLGk9ZS5sZW5ndGg7bjxpO24rKylyPXRoaXMuaXRlcmF0ZShyLGVbbl0sdCxhKTtyZXR1cm4gcn1leHRlbmQoZSx0LGEpe2xldCByPXQtMSxuPXQrMSxpPXQrYS0yLHM9dCthO2Vbci0tXT1lW24rK107ZVtzKytdPWVbaS0tXTtlW3ItLV09ZVtuKytdO2VbcysrXT1lW2ktLV07ZVtyLS1dPWVbbisrXTtlW3MrK109ZVtpLS1dO2Vbcl09ZVtuXTtlW3NdPWVbaV19ZmlsdGVyKGUsdCxhKXsoMCxyLnVucmVhY2hhYmxlKSgiQWJzdHJhY3QgbWV0aG9kIGBmaWx0ZXJgIGNhbGxlZCIpfWl0ZXJhdGUoZSx0LGEscil7Y29uc3Qgbj1lLndpZHRoLGk9ZS5oZWlnaHQ7bGV0IHM9ZS5pdGVtcztjb25zdCBvPXQud2lkdGgsYz10LmhlaWdodCxsPXQuaXRlbXM7bGV0IGgsdSxkLGYsZyxwO2ZvcihkPTAsaD0wO2g8aTtoKyspe2Y9MipoKm87Zm9yKHU9MDt1PG47dSsrLGQrKyxmKz0yKWxbZl09c1tkXX1zPWUuaXRlbXM9bnVsbDtjb25zdCBtPW5ldyBGbG9hdDMyQXJyYXkobys4KTtpZigxPT09byl7aWYoMCE9KDEmYSkpZm9yKHA9MCxkPTA7cDxjO3ArKyxkKz1vKWxbZF0qPS41fWVsc2UgZm9yKHA9MCxkPTA7cDxjO3ArKyxkKz1vKXttLnNldChsLnN1YmFycmF5KGQsZCtvKSw0KTt0aGlzLmV4dGVuZChtLDQsbyk7dGhpcy5maWx0ZXIobSw0LG8pO2wuc2V0KG0uc3ViYXJyYXkoNCw0K28pLGQpfWxldCBiPTE2O2NvbnN0IHk9W107Zm9yKGg9MDtoPGI7aCsrKXkucHVzaChuZXcgRmxvYXQzMkFycmF5KGMrOCkpO2xldCB3LFM9MDtlPTQrYztpZigxPT09Yyl7aWYoMCE9KDEmcikpZm9yKGc9MDtnPG87ZysrKWxbZ10qPS41fWVsc2UgZm9yKGc9MDtnPG87ZysrKXtpZigwPT09Uyl7Yj1NYXRoLm1pbihvLWcsYik7Zm9yKGQ9ZyxmPTQ7ZjxlO2QrPW8sZisrKWZvcih3PTA7dzxiO3crKyl5W3ddW2ZdPWxbZCt3XTtTPWJ9Uy0tO2NvbnN0IHQ9eVtTXTt0aGlzLmV4dGVuZCh0LDQsYyk7dGhpcy5maWx0ZXIodCw0LGMpO2lmKDA9PT1TKXtkPWctYisxO2ZvcihmPTQ7ZjxlO2QrPW8sZisrKWZvcih3PTA7dzxiO3crKylsW2Qrd109eVt3XVtmXX19cmV0dXJue3dpZHRoOm8saGVpZ2h0OmMsaXRlbXM6bH19fWNsYXNzIElycmV2ZXJzaWJsZVRyYW5zZm9ybSBleHRlbmRzIFRyYW5zZm9ybXtmaWx0ZXIoZSx0LGEpe2NvbnN0IHI9YT4+MTtsZXQgbixpLHMsbztjb25zdCBjPS0xLjU4NjEzNDM0MjA1OTkyNCxsPS0uMDUyOTgwMTE4NTcyOTYxLGg9Ljg4MjkxMTA3NTUzMDkzNCx1PS40NDM1MDY4NTIwNDM5NzEsZD0xLjIzMDE3NDEwNDkxNDAwMTtuPSh0fD0wKS0zO2ZvcihpPXIrNDtpLS07bis9MillW25dKj0uODEyODkzMDY2MTE1OTYwOTtuPXQtMjtzPXUqZVtuLTFdO2ZvcihpPXIrMztpLS07bis9Mil7bz11KmVbbisxXTtlW25dPWQqZVtuXS1zLW87aWYoIWktLSlicmVhaztuKz0yO3M9dSplW24rMV07ZVtuXT1kKmVbbl0tcy1vfW49dC0xO3M9aCplW24tMV07Zm9yKGk9cisyO2ktLTtuKz0yKXtvPWgqZVtuKzFdO2Vbbl0tPXMrbztpZighaS0tKWJyZWFrO24rPTI7cz1oKmVbbisxXTtlW25dLT1zK299bj10O3M9bCplW24tMV07Zm9yKGk9cisxO2ktLTtuKz0yKXtvPWwqZVtuKzFdO2Vbbl0tPXMrbztpZighaS0tKWJyZWFrO24rPTI7cz1sKmVbbisxXTtlW25dLT1zK299aWYoMCE9PXIpe249dCsxO3M9YyplW24tMV07Zm9yKGk9cjtpLS07bis9Mil7bz1jKmVbbisxXTtlW25dLT1zK287aWYoIWktLSlicmVhaztuKz0yO3M9YyplW24rMV07ZVtuXS09cytvfX19fWNsYXNzIFJldmVyc2libGVUcmFuc2Zvcm0gZXh0ZW5kcyBUcmFuc2Zvcm17ZmlsdGVyKGUsdCxhKXtjb25zdCByPWE+PjE7bGV0IG4saTtmb3Iobj10fD0wLGk9cisxO2ktLTtuKz0yKWVbbl0tPWVbbi0xXStlW24rMV0rMj4+Mjtmb3Iobj10KzEsaT1yO2ktLTtuKz0yKWVbbl0rPWVbbi0xXStlW24rMV0+PjF9fX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LkxaV1N0cmVhbT12b2lkIDA7dmFyIHI9YSgxOSk7Y2xhc3MgTFpXU3RyZWFtIGV4dGVuZHMgci5EZWNvZGVTdHJlYW17Y29uc3RydWN0b3IoZSx0LGEpe3N1cGVyKHQpO3RoaXMuc3RyPWU7dGhpcy5kaWN0PWUuZGljdDt0aGlzLmNhY2hlZERhdGE9MDt0aGlzLmJpdHNDYWNoZWQ9MDtjb25zdCByPTQwOTYsbj17ZWFybHlDaGFuZ2U6YSxjb2RlTGVuZ3RoOjksbmV4dENvZGU6MjU4LGRpY3Rpb25hcnlWYWx1ZXM6bmV3IFVpbnQ4QXJyYXkociksZGljdGlvbmFyeUxlbmd0aHM6bmV3IFVpbnQxNkFycmF5KHIpLGRpY3Rpb25hcnlQcmV2Q29kZXM6bmV3IFVpbnQxNkFycmF5KHIpLGN1cnJlbnRTZXF1ZW5jZTpuZXcgVWludDhBcnJheShyKSxjdXJyZW50U2VxdWVuY2VMZW5ndGg6MH07Zm9yKGxldCBlPTA7ZTwyNTY7KytlKXtuLmRpY3Rpb25hcnlWYWx1ZXNbZV09ZTtuLmRpY3Rpb25hcnlMZW5ndGhzW2VdPTF9dGhpcy5sendTdGF0ZT1ufXJlYWRCaXRzKGUpe2xldCB0PXRoaXMuYml0c0NhY2hlZCxhPXRoaXMuY2FjaGVkRGF0YTtmb3IoO3Q8ZTspe2NvbnN0IGU9dGhpcy5zdHIuZ2V0Qnl0ZSgpO2lmKC0xPT09ZSl7dGhpcy5lb2Y9ITA7cmV0dXJuIG51bGx9YT1hPDw4fGU7dCs9OH10aGlzLmJpdHNDYWNoZWQ9dC09ZTt0aGlzLmNhY2hlZERhdGE9YTt0aGlzLmxhc3RDb2RlPW51bGw7cmV0dXJuIGE+Pj50JigxPDxlKS0xfXJlYWRCbG9jaygpe2xldCBlLHQsYSxyPTEwMjQ7Y29uc3Qgbj10aGlzLmx6d1N0YXRlO2lmKCFuKXJldHVybjtjb25zdCBpPW4uZWFybHlDaGFuZ2U7bGV0IHM9bi5uZXh0Q29kZTtjb25zdCBvPW4uZGljdGlvbmFyeVZhbHVlcyxjPW4uZGljdGlvbmFyeUxlbmd0aHMsbD1uLmRpY3Rpb25hcnlQcmV2Q29kZXM7bGV0IGg9bi5jb2RlTGVuZ3RoLHU9bi5wcmV2Q29kZTtjb25zdCBkPW4uY3VycmVudFNlcXVlbmNlO2xldCBmPW4uY3VycmVudFNlcXVlbmNlTGVuZ3RoLGc9MCxwPXRoaXMuYnVmZmVyTGVuZ3RoLG09dGhpcy5lbnN1cmVCdWZmZXIodGhpcy5idWZmZXJMZW5ndGgrcik7Zm9yKGU9MDtlPDUxMjtlKyspe2NvbnN0IGU9dGhpcy5yZWFkQml0cyhoKSxuPWY+MDtpZihlPDI1Nil7ZFswXT1lO2Y9MX1lbHNle2lmKCEoZT49MjU4KSl7aWYoMjU2PT09ZSl7aD05O3M9MjU4O2Y9MDtjb250aW51ZX10aGlzLmVvZj0hMDtkZWxldGUgdGhpcy5sendTdGF0ZTticmVha31pZihlPHMpe2Y9Y1tlXTtmb3IodD1mLTEsYT1lO3Q+PTA7dC0tKXtkW3RdPW9bYV07YT1sW2FdfX1lbHNlIGRbZisrXT1kWzBdfWlmKG4pe2xbc109dTtjW3NdPWNbdV0rMTtvW3NdPWRbMF07cysrO2g9cytpJnMraS0xP2g6MHxNYXRoLm1pbihNYXRoLmxvZyhzK2kpLy42OTMxNDcxODA1NTk5NDUzKzEsMTIpfXU9ZTtnKz1mO2lmKHI8Zyl7ZG97cis9NTEyfXdoaWxlKHI8Zyk7bT10aGlzLmVuc3VyZUJ1ZmZlcih0aGlzLmJ1ZmZlckxlbmd0aCtyKX1mb3IodD0wO3Q8Zjt0KyspbVtwKytdPWRbdF19bi5uZXh0Q29kZT1zO24uY29kZUxlbmd0aD1oO24ucHJldkNvZGU9dTtuLmN1cnJlbnRTZXF1ZW5jZUxlbmd0aD1mO3RoaXMuYnVmZmVyTGVuZ3RoPXB9fXQuTFpXU3RyZWFtPUxaV1N0cmVhbX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LlByZWRpY3RvclN0cmVhbT12b2lkIDA7dmFyIHI9YSgxOSksbj1hKDUpLGk9YSgyKTtjbGFzcyBQcmVkaWN0b3JTdHJlYW0gZXh0ZW5kcyByLkRlY29kZVN0cmVhbXtjb25zdHJ1Y3RvcihlLHQsYSl7c3VwZXIodCk7aWYoIShhIGluc3RhbmNlb2Ygbi5EaWN0KSlyZXR1cm4gZTtjb25zdCByPXRoaXMucHJlZGljdG9yPWEuZ2V0KCJQcmVkaWN0b3IiKXx8MTtpZihyPD0xKXJldHVybiBlO2lmKDIhPT1yJiYocjwxMHx8cj4xNSkpdGhyb3cgbmV3IGkuRm9ybWF0RXJyb3IoYFVuc3VwcG9ydGVkIHByZWRpY3RvcjogJHtyfWApO3RoaXMucmVhZEJsb2NrPTI9PT1yP3RoaXMucmVhZEJsb2NrVGlmZjp0aGlzLnJlYWRCbG9ja1BuZzt0aGlzLnN0cj1lO3RoaXMuZGljdD1lLmRpY3Q7Y29uc3Qgcz10aGlzLmNvbG9ycz1hLmdldCgiQ29sb3JzIil8fDEsbz10aGlzLmJpdHM9YS5nZXQoIkJQQyIsIkJpdHNQZXJDb21wb25lbnQiKXx8OCxjPXRoaXMuY29sdW1ucz1hLmdldCgiQ29sdW1ucyIpfHwxO3RoaXMucGl4Qnl0ZXM9cypvKzc+PjM7dGhpcy5yb3dCeXRlcz1jKnMqbys3Pj4zO3JldHVybiB0aGlzfXJlYWRCbG9ja1RpZmYoKXtjb25zdCBlPXRoaXMucm93Qnl0ZXMsdD10aGlzLmJ1ZmZlckxlbmd0aCxhPXRoaXMuZW5zdXJlQnVmZmVyKHQrZSkscj10aGlzLmJpdHMsbj10aGlzLmNvbG9ycyxpPXRoaXMuc3RyLmdldEJ5dGVzKGUpO3RoaXMuZW9mPSFpLmxlbmd0aDtpZih0aGlzLmVvZilyZXR1cm47bGV0IHMsbz0wLGM9MCxsPTAsaD0wLHU9dDtpZigxPT09ciYmMT09PW4pZm9yKHM9MDtzPGU7KytzKXtsZXQgZT1pW3NdXm87ZV49ZT4+MTtlXj1lPj4yO2VePWU+PjQ7bz0oMSZlKTw8NzthW3UrK109ZX1lbHNlIGlmKDg9PT1yKXtmb3Iocz0wO3M8bjsrK3MpYVt1KytdPWlbc107Zm9yKDtzPGU7KytzKXthW3VdPWFbdS1uXStpW3NdO3UrK319ZWxzZSBpZigxNj09PXIpe2NvbnN0IHQ9MipuO2ZvcihzPTA7czx0OysrcylhW3UrK109aVtzXTtmb3IoO3M8ZTtzKz0yKXtjb25zdCBlPSgoMjU1Jmlbc10pPDw4KSsoMjU1JmlbcysxXSkrKCgyNTUmYVt1LXRdKTw8OCkrKDI1NSZhW3UtdCsxXSk7YVt1KytdPWU+PjgmMjU1O2FbdSsrXT0yNTUmZX19ZWxzZXtjb25zdCBlPW5ldyBVaW50OEFycmF5KG4rMSksdT0oMTw8ciktMTtsZXQgZD0wLGY9dDtjb25zdCBnPXRoaXMuY29sdW1ucztmb3Iocz0wO3M8ZzsrK3MpZm9yKGxldCB0PTA7dDxuOysrdCl7aWYobDxyKXtvPW88PDh8MjU1JmlbZCsrXTtsKz04fWVbdF09ZVt0XSsobz4+bC1yKSZ1O2wtPXI7Yz1jPDxyfGVbdF07aCs9cjtpZihoPj04KXthW2YrK109Yz4+aC04JjI1NTtoLT04fX1oPjAmJihhW2YrK109KGM8PDgtaCkrKG8mKDE8PDgtaCktMSkpfXRoaXMuYnVmZmVyTGVuZ3RoKz1lfXJlYWRCbG9ja1BuZygpe2NvbnN0IGU9dGhpcy5yb3dCeXRlcyx0PXRoaXMucGl4Qnl0ZXMsYT10aGlzLnN0ci5nZXRCeXRlKCkscj10aGlzLnN0ci5nZXRCeXRlcyhlKTt0aGlzLmVvZj0hci5sZW5ndGg7aWYodGhpcy5lb2YpcmV0dXJuO2NvbnN0IG49dGhpcy5idWZmZXJMZW5ndGgscz10aGlzLmVuc3VyZUJ1ZmZlcihuK2UpO2xldCBvPXMuc3ViYXJyYXkobi1lLG4pOzA9PT1vLmxlbmd0aCYmKG89bmV3IFVpbnQ4QXJyYXkoZSkpO2xldCBjLGwsaCx1PW47c3dpdGNoKGEpe2Nhc2UgMDpmb3IoYz0wO2M8ZTsrK2Mpc1t1KytdPXJbY107YnJlYWs7Y2FzZSAxOmZvcihjPTA7Yzx0OysrYylzW3UrK109cltjXTtmb3IoO2M8ZTsrK2Mpe3NbdV09c1t1LXRdK3JbY10mMjU1O3UrK31icmVhaztjYXNlIDI6Zm9yKGM9MDtjPGU7KytjKXNbdSsrXT1vW2NdK3JbY10mMjU1O2JyZWFrO2Nhc2UgMzpmb3IoYz0wO2M8dDsrK2Mpc1t1KytdPShvW2NdPj4xKStyW2NdO2Zvcig7YzxlOysrYyl7c1t1XT0ob1tjXStzW3UtdF0+PjEpK3JbY10mMjU1O3UrK31icmVhaztjYXNlIDQ6Zm9yKGM9MDtjPHQ7KytjKXtsPW9bY107aD1yW2NdO3NbdSsrXT1sK2h9Zm9yKDtjPGU7KytjKXtsPW9bY107Y29uc3QgZT1vW2MtdF0sYT1zW3UtdF0sbj1hK2wtZTtsZXQgaT1uLWE7aTwwJiYoaT0taSk7bGV0IGQ9bi1sO2Q8MCYmKGQ9LWQpO2xldCBmPW4tZTtmPDAmJihmPS1mKTtoPXJbY107c1t1KytdPWk8PWQmJmk8PWY/YStoOmQ8PWY/bCtoOmUraH1icmVhaztkZWZhdWx0OnRocm93IG5ldyBpLkZvcm1hdEVycm9yKGBVbnN1cHBvcnRlZCBwcmVkaWN0b3I6ICR7YX1gKX10aGlzLmJ1ZmZlckxlbmd0aCs9ZX19dC5QcmVkaWN0b3JTdHJlYW09UHJlZGljdG9yU3RyZWFtfSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuUnVuTGVuZ3RoU3RyZWFtPXZvaWQgMDt2YXIgcj1hKDE5KTtjbGFzcyBSdW5MZW5ndGhTdHJlYW0gZXh0ZW5kcyByLkRlY29kZVN0cmVhbXtjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKHQpO3RoaXMuc3RyPWU7dGhpcy5kaWN0PWUuZGljdH1yZWFkQmxvY2soKXtjb25zdCBlPXRoaXMuc3RyLmdldEJ5dGVzKDIpO2lmKCFlfHxlLmxlbmd0aDwyfHwxMjg9PT1lWzBdKXt0aGlzLmVvZj0hMDtyZXR1cm59bGV0IHQsYT10aGlzLmJ1ZmZlckxlbmd0aCxyPWVbMF07aWYocjwxMjgpe3Q9dGhpcy5lbnN1cmVCdWZmZXIoYStyKzEpO3RbYSsrXT1lWzFdO2lmKHI+MCl7Y29uc3QgZT10aGlzLnN0ci5nZXRCeXRlcyhyKTt0LnNldChlLGEpO2ErPXJ9fWVsc2V7cj0yNTctcjtjb25zdCBuPWVbMV07dD10aGlzLmVuc3VyZUJ1ZmZlcihhK3IrMSk7Zm9yKGxldCBlPTA7ZTxyO2UrKyl0W2ErK109bn10aGlzLmJ1ZmZlckxlbmd0aD1hfX10LlJ1bkxlbmd0aFN0cmVhbT1SdW5MZW5ndGhTdHJlYW19LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5Gb250PXQuRXJyb3JGb250PXZvaWQgMDt2YXIgcj1hKDIpLG49YSgzNSksaT1hKDM4KSxzPWEoNDApLG89YSgzOSksYz1hKDM3KSxsPWEoNDEpLGg9YSg0MiksdT1hKDQzKSxkPWEoNDQpLGY9YSg0NSksZz1hKDQ2KSxwPWEoMTYpLG09YSg0NyksYj1hKDYpLHk9YSgxMCksdz1hKDQ4KTtjb25zdCBTPVtbNTczNDQsNjM3NDNdLFsxMDQ4NTc2LDExMTQxMDldXSx4PTFlMyxrPVsiYXNjZW50IiwiYmJveCIsImJsYWNrIiwiYm9sZCIsImNoYXJQcm9jT3BlcmF0b3JMaXN0IiwiY29tcG9zaXRlIiwiY3NzRm9udEluZm8iLCJkYXRhIiwiZGVmYXVsdFZNZXRyaWNzIiwiZGVmYXVsdFdpZHRoIiwiZGVzY2VudCIsImZhbGxiYWNrTmFtZSIsImZvbnRNYXRyaXgiLCJmb250VHlwZSIsImlzVHlwZTNGb250IiwiaXRhbGljIiwibG9hZGVkTmFtZSIsIm1pbWV0eXBlIiwibWlzc2luZ0ZpbGUiLCJuYW1lIiwicmVtZWFzdXJlIiwic3VidHlwZSIsInR5cGUiLCJ2ZXJ0aWNhbCJdLEM9WyJjTWFwIiwiZGVmYXVsdEVuY29kaW5nIiwiZGlmZmVyZW5jZXMiLCJpc01vbm9zcGFjZSIsImlzU2VyaWZGb250IiwiaXNTeW1ib2xpY0ZvbnQiLCJzZWFjTWFwIiwidG9Gb250Q2hhciIsInRvVW5pY29kZSIsInZtZXRyaWNzIiwid2lkdGhzIl07ZnVuY3Rpb24gYWRqdXN0V2lkdGhzKGUpe2lmKCFlLmZvbnRNYXRyaXgpcmV0dXJuO2lmKGUuZm9udE1hdHJpeFswXT09PXIuRk9OVF9JREVOVElUWV9NQVRSSVhbMF0pcmV0dXJuO2NvbnN0IHQ9LjAwMS9lLmZvbnRNYXRyaXhbMF0sYT1lLndpZHRocztmb3IoY29uc3QgZSBpbiBhKWFbZV0qPXQ7ZS5kZWZhdWx0V2lkdGgqPXR9ZnVuY3Rpb24gYW1lbmRGYWxsYmFja1RvVW5pY29kZShlKXtpZighZS5mYWxsYmFja1RvVW5pY29kZSlyZXR1cm47aWYoZS50b1VuaWNvZGUgaW5zdGFuY2VvZiBoLklkZW50aXR5VG9Vbmljb2RlTWFwKXJldHVybjtjb25zdCB0PVtdO2Zvcihjb25zdCBhIGluIGUuZmFsbGJhY2tUb1VuaWNvZGUpZS50b1VuaWNvZGUuaGFzKGEpfHwodFthXT1lLmZhbGxiYWNrVG9Vbmljb2RlW2FdKTt0Lmxlbmd0aD4wJiZlLnRvVW5pY29kZS5hbWVuZCh0KX1jbGFzcyBHbHlwaHtjb25zdHJ1Y3RvcihlLHQsYSxyLG4saSxvLGMsbCl7dGhpcy5vcmlnaW5hbENoYXJDb2RlPWU7dGhpcy5mb250Q2hhcj10O3RoaXMudW5pY29kZT1hO3RoaXMuYWNjZW50PXI7dGhpcy53aWR0aD1uO3RoaXMudm1ldHJpYz1pO3RoaXMub3BlcmF0b3JMaXN0SWQ9bzt0aGlzLmlzU3BhY2U9Yzt0aGlzLmlzSW5Gb250PWw7Y29uc3QgaD0oMCxzLmdldENoYXJVbmljb2RlQ2F0ZWdvcnkpKGEpO3RoaXMuaXNXaGl0ZXNwYWNlPWguaXNXaGl0ZXNwYWNlO3RoaXMuaXNaZXJvV2lkdGhEaWFjcml0aWM9aC5pc1plcm9XaWR0aERpYWNyaXRpYzt0aGlzLmlzSW52aXNpYmxlRm9ybWF0TWFyaz1oLmlzSW52aXNpYmxlRm9ybWF0TWFya31tYXRjaGVzRm9yQ2FjaGUoZSx0LGEscixuLGkscyxvLGMpe3JldHVybiB0aGlzLm9yaWdpbmFsQ2hhckNvZGU9PT1lJiZ0aGlzLmZvbnRDaGFyPT09dCYmdGhpcy51bmljb2RlPT09YSYmdGhpcy5hY2NlbnQ9PT1yJiZ0aGlzLndpZHRoPT09biYmdGhpcy52bWV0cmljPT09aSYmdGhpcy5vcGVyYXRvckxpc3RJZD09PXMmJnRoaXMuaXNTcGFjZT09PW8mJnRoaXMuaXNJbkZvbnQ9PT1jfX1mdW5jdGlvbiBpbnQxNihlLHQpe3JldHVybihlPDw4KSt0fWZ1bmN0aW9uIHdyaXRlU2lnbmVkSW50MTYoZSx0LGEpe2VbdCsxXT1hO2VbdF09YT4+Pjh9ZnVuY3Rpb24gc2lnbmVkSW50MTYoZSx0KXtjb25zdCBhPShlPDw4KSt0O3JldHVybiAzMjc2OCZhP2EtNjU1MzY6YX1mdW5jdGlvbiBzdHJpbmcxNihlKXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShlPj44JjI1NSwyNTUmZSl9ZnVuY3Rpb24gc2FmZVN0cmluZzE2KGUpe2U+MzI3Njc/ZT0zMjc2NzplPC0zMjc2OCYmKGU9LTMyNzY4KTtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShlPj44JjI1NSwyNTUmZSl9ZnVuY3Rpb24gaXNUcnVlVHlwZUNvbGxlY3Rpb25GaWxlKGUpe2NvbnN0IHQ9ZS5wZWVrQnl0ZXMoNCk7cmV0dXJuInR0Y2YiPT09KDAsci5ieXRlc1RvU3RyaW5nKSh0KX1mdW5jdGlvbiBnZXRGb250RmlsZVR5cGUoZSx7dHlwZTp0LHN1YnR5cGU6YSxjb21wb3NpdGU6bn0pe2xldCBpLHM7aWYoZnVuY3Rpb24gaXNUcnVlVHlwZUZpbGUoZSl7Y29uc3QgdD1lLnBlZWtCeXRlcyg0KTtyZXR1cm4gNjU1MzY9PT0oMCxiLnJlYWRVaW50MzIpKHQsMCl8fCJ0cnVlIj09PSgwLHIuYnl0ZXNUb1N0cmluZykodCl9KGUpfHxpc1RydWVUeXBlQ29sbGVjdGlvbkZpbGUoZSkpaT1uPyJDSURGb250VHlwZTIiOiJUcnVlVHlwZSI7ZWxzZSBpZihmdW5jdGlvbiBpc09wZW5UeXBlRmlsZShlKXtjb25zdCB0PWUucGVla0J5dGVzKDQpO3JldHVybiJPVFRPIj09PSgwLHIuYnl0ZXNUb1N0cmluZykodCl9KGUpKWk9bj8iQ0lERm9udFR5cGUyIjoiT3BlblR5cGUiO2Vsc2UgaWYoZnVuY3Rpb24gaXNUeXBlMUZpbGUoZSl7Y29uc3QgdD1lLnBlZWtCeXRlcygyKTtyZXR1cm4gMzc9PT10WzBdJiYzMz09PXRbMV18fDEyOD09PXRbMF0mJjE9PT10WzFdfShlKSlpPW4/IkNJREZvbnRUeXBlMCI6Ik1NVHlwZTEiPT09dD8iTU1UeXBlMSI6IlR5cGUxIjtlbHNlIGlmKGZ1bmN0aW9uIGlzQ0ZGRmlsZShlKXtjb25zdCB0PWUucGVla0J5dGVzKDQpO3JldHVybiB0WzBdPj0xJiZ0WzNdPj0xJiZ0WzNdPD00fShlKSlpZihuKXtpPSJDSURGb250VHlwZTAiO3M9IkNJREZvbnRUeXBlMEMifWVsc2V7aT0iTU1UeXBlMSI9PT10PyJNTVR5cGUxIjoiVHlwZTEiO3M9IlR5cGUxQyJ9ZWxzZXsoMCxyLndhcm4pKCJnZXRGb250RmlsZVR5cGU6IFVuYWJsZSB0byBkZXRlY3QgY29ycmVjdCBmb250IGZpbGUgVHlwZS9TdWJ0eXBlLiIpO2k9dDtzPWF9cmV0dXJuW2ksc119ZnVuY3Rpb24gYXBwbHlTdGFuZGFyZEZvbnRHbHlwaE1hcChlLHQpe2Zvcihjb25zdCBhIGluIHQpZVsrYV09dFthXX1mdW5jdGlvbiBidWlsZFRvRm9udENoYXIoZSx0LGEpe2NvbnN0IHI9W107bGV0IG47Zm9yKGxldCBhPTAsaT1lLmxlbmd0aDthPGk7YSsrKXtuPSgwLHMuZ2V0VW5pY29kZUZvckdseXBoKShlW2FdLHQpOy0xIT09biYmKHJbYV09bil9Zm9yKGNvbnN0IGUgaW4gYSl7bj0oMCxzLmdldFVuaWNvZGVGb3JHbHlwaCkoYVtlXSx0KTstMSE9PW4mJihyWytlXT1uKX1yZXR1cm4gcn1mdW5jdGlvbiBjb252ZXJ0Q2lkU3RyaW5nKGUsdCxhPSExKXtzd2l0Y2godC5sZW5ndGgpe2Nhc2UgMTpyZXR1cm4gdC5jaGFyQ29kZUF0KDApO2Nhc2UgMjpyZXR1cm4gdC5jaGFyQ29kZUF0KDApPDw4fHQuY2hhckNvZGVBdCgxKX1jb25zdCBuPWBVbnN1cHBvcnRlZCBDSUQgc3RyaW5nIChjaGFyQ29kZSAke2V9KTogIiR7dH0iLmA7aWYoYSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcihuKTsoMCxyLndhcm4pKG4pO3JldHVybiB0fWZ1bmN0aW9uIGFkanVzdE1hcHBpbmcoZSx0LGEsbil7Y29uc3QgaT1PYmplY3QuY3JlYXRlKG51bGwpLHM9bmV3IE1hcCxvPVtdLGM9bmV3IFNldDtsZXQgbD0wO2NvbnN0IGg9U1tsXVswXTtsZXQgdT1oLGQ9U1tsXVsxXTtmb3IobGV0IGYgaW4gZSl7Znw9MDtsZXQgZz1lW2ZdO2lmKCF0KGcpKWNvbnRpbnVlO2lmKHU+ZCl7bCsrO2lmKGw+PVMubGVuZ3RoKXsoMCxyLndhcm4pKCJSYW4gb3V0IG9mIHNwYWNlIGluIGZvbnQgcHJpdmF0ZSB1c2UgYXJlYS4iKTticmVha311PVNbbF1bMF07ZD1TW2xdWzFdfWNvbnN0IHA9dSsrOzA9PT1nJiYoZz1hKTtsZXQgbT1uLmdldChmKTsic3RyaW5nIj09dHlwZW9mIG0mJihtPW0uY29kZVBvaW50QXQoMCkpO2lmKG0mJm08aCYmIWMuaGFzKGcpKXtzLnNldChtLGcpO2MuYWRkKGcpfWlbcF09ZztvW2ZdPXB9cmV0dXJue3RvRm9udENoYXI6byxjaGFyQ29kZVRvR2x5cGhJZDppLHRvVW5pY29kZUV4dHJhTWFwOnMsbmV4dEF2YWlsYWJsZUZvbnRDaGFyQ29kZTp1fX1mdW5jdGlvbiBjcmVhdGVDbWFwVGFibGUoZSx0LGEpe2NvbnN0IG49ZnVuY3Rpb24gZ2V0UmFuZ2VzKGUsdCxhKXtjb25zdCByPVtdO2Zvcihjb25zdCB0IGluIGUpZVt0XT49YXx8ci5wdXNoKHtmb250Q2hhckNvZGU6MHx0LGdseXBoSWQ6ZVt0XX0pO2lmKHQpZm9yKGNvbnN0W2Usbl1vZiB0KW4+PWF8fHIucHVzaCh7Zm9udENoYXJDb2RlOmUsZ2x5cGhJZDpufSk7MD09PXIubGVuZ3RoJiZyLnB1c2goe2ZvbnRDaGFyQ29kZTowLGdseXBoSWQ6MH0pO3Iuc29ydCgoZnVuY3Rpb24gZm9udEdldFJhbmdlc1NvcnQoZSx0KXtyZXR1cm4gZS5mb250Q2hhckNvZGUtdC5mb250Q2hhckNvZGV9KSk7Y29uc3Qgbj1bXSxpPXIubGVuZ3RoO2ZvcihsZXQgZT0wO2U8aTspe2NvbnN0IHQ9cltlXS5mb250Q2hhckNvZGUsYT1bcltlXS5nbHlwaElkXTsrK2U7bGV0IHM9dDtmb3IoO2U8aSYmcysxPT09cltlXS5mb250Q2hhckNvZGU7KXthLnB1c2gocltlXS5nbHlwaElkKTsrK3M7KytlO2lmKDY1NTM1PT09cylicmVha31uLnB1c2goW3QscyxhXSl9cmV0dXJuIG59KGUsdCxhKSxpPW4uYXQoLTEpWzFdPjY1NTM1PzI6MTtsZXQgcyxvLGMsbCxoPSJcMFwwIitzdHJpbmcxNihpKSsiXDADXDABIisoMCxyLnN0cmluZzMyKSg0KzgqaSk7Zm9yKHM9bi5sZW5ndGgtMTtzPj0wJiYhKG5bc11bMF08PTY1NTM1KTstLXMpO2NvbnN0IHU9cysxO25bc11bMF08NjU1MzUmJjY1NTM1PT09bltzXVsxXSYmKG5bc11bMV09NjU1MzQpO2NvbnN0IGQ9bltzXVsxXTw2NTUzNT8xOjAsZj11K2QsZz1tLk9wZW5UeXBlRmlsZUJ1aWxkZXIuZ2V0U2VhcmNoUGFyYW1zKGYsMik7bGV0IHAsYix5LHcsUz0iIix4PSIiLGs9IiIsQz0iIix2PSIiLEY9MDtmb3Iocz0wLG89dTtzPG87cysrKXtwPW5bc107Yj1wWzBdO3k9cFsxXTtTKz1zdHJpbmcxNihiKTt4Kz1zdHJpbmcxNih5KTt3PXBbMl07bGV0IGU9ITA7Zm9yKGM9MSxsPXcubGVuZ3RoO2M8bDsrK2MpaWYod1tjXSE9PXdbYy0xXSsxKXtlPSExO2JyZWFrfWlmKGUpe2srPXN0cmluZzE2KHdbMF0tYiY2NTUzNSk7Qys9c3RyaW5nMTYoMCl9ZWxzZXtjb25zdCBlPTIqKGYtcykrMipGO0YrPXktYisxO2srPXN0cmluZzE2KDApO0MrPXN0cmluZzE2KGUpO2ZvcihjPTAsbD13Lmxlbmd0aDtjPGw7KytjKXYrPXN0cmluZzE2KHdbY10pfX1pZihkPjApe3grPSLDv8O/IjtTKz0iw7/DvyI7ays9IlwwASI7Qys9IlwwXDAifWNvbnN0IE89IlwwXDAiK3N0cmluZzE2KDIqZikrc3RyaW5nMTYoZy5yYW5nZSkrc3RyaW5nMTYoZy5lbnRyeSkrc3RyaW5nMTYoZy5yYW5nZVNoaWZ0KSt4KyJcMFwwIitTK2srQyt2O2xldCBUPSIiLE09IiI7aWYoaT4xKXtoKz0iXDADXDBcbiIrKDAsci5zdHJpbmczMikoNCs4KmkrNCtPLmxlbmd0aCk7VD0iIjtmb3Iocz0wLG89bi5sZW5ndGg7czxvO3MrKyl7cD1uW3NdO2I9cFswXTt3PXBbMl07bGV0IGU9d1swXTtmb3IoYz0xLGw9dy5sZW5ndGg7YzxsOysrYylpZih3W2NdIT09d1tjLTFdKzEpe3k9cFswXStjLTE7VCs9KDAsci5zdHJpbmczMikoYikrKDAsci5zdHJpbmczMikoeSkrKDAsci5zdHJpbmczMikoZSk7Yj15KzE7ZT13W2NdfVQrPSgwLHIuc3RyaW5nMzIpKGIpKygwLHIuc3RyaW5nMzIpKHBbMV0pKygwLHIuc3RyaW5nMzIpKGUpfU09IlwwXGZcMFwwIisoMCxyLnN0cmluZzMyKShULmxlbmd0aCsxNikrIlwwXDBcMFwwIisoMCxyLnN0cmluZzMyKShULmxlbmd0aC8xMil9cmV0dXJuIGgrIlwwBCIrc3RyaW5nMTYoTy5sZW5ndGgrNCkrTytNK1R9ZnVuY3Rpb24gY3JlYXRlT1MyVGFibGUoZSx0LGEpe2E9YXx8e3VuaXRzUGVyRW06MCx5TWF4OjAseU1pbjowLGFzY2VudDowLGRlc2NlbnQ6MH07bGV0IG49MCxpPTAsbz0wLGM9MCxsPW51bGwsaD0wO2lmKHQpe2ZvcihsZXQgZSBpbiB0KXtlfD0wOyhsPmV8fCFsKSYmKGw9ZSk7aDxlJiYoaD1lKTtjb25zdCB0PSgwLHMuZ2V0VW5pY29kZVJhbmdlRm9yKShlKTtpZih0PDMyKW58PTE8PHQ7ZWxzZSBpZih0PDY0KWl8PTE8PHQtMzI7ZWxzZSBpZih0PDk2KW98PTE8PHQtNjQ7ZWxzZXtpZighKHQ8MTIzKSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiVW5pY29kZSByYW5nZXMgQml0cyA+IDEyMyBhcmUgcmVzZXJ2ZWQgZm9yIGludGVybmFsIHVzYWdlIik7Y3w9MTw8dC05Nn19aD42NTUzNSYmKGg9NjU1MzUpfWVsc2V7bD0wO2g9MjU1fWNvbnN0IHU9ZS5iYm94fHxbMCwwLDAsMF0sZD1hLnVuaXRzUGVyRW18fDEvKGUuZm9udE1hdHJpeHx8ci5GT05UX0lERU5USVRZX01BVFJJWClbMF0sZj1lLmFzY2VudFNjYWxlZD8xOmQveCxnPWEuYXNjZW50fHxNYXRoLnJvdW5kKGYqKGUuYXNjZW50fHx1WzNdKSk7bGV0IHA9YS5kZXNjZW50fHxNYXRoLnJvdW5kKGYqKGUuZGVzY2VudHx8dVsxXSkpO3A+MCYmZS5kZXNjZW50PjAmJnVbMV08MCYmKHA9LXApO2NvbnN0IG09YS55TWF4fHxnLGI9LWEueU1pbnx8LXA7cmV0dXJuIlwwAwIkAcO0XDAFXDBcMALCigLCu1wwXDBcMMKMAsKKAsK7XDBcMAHDn1x4MDAxAQJcMFwwXDBcMAYiK1N0cmluZy5mcm9tQ2hhckNvZGUoZS5maXhlZFBpdGNoPzk6MCkrIlwwXDBcMFwwXDBcMCIrKDAsci5zdHJpbmczMikobikrKDAsci5zdHJpbmczMikoaSkrKDAsci5zdHJpbmczMikobykrKDAsci5zdHJpbmczMikoYykrIioyMSoiK3N0cmluZzE2KGUuaXRhbGljQW5nbGU/MTowKStzdHJpbmcxNihsfHxlLmZpcnN0Q2hhcikrc3RyaW5nMTYoaHx8ZS5sYXN0Q2hhcikrc3RyaW5nMTYoZykrc3RyaW5nMTYocCkrIlwwZCIrc3RyaW5nMTYobSkrc3RyaW5nMTYoYikrIlwwXDBcMFwwXDBcMFwwXDAiK3N0cmluZzE2KGUueEhlaWdodCkrc3RyaW5nMTYoZS5jYXBIZWlnaHQpK3N0cmluZzE2KDApK3N0cmluZzE2KGx8fGUuZmlyc3RDaGFyKSsiXDADIn1mdW5jdGlvbiBjcmVhdGVQb3N0VGFibGUoZSl7Y29uc3QgdD1NYXRoLmZsb29yKDY1NTM2KmUuaXRhbGljQW5nbGUpO3JldHVybiJcMANcMFwwIisoMCxyLnN0cmluZzMyKSh0KSsiXDBcMFwwXDAiKygwLHIuc3RyaW5nMzIpKGUuZml4ZWRQaXRjaD8xOjApKyJcMFwwXDBcMFwwXDBcMFwwXDBcMFwwXDBcMFwwXDBcMCJ9ZnVuY3Rpb24gY3JlYXRlUG9zdHNjcmlwdE5hbWUoZSl7cmV0dXJuIGUucmVwbGFjZSgvW15ceDIxLVx4N0VdfFtbXF0oKXt9PD4vJV0vZywiIikuc2xpY2UoMCw2Myl9ZnVuY3Rpb24gY3JlYXRlTmFtZVRhYmxlKGUsdCl7dHx8KHQ9W1tdLFtdXSk7Y29uc3QgYT1bdFswXVswXXx8Ik9yaWdpbmFsIGxpY2VuY2UiLHRbMF1bMV18fGUsdFswXVsyXXx8IlVua25vd24iLHRbMF1bM118fCJ1bmlxdWVJRCIsdFswXVs0XXx8ZSx0WzBdWzVdfHwiVmVyc2lvbiAwLjExIix0WzBdWzZdfHxjcmVhdGVQb3N0c2NyaXB0TmFtZShlKSx0WzBdWzddfHwiVW5rbm93biIsdFswXVs4XXx8IlVua25vd24iLHRbMF1bOV18fCJVbmtub3duIl0scj1bXTtsZXQgbixpLHMsbyxjO2ZvcihuPTAsaT1hLmxlbmd0aDtuPGk7bisrKXtjPXRbMV1bbl18fGFbbl07Y29uc3QgZT1bXTtmb3Iocz0wLG89Yy5sZW5ndGg7czxvO3MrKyllLnB1c2goc3RyaW5nMTYoYy5jaGFyQ29kZUF0KHMpKSk7ci5wdXNoKGUuam9pbigiIikpfWNvbnN0IGw9W2Escl0saD1bIlwwASIsIlwwAyJdLHU9WyJcMFwwIiwiXDABIl0sZD1bIlwwXDAiLCIEXHQiXSxmPWEubGVuZ3RoKmgubGVuZ3RoO2xldCBnPSJcMFwwIitzdHJpbmcxNihmKStzdHJpbmcxNigxMipmKzYpLHA9MDtmb3Iobj0wLGk9aC5sZW5ndGg7bjxpO24rKyl7Y29uc3QgZT1sW25dO2ZvcihzPTAsbz1lLmxlbmd0aDtzPG87cysrKXtjPWVbc107Zys9aFtuXSt1W25dK2Rbbl0rc3RyaW5nMTYocykrc3RyaW5nMTYoYy5sZW5ndGgpK3N0cmluZzE2KHApO3ArPWMubGVuZ3RofX1nKz1hLmpvaW4oIiIpK3Iuam9pbigiIik7cmV0dXJuIGd9dC5Gb250PWNsYXNzIEZvbnR7Y29uc3RydWN0b3IoZSx0LGEpe3RoaXMubmFtZT1lO3RoaXMucHNOYW1lPW51bGw7dGhpcy5taW1ldHlwZT1udWxsO3RoaXMuZGlzYWJsZUZvbnRGYWNlPSExO3RoaXMubG9hZGVkTmFtZT1hLmxvYWRlZE5hbWU7dGhpcy5pc1R5cGUzRm9udD1hLmlzVHlwZTNGb250O3RoaXMubWlzc2luZ0ZpbGU9ITE7dGhpcy5jc3NGb250SW5mbz1hLmNzc0ZvbnRJbmZvO3RoaXMuX2NoYXJzQ2FjaGU9T2JqZWN0LmNyZWF0ZShudWxsKTt0aGlzLl9nbHlwaENhY2hlPU9iamVjdC5jcmVhdGUobnVsbCk7bGV0IG49ISEoYS5mbGFncyZpLkZvbnRGbGFncy5TZXJpZik7aWYoIW4mJiFhLmlzU2ltdWxhdGVkRmxhZ3Mpe2NvbnN0IHQ9ZS5yZXBsYWNlKC9bLF9dL2csIi0iKS5zcGxpdCgiLSIpWzBdLGE9KDAsbC5nZXRTZXJpZkZvbnRzKSgpO2Zvcihjb25zdCBlIG9mIHQuc3BsaXQoIisiKSlpZihhW2VdKXtuPSEwO2JyZWFrfX10aGlzLmlzU2VyaWZGb250PW47dGhpcy5pc1N5bWJvbGljRm9udD0hIShhLmZsYWdzJmkuRm9udEZsYWdzLlN5bWJvbGljKTt0aGlzLmlzTW9ub3NwYWNlPSEhKGEuZmxhZ3MmaS5Gb250RmxhZ3MuRml4ZWRQaXRjaCk7bGV0IHM9YS50eXBlLG89YS5zdWJ0eXBlO3RoaXMudHlwZT1zO3RoaXMuc3VidHlwZT1vO2xldCBjLGg9InNhbnMtc2VyaWYiO3RoaXMuaXNNb25vc3BhY2U/aD0ibW9ub3NwYWNlIjp0aGlzLmlzU2VyaWZGb250JiYoaD0ic2VyaWYiKTt0aGlzLmZhbGxiYWNrTmFtZT1oO3RoaXMuZGlmZmVyZW5jZXM9YS5kaWZmZXJlbmNlczt0aGlzLndpZHRocz1hLndpZHRoczt0aGlzLmRlZmF1bHRXaWR0aD1hLmRlZmF1bHRXaWR0aDt0aGlzLmNvbXBvc2l0ZT1hLmNvbXBvc2l0ZTt0aGlzLmNNYXA9YS5jTWFwO3RoaXMuY2FwSGVpZ2h0PWEuY2FwSGVpZ2h0L3g7dGhpcy5hc2NlbnQ9YS5hc2NlbnQveDt0aGlzLmRlc2NlbnQ9YS5kZXNjZW50L3g7dGhpcy5saW5lSGVpZ2h0PXRoaXMuYXNjZW50LXRoaXMuZGVzY2VudDt0aGlzLmZvbnRNYXRyaXg9YS5mb250TWF0cml4O3RoaXMuYmJveD1hLmJib3g7dGhpcy5kZWZhdWx0RW5jb2Rpbmc9YS5kZWZhdWx0RW5jb2Rpbmc7dGhpcy50b1VuaWNvZGU9YS50b1VuaWNvZGU7dGhpcy50b0ZvbnRDaGFyPVtdO2lmKCJUeXBlMyIhPT1hLnR5cGUpe3RoaXMuY2lkRW5jb2Rpbmc9YS5jaWRFbmNvZGluZ3x8IiI7dGhpcy52ZXJ0aWNhbD0hIWEudmVydGljYWw7aWYodGhpcy52ZXJ0aWNhbCl7dGhpcy52bWV0cmljcz1hLnZtZXRyaWNzO3RoaXMuZGVmYXVsdFZNZXRyaWNzPWEuZGVmYXVsdFZNZXRyaWNzfWlmKHQmJiF0LmlzRW1wdHkpe1tzLG9dPWdldEZvbnRGaWxlVHlwZSh0LGEpO3M9PT10aGlzLnR5cGUmJm89PT10aGlzLnN1YnR5cGV8fCgwLHIuaW5mbykoYEluY29uc2lzdGVudCBmb250IGZpbGUgVHlwZS9TdWJUeXBlLCBleHBlY3RlZDogJHt0aGlzLnR5cGV9LyR7dGhpcy5zdWJ0eXBlfSBidXQgZm91bmQ6ICR7c30vJHtvfS5gKTt0cnl7c3dpdGNoKHMpe2Nhc2UiTU1UeXBlMSI6KDAsci5pbmZvKSgiTU1UeXBlMSBmb250ICgiK2UrIiksIGZhbGxpbmcgYmFjayB0byBUeXBlMS4iKTtjYXNlIlR5cGUxIjpjYXNlIkNJREZvbnRUeXBlMCI6dGhpcy5taW1ldHlwZT0iZm9udC9vcGVudHlwZSI7Y29uc3Qgbj0iVHlwZTFDIj09PW98fCJDSURGb250VHlwZTBDIj09PW8/bmV3IHUuQ0ZGRm9udCh0LGEpOm5ldyB3LlR5cGUxRm9udChlLHQsYSk7YWRqdXN0V2lkdGhzKGEpO2M9dGhpcy5jb252ZXJ0KGUsbixhKTticmVhaztjYXNlIk9wZW5UeXBlIjpjYXNlIlRydWVUeXBlIjpjYXNlIkNJREZvbnRUeXBlMiI6dGhpcy5taW1ldHlwZT0iZm9udC9vcGVudHlwZSI7Yz10aGlzLmNoZWNrQW5kUmVwYWlyKGUsdCxhKTtpZih0aGlzLmlzT3BlblR5cGUpe2FkanVzdFdpZHRocyhhKTtzPSJPcGVuVHlwZSJ9YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcihgRm9udCAke3N9IGlzIG5vdCBzdXBwb3J0ZWRgKX19Y2F0Y2goZSl7KDAsci53YXJuKShlKTt0aGlzLmZhbGxiYWNrVG9TeXN0ZW1Gb250KGEpO3JldHVybn1hbWVuZEZhbGxiYWNrVG9Vbmljb2RlKGEpO3RoaXMuZGF0YT1jO3RoaXMuZm9udFR5cGU9KDAsaS5nZXRGb250VHlwZSkocyxvLGEuaXNTdGFuZGFyZEZvbnQpO3RoaXMuZm9udE1hdHJpeD1hLmZvbnRNYXRyaXg7dGhpcy53aWR0aHM9YS53aWR0aHM7dGhpcy5kZWZhdWx0V2lkdGg9YS5kZWZhdWx0V2lkdGg7dGhpcy50b1VuaWNvZGU9YS50b1VuaWNvZGU7dGhpcy5zZWFjTWFwPWEuc2VhY01hcH1lbHNle3QmJigwLHIud2FybikoJ0ZvbnQgZmlsZSBpcyBlbXB0eSBpbiAiJytlKyciICgnK3RoaXMubG9hZGVkTmFtZSsiKSIpO3RoaXMuZmFsbGJhY2tUb1N5c3RlbUZvbnQoYSl9fWVsc2V7Zm9yKGxldCBlPTA7ZTwyNTY7ZSsrKXRoaXMudG9Gb250Q2hhcltlXT10aGlzLmRpZmZlcmVuY2VzW2VdfHxhLmRlZmF1bHRFbmNvZGluZ1tlXTt0aGlzLmZvbnRUeXBlPXIuRm9udFR5cGUuVFlQRTN9fWdldCByZW5kZXJlcigpe2NvbnN0IGU9ZC5Gb250UmVuZGVyZXJGYWN0b3J5LmNyZWF0ZSh0aGlzLGkuU0VBQ19BTkFMWVNJU19FTkFCTEVEKTtyZXR1cm4oMCxyLnNoYWRvdykodGhpcywicmVuZGVyZXIiLGUpfWV4cG9ydERhdGEoZT0hMSl7Y29uc3QgdD1lP1suLi5rLC4uLkNdOmssYT1PYmplY3QuY3JlYXRlKG51bGwpO2xldCByLG47Zm9yKHIgb2YgdCl7bj10aGlzW3JdO3ZvaWQgMCE9PW4mJihhW3JdPW4pfXJldHVybiBhfWZhbGxiYWNrVG9TeXN0ZW1Gb250KGUpe3RoaXMubWlzc2luZ0ZpbGU9ITA7Y29uc3QgdD10aGlzLm5hbWUsYT10aGlzLnR5cGUsbj10aGlzLnN1YnR5cGU7bGV0IHU9KDAsaS5ub3JtYWxpemVGb250TmFtZSkodCk7Y29uc3QgZD0oMCxsLmdldFN0ZEZvbnRNYXApKCksZz0oMCxsLmdldE5vblN0ZEZvbnRNYXApKCkscD0hIWRbdV0sbT0hKCFnW3VdfHwhZFtnW3VdXSk7dT1kW3VdfHxnW3VdfHx1O2NvbnN0IGI9KDAsZi5nZXRGb250QmFzaWNNZXRyaWNzKSgpW3VdO2lmKGIpe2lzTmFOKHRoaXMuYXNjZW50KSYmKHRoaXMuYXNjZW50PWIuYXNjZW50L3gpO2lzTmFOKHRoaXMuZGVzY2VudCkmJih0aGlzLmRlc2NlbnQ9Yi5kZXNjZW50L3gpO2lzTmFOKHRoaXMuY2FwSGVpZ2h0KSYmKHRoaXMuY2FwSGVpZ2h0PWIuY2FwSGVpZ2h0L3gpfXRoaXMuYm9sZD0tMSE9PXUuc2VhcmNoKC9ib2xkL2dpKTt0aGlzLml0YWxpYz0tMSE9PXUuc2VhcmNoKC9vYmxpcXVlL2dpKXx8LTEhPT11LnNlYXJjaCgvaXRhbGljL2dpKTt0aGlzLmJsYWNrPS0xIT09dC5zZWFyY2goL0JsYWNrL2cpO2NvbnN0IHk9LTEhPT10LnNlYXJjaCgvTmFycm93L2cpO3RoaXMucmVtZWFzdXJlPSghcHx8eSkmJk9iamVjdC5rZXlzKHRoaXMud2lkdGhzKS5sZW5ndGg+MDtpZigocHx8bSkmJiJDSURGb250VHlwZTIiPT09YSYmdGhpcy5jaWRFbmNvZGluZy5zdGFydHNXaXRoKCJJZGVudGl0eS0iKSl7Y29uc3QgYT1lLmNpZFRvR2lkTWFwLHI9W107YXBwbHlTdGFuZGFyZEZvbnRHbHlwaE1hcChyLCgwLGwuZ2V0R2x5cGhNYXBGb3JTdGFuZGFyZEZvbnRzKSgpKTsvQXJpYWwtP0JsYWNrL2kudGVzdCh0KT9hcHBseVN0YW5kYXJkRm9udEdseXBoTWFwKHIsKDAsbC5nZXRTdXBwbGVtZW50YWxHbHlwaE1hcEZvckFyaWFsQmxhY2spKCkpOi9DYWxpYnJpL2kudGVzdCh0KSYmYXBwbHlTdGFuZGFyZEZvbnRHbHlwaE1hcChyLCgwLGwuZ2V0U3VwcGxlbWVudGFsR2x5cGhNYXBGb3JDYWxpYnJpKSgpKTtpZihhKXtmb3IoY29uc3QgZSBpbiByKXtjb25zdCB0PXJbZV07dm9pZCAwIT09YVt0XSYmKHJbK2VdPWFbdF0pfWEubGVuZ3RoIT09dGhpcy50b1VuaWNvZGUubGVuZ3RoJiZlLmhhc0luY2x1ZGVkVG9Vbmljb2RlTWFwJiZ0aGlzLnRvVW5pY29kZSBpbnN0YW5jZW9mIGguSWRlbnRpdHlUb1VuaWNvZGVNYXAmJnRoaXMudG9Vbmljb2RlLmZvckVhY2goKGZ1bmN0aW9uKGUsdCl7Y29uc3Qgbj1yW2VdO3ZvaWQgMD09PWFbbl0mJihyWytlXT10KX0pKX10aGlzLnRvVW5pY29kZSBpbnN0YW5jZW9mIGguSWRlbnRpdHlUb1VuaWNvZGVNYXB8fHRoaXMudG9Vbmljb2RlLmZvckVhY2goKGZ1bmN0aW9uKGUsdCl7clsrZV09dH0pKTt0aGlzLnRvRm9udENoYXI9cjt0aGlzLnRvVW5pY29kZT1uZXcgaC5Ub1VuaWNvZGVNYXAocil9ZWxzZSBpZigvU3ltYm9sL2kudGVzdCh1KSl0aGlzLnRvRm9udENoYXI9YnVpbGRUb0ZvbnRDaGFyKGMuU3ltYm9sU2V0RW5jb2RpbmcsKDAsby5nZXRHbHlwaHNVbmljb2RlKSgpLHRoaXMuZGlmZmVyZW5jZXMpO2Vsc2UgaWYoL0RpbmdiYXRzL2kudGVzdCh1KSl7L1dpbmdkaW5ncy9pLnRlc3QodCkmJigwLHIud2FybikoIk5vbi1lbWJlZGRlZCBXaW5nZGluZ3MgZm9udCwgZmFsbGluZyBiYWNrIHRvIFphcGZEaW5nYmF0cy4iKTt0aGlzLnRvRm9udENoYXI9YnVpbGRUb0ZvbnRDaGFyKGMuWmFwZkRpbmdiYXRzRW5jb2RpbmcsKDAsby5nZXREaW5nYmF0c0dseXBoc1VuaWNvZGUpKCksdGhpcy5kaWZmZXJlbmNlcyl9ZWxzZSBpZihwKXtjb25zdCBlPWJ1aWxkVG9Gb250Q2hhcih0aGlzLmRlZmF1bHRFbmNvZGluZywoMCxvLmdldEdseXBoc1VuaWNvZGUpKCksdGhpcy5kaWZmZXJlbmNlcyk7IkNJREZvbnRUeXBlMiIhPT1hfHx0aGlzLmNpZEVuY29kaW5nLnN0YXJ0c1dpdGgoIklkZW50aXR5LSIpfHx0aGlzLnRvVW5pY29kZSBpbnN0YW5jZW9mIGguSWRlbnRpdHlUb1VuaWNvZGVNYXB8fHRoaXMudG9Vbmljb2RlLmZvckVhY2goKGZ1bmN0aW9uKHQsYSl7ZVsrdF09YX0pKTt0aGlzLnRvRm9udENoYXI9ZX1lbHNle2NvbnN0IGU9KDAsby5nZXRHbHlwaHNVbmljb2RlKSgpLGE9W107dGhpcy50b1VuaWNvZGUuZm9yRWFjaCgoKHQscik9PntpZighdGhpcy5jb21wb3NpdGUpe2NvbnN0IGE9dGhpcy5kaWZmZXJlbmNlc1t0XXx8dGhpcy5kZWZhdWx0RW5jb2RpbmdbdF0sbj0oMCxzLmdldFVuaWNvZGVGb3JHbHlwaCkoYSxlKTstMSE9PW4mJihyPW4pfWFbK3RdPXJ9KSk7dGhpcy5jb21wb3NpdGUmJnRoaXMudG9Vbmljb2RlIGluc3RhbmNlb2YgaC5JZGVudGl0eVRvVW5pY29kZU1hcCYmL1ZlcmRhbmEvaS50ZXN0KHQpJiZhcHBseVN0YW5kYXJkRm9udEdseXBoTWFwKGEsKDAsbC5nZXRHbHlwaE1hcEZvclN0YW5kYXJkRm9udHMpKCkpO3RoaXMudG9Gb250Q2hhcj1hfWFtZW5kRmFsbGJhY2tUb1VuaWNvZGUoZSk7dGhpcy5sb2FkZWROYW1lPXUuc3BsaXQoIi0iKVswXTt0aGlzLmZvbnRUeXBlPSgwLGkuZ2V0Rm9udFR5cGUpKGEsbixlLmlzU3RhbmRhcmRGb250KX1jaGVja0FuZFJlcGFpcihlLHQsYSl7Y29uc3Qgcz1bIk9TLzIiLCJjbWFwIiwiaGVhZCIsImhoZWEiLCJobXR4IiwibWF4cCIsIm5hbWUiLCJwb3N0IiwibG9jYSIsImdseWYiLCJmcGdtIiwicHJlcCIsImN2dCAiLCJDRkYgIl07ZnVuY3Rpb24gcmVhZFRhYmxlcyhlLHQpe2NvbnN0IGE9T2JqZWN0LmNyZWF0ZShudWxsKTthWyJPUy8yIl09bnVsbDthLmNtYXA9bnVsbDthLmhlYWQ9bnVsbDthLmhoZWE9bnVsbDthLmhtdHg9bnVsbDthLm1heHA9bnVsbDthLm5hbWU9bnVsbDthLnBvc3Q9bnVsbDtmb3IobGV0IHI9MDtyPHQ7cisrKXtjb25zdCB0PXJlYWRUYWJsZUVudHJ5KGUpO3MuaW5jbHVkZXModC50YWcpJiYoMCE9PXQubGVuZ3RoJiYoYVt0LnRhZ109dCkpfXJldHVybiBhfWZ1bmN0aW9uIHJlYWRUYWJsZUVudHJ5KGUpe2NvbnN0IHQ9ZS5nZXRTdHJpbmcoNCksYT1lLmdldEludDMyKCk+Pj4wLHI9ZS5nZXRJbnQzMigpPj4+MCxuPWUuZ2V0SW50MzIoKT4+PjAsaT1lLnBvcztlLnBvcz1lLnN0YXJ0fHwwO2Uuc2tpcChyKTtjb25zdCBzPWUuZ2V0Qnl0ZXMobik7ZS5wb3M9aTtpZigiaGVhZCI9PT10KXtzWzhdPXNbOV09c1sxMF09c1sxMV09MDtzWzE3XXw9MzJ9cmV0dXJue3RhZzp0LGNoZWNrc3VtOmEsbGVuZ3RoOm4sb2Zmc2V0OnIsZGF0YTpzfX1mdW5jdGlvbiByZWFkT3BlblR5cGVIZWFkZXIoZSl7cmV0dXJue3ZlcnNpb246ZS5nZXRTdHJpbmcoNCksbnVtVGFibGVzOmUuZ2V0VWludDE2KCksc2VhcmNoUmFuZ2U6ZS5nZXRVaW50MTYoKSxlbnRyeVNlbGVjdG9yOmUuZ2V0VWludDE2KCkscmFuZ2VTaGlmdDplLmdldFVpbnQxNigpfX1mdW5jdGlvbiBzYW5pdGl6ZUdseXBoKGUsdCxhLHIsbixpKXtjb25zdCBzPXtsZW5ndGg6MCxzaXplT2ZJbnN0cnVjdGlvbnM6MH07aWYoYS10PD0xMilyZXR1cm4gcztjb25zdCBvPWUuc3ViYXJyYXkodCxhKTtsZXQgYz1zaWduZWRJbnQxNihvWzBdLG9bMV0pO2lmKGM8MCl7Yz0tMTt3cml0ZVNpZ25lZEludDE2KG8sMCxjKTtyLnNldChvLG4pO3MubGVuZ3RoPW8ubGVuZ3RoO3JldHVybiBzfWxldCBsLGg9MTAsdT0wO2ZvcihsPTA7bDxjO2wrKyl7dT0ob1toXTw8OHxvW2grMV0pKzE7aCs9Mn1jb25zdCBkPWgsZj1vW2hdPDw4fG9baCsxXTtzLnNpemVPZkluc3RydWN0aW9ucz1mO2grPTIrZjtjb25zdCBnPWg7bGV0IHA9MDtmb3IobD0wO2w8dTtsKyspe2NvbnN0IGU9b1toKytdOzE5MiZlJiYob1toLTFdPTYzJmUpO2xldCB0PTI7MiZlP3Q9MToxNiZlJiYodD0wKTtsZXQgYT0yOzQmZT9hPTE6MzImZSYmKGE9MCk7Y29uc3Qgcj10K2E7cCs9cjtpZig4JmUpe2NvbnN0IGU9b1toKytdO2wrPWU7cCs9ZSpyfX1pZigwPT09cClyZXR1cm4gcztsZXQgbT1oK3A7aWYobT5vLmxlbmd0aClyZXR1cm4gcztpZighaSYmZj4wKXtyLnNldChvLnN1YmFycmF5KDAsZCksbik7ci5zZXQoWzAsMF0sbitkKTtyLnNldChvLnN1YmFycmF5KGcsbSksbitkKzIpO20tPWY7by5sZW5ndGgtbT4zJiYobT1tKzMmLTQpO3MubGVuZ3RoPW07cmV0dXJuIHN9aWYoby5sZW5ndGgtbT4zKXttPW0rMyYtNDtyLnNldChvLnN1YmFycmF5KDAsbSksbik7cy5sZW5ndGg9bTtyZXR1cm4gc31yLnNldChvLG4pO3MubGVuZ3RoPW8ubGVuZ3RoO3JldHVybiBzfWZ1bmN0aW9uIHJlYWROYW1lVGFibGUoZSl7Y29uc3QgYT0odC5zdGFydHx8MCkrZS5vZmZzZXQ7dC5wb3M9YTtjb25zdCByPVtbXSxbXV0sbj1lLmxlbmd0aCxpPWErbjtpZigwIT09dC5nZXRVaW50MTYoKXx8bjw2KXJldHVybiByO2NvbnN0IHM9dC5nZXRVaW50MTYoKSxvPXQuZ2V0VWludDE2KCksYz1bXTtsZXQgbCxoO2ZvcihsPTA7bDxzJiZ0LnBvcysxMjw9aTtsKyspe2NvbnN0IGU9e3BsYXRmb3JtOnQuZ2V0VWludDE2KCksZW5jb2Rpbmc6dC5nZXRVaW50MTYoKSxsYW5ndWFnZTp0LmdldFVpbnQxNigpLG5hbWU6dC5nZXRVaW50MTYoKSxsZW5ndGg6dC5nZXRVaW50MTYoKSxvZmZzZXQ6dC5nZXRVaW50MTYoKX07KDE9PT1lLnBsYXRmb3JtJiYwPT09ZS5lbmNvZGluZyYmMD09PWUubGFuZ3VhZ2V8fDM9PT1lLnBsYXRmb3JtJiYxPT09ZS5lbmNvZGluZyYmMTAzMz09PWUubGFuZ3VhZ2UpJiZjLnB1c2goZSl9Zm9yKGw9MCxoPWMubGVuZ3RoO2w8aDtsKyspe2NvbnN0IGU9Y1tsXTtpZihlLmxlbmd0aDw9MCljb250aW51ZTtjb25zdCBuPWErbytlLm9mZnNldDtpZihuK2UubGVuZ3RoPmkpY29udGludWU7dC5wb3M9bjtjb25zdCBzPWUubmFtZTtpZihlLmVuY29kaW5nKXtsZXQgYT0iIjtmb3IobGV0IHI9MCxuPWUubGVuZ3RoO3I8bjtyKz0yKWErPVN0cmluZy5mcm9tQ2hhckNvZGUodC5nZXRVaW50MTYoKSk7clsxXVtzXT1hfWVsc2UgclswXVtzXT10LmdldFN0cmluZyhlLmxlbmd0aCl9cmV0dXJuIHJ9Y29uc3QgbD1bMCwwLDAsMCwwLDAsMCwwLC0yLC0yLC0yLC0yLDAsMCwtMiwtNSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwwLDAsLTEsMCwtMSwtMSwtMSwtMSwxLC0xLC05OTksMCwxLDAsLTEsLTIsMCwtMSwtMiwtMSwtMSwwLC0xLC0xLDAsMCwtOTk5LC05OTksLTEsLTEsLTEsLTEsLTIsLTk5OSwtMiwtMiwtOTk5LDAsLTIsLTIsMCwwLC0yLDAsLTIsMCwwLDAsLTIsLTEsLTEsMSwxLDAsMCwtMSwtMSwtMSwtMSwtMSwtMSwtMSwwLDAsLTEsMCwtMSwtMSwwLC05OTksLTEsLTEsLTEsLTEsLTEsLTEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsLTIsLTk5OSwtOTk5LC05OTksLTk5OSwtOTk5LC0xLC0xLC0yLC0yLDAsMCwwLDAsLTEsLTEsLTk5OSwtMiwtMiwwLDAsLTEsLTIsLTIsMCwwLDAsLTEsLTEsLTEsLTJdO2Z1bmN0aW9uIHNhbml0aXplVFRQcm9ncmFtKGUsdCl7bGV0IGEsbixpLHMsbyxjPWUuZGF0YSxoPTAsdT0wLGQ9MDtjb25zdCBmPVtdLGc9W10scD1bXTtsZXQgbT10LnRvb0NvbXBsZXhUb0ZvbGxvd0Z1bmN0aW9ucyxiPSExLHk9MCx3PTA7Zm9yKGxldCBlPWMubGVuZ3RoO2g8ZTspe2NvbnN0IGU9Y1toKytdO2lmKDY0PT09ZSl7bj1jW2grK107aWYoYnx8dyloKz1uO2Vsc2UgZm9yKGE9MDthPG47YSsrKWYucHVzaChjW2grK10pfWVsc2UgaWYoNjU9PT1lKXtuPWNbaCsrXTtpZihifHx3KWgrPTIqbjtlbHNlIGZvcihhPTA7YTxuO2ErKyl7aT1jW2grK107Zi5wdXNoKGk8PDh8Y1toKytdKX19ZWxzZSBpZigxNzY9PSgyNDgmZSkpe249ZS0xNzYrMTtpZihifHx3KWgrPW47ZWxzZSBmb3IoYT0wO2E8bjthKyspZi5wdXNoKGNbaCsrXSl9ZWxzZSBpZigxODQ9PSgyNDgmZSkpe249ZS0xODQrMTtpZihifHx3KWgrPTIqbjtlbHNlIGZvcihhPTA7YTxuO2ErKyl7aT1jW2grK107Zi5wdXNoKGk8PDh8Y1toKytdKX19ZWxzZSBpZig0MyE9PWV8fG0paWYoNDQhPT1lfHxtKXtpZig0NT09PWUpaWYoYil7Yj0hMTt1PWh9ZWxzZXtvPWcucG9wKCk7aWYoIW8peygwLHIud2FybikoIlRUOiBFTkRGIGJhZCBzdGFjayIpO3QuaGludHNWYWxpZD0hMTtyZXR1cm59cz1wLnBvcCgpO2M9by5kYXRhO2g9by5pO3QuZnVuY3Rpb25zU3RhY2tEZWx0YXNbc109Zi5sZW5ndGgtby5zdGFja1RvcH1lbHNlIGlmKDEzNz09PWUpe2lmKGJ8fHcpeygwLHIud2FybikoIlRUOiBuZXN0ZWQgSURFRnMgbm90IGFsbG93ZWQiKTttPSEwfWI9ITA7ZD1ofWVsc2UgaWYoODg9PT1lKSsreTtlbHNlIGlmKDI3PT09ZSl3PXk7ZWxzZSBpZig4OT09PWUpe3c9PT15JiYodz0wKTstLXl9ZWxzZSBpZigyOD09PWUmJiFiJiYhdyl7Y29uc3QgZT1mLmF0KC0xKTtlPjAmJihoKz1lLTEpfX1lbHNle2lmKGJ8fHcpeygwLHIud2FybikoIlRUOiBuZXN0ZWQgRkRFRnMgbm90IGFsbG93ZWQiKTttPSEwfWI9ITA7ZD1oO3M9Zi5wb3AoKTt0LmZ1bmN0aW9uc0RlZmluZWRbc109e2RhdGE6YyxpOmh9fWVsc2UgaWYoIWImJiF3KXtzPWYuYXQoLTEpO2lmKGlzTmFOKHMpKSgwLHIuaW5mbykoIlRUOiBDQUxMIGVtcHR5IHN0YWNrIChvciBpbnZhbGlkIGVudHJ5KS4iKTtlbHNle3QuZnVuY3Rpb25zVXNlZFtzXT0hMDtpZihzIGluIHQuZnVuY3Rpb25zU3RhY2tEZWx0YXMpe2NvbnN0IGU9Zi5sZW5ndGgrdC5mdW5jdGlvbnNTdGFja0RlbHRhc1tzXTtpZihlPDApeygwLHIud2FybikoIlRUOiBDQUxMIGludmFsaWQgZnVuY3Rpb25zIHN0YWNrIGRlbHRhLiIpO3QuaGludHNWYWxpZD0hMTtyZXR1cm59Zi5sZW5ndGg9ZX1lbHNlIGlmKHMgaW4gdC5mdW5jdGlvbnNEZWZpbmVkJiYhcC5pbmNsdWRlcyhzKSl7Zy5wdXNoKHtkYXRhOmMsaTpoLHN0YWNrVG9wOmYubGVuZ3RoLTF9KTtwLnB1c2gocyk7bz10LmZ1bmN0aW9uc0RlZmluZWRbc107aWYoIW8peygwLHIud2FybikoIlRUOiBDQUxMIG5vbi1leGlzdGVudCBmdW5jdGlvbiIpO3QuaGludHNWYWxpZD0hMTtyZXR1cm59Yz1vLmRhdGE7aD1vLml9fX1pZighYiYmIXcpe2xldCB0PTA7ZTw9MTQyP3Q9bFtlXTplPj0xOTImJmU8PTIyMz90PS0xOmU+PTIyNCYmKHQ9LTIpO2lmKGU+PTExMyYmZTw9MTE3KXtuPWYucG9wKCk7aXNOYU4obil8fCh0PTIqLW4pfWZvcig7dDwwJiZmLmxlbmd0aD4wOyl7Zi5wb3AoKTt0Kyt9Zm9yKDt0PjA7KXtmLnB1c2goTmFOKTt0LS19fX10LnRvb0NvbXBsZXhUb0ZvbGxvd0Z1bmN0aW9ucz1tO2NvbnN0IFM9W2NdO2g+Yy5sZW5ndGgmJlMucHVzaChuZXcgVWludDhBcnJheShoLWMubGVuZ3RoKSk7aWYoZD51KXsoMCxyLndhcm4pKCJUVDogY29tcGxlbWVudGluZyBhIG1pc3NpbmcgZnVuY3Rpb24gdGFpbCIpO1MucHVzaChuZXcgVWludDhBcnJheShbMzQsNDVdKSl9IWZ1bmN0aW9uIGZvbGRUVFRhYmxlKGUsdCl7aWYodC5sZW5ndGg+MSl7bGV0IGEscixuPTA7Zm9yKGE9MCxyPXQubGVuZ3RoO2E8cjthKyspbis9dFthXS5sZW5ndGg7bj1uKzMmLTQ7Y29uc3QgaT1uZXcgVWludDhBcnJheShuKTtsZXQgcz0wO2ZvcihhPTAscj10Lmxlbmd0aDthPHI7YSsrKXtpLnNldCh0W2FdLHMpO3MrPXRbYV0ubGVuZ3RofWUuZGF0YT1pO2UubGVuZ3RoPW59fShlLFMpfWxldCBkLGYsYix3O2lmKGlzVHJ1ZVR5cGVDb2xsZWN0aW9uRmlsZSh0PW5ldyB5LlN0cmVhbShuZXcgVWludDhBcnJheSh0LmdldEJ5dGVzKCkpKSkpe2NvbnN0IGU9ZnVuY3Rpb24gcmVhZFRydWVUeXBlQ29sbGVjdGlvbkRhdGEoZSx0KXtjb25zdHtudW1Gb250czphLG9mZnNldFRhYmxlOm59PWZ1bmN0aW9uIHJlYWRUcnVlVHlwZUNvbGxlY3Rpb25IZWFkZXIoZSl7Y29uc3QgdD1lLmdldFN0cmluZyg0KTsoMCxyLmFzc2VydCkoInR0Y2YiPT09dCwiTXVzdCBiZSBhIFRydWVUeXBlIENvbGxlY3Rpb24gZm9udC4iKTtjb25zdCBhPWUuZ2V0VWludDE2KCksbj1lLmdldFVpbnQxNigpLGk9ZS5nZXRJbnQzMigpPj4+MCxzPVtdO2ZvcihsZXQgdD0wO3Q8aTt0Kyspcy5wdXNoKGUuZ2V0SW50MzIoKT4+PjApO2NvbnN0IG89e3R0Y1RhZzp0LG1ham9yVmVyc2lvbjphLG1pbm9yVmVyc2lvbjpuLG51bUZvbnRzOmksb2Zmc2V0VGFibGU6c307c3dpdGNoKGEpe2Nhc2UgMTpyZXR1cm4gbztjYXNlIDI6by5kc2lnVGFnPWUuZ2V0SW50MzIoKT4+PjA7by5kc2lnTGVuZ3RoPWUuZ2V0SW50MzIoKT4+PjA7by5kc2lnT2Zmc2V0PWUuZ2V0SW50MzIoKT4+PjA7cmV0dXJuIG99dGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoYEludmFsaWQgVHJ1ZVR5cGUgQ29sbGVjdGlvbiBtYWpvclZlcnNpb246ICR7YX0uYCl9KGUpLGk9dC5zcGxpdCgiKyIpO2xldCBzO2ZvcihsZXQgbz0wO288YTtvKyspe2UucG9zPShlLnN0YXJ0fHwwKStuW29dO2NvbnN0IGE9cmVhZE9wZW5UeXBlSGVhZGVyKGUpLGM9cmVhZFRhYmxlcyhlLGEubnVtVGFibGVzKTtpZighYy5uYW1lKXRocm93IG5ldyByLkZvcm1hdEVycm9yKCdUcnVlVHlwZSBDb2xsZWN0aW9uIGZvbnQgbXVzdCBjb250YWluIGEgIm5hbWUiIHRhYmxlLicpO2NvbnN0IGw9cmVhZE5hbWVUYWJsZShjLm5hbWUpO2ZvcihsZXQgZT0wLHI9bC5sZW5ndGg7ZTxyO2UrKylmb3IobGV0IHI9MCxuPWxbZV0ubGVuZ3RoO3I8bjtyKyspe2NvbnN0IG49bFtlXVtyXSYmbFtlXVtyXS5yZXBsYWNlKC9ccy9nLCIiKTtpZihuKXtpZihuPT09dClyZXR1cm57aGVhZGVyOmEsdGFibGVzOmN9O2lmKCEoaS5sZW5ndGg8MikpZm9yKGNvbnN0IGUgb2YgaSluPT09ZSYmKHM9e25hbWU6ZSxoZWFkZXI6YSx0YWJsZXM6Y30pfX19aWYocyl7KDAsci53YXJuKShgVHJ1ZVR5cGUgQ29sbGVjdGlvbiBkb2VzIG5vdCBjb250YWluICIke3R9IiBmb250LCBmYWxsaW5nIGJhY2sgdG8gIiR7cy5uYW1lfSIgZm9udCBpbnN0ZWFkLmApO3JldHVybntoZWFkZXI6cy5oZWFkZXIsdGFibGVzOnMudGFibGVzfX10aHJvdyBuZXcgci5Gb3JtYXRFcnJvcihgVHJ1ZVR5cGUgQ29sbGVjdGlvbiBkb2VzIG5vdCBjb250YWluICIke3R9IiBmb250LmApfSh0LHRoaXMubmFtZSk7ZD1lLmhlYWRlcjtmPWUudGFibGVzfWVsc2V7ZD1yZWFkT3BlblR5cGVIZWFkZXIodCk7Zj1yZWFkVGFibGVzKHQsZC5udW1UYWJsZXMpfWNvbnN0IFM9IWZbIkNGRiAiXTtpZihTKXtpZighZi5sb2NhKXRocm93IG5ldyByLkZvcm1hdEVycm9yKCdSZXF1aXJlZCAibG9jYSIgdGFibGUgaXMgbm90IGZvdW5kJyk7aWYoIWYuZ2x5Zil7KDAsci53YXJuKSgnUmVxdWlyZWQgImdseWYiIHRhYmxlIGlzIG5vdCBmb3VuZCAtLSB0cnlpbmcgdG8gcmVjb3Zlci4nKTtmLmdseWY9e3RhZzoiZ2x5ZiIsZGF0YTpuZXcgVWludDhBcnJheSgwKX19dGhpcy5pc09wZW5UeXBlPSExfWVsc2V7Y29uc3QgdD1hLmNvbXBvc2l0ZSYmKChhLmNpZFRvR2lkTWFwfHxbXSkubGVuZ3RoPjB8fCEoYS5jTWFwIGluc3RhbmNlb2YgcC5JZGVudGl0eUNNYXApKTtpZigiT1RUTyI9PT1kLnZlcnNpb24mJiF0fHwhZi5oZWFkfHwhZi5oaGVhfHwhZi5tYXhwfHwhZi5wb3N0KXt3PW5ldyB5LlN0cmVhbShmWyJDRkYgIl0uZGF0YSk7Yj1uZXcgdS5DRkZGb250KHcsYSk7YWRqdXN0V2lkdGhzKGEpO3JldHVybiB0aGlzLmNvbnZlcnQoZSxiLGEpfWRlbGV0ZSBmLmdseWY7ZGVsZXRlIGYubG9jYTtkZWxldGUgZi5mcGdtO2RlbGV0ZSBmLnByZXA7ZGVsZXRlIGZbImN2dCAiXTt0aGlzLmlzT3BlblR5cGU9ITB9aWYoIWYubWF4cCl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcignUmVxdWlyZWQgIm1heHAiIHRhYmxlIGlzIG5vdCBmb3VuZCcpO3QucG9zPSh0LnN0YXJ0fHwwKStmLm1heHAub2Zmc2V0O2NvbnN0IHg9dC5nZXRJbnQzMigpLGs9dC5nZXRVaW50MTYoKTtpZihhLnNjYWxlRmFjdG9ycyYmYS5zY2FsZUZhY3RvcnMubGVuZ3RoPT09ayYmUyl7Y29uc3R7c2NhbGVGYWN0b3JzOmV9PWEsdD1pbnQxNihmLmhlYWQuZGF0YVs1MF0sZi5oZWFkLmRhdGFbNTFdKSxyPW5ldyBnLkdseWZUYWJsZSh7Z2x5ZlRhYmxlOmYuZ2x5Zi5kYXRhLGlzR2x5cGhMb2NhdGlvbnNMb25nOnQsbG9jYVRhYmxlOmYubG9jYS5kYXRhLG51bUdseXBoczprfSk7ci5zY2FsZShlKTtjb25zdHtnbHlmOm4sbG9jYTppLGlzTG9jYXRpb25Mb25nOnN9PXIud3JpdGUoKTtmLmdseWYuZGF0YT1uO2YubG9jYS5kYXRhPWk7aWYocyE9PSEhdCl7Zi5oZWFkLmRhdGFbNTBdPTA7Zi5oZWFkLmRhdGFbNTFdPXM/MTowfWNvbnN0IG89Zi5obXR4LmRhdGE7Zm9yKGxldCB0PTA7dDxrO3QrKyl7Y29uc3QgYT00KnQscj1NYXRoLnJvdW5kKGVbdF0qaW50MTYob1thXSxvW2ErMV0pKTtvW2FdPXI+PjgmMjU1O29bYSsxXT0yNTUmcjt3cml0ZVNpZ25lZEludDE2KG8sYSsyLE1hdGgucm91bmQoZVt0XSpzaWduZWRJbnQxNihvW2ErMl0sb1thKzNdKSkpfX1sZXQgQz1rKzEsdj0hMDtpZihDPjY1NTM1KXt2PSExO0M9azsoMCxyLndhcm4pKCJOb3QgZW5vdWdoIHNwYWNlIGluIGdseWZzIHRvIGR1cGxpY2F0ZSBmaXJzdCBnbHlwaC4iKX1sZXQgRj0wLE89MDtpZih4Pj02NTUzNiYmZi5tYXhwLmxlbmd0aD49MjIpe3QucG9zKz04O2lmKHQuZ2V0VWludDE2KCk+Mil7Zi5tYXhwLmRhdGFbMTRdPTA7Zi5tYXhwLmRhdGFbMTVdPTJ9dC5wb3MrPTQ7Rj10LmdldFVpbnQxNigpO3QucG9zKz00O089dC5nZXRVaW50MTYoKX1mLm1heHAuZGF0YVs0XT1DPj44O2YubWF4cC5kYXRhWzVdPTI1NSZDO2NvbnN0IFQ9ZnVuY3Rpb24gc2FuaXRpemVUVFByb2dyYW1zKGUsdCxhLG4pe2NvbnN0IGk9e2Z1bmN0aW9uc0RlZmluZWQ6W10sZnVuY3Rpb25zVXNlZDpbXSxmdW5jdGlvbnNTdGFja0RlbHRhczpbXSx0b29Db21wbGV4VG9Gb2xsb3dGdW5jdGlvbnM6ITEsaGludHNWYWxpZDohMH07ZSYmc2FuaXRpemVUVFByb2dyYW0oZSxpKTt0JiZzYW5pdGl6ZVRUUHJvZ3JhbSh0LGkpO2UmJmZ1bmN0aW9uIGNoZWNrSW52YWxpZEZ1bmN0aW9ucyhlLHQpe2lmKCFlLnRvb0NvbXBsZXhUb0ZvbGxvd0Z1bmN0aW9ucylpZihlLmZ1bmN0aW9uc0RlZmluZWQubGVuZ3RoPnQpeygwLHIud2FybikoIlRUOiBtb3JlIGZ1bmN0aW9ucyBkZWZpbmVkIHRoYW4gZXhwZWN0ZWQiKTtlLmhpbnRzVmFsaWQ9ITF9ZWxzZSBmb3IobGV0IGE9MCxuPWUuZnVuY3Rpb25zVXNlZC5sZW5ndGg7YTxuO2ErKyl7aWYoYT50KXsoMCxyLndhcm4pKCJUVDogaW52YWxpZCBmdW5jdGlvbiBpZDogIithKTtlLmhpbnRzVmFsaWQ9ITE7cmV0dXJufWlmKGUuZnVuY3Rpb25zVXNlZFthXSYmIWUuZnVuY3Rpb25zRGVmaW5lZFthXSl7KDAsci53YXJuKSgiVFQ6IHVuZGVmaW5lZCBmdW5jdGlvbjogIithKTtlLmhpbnRzVmFsaWQ9ITE7cmV0dXJufX19KGksbik7aWYoYSYmMSZhLmxlbmd0aCl7Y29uc3QgZT1uZXcgVWludDhBcnJheShhLmxlbmd0aCsxKTtlLnNldChhLmRhdGEpO2EuZGF0YT1lfXJldHVybiBpLmhpbnRzVmFsaWR9KGYuZnBnbSxmLnByZXAsZlsiY3Z0ICJdLEYpO2lmKCFUKXtkZWxldGUgZi5mcGdtO2RlbGV0ZSBmLnByZXA7ZGVsZXRlIGZbImN2dCAiXX0hZnVuY3Rpb24gc2FuaXRpemVNZXRyaWNzKGUsdCxhLG4saSxzKXtpZighdCl7YSYmKGEuZGF0YT1udWxsKTtyZXR1cm59ZS5wb3M9KGUuc3RhcnR8fDApK3Qub2Zmc2V0O2UucG9zKz00O2UucG9zKz0yO2UucG9zKz0yO2UucG9zKz0yO2UucG9zKz0yO2UucG9zKz0yO2UucG9zKz0yO2UucG9zKz0yO2UucG9zKz0yO2UucG9zKz0yO2NvbnN0IG89ZS5nZXRVaW50MTYoKTtlLnBvcys9ODtlLnBvcys9MjtsZXQgYz1lLmdldFVpbnQxNigpO2lmKDAhPT1vKXtpZighKDImaW50MTYobi5kYXRhWzQ0XSxuLmRhdGFbNDVdKSkpe3QuZGF0YVsyMl09MDt0LmRhdGFbMjNdPTB9fWlmKGM+aSl7KDAsci5pbmZvKShgVGhlIG51bU9mTWV0cmljcyAoJHtjfSkgc2hvdWxkIG5vdCBiZSBncmVhdGVyIHRoYW4gdGhlIG51bUdseXBocyAoJHtpfSkuYCk7Yz1pO3QuZGF0YVszNF09KDY1MjgwJmMpPj44O3QuZGF0YVszNV09MjU1JmN9Y29uc3QgbD1pLWMtKGEubGVuZ3RoLTQqYz4+MSk7aWYobD4wKXtjb25zdCBlPW5ldyBVaW50OEFycmF5KGEubGVuZ3RoKzIqbCk7ZS5zZXQoYS5kYXRhKTtpZihzKXtlW2EubGVuZ3RoXT1hLmRhdGFbMl07ZVthLmxlbmd0aCsxXT1hLmRhdGFbM119YS5kYXRhPWV9fSh0LGYuaGhlYSxmLmhtdHgsZi5oZWFkLEMsdik7aWYoIWYuaGVhZCl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcignUmVxdWlyZWQgImhlYWQiIHRhYmxlIGlzIG5vdCBmb3VuZCcpOyFmdW5jdGlvbiBzYW5pdGl6ZUhlYWQoZSx0LGEpe2NvbnN0IG49ZS5kYXRhLGk9ZnVuY3Rpb24gaW50MzIoZSx0LGEscil7cmV0dXJuKGU8PDI0KSsodDw8MTYpKyhhPDw4KStyfShuWzBdLG5bMV0sblsyXSxuWzNdKTtpZihpPj4xNiE9MSl7KDAsci5pbmZvKSgiQXR0ZW1wdGluZyB0byBmaXggaW52YWxpZCB2ZXJzaW9uIGluIGhlYWQgdGFibGU6ICIraSk7blswXT0wO25bMV09MTtuWzJdPTA7blszXT0wfWNvbnN0IHM9aW50MTYobls1MF0sbls1MV0pO2lmKHM8MHx8cz4xKXsoMCxyLmluZm8pKCJBdHRlbXB0aW5nIHRvIGZpeCBpbnZhbGlkIGluZGV4VG9Mb2NGb3JtYXQgaW4gaGVhZCB0YWJsZTogIitzKTtjb25zdCBlPXQrMTtpZihhPT09ZTw8MSl7bls1MF09MDtuWzUxXT0wfWVsc2V7aWYoYSE9PWU8PDIpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoIkNvdWxkIG5vdCBmaXggaW5kZXhUb0xvY0Zvcm1hdDogIitzKTtuWzUwXT0wO25bNTFdPTF9fX0oZi5oZWFkLGssUz9mLmxvY2EubGVuZ3RoOjApO2xldCBNPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoUyl7Y29uc3QgZT1pbnQxNihmLmhlYWQuZGF0YVs1MF0sZi5oZWFkLmRhdGFbNTFdKSx0PWZ1bmN0aW9uIHNhbml0aXplR2x5cGhMb2NhdGlvbnMoZSx0LGEscixuLGkscyl7bGV0IG8sYyxsO2lmKHIpe289NDtjPWZ1bmN0aW9uIGZvbnRJdGVtRGVjb2RlTG9uZyhlLHQpe3JldHVybiBlW3RdPDwyNHxlW3QrMV08PDE2fGVbdCsyXTw8OHxlW3QrM119O2w9ZnVuY3Rpb24gZm9udEl0ZW1FbmNvZGVMb25nKGUsdCxhKXtlW3RdPWE+Pj4yNCYyNTU7ZVt0KzFdPWE+PjE2JjI1NTtlW3QrMl09YT4+OCYyNTU7ZVt0KzNdPTI1NSZhfX1lbHNle289MjtjPWZ1bmN0aW9uIGZvbnRJdGVtRGVjb2RlKGUsdCl7cmV0dXJuIGVbdF08PDl8ZVt0KzFdPDwxfTtsPWZ1bmN0aW9uIGZvbnRJdGVtRW5jb2RlKGUsdCxhKXtlW3RdPWE+PjkmMjU1O2VbdCsxXT1hPj4xJjI1NX19Y29uc3QgaD1pP2ErMTphLHU9byooMStoKSxkPW5ldyBVaW50OEFycmF5KHUpO2Quc2V0KGUuZGF0YS5zdWJhcnJheSgwLHUpKTtlLmRhdGE9ZDtjb25zdCBmPXQuZGF0YSxnPWYubGVuZ3RoLHA9bmV3IFVpbnQ4QXJyYXkoZyk7bGV0IG0sYjtjb25zdCB5PVtdO2ZvcihtPTAsYj0wO208YSsxO20rKyxiKz1vKXtsZXQgZT1jKGQsYik7ZT5nJiYoZT1nKTt5LnB1c2goe2luZGV4Om0sb2Zmc2V0OmUsZW5kT2Zmc2V0OjB9KX15LnNvcnQoKChlLHQpPT5lLm9mZnNldC10Lm9mZnNldCkpO2ZvcihtPTA7bTxhO20rKyl5W21dLmVuZE9mZnNldD15W20rMV0ub2Zmc2V0O3kuc29ydCgoKGUsdCk9PmUuaW5kZXgtdC5pbmRleCkpO2ZvcihtPTA7bTxhO20rKyl7Y29uc3R7b2Zmc2V0OmUsZW5kT2Zmc2V0OnR9PXlbbV07aWYoMCE9PWV8fDAhPT10KWJyZWFrO2NvbnN0IGE9eVttKzFdLm9mZnNldDtpZigwIT09YSl7eVttXS5lbmRPZmZzZXQ9YTticmVha319Y29uc3Qgdz1PYmplY3QuY3JlYXRlKG51bGwpO2xldCBTPTA7bChkLDAsUyk7Zm9yKG09MCxiPW87bTxhO20rKyxiKz1vKXtjb25zdCBlPXNhbml0aXplR2x5cGgoZix5W21dLm9mZnNldCx5W21dLmVuZE9mZnNldCxwLFMsbiksdD1lLmxlbmd0aDswPT09dCYmKHdbbV09ITApO2Uuc2l6ZU9mSW5zdHJ1Y3Rpb25zPnMmJihzPWUuc2l6ZU9mSW5zdHJ1Y3Rpb25zKTtTKz10O2woZCxiLFMpfWlmKDA9PT1TKXtjb25zdCBlPW5ldyBVaW50OEFycmF5KFswLDEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsNDksMF0pO2ZvcihtPTAsYj1vO208aDttKyssYis9bylsKGQsYixlLmxlbmd0aCk7dC5kYXRhPWV9ZWxzZSBpZihpKXtjb25zdCBhPWMoZCxvKTtpZihwLmxlbmd0aD5hK1MpdC5kYXRhPXAuc3ViYXJyYXkoMCxhK1MpO2Vsc2V7dC5kYXRhPW5ldyBVaW50OEFycmF5KGErUyk7dC5kYXRhLnNldChwLnN1YmFycmF5KDAsUykpfXQuZGF0YS5zZXQocC5zdWJhcnJheSgwLGEpLFMpO2woZS5kYXRhLGQubGVuZ3RoLW8sUythKX1lbHNlIHQuZGF0YT1wLnN1YmFycmF5KDAsUyk7cmV0dXJue21pc3NpbmdHbHlwaHM6dyxtYXhTaXplT2ZJbnN0cnVjdGlvbnM6c319KGYubG9jYSxmLmdseWYsayxlLFQsdixPKTtNPXQubWlzc2luZ0dseXBocztpZih4Pj02NTUzNiYmZi5tYXhwLmxlbmd0aD49MjIpe2YubWF4cC5kYXRhWzI2XT10Lm1heFNpemVPZkluc3RydWN0aW9ucz4+ODtmLm1heHAuZGF0YVsyN109MjU1JnQubWF4U2l6ZU9mSW5zdHJ1Y3Rpb25zfX1pZighZi5oaGVhKXRocm93IG5ldyByLkZvcm1hdEVycm9yKCdSZXF1aXJlZCAiaGhlYSIgdGFibGUgaXMgbm90IGZvdW5kJyk7aWYoMD09PWYuaGhlYS5kYXRhWzEwXSYmMD09PWYuaGhlYS5kYXRhWzExXSl7Zi5oaGVhLmRhdGFbMTBdPTI1NTtmLmhoZWEuZGF0YVsxMV09MjU1fWNvbnN0IEU9e3VuaXRzUGVyRW06aW50MTYoZi5oZWFkLmRhdGFbMThdLGYuaGVhZC5kYXRhWzE5XSkseU1heDppbnQxNihmLmhlYWQuZGF0YVs0Ml0sZi5oZWFkLmRhdGFbNDNdKSx5TWluOnNpZ25lZEludDE2KGYuaGVhZC5kYXRhWzM4XSxmLmhlYWQuZGF0YVszOV0pLGFzY2VudDpzaWduZWRJbnQxNihmLmhoZWEuZGF0YVs0XSxmLmhoZWEuZGF0YVs1XSksZGVzY2VudDpzaWduZWRJbnQxNihmLmhoZWEuZGF0YVs2XSxmLmhoZWEuZGF0YVs3XSksbGluZUdhcDpzaWduZWRJbnQxNihmLmhoZWEuZGF0YVs4XSxmLmhoZWEuZGF0YVs5XSl9O3RoaXMuYXNjZW50PUUuYXNjZW50L0UudW5pdHNQZXJFbTt0aGlzLmRlc2NlbnQ9RS5kZXNjZW50L0UudW5pdHNQZXJFbTt0aGlzLmxpbmVHYXA9RS5saW5lR2FwL0UudW5pdHNQZXJFbTtpZih0aGlzLmNzc0ZvbnRJbmZvJiZ0aGlzLmNzc0ZvbnRJbmZvLmxpbmVIZWlnaHQpe3RoaXMubGluZUhlaWdodD10aGlzLmNzc0ZvbnRJbmZvLm1ldHJpY3MubGluZUhlaWdodDt0aGlzLmxpbmVHYXA9dGhpcy5jc3NGb250SW5mby5tZXRyaWNzLmxpbmVHYXB9ZWxzZSB0aGlzLmxpbmVIZWlnaHQ9dGhpcy5hc2NlbnQtdGhpcy5kZXNjZW50K3RoaXMubGluZUdhcDtmLnBvc3QmJmZ1bmN0aW9uIHJlYWRQb3N0U2NyaXB0VGFibGUoZSxhLG4pe2NvbnN0IHM9KHQuc3RhcnR8fDApK2Uub2Zmc2V0O3QucG9zPXM7Y29uc3Qgbz1zK2UubGVuZ3RoLGM9dC5nZXRJbnQzMigpO3Quc2tpcCgyOCk7bGV0IGwsaCx1PSEwO3N3aXRjaChjKXtjYXNlIDY1NTM2Omw9aS5NYWNTdGFuZGFyZEdseXBoT3JkZXJpbmc7YnJlYWs7Y2FzZSAxMzEwNzI6Y29uc3QgZT10LmdldFVpbnQxNigpO2lmKGUhPT1uKXt1PSExO2JyZWFrfWNvbnN0IHM9W107Zm9yKGg9MDtoPGU7KytoKXtjb25zdCBlPXQuZ2V0VWludDE2KCk7aWYoZT49MzI3Njgpe3U9ITE7YnJlYWt9cy5wdXNoKGUpfWlmKCF1KWJyZWFrO2NvbnN0IGQ9W10sZj1bXTtmb3IoO3QucG9zPG87KXtjb25zdCBlPXQuZ2V0Qnl0ZSgpO2YubGVuZ3RoPWU7Zm9yKGg9MDtoPGU7KytoKWZbaF09U3RyaW5nLmZyb21DaGFyQ29kZSh0LmdldEJ5dGUoKSk7ZC5wdXNoKGYuam9pbigiIikpfWw9W107Zm9yKGg9MDtoPGU7KytoKXtjb25zdCBlPXNbaF07ZTwyNTg/bC5wdXNoKGkuTWFjU3RhbmRhcmRHbHlwaE9yZGVyaW5nW2VdKTpsLnB1c2goZFtlLTI1OF0pfWJyZWFrO2Nhc2UgMTk2NjA4OmJyZWFrO2RlZmF1bHQ6KDAsci53YXJuKSgiVW5rbm93bi91bnN1cHBvcnRlZCBwb3N0IHRhYmxlIHZlcnNpb24gIitjKTt1PSExO2EuZGVmYXVsdEVuY29kaW5nJiYobD1hLmRlZmF1bHRFbmNvZGluZyl9YS5nbHlwaE5hbWVzPWw7cmV0dXJuIHV9KGYucG9zdCxhLGspO2YucG9zdD17dGFnOiJwb3N0IixkYXRhOmNyZWF0ZVBvc3RUYWJsZShhKX07Y29uc3QgRD1bXTtmdW5jdGlvbiBoYXNHbHlwaChlKXtyZXR1cm4hTVtlXX1pZihhLmNvbXBvc2l0ZSl7Y29uc3QgZT1hLmNpZFRvR2lkTWFwfHxbXSx0PTA9PT1lLmxlbmd0aDthLmNNYXAuZm9yRWFjaCgoZnVuY3Rpb24oYSxuKXsic3RyaW5nIj09dHlwZW9mIG4mJihuPWNvbnZlcnRDaWRTdHJpbmcoYSxuLCEwKSk7aWYobj42NTUzNSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiTWF4IHNpemUgb2YgQ0lEIGlzIDY1LDUzNSIpO2xldCBpPS0xO3Q/aT1uOnZvaWQgMCE9PWVbbl0mJihpPWVbbl0pO2k+PTAmJmk8ayYmaGFzR2x5cGgoaSkmJihEW2FdPWkpfSkpfWVsc2V7Y29uc3QgZT1mdW5jdGlvbiByZWFkQ21hcFRhYmxlKGUsdCxhLG4pe2lmKCFlKXsoMCxyLndhcm4pKCJObyBjbWFwIHRhYmxlIGF2YWlsYWJsZS4iKTtyZXR1cm57cGxhdGZvcm1JZDotMSxlbmNvZGluZ0lkOi0xLG1hcHBpbmdzOltdLGhhc1Nob3J0Q21hcDohMX19bGV0IGkscz0odC5zdGFydHx8MCkrZS5vZmZzZXQ7dC5wb3M9czt0LnNraXAoMik7Y29uc3Qgbz10LmdldFVpbnQxNigpO2xldCBjLGw9ITE7Zm9yKGxldCBlPTA7ZTxvO2UrKyl7Y29uc3Qgcj10LmdldFVpbnQxNigpLGk9dC5nZXRVaW50MTYoKSxzPXQuZ2V0SW50MzIoKT4+PjA7bGV0IGg9ITE7aWYoIWN8fGMucGxhdGZvcm1JZCE9PXJ8fGMuZW5jb2RpbmdJZCE9PWkpe2lmKDAhPT1yfHwwIT09aSYmMSE9PWkmJjMhPT1pKWlmKDE9PT1yJiYwPT09aSloPSEwO2Vsc2UgaWYoMyE9PXJ8fDEhPT1pfHwhbiYmYyl7aWYoYSYmMz09PXImJjA9PT1pKXtoPSEwO2xldCBhPSEwO2lmKGU8by0xKXtjb25zdCBlPXQucGVla0J5dGVzKDIpO2ludDE2KGVbMF0sZVsxXSk8ciYmKGE9ITEpfWEmJihsPSEwKX19ZWxzZXtoPSEwO2F8fChsPSEwKX1lbHNlIGg9ITA7aCYmKGM9e3BsYXRmb3JtSWQ6cixlbmNvZGluZ0lkOmksb2Zmc2V0OnN9KTtpZihsKWJyZWFrfX1jJiYodC5wb3M9cytjLm9mZnNldCk7aWYoIWN8fC0xPT09dC5wZWVrQnl0ZSgpKXsoMCxyLndhcm4pKCJDb3VsZCBub3QgZmluZCBhIHByZWZlcnJlZCBjbWFwIHRhYmxlLiIpO3JldHVybntwbGF0Zm9ybUlkOi0xLGVuY29kaW5nSWQ6LTEsbWFwcGluZ3M6W10saGFzU2hvcnRDbWFwOiExfX1jb25zdCBoPXQuZ2V0VWludDE2KCk7bGV0IHU9ITE7Y29uc3QgZD1bXTtsZXQgZixnO2lmKDA9PT1oKXt0LnNraXAoNCk7Zm9yKGY9MDtmPDI1NjtmKyspe2NvbnN0IGU9dC5nZXRCeXRlKCk7ZSYmZC5wdXNoKHtjaGFyQ29kZTpmLGdseXBoSWQ6ZX0pfXU9ITB9ZWxzZSBpZigyPT09aCl7dC5za2lwKDQpO2NvbnN0IGU9W107bGV0IGE9MDtmb3IobGV0IHI9MDtyPDI1NjtyKyspe2NvbnN0IHI9dC5nZXRVaW50MTYoKT4+MztlLnB1c2gocik7YT1NYXRoLm1heChyLGEpfWNvbnN0IHI9W107Zm9yKGxldCBlPTA7ZTw9YTtlKyspci5wdXNoKHtmaXJzdENvZGU6dC5nZXRVaW50MTYoKSxlbnRyeUNvdW50OnQuZ2V0VWludDE2KCksaWREZWx0YTpzaWduZWRJbnQxNih0LmdldEJ5dGUoKSx0LmdldEJ5dGUoKSksaWRSYW5nZVBvczp0LnBvcyt0LmdldFVpbnQxNigpfSk7Zm9yKGxldCBhPTA7YTwyNTY7YSsrKWlmKDA9PT1lW2FdKXt0LnBvcz1yWzBdLmlkUmFuZ2VQb3MrMiphO2c9dC5nZXRVaW50MTYoKTtkLnB1c2goe2NoYXJDb2RlOmEsZ2x5cGhJZDpnfSl9ZWxzZXtjb25zdCBuPXJbZVthXV07Zm9yKGY9MDtmPG4uZW50cnlDb3VudDtmKyspe2NvbnN0IGU9KGE8PDgpK2Yrbi5maXJzdENvZGU7dC5wb3M9bi5pZFJhbmdlUG9zKzIqZjtnPXQuZ2V0VWludDE2KCk7MCE9PWcmJihnPShnK24uaWREZWx0YSklNjU1MzYpO2QucHVzaCh7Y2hhckNvZGU6ZSxnbHlwaElkOmd9KX19fWVsc2UgaWYoND09PWgpe3Quc2tpcCg0KTtjb25zdCBlPXQuZ2V0VWludDE2KCk+PjE7dC5za2lwKDYpO2NvbnN0IGE9W107bGV0IHI7Zm9yKHI9MDtyPGU7cisrKWEucHVzaCh7ZW5kOnQuZ2V0VWludDE2KCl9KTt0LnNraXAoMik7Zm9yKHI9MDtyPGU7cisrKWFbcl0uc3RhcnQ9dC5nZXRVaW50MTYoKTtmb3Iocj0wO3I8ZTtyKyspYVtyXS5kZWx0YT10LmdldFVpbnQxNigpO2xldCBuLG89MDtmb3Iocj0wO3I8ZTtyKyspe2k9YVtyXTtjb25zdCBzPXQuZ2V0VWludDE2KCk7aWYocyl7bj0ocz4+MSktKGUtcik7aS5vZmZzZXRJbmRleD1uO289TWF0aC5tYXgobyxuK2kuZW5kLWkuc3RhcnQrMSl9ZWxzZSBpLm9mZnNldEluZGV4PS0xfWNvbnN0IGM9W107Zm9yKGY9MDtmPG87ZisrKWMucHVzaCh0LmdldFVpbnQxNigpKTtmb3Iocj0wO3I8ZTtyKyspe2k9YVtyXTtzPWkuc3RhcnQ7Y29uc3QgZT1pLmVuZCx0PWkuZGVsdGE7bj1pLm9mZnNldEluZGV4O2ZvcihmPXM7Zjw9ZTtmKyspaWYoNjU1MzUhPT1mKXtnPW48MD9mOmNbbitmLXNdO2c9Zyt0JjY1NTM1O2QucHVzaCh7Y2hhckNvZGU6ZixnbHlwaElkOmd9KX19fWVsc2UgaWYoNj09PWgpe3Quc2tpcCg0KTtjb25zdCBlPXQuZ2V0VWludDE2KCksYT10LmdldFVpbnQxNigpO2ZvcihmPTA7ZjxhO2YrKyl7Zz10LmdldFVpbnQxNigpO2NvbnN0IGE9ZStmO2QucHVzaCh7Y2hhckNvZGU6YSxnbHlwaElkOmd9KX19ZWxzZXtpZigxMiE9PWgpeygwLHIud2FybikoImNtYXAgdGFibGUgaGFzIHVuc3VwcG9ydGVkIGZvcm1hdDogIitoKTtyZXR1cm57cGxhdGZvcm1JZDotMSxlbmNvZGluZ0lkOi0xLG1hcHBpbmdzOltdLGhhc1Nob3J0Q21hcDohMX19e3Quc2tpcCgxMCk7Y29uc3QgZT10LmdldEludDMyKCk+Pj4wO2ZvcihmPTA7ZjxlO2YrKyl7Y29uc3QgZT10LmdldEludDMyKCk+Pj4wLGE9dC5nZXRJbnQzMigpPj4+MDtsZXQgcj10LmdldEludDMyKCk+Pj4wO2ZvcihsZXQgdD1lO3Q8PWE7dCsrKWQucHVzaCh7Y2hhckNvZGU6dCxnbHlwaElkOnIrK30pfX19ZC5zb3J0KChmdW5jdGlvbihlLHQpe3JldHVybiBlLmNoYXJDb2RlLXQuY2hhckNvZGV9KSk7Zm9yKGxldCBlPTE7ZTxkLmxlbmd0aDtlKyspaWYoZFtlLTFdLmNoYXJDb2RlPT09ZFtlXS5jaGFyQ29kZSl7ZC5zcGxpY2UoZSwxKTtlLS19cmV0dXJue3BsYXRmb3JtSWQ6Yy5wbGF0Zm9ybUlkLGVuY29kaW5nSWQ6Yy5lbmNvZGluZ0lkLG1hcHBpbmdzOmQsaGFzU2hvcnRDbWFwOnV9fShmLmNtYXAsdCx0aGlzLmlzU3ltYm9saWNGb250LGEuaGFzRW5jb2RpbmcpLG49ZS5wbGF0Zm9ybUlkLHM9ZS5lbmNvZGluZ0lkLGw9ZS5tYXBwaW5ncyx1PWwubGVuZ3RoO2xldCBkPVtdLGc9ITE7IWEuaGFzRW5jb2Rpbmd8fCJNYWNSb21hbkVuY29kaW5nIiE9PWEuYmFzZUVuY29kaW5nTmFtZSYmIldpbkFuc2lFbmNvZGluZyIhPT1hLmJhc2VFbmNvZGluZ05hbWV8fChkPSgwLGMuZ2V0RW5jb2RpbmcpKGEuYmFzZUVuY29kaW5nTmFtZSkpO2lmKGEuaGFzRW5jb2RpbmcmJiF0aGlzLmlzU3ltYm9saWNGb250JiYoMz09PW4mJjE9PT1zfHwxPT09biYmMD09PXMpKXtjb25zdCBlPSgwLG8uZ2V0R2x5cGhzVW5pY29kZSkoKTtmb3IobGV0IHQ9MDt0PDI1Njt0Kyspe2xldCByO3I9dm9pZCAwIT09dGhpcy5kaWZmZXJlbmNlc1t0XT90aGlzLmRpZmZlcmVuY2VzW3RdOmQubGVuZ3RoJiYiIiE9PWRbdF0/ZFt0XTpjLlN0YW5kYXJkRW5jb2RpbmdbdF07aWYoIXIpY29udGludWU7Y29uc3Qgbz0oMCxpLnJlY292ZXJHbHlwaE5hbWUpKHIsZSk7bGV0IGY7Mz09PW4mJjE9PT1zP2Y9ZVtvXToxPT09biYmMD09PXMmJihmPWMuTWFjUm9tYW5FbmNvZGluZy5pbmRleE9mKG8pKTtpZih2b2lkIDA9PT1mKXtpZighYS5nbHlwaE5hbWVzJiZhLmhhc0luY2x1ZGVkVG9Vbmljb2RlTWFwJiYhKHRoaXMudG9Vbmljb2RlIGluc3RhbmNlb2YgaC5JZGVudGl0eVRvVW5pY29kZU1hcCkpe2NvbnN0IGU9dGhpcy50b1VuaWNvZGUuZ2V0KHQpO2UmJihmPWUuY29kZVBvaW50QXQoMCkpfWlmKHZvaWQgMD09PWYpY29udGludWV9Zm9yKGxldCBlPTA7ZTx1OysrZSlpZihsW2VdLmNoYXJDb2RlPT09Zil7RFt0XT1sW2VdLmdseXBoSWQ7YnJlYWt9fX1lbHNlIGlmKDA9PT1uKXtmb3IobGV0IGU9MDtlPHU7KytlKURbbFtlXS5jaGFyQ29kZV09bFtlXS5nbHlwaElkO2c9ITB9ZWxzZSBmb3IobGV0IGU9MDtlPHU7KytlKXtsZXQgdD1sW2VdLmNoYXJDb2RlOzM9PT1uJiZ0Pj02MTQ0MCYmdDw9NjE2OTUmJih0Jj0yNTUpO0RbdF09bFtlXS5nbHlwaElkfWlmKGEuZ2x5cGhOYW1lcyYmKGQubGVuZ3RofHx0aGlzLmRpZmZlcmVuY2VzLmxlbmd0aCkpZm9yKGxldCBlPTA7ZTwyNTY7KytlKXtpZighZyYmdm9pZCAwIT09RFtlXSljb250aW51ZTtjb25zdCB0PXRoaXMuZGlmZmVyZW5jZXNbZV18fGRbZV07aWYoIXQpY29udGludWU7Y29uc3Qgcj1hLmdseXBoTmFtZXMuaW5kZXhPZih0KTtyPjAmJmhhc0dseXBoKHIpJiYoRFtlXT1yKX19MD09PUQubGVuZ3RoJiYoRFswXT0wKTtsZXQgTj1DLTE7dnx8KE49MCk7aWYoIWEuY3NzRm9udEluZm8pe2NvbnN0IGU9YWRqdXN0TWFwcGluZyhELGhhc0dseXBoLE4sdGhpcy50b1VuaWNvZGUpO3RoaXMudG9Gb250Q2hhcj1lLnRvRm9udENoYXI7Zi5jbWFwPXt0YWc6ImNtYXAiLGRhdGE6Y3JlYXRlQ21hcFRhYmxlKGUuY2hhckNvZGVUb0dseXBoSWQsZS50b1VuaWNvZGVFeHRyYU1hcCxDKX07ZlsiT1MvMiJdJiZmdW5jdGlvbiB2YWxpZGF0ZU9TMlRhYmxlKGUsdCl7dC5wb3M9KHQuc3RhcnR8fDApK2Uub2Zmc2V0O2NvbnN0IGE9dC5nZXRVaW50MTYoKTt0LnNraXAoNjApO2NvbnN0IHI9dC5nZXRVaW50MTYoKTtpZihhPDQmJjc2OCZyKXJldHVybiExO2lmKHQuZ2V0VWludDE2KCk+dC5nZXRVaW50MTYoKSlyZXR1cm4hMTt0LnNraXAoNik7aWYoMD09PXQuZ2V0VWludDE2KCkpcmV0dXJuITE7ZS5kYXRhWzhdPWUuZGF0YVs5XT0wO3JldHVybiEwfShmWyJPUy8yIl0sdCl8fChmWyJPUy8yIl09e3RhZzoiT1MvMiIsZGF0YTpjcmVhdGVPUzJUYWJsZShhLGUuY2hhckNvZGVUb0dseXBoSWQsRSl9KX1pZighUyl0cnl7dz1uZXcgeS5TdHJlYW0oZlsiQ0ZGICJdLmRhdGEpO2I9bmV3IG4uQ0ZGUGFyc2VyKHcsYSxpLlNFQUNfQU5BTFlTSVNfRU5BQkxFRCkucGFyc2UoKTtiLmR1cGxpY2F0ZUZpcnN0R2x5cGgoKTtjb25zdCBlPW5ldyBuLkNGRkNvbXBpbGVyKGIpO2ZbIkNGRiAiXS5kYXRhPWUuY29tcGlsZSgpfWNhdGNoKGUpeygwLHIud2FybikoIkZhaWxlZCB0byBjb21waWxlIGZvbnQgIithLmxvYWRlZE5hbWUpfWlmKGYubmFtZSl7Y29uc3QgdD1yZWFkTmFtZVRhYmxlKGYubmFtZSk7Zi5uYW1lLmRhdGE9Y3JlYXRlTmFtZVRhYmxlKGUsdCk7dGhpcy5wc05hbWU9dFswXVs2XXx8bnVsbH1lbHNlIGYubmFtZT17dGFnOiJuYW1lIixkYXRhOmNyZWF0ZU5hbWVUYWJsZSh0aGlzLm5hbWUpfTtjb25zdCBSPW5ldyBtLk9wZW5UeXBlRmlsZUJ1aWxkZXIoZC52ZXJzaW9uKTtmb3IoY29uc3QgZSBpbiBmKVIuYWRkVGFibGUoZSxmW2VdLmRhdGEpO3JldHVybiBSLnRvQXJyYXkoKX1jb252ZXJ0KGUsdCxhKXthLmZpeGVkUGl0Y2g9ITE7YS5idWlsdEluRW5jb2RpbmcmJmZ1bmN0aW9uIGFkanVzdFRvVW5pY29kZShlLHQpe2lmKGUuaXNJbnRlcm5hbEZvbnQpcmV0dXJuO2lmKHQ9PT1lLmRlZmF1bHRFbmNvZGluZylyZXR1cm47aWYoZS50b1VuaWNvZGUgaW5zdGFuY2VvZiBoLklkZW50aXR5VG9Vbmljb2RlTWFwKXJldHVybjtjb25zdCBhPVtdLHI9KDAsby5nZXRHbHlwaHNVbmljb2RlKSgpO2Zvcihjb25zdCBuIGluIHQpe2lmKGUuaGFzSW5jbHVkZWRUb1VuaWNvZGVNYXApe2lmKGUudG9Vbmljb2RlLmhhcyhuKSljb250aW51ZX1lbHNlIGlmKGUuaGFzRW5jb2RpbmcmJigwPT09ZS5kaWZmZXJlbmNlcy5sZW5ndGh8fHZvaWQgMCE9PWUuZGlmZmVyZW5jZXNbbl0pKWNvbnRpbnVlO2NvbnN0IGk9dFtuXSxvPSgwLHMuZ2V0VW5pY29kZUZvckdseXBoKShpLHIpOy0xIT09byYmKGFbbl09U3RyaW5nLmZyb21DaGFyQ29kZShvKSl9YS5sZW5ndGg+MCYmZS50b1VuaWNvZGUuYW1lbmQoYSl9KGEsYS5idWlsdEluRW5jb2RpbmcpO2xldCBuPTE7dCBpbnN0YW5jZW9mIHUuQ0ZGRm9udCYmKG49dC5udW1HbHlwaHMtMSk7Y29uc3QgbD10LmdldEdseXBoTWFwcGluZyhhKTtsZXQgZD1udWxsLGY9bCxnPW51bGw7aWYoIWEuY3NzRm9udEluZm8pe2Q9YWRqdXN0TWFwcGluZyhsLHQuaGFzR2x5cGhJZC5iaW5kKHQpLG4sdGhpcy50b1VuaWNvZGUpO3RoaXMudG9Gb250Q2hhcj1kLnRvRm9udENoYXI7Zj1kLmNoYXJDb2RlVG9HbHlwaElkO2c9ZC50b1VuaWNvZGVFeHRyYU1hcH1jb25zdCBwPXQubnVtR2x5cGhzO2Z1bmN0aW9uIGdldENoYXJDb2RlcyhlLHQpe2xldCBhPW51bGw7Zm9yKGNvbnN0IHIgaW4gZSlpZih0PT09ZVtyXSl7YXx8KGE9W10pO2EucHVzaCgwfHIpfXJldHVybiBhfWZ1bmN0aW9uIGNyZWF0ZUNoYXJDb2RlKGUsdCl7Zm9yKGNvbnN0IGEgaW4gZSlpZih0PT09ZVthXSlyZXR1cm4gMHxhO2QuY2hhckNvZGVUb0dseXBoSWRbZC5uZXh0QXZhaWxhYmxlRm9udENoYXJDb2RlXT10O3JldHVybiBkLm5leHRBdmFpbGFibGVGb250Q2hhckNvZGUrK31jb25zdCBiPXQuc2VhY3M7aWYoZCYmaS5TRUFDX0FOQUxZU0lTX0VOQUJMRUQmJmImJmIubGVuZ3RoKXtjb25zdCBlPWEuZm9udE1hdHJpeHx8ci5GT05UX0lERU5USVRZX01BVFJJWCxuPXQuZ2V0Q2hhcnNldCgpLGk9T2JqZWN0LmNyZWF0ZShudWxsKTtmb3IobGV0IHQgaW4gYil7dHw9MDtjb25zdCBhPWJbdF0scj1jLlN0YW5kYXJkRW5jb2RpbmdbYVsyXV0scz1jLlN0YW5kYXJkRW5jb2RpbmdbYVszXV0sbz1uLmluZGV4T2YociksaD1uLmluZGV4T2Yocyk7aWYobzwwfHxoPDApY29udGludWU7Y29uc3QgdT17eDphWzBdKmVbMF0rYVsxXSplWzJdK2VbNF0seTphWzBdKmVbMV0rYVsxXSplWzNdK2VbNV19LGY9Z2V0Q2hhckNvZGVzKGwsdCk7aWYoZilmb3IobGV0IGU9MCx0PWYubGVuZ3RoO2U8dDtlKyspe2NvbnN0IHQ9ZltlXSxhPWQuY2hhckNvZGVUb0dseXBoSWQscj1jcmVhdGVDaGFyQ29kZShhLG8pLG49Y3JlYXRlQ2hhckNvZGUoYSxoKTtpW3RdPXtiYXNlRm9udENoYXJDb2RlOnIsYWNjZW50Rm9udENoYXJDb2RlOm4sYWNjZW50T2Zmc2V0OnV9fX1hLnNlYWNNYXA9aX1jb25zdCB5PTEvKGEuZm9udE1hdHJpeHx8ci5GT05UX0lERU5USVRZX01BVFJJWClbMF0sdz1uZXcgbS5PcGVuVHlwZUZpbGVCdWlsZGVyKCJPVFRPIik7dy5hZGRUYWJsZSgiQ0ZGICIsdC5kYXRhKTt3LmFkZFRhYmxlKCJPUy8yIixjcmVhdGVPUzJUYWJsZShhLGYpKTt3LmFkZFRhYmxlKCJjbWFwIixjcmVhdGVDbWFwVGFibGUoZixnLHApKTt3LmFkZFRhYmxlKCJoZWFkIiwiXDABXDBcMFwwXDAQXDBcMFwwXDBcMF8PPMO1XDBcMCIrc2FmZVN0cmluZzE2KHkpKyJcMFwwXDBcMMKeXHZ+J1wwXDBcMFwwwp5cdn4nXDBcMCIrc2FmZVN0cmluZzE2KGEuZGVzY2VudCkrIg/DvyIrc2FmZVN0cmluZzE2KGEuYXNjZW50KStzdHJpbmcxNihhLml0YWxpY0FuZ2xlPzI6MCkrIlwwEVwwXDBcMFwwXDBcMCIpO3cuYWRkVGFibGUoImhoZWEiLCJcMAFcMFwwIitzYWZlU3RyaW5nMTYoYS5hc2NlbnQpK3NhZmVTdHJpbmcxNihhLmRlc2NlbnQpKyJcMFwww7/Dv1wwXDBcMFwwXDBcMCIrc2FmZVN0cmluZzE2KGEuY2FwSGVpZ2h0KStzYWZlU3RyaW5nMTYoTWF0aC50YW4oYS5pdGFsaWNBbmdsZSkqYS54SGVpZ2h0KSsiXDBcMFwwXDBcMFwwXDBcMFwwXDBcMFwwIitzdHJpbmcxNihwKSk7dy5hZGRUYWJsZSgiaG10eCIsZnVuY3Rpb24gZm9udEZpZWxkc0htdHgoKXtjb25zdCBlPXQuY2hhcnN0cmluZ3MsYT10LmNmZj90LmNmZi53aWR0aHM6bnVsbDtsZXQgcj0iXDBcMFwwXDAiO2ZvcihsZXQgdD0xLG49cDt0PG47dCsrKXtsZXQgbj0wO2lmKGUpe2NvbnN0IGE9ZVt0LTFdO249IndpZHRoImluIGE/YS53aWR0aDowfWVsc2UgYSYmKG49TWF0aC5jZWlsKGFbdF18fDApKTtyKz1zdHJpbmcxNihuKStzdHJpbmcxNigwKX1yZXR1cm4gcn0oKSk7dy5hZGRUYWJsZSgibWF4cCIsIlwwXDBQXDAiK3N0cmluZzE2KHApKTt3LmFkZFRhYmxlKCJuYW1lIixjcmVhdGVOYW1lVGFibGUoZSkpO3cuYWRkVGFibGUoInBvc3QiLGNyZWF0ZVBvc3RUYWJsZShhKSk7cmV0dXJuIHcudG9BcnJheSgpfWdldCBzcGFjZVdpZHRoKCl7Y29uc3QgZT1bInNwYWNlIiwibWludXMiLCJvbmUiLCJpIiwiSSJdO2xldCB0O2ZvcihsZXQgYT0wLHI9ZS5sZW5ndGg7YTxyO2ErKyl7Y29uc3Qgcj1lW2FdO2lmKHIgaW4gdGhpcy53aWR0aHMpe3Q9dGhpcy53aWR0aHNbcl07YnJlYWt9Y29uc3Qgbj0oMCxvLmdldEdseXBoc1VuaWNvZGUpKClbcl07bGV0IGk9MDtpZih0aGlzLmNvbXBvc2l0ZSYmdGhpcy5jTWFwLmNvbnRhaW5zKG4pKXtpPXRoaXMuY01hcC5sb29rdXAobik7InN0cmluZyI9PXR5cGVvZiBpJiYoaT1jb252ZXJ0Q2lkU3RyaW5nKG4saSkpfSFpJiZ0aGlzLnRvVW5pY29kZSYmKGk9dGhpcy50b1VuaWNvZGUuY2hhckNvZGVPZihuKSk7aTw9MCYmKGk9bik7dD10aGlzLndpZHRoc1tpXTtpZih0KWJyZWFrfXQ9dHx8dGhpcy5kZWZhdWx0V2lkdGg7cmV0dXJuKDAsci5zaGFkb3cpKHRoaXMsInNwYWNlV2lkdGgiLHQpfV9jaGFyVG9HbHlwaChlLHQ9ITEpe2xldCBhLG4saSxvPWU7aWYodGhpcy5jTWFwJiZ0aGlzLmNNYXAuY29udGFpbnMoZSkpe289dGhpcy5jTWFwLmxvb2t1cChlKTsic3RyaW5nIj09dHlwZW9mIG8mJihvPWNvbnZlcnRDaWRTdHJpbmcoZSxvKSl9bj10aGlzLndpZHRoc1tvXTsibnVtYmVyIiE9dHlwZW9mIG4mJihuPXRoaXMuZGVmYXVsdFdpZHRoKTtjb25zdCBjPXRoaXMudm1ldHJpY3MmJnRoaXMudm1ldHJpY3Nbb107bGV0IGw9dGhpcy50b1VuaWNvZGUuZ2V0KGUpfHxlOyJudW1iZXIiPT10eXBlb2YgbCYmKGw9U3RyaW5nLmZyb21DaGFyQ29kZShsKSk7bGV0IGg9dm9pZCAwIT09dGhpcy50b0ZvbnRDaGFyW2VdO2E9dGhpcy50b0ZvbnRDaGFyW2VdfHxlO2lmKHRoaXMubWlzc2luZ0ZpbGUpe2NvbnN0IHQ9dGhpcy5kaWZmZXJlbmNlc1tlXXx8dGhpcy5kZWZhdWx0RW5jb2RpbmdbZV07Ii5ub3RkZWYiIT09dCYmIiIhPT10fHwiVHlwZTEiIT09dGhpcy50eXBlfHwoYT0zMik7YT0oMCxzLm1hcFNwZWNpYWxVbmljb2RlVmFsdWVzKShhKX10aGlzLmlzVHlwZTNGb250JiYoaT1hKTtsZXQgdT1udWxsO2lmKHRoaXMuc2VhY01hcCYmdGhpcy5zZWFjTWFwW2VdKXtoPSEwO2NvbnN0IHQ9dGhpcy5zZWFjTWFwW2VdO2E9dC5iYXNlRm9udENoYXJDb2RlO3U9e2ZvbnRDaGFyOlN0cmluZy5mcm9tQ29kZVBvaW50KHQuYWNjZW50Rm9udENoYXJDb2RlKSxvZmZzZXQ6dC5hY2NlbnRPZmZzZXR9fWxldCBkPSIiOyJudW1iZXIiPT10eXBlb2YgYSYmKGE8PTExMTQxMTE/ZD1TdHJpbmcuZnJvbUNvZGVQb2ludChhKTooMCxyLndhcm4pKGBjaGFyVG9HbHlwaCAtIGludmFsaWQgZm9udENoYXJDb2RlOiAke2F9YCkpO2xldCBmPXRoaXMuX2dseXBoQ2FjaGVbZV07aWYoIWZ8fCFmLm1hdGNoZXNGb3JDYWNoZShlLGQsbCx1LG4sYyxpLHQsaCkpe2Y9bmV3IEdseXBoKGUsZCxsLHUsbixjLGksdCxoKTt0aGlzLl9nbHlwaENhY2hlW2VdPWZ9cmV0dXJuIGZ9Y2hhcnNUb0dseXBocyhlKXtsZXQgdD10aGlzLl9jaGFyc0NhY2hlW2VdO2lmKHQpcmV0dXJuIHQ7dD1bXTtpZih0aGlzLmNNYXApe2NvbnN0IGE9T2JqZWN0LmNyZWF0ZShudWxsKSxyPWUubGVuZ3RoO2xldCBuPTA7Zm9yKDtuPHI7KXt0aGlzLmNNYXAucmVhZENoYXJDb2RlKGUsbixhKTtjb25zdHtjaGFyY29kZTpyLGxlbmd0aDppfT1hO24rPWk7Y29uc3Qgcz10aGlzLl9jaGFyVG9HbHlwaChyLDE9PT1pJiYzMj09PWUuY2hhckNvZGVBdChuLTEpKTt0LnB1c2gocyl9fWVsc2UgZm9yKGxldCBhPTAscj1lLmxlbmd0aDthPHI7KythKXtjb25zdCByPWUuY2hhckNvZGVBdChhKSxuPXRoaXMuX2NoYXJUb0dseXBoKHIsMzI9PT1yKTt0LnB1c2gobil9cmV0dXJuIHRoaXMuX2NoYXJzQ2FjaGVbZV09dH1nZXRDaGFyUG9zaXRpb25zKGUpe2NvbnN0IHQ9W107aWYodGhpcy5jTWFwKXtjb25zdCBhPU9iamVjdC5jcmVhdGUobnVsbCk7bGV0IHI9MDtmb3IoO3I8ZS5sZW5ndGg7KXt0aGlzLmNNYXAucmVhZENoYXJDb2RlKGUscixhKTtjb25zdCBuPWEubGVuZ3RoO3QucHVzaChbcixyK25dKTtyKz1ufX1lbHNlIGZvcihsZXQgYT0wLHI9ZS5sZW5ndGg7YTxyOysrYSl0LnB1c2goW2EsYSsxXSk7cmV0dXJuIHR9Z2V0IGdseXBoQ2FjaGVWYWx1ZXMoKXtyZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLl9nbHlwaENhY2hlKX1lbmNvZGVTdHJpbmcoZSl7Y29uc3QgdD1bXSxhPVtdLGhhc0N1cnJlbnRCdWZFcnJvcnM9KCk9PnQubGVuZ3RoJTI9PTEscj10aGlzLnRvVW5pY29kZSBpbnN0YW5jZW9mIGguSWRlbnRpdHlUb1VuaWNvZGVNYXA/ZT0+dGhpcy50b1VuaWNvZGUuY2hhckNvZGVPZihlKTplPT50aGlzLnRvVW5pY29kZS5jaGFyQ29kZU9mKFN0cmluZy5mcm9tQ29kZVBvaW50KGUpKTtmb3IobGV0IG49MCxpPWUubGVuZ3RoO248aTtuKyspe2NvbnN0IGk9ZS5jb2RlUG9pbnRBdChuKTtpPjU1Mjk1JiYoaTw1NzM0NHx8aT42NTUzMykmJm4rKztpZih0aGlzLnRvVW5pY29kZSl7Y29uc3QgZT1yKGkpO2lmKC0xIT09ZSl7aWYoaGFzQ3VycmVudEJ1ZkVycm9ycygpKXt0LnB1c2goYS5qb2luKCIiKSk7YS5sZW5ndGg9MH1mb3IobGV0IHQ9KHRoaXMuY01hcD90aGlzLmNNYXAuZ2V0Q2hhckNvZGVMZW5ndGgoZSk6MSktMTt0Pj0wO3QtLSlhLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShlPj44KnQmMjU1KSk7Y29udGludWV9fWlmKCFoYXNDdXJyZW50QnVmRXJyb3JzKCkpe3QucHVzaChhLmpvaW4oIiIpKTthLmxlbmd0aD0wfWEucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludChpKSl9dC5wdXNoKGEuam9pbigiIikpO3JldHVybiB0fX07dC5FcnJvckZvbnQ9Y2xhc3MgRXJyb3JGb250e2NvbnN0cnVjdG9yKGUpe3RoaXMuZXJyb3I9ZTt0aGlzLmxvYWRlZE5hbWU9ImdfZm9udF9lcnJvciI7dGhpcy5taXNzaW5nRmlsZT0hMH1jaGFyc1RvR2x5cGhzKCl7cmV0dXJuW119ZW5jb2RlU3RyaW5nKGUpe3JldHVybltlXX1leHBvcnREYXRhKGU9ITEpe3JldHVybntlcnJvcjp0aGlzLmVycm9yfX19fSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuQ0ZGVG9wRGljdD10LkNGRlN0cmluZ3M9dC5DRkZTdGFuZGFyZFN0cmluZ3M9dC5DRkZQcml2YXRlRGljdD10LkNGRlBhcnNlcj10LkNGRkluZGV4PXQuQ0ZGSGVhZGVyPXQuQ0ZGRkRTZWxlY3Q9dC5DRkZDb21waWxlcj10LkNGRkNoYXJzZXQ9dC5DRkY9dm9pZCAwO3ZhciByPWEoMiksbj1hKDM2KSxpPWEoMzcpO2NvbnN0IHM9WyIubm90ZGVmIiwic3BhY2UiLCJleGNsYW0iLCJxdW90ZWRibCIsIm51bWJlcnNpZ24iLCJkb2xsYXIiLCJwZXJjZW50IiwiYW1wZXJzYW5kIiwicXVvdGVyaWdodCIsInBhcmVubGVmdCIsInBhcmVucmlnaHQiLCJhc3RlcmlzayIsInBsdXMiLCJjb21tYSIsImh5cGhlbiIsInBlcmlvZCIsInNsYXNoIiwiemVybyIsIm9uZSIsInR3byIsInRocmVlIiwiZm91ciIsImZpdmUiLCJzaXgiLCJzZXZlbiIsImVpZ2h0IiwibmluZSIsImNvbG9uIiwic2VtaWNvbG9uIiwibGVzcyIsImVxdWFsIiwiZ3JlYXRlciIsInF1ZXN0aW9uIiwiYXQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsIkkiLCJKIiwiSyIsIkwiLCJNIiwiTiIsIk8iLCJQIiwiUSIsIlIiLCJTIiwiVCIsIlUiLCJWIiwiVyIsIlgiLCJZIiwiWiIsImJyYWNrZXRsZWZ0IiwiYmFja3NsYXNoIiwiYnJhY2tldHJpZ2h0IiwiYXNjaWljaXJjdW0iLCJ1bmRlcnNjb3JlIiwicXVvdGVsZWZ0IiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImgiLCJpIiwiaiIsImsiLCJsIiwibSIsIm4iLCJvIiwicCIsInEiLCJyIiwicyIsInQiLCJ1IiwidiIsInciLCJ4IiwieSIsInoiLCJicmFjZWxlZnQiLCJiYXIiLCJicmFjZXJpZ2h0IiwiYXNjaWl0aWxkZSIsImV4Y2xhbWRvd24iLCJjZW50Iiwic3RlcmxpbmciLCJmcmFjdGlvbiIsInllbiIsImZsb3JpbiIsInNlY3Rpb24iLCJjdXJyZW5jeSIsInF1b3Rlc2luZ2xlIiwicXVvdGVkYmxsZWZ0IiwiZ3VpbGxlbW90bGVmdCIsImd1aWxzaW5nbGxlZnQiLCJndWlsc2luZ2xyaWdodCIsImZpIiwiZmwiLCJlbmRhc2giLCJkYWdnZXIiLCJkYWdnZXJkYmwiLCJwZXJpb2RjZW50ZXJlZCIsInBhcmFncmFwaCIsImJ1bGxldCIsInF1b3Rlc2luZ2xiYXNlIiwicXVvdGVkYmxiYXNlIiwicXVvdGVkYmxyaWdodCIsImd1aWxsZW1vdHJpZ2h0IiwiZWxsaXBzaXMiLCJwZXJ0aG91c2FuZCIsInF1ZXN0aW9uZG93biIsImdyYXZlIiwiYWN1dGUiLCJjaXJjdW1mbGV4IiwidGlsZGUiLCJtYWNyb24iLCJicmV2ZSIsImRvdGFjY2VudCIsImRpZXJlc2lzIiwicmluZyIsImNlZGlsbGEiLCJodW5nYXJ1bWxhdXQiLCJvZ29uZWsiLCJjYXJvbiIsImVtZGFzaCIsIkFFIiwib3JkZmVtaW5pbmUiLCJMc2xhc2giLCJPc2xhc2giLCJPRSIsIm9yZG1hc2N1bGluZSIsImFlIiwiZG90bGVzc2kiLCJsc2xhc2giLCJvc2xhc2giLCJvZSIsImdlcm1hbmRibHMiLCJvbmVzdXBlcmlvciIsImxvZ2ljYWxub3QiLCJtdSIsInRyYWRlbWFyayIsIkV0aCIsIm9uZWhhbGYiLCJwbHVzbWludXMiLCJUaG9ybiIsIm9uZXF1YXJ0ZXIiLCJkaXZpZGUiLCJicm9rZW5iYXIiLCJkZWdyZWUiLCJ0aG9ybiIsInRocmVlcXVhcnRlcnMiLCJ0d29zdXBlcmlvciIsInJlZ2lzdGVyZWQiLCJtaW51cyIsImV0aCIsIm11bHRpcGx5IiwidGhyZWVzdXBlcmlvciIsImNvcHlyaWdodCIsIkFhY3V0ZSIsIkFjaXJjdW1mbGV4IiwiQWRpZXJlc2lzIiwiQWdyYXZlIiwiQXJpbmciLCJBdGlsZGUiLCJDY2VkaWxsYSIsIkVhY3V0ZSIsIkVjaXJjdW1mbGV4IiwiRWRpZXJlc2lzIiwiRWdyYXZlIiwiSWFjdXRlIiwiSWNpcmN1bWZsZXgiLCJJZGllcmVzaXMiLCJJZ3JhdmUiLCJOdGlsZGUiLCJPYWN1dGUiLCJPY2lyY3VtZmxleCIsIk9kaWVyZXNpcyIsIk9ncmF2ZSIsIk90aWxkZSIsIlNjYXJvbiIsIlVhY3V0ZSIsIlVjaXJjdW1mbGV4IiwiVWRpZXJlc2lzIiwiVWdyYXZlIiwiWWFjdXRlIiwiWWRpZXJlc2lzIiwiWmNhcm9uIiwiYWFjdXRlIiwiYWNpcmN1bWZsZXgiLCJhZGllcmVzaXMiLCJhZ3JhdmUiLCJhcmluZyIsImF0aWxkZSIsImNjZWRpbGxhIiwiZWFjdXRlIiwiZWNpcmN1bWZsZXgiLCJlZGllcmVzaXMiLCJlZ3JhdmUiLCJpYWN1dGUiLCJpY2lyY3VtZmxleCIsImlkaWVyZXNpcyIsImlncmF2ZSIsIm50aWxkZSIsIm9hY3V0ZSIsIm9jaXJjdW1mbGV4Iiwib2RpZXJlc2lzIiwib2dyYXZlIiwib3RpbGRlIiwic2Nhcm9uIiwidWFjdXRlIiwidWNpcmN1bWZsZXgiLCJ1ZGllcmVzaXMiLCJ1Z3JhdmUiLCJ5YWN1dGUiLCJ5ZGllcmVzaXMiLCJ6Y2Fyb24iLCJleGNsYW1zbWFsbCIsIkh1bmdhcnVtbGF1dHNtYWxsIiwiZG9sbGFyb2xkc3R5bGUiLCJkb2xsYXJzdXBlcmlvciIsImFtcGVyc2FuZHNtYWxsIiwiQWN1dGVzbWFsbCIsInBhcmVubGVmdHN1cGVyaW9yIiwicGFyZW5yaWdodHN1cGVyaW9yIiwidHdvZG90ZW5sZWFkZXIiLCJvbmVkb3RlbmxlYWRlciIsInplcm9vbGRzdHlsZSIsIm9uZW9sZHN0eWxlIiwidHdvb2xkc3R5bGUiLCJ0aHJlZW9sZHN0eWxlIiwiZm91cm9sZHN0eWxlIiwiZml2ZW9sZHN0eWxlIiwic2l4b2xkc3R5bGUiLCJzZXZlbm9sZHN0eWxlIiwiZWlnaHRvbGRzdHlsZSIsIm5pbmVvbGRzdHlsZSIsImNvbW1hc3VwZXJpb3IiLCJ0aHJlZXF1YXJ0ZXJzZW1kYXNoIiwicGVyaW9kc3VwZXJpb3IiLCJxdWVzdGlvbnNtYWxsIiwiYXN1cGVyaW9yIiwiYnN1cGVyaW9yIiwiY2VudHN1cGVyaW9yIiwiZHN1cGVyaW9yIiwiZXN1cGVyaW9yIiwiaXN1cGVyaW9yIiwibHN1cGVyaW9yIiwibXN1cGVyaW9yIiwibnN1cGVyaW9yIiwib3N1cGVyaW9yIiwicnN1cGVyaW9yIiwic3N1cGVyaW9yIiwidHN1cGVyaW9yIiwiZmYiLCJmZmkiLCJmZmwiLCJwYXJlbmxlZnRpbmZlcmlvciIsInBhcmVucmlnaHRpbmZlcmlvciIsIkNpcmN1bWZsZXhzbWFsbCIsImh5cGhlbnN1cGVyaW9yIiwiR3JhdmVzbWFsbCIsIkFzbWFsbCIsIkJzbWFsbCIsIkNzbWFsbCIsIkRzbWFsbCIsIkVzbWFsbCIsIkZzbWFsbCIsIkdzbWFsbCIsIkhzbWFsbCIsIklzbWFsbCIsIkpzbWFsbCIsIktzbWFsbCIsIkxzbWFsbCIsIk1zbWFsbCIsIk5zbWFsbCIsIk9zbWFsbCIsIlBzbWFsbCIsIlFzbWFsbCIsIlJzbWFsbCIsIlNzbWFsbCIsIlRzbWFsbCIsIlVzbWFsbCIsIlZzbWFsbCIsIldzbWFsbCIsIlhzbWFsbCIsIllzbWFsbCIsIlpzbWFsbCIsImNvbG9ubW9uZXRhcnkiLCJvbmVmaXR0ZWQiLCJydXBpYWgiLCJUaWxkZXNtYWxsIiwiZXhjbGFtZG93bnNtYWxsIiwiY2VudG9sZHN0eWxlIiwiTHNsYXNoc21hbGwiLCJTY2Fyb25zbWFsbCIsIlpjYXJvbnNtYWxsIiwiRGllcmVzaXNzbWFsbCIsIkJyZXZlc21hbGwiLCJDYXJvbnNtYWxsIiwiRG90YWNjZW50c21hbGwiLCJNYWNyb25zbWFsbCIsImZpZ3VyZWRhc2giLCJoeXBoZW5pbmZlcmlvciIsIk9nb25la3NtYWxsIiwiUmluZ3NtYWxsIiwiQ2VkaWxsYXNtYWxsIiwicXVlc3Rpb25kb3duc21hbGwiLCJvbmVlaWdodGgiLCJ0aHJlZWVpZ2h0aHMiLCJmaXZlZWlnaHRocyIsInNldmVuZWlnaHRocyIsIm9uZXRoaXJkIiwidHdvdGhpcmRzIiwiemVyb3N1cGVyaW9yIiwiZm91cnN1cGVyaW9yIiwiZml2ZXN1cGVyaW9yIiwic2l4c3VwZXJpb3IiLCJzZXZlbnN1cGVyaW9yIiwiZWlnaHRzdXBlcmlvciIsIm5pbmVzdXBlcmlvciIsInplcm9pbmZlcmlvciIsIm9uZWluZmVyaW9yIiwidHdvaW5mZXJpb3IiLCJ0aHJlZWluZmVyaW9yIiwiZm91cmluZmVyaW9yIiwiZml2ZWluZmVyaW9yIiwic2l4aW5mZXJpb3IiLCJzZXZlbmluZmVyaW9yIiwiZWlnaHRpbmZlcmlvciIsIm5pbmVpbmZlcmlvciIsImNlbnRpbmZlcmlvciIsImRvbGxhcmluZmVyaW9yIiwicGVyaW9kaW5mZXJpb3IiLCJjb21tYWluZmVyaW9yIiwiQWdyYXZlc21hbGwiLCJBYWN1dGVzbWFsbCIsIkFjaXJjdW1mbGV4c21hbGwiLCJBdGlsZGVzbWFsbCIsIkFkaWVyZXNpc3NtYWxsIiwiQXJpbmdzbWFsbCIsIkFFc21hbGwiLCJDY2VkaWxsYXNtYWxsIiwiRWdyYXZlc21hbGwiLCJFYWN1dGVzbWFsbCIsIkVjaXJjdW1mbGV4c21hbGwiLCJFZGllcmVzaXNzbWFsbCIsIklncmF2ZXNtYWxsIiwiSWFjdXRlc21hbGwiLCJJY2lyY3VtZmxleHNtYWxsIiwiSWRpZXJlc2lzc21hbGwiLCJFdGhzbWFsbCIsIk50aWxkZXNtYWxsIiwiT2dyYXZlc21hbGwiLCJPYWN1dGVzbWFsbCIsIk9jaXJjdW1mbGV4c21hbGwiLCJPdGlsZGVzbWFsbCIsIk9kaWVyZXNpc3NtYWxsIiwiT0VzbWFsbCIsIk9zbGFzaHNtYWxsIiwiVWdyYXZlc21hbGwiLCJVYWN1dGVzbWFsbCIsIlVjaXJjdW1mbGV4c21hbGwiLCJVZGllcmVzaXNzbWFsbCIsIllhY3V0ZXNtYWxsIiwiVGhvcm5zbWFsbCIsIllkaWVyZXNpc3NtYWxsIiwiMDAxLjAwMCIsIjAwMS4wMDEiLCIwMDEuMDAyIiwiMDAxLjAwMyIsIkJsYWNrIiwiQm9sZCIsIkJvb2siLCJMaWdodCIsIk1lZGl1bSIsIlJlZ3VsYXIiLCJSb21hbiIsIlNlbWlib2xkIl07dC5DRkZTdGFuZGFyZFN0cmluZ3M9cztjb25zdCBvPTM5MSxjPVtudWxsLHtpZDoiaHN0ZW0iLG1pbjoyLHN0YWNrQ2xlYXJpbmc6ITAsc3RlbTohMH0sbnVsbCx7aWQ6InZzdGVtIixtaW46MixzdGFja0NsZWFyaW5nOiEwLHN0ZW06ITB9LHtpZDoidm1vdmV0byIsbWluOjEsc3RhY2tDbGVhcmluZzohMH0se2lkOiJybGluZXRvIixtaW46MixyZXNldFN0YWNrOiEwfSx7aWQ6ImhsaW5ldG8iLG1pbjoxLHJlc2V0U3RhY2s6ITB9LHtpZDoidmxpbmV0byIsbWluOjEscmVzZXRTdGFjazohMH0se2lkOiJycmN1cnZldG8iLG1pbjo2LHJlc2V0U3RhY2s6ITB9LG51bGwse2lkOiJjYWxsc3ViciIsbWluOjEsdW5kZWZTdGFjazohMH0se2lkOiJyZXR1cm4iLG1pbjowLHVuZGVmU3RhY2s6ITB9LG51bGwsbnVsbCx7aWQ6ImVuZGNoYXIiLG1pbjowLHN0YWNrQ2xlYXJpbmc6ITB9LG51bGwsbnVsbCxudWxsLHtpZDoiaHN0ZW1obSIsbWluOjIsc3RhY2tDbGVhcmluZzohMCxzdGVtOiEwfSx7aWQ6ImhpbnRtYXNrIixtaW46MCxzdGFja0NsZWFyaW5nOiEwfSx7aWQ6ImNudHJtYXNrIixtaW46MCxzdGFja0NsZWFyaW5nOiEwfSx7aWQ6InJtb3ZldG8iLG1pbjoyLHN0YWNrQ2xlYXJpbmc6ITB9LHtpZDoiaG1vdmV0byIsbWluOjEsc3RhY2tDbGVhcmluZzohMH0se2lkOiJ2c3RlbWhtIixtaW46MixzdGFja0NsZWFyaW5nOiEwLHN0ZW06ITB9LHtpZDoicmN1cnZlbGluZSIsbWluOjgscmVzZXRTdGFjazohMH0se2lkOiJybGluZWN1cnZlIixtaW46OCxyZXNldFN0YWNrOiEwfSx7aWQ6InZ2Y3VydmV0byIsbWluOjQscmVzZXRTdGFjazohMH0se2lkOiJoaGN1cnZldG8iLG1pbjo0LHJlc2V0U3RhY2s6ITB9LG51bGwse2lkOiJjYWxsZ3N1YnIiLG1pbjoxLHVuZGVmU3RhY2s6ITB9LHtpZDoidmhjdXJ2ZXRvIixtaW46NCxyZXNldFN0YWNrOiEwfSx7aWQ6Imh2Y3VydmV0byIsbWluOjQscmVzZXRTdGFjazohMH1dLGw9W251bGwsbnVsbCxudWxsLHtpZDoiYW5kIixtaW46MixzdGFja0RlbHRhOi0xfSx7aWQ6Im9yIixtaW46MixzdGFja0RlbHRhOi0xfSx7aWQ6Im5vdCIsbWluOjEsc3RhY2tEZWx0YTowfSxudWxsLG51bGwsbnVsbCx7aWQ6ImFicyIsbWluOjEsc3RhY2tEZWx0YTowfSx7aWQ6ImFkZCIsbWluOjIsc3RhY2tEZWx0YTotMSxzdGFja0ZuKGUsdCl7ZVt0LTJdPWVbdC0yXStlW3QtMV19fSx7aWQ6InN1YiIsbWluOjIsc3RhY2tEZWx0YTotMSxzdGFja0ZuKGUsdCl7ZVt0LTJdPWVbdC0yXS1lW3QtMV19fSx7aWQ6ImRpdiIsbWluOjIsc3RhY2tEZWx0YTotMSxzdGFja0ZuKGUsdCl7ZVt0LTJdPWVbdC0yXS9lW3QtMV19fSxudWxsLHtpZDoibmVnIixtaW46MSxzdGFja0RlbHRhOjAsc3RhY2tGbihlLHQpe2VbdC0xXT0tZVt0LTFdfX0se2lkOiJlcSIsbWluOjIsc3RhY2tEZWx0YTotMX0sbnVsbCxudWxsLHtpZDoiZHJvcCIsbWluOjEsc3RhY2tEZWx0YTotMX0sbnVsbCx7aWQ6InB1dCIsbWluOjIsc3RhY2tEZWx0YTotMn0se2lkOiJnZXQiLG1pbjoxLHN0YWNrRGVsdGE6MH0se2lkOiJpZmVsc2UiLG1pbjo0LHN0YWNrRGVsdGE6LTN9LHtpZDoicmFuZG9tIixtaW46MCxzdGFja0RlbHRhOjF9LHtpZDoibXVsIixtaW46MixzdGFja0RlbHRhOi0xLHN0YWNrRm4oZSx0KXtlW3QtMl09ZVt0LTJdKmVbdC0xXX19LG51bGwse2lkOiJzcXJ0IixtaW46MSxzdGFja0RlbHRhOjB9LHtpZDoiZHVwIixtaW46MSxzdGFja0RlbHRhOjF9LHtpZDoiZXhjaCIsbWluOjIsc3RhY2tEZWx0YTowfSx7aWQ6ImluZGV4IixtaW46MixzdGFja0RlbHRhOjB9LHtpZDoicm9sbCIsbWluOjMsc3RhY2tEZWx0YTotMn0sbnVsbCxudWxsLG51bGwse2lkOiJoZmxleCIsbWluOjcscmVzZXRTdGFjazohMH0se2lkOiJmbGV4IixtaW46MTMscmVzZXRTdGFjazohMH0se2lkOiJoZmxleDEiLG1pbjo5LHJlc2V0U3RhY2s6ITB9LHtpZDoiZmxleDEiLG1pbjoxMSxyZXNldFN0YWNrOiEwfV07dC5DRkZQYXJzZXI9Y2xhc3MgQ0ZGUGFyc2Vye2NvbnN0cnVjdG9yKGUsdCxhKXt0aGlzLmJ5dGVzPWUuZ2V0Qnl0ZXMoKTt0aGlzLnByb3BlcnRpZXM9dDt0aGlzLnNlYWNBbmFseXNpc0VuYWJsZWQ9ISFhfXBhcnNlKCl7Y29uc3QgZT10aGlzLnByb3BlcnRpZXMsdD1uZXcgQ0ZGO3RoaXMuY2ZmPXQ7Y29uc3QgYT10aGlzLnBhcnNlSGVhZGVyKCkscj10aGlzLnBhcnNlSW5kZXgoYS5lbmRQb3MpLG49dGhpcy5wYXJzZUluZGV4KHIuZW5kUG9zKSxpPXRoaXMucGFyc2VJbmRleChuLmVuZFBvcykscz10aGlzLnBhcnNlSW5kZXgoaS5lbmRQb3MpLG89dGhpcy5wYXJzZURpY3Qobi5vYmouZ2V0KDApKSxjPXRoaXMuY3JlYXRlRGljdChDRkZUb3BEaWN0LG8sdC5zdHJpbmdzKTt0LmhlYWRlcj1hLm9iajt0Lm5hbWVzPXRoaXMucGFyc2VOYW1lSW5kZXgoci5vYmopO3Quc3RyaW5ncz10aGlzLnBhcnNlU3RyaW5nSW5kZXgoaS5vYmopO3QudG9wRGljdD1jO3QuZ2xvYmFsU3VickluZGV4PXMub2JqO3RoaXMucGFyc2VQcml2YXRlRGljdCh0LnRvcERpY3QpO3QuaXNDSURGb250PWMuaGFzTmFtZSgiUk9TIik7Y29uc3QgbD1jLmdldEJ5TmFtZSgiQ2hhclN0cmluZ3MiKSxoPXRoaXMucGFyc2VJbmRleChsKS5vYmosdT1jLmdldEJ5TmFtZSgiRm9udE1hdHJpeCIpO3UmJihlLmZvbnRNYXRyaXg9dSk7Y29uc3QgZD1jLmdldEJ5TmFtZSgiRm9udEJCb3giKTtpZihkKXtlLmFzY2VudD1NYXRoLm1heChkWzNdLGRbMV0pO2UuZGVzY2VudD1NYXRoLm1pbihkWzFdLGRbM10pO2UuYXNjZW50U2NhbGVkPSEwfWxldCBmLGc7aWYodC5pc0NJREZvbnQpe2NvbnN0IGU9dGhpcy5wYXJzZUluZGV4KGMuZ2V0QnlOYW1lKCJGREFycmF5IikpLm9iajtmb3IobGV0IGE9MCxyPWUuY291bnQ7YTxyOysrYSl7Y29uc3Qgcj1lLmdldChhKSxuPXRoaXMuY3JlYXRlRGljdChDRkZUb3BEaWN0LHRoaXMucGFyc2VEaWN0KHIpLHQuc3RyaW5ncyk7dGhpcy5wYXJzZVByaXZhdGVEaWN0KG4pO3QuZmRBcnJheS5wdXNoKG4pfWc9bnVsbDtmPXRoaXMucGFyc2VDaGFyc2V0cyhjLmdldEJ5TmFtZSgiY2hhcnNldCIpLGguY291bnQsdC5zdHJpbmdzLCEwKTt0LmZkU2VsZWN0PXRoaXMucGFyc2VGRFNlbGVjdChjLmdldEJ5TmFtZSgiRkRTZWxlY3QiKSxoLmNvdW50KX1lbHNle2Y9dGhpcy5wYXJzZUNoYXJzZXRzKGMuZ2V0QnlOYW1lKCJjaGFyc2V0IiksaC5jb3VudCx0LnN0cmluZ3MsITEpO2c9dGhpcy5wYXJzZUVuY29kaW5nKGMuZ2V0QnlOYW1lKCJFbmNvZGluZyIpLGUsdC5zdHJpbmdzLGYuY2hhcnNldCl9dC5jaGFyc2V0PWY7dC5lbmNvZGluZz1nO2NvbnN0IHA9dGhpcy5wYXJzZUNoYXJTdHJpbmdzKHtjaGFyU3RyaW5nczpoLGxvY2FsU3VickluZGV4OmMucHJpdmF0ZURpY3Quc3VicnNJbmRleCxnbG9iYWxTdWJySW5kZXg6cy5vYmosZmRTZWxlY3Q6dC5mZFNlbGVjdCxmZEFycmF5OnQuZmRBcnJheSxwcml2YXRlRGljdDpjLnByaXZhdGVEaWN0fSk7dC5jaGFyU3RyaW5ncz1wLmNoYXJTdHJpbmdzO3Quc2VhY3M9cC5zZWFjczt0LndpZHRocz1wLndpZHRocztyZXR1cm4gdH1wYXJzZUhlYWRlcigpe2xldCBlPXRoaXMuYnl0ZXM7Y29uc3QgdD1lLmxlbmd0aDtsZXQgYT0wO2Zvcig7YTx0JiYxIT09ZVthXTspKythO2lmKGE+PXQpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoIkludmFsaWQgQ0ZGIGhlYWRlciIpO2lmKDAhPT1hKXsoMCxyLmluZm8pKCJjZmYgZGF0YSBpcyBzaGlmdGVkIik7ZT1lLnN1YmFycmF5KGEpO3RoaXMuYnl0ZXM9ZX1jb25zdCBuPWVbMF0saT1lWzFdLHM9ZVsyXSxvPWVbM107cmV0dXJue29iajpuZXcgQ0ZGSGVhZGVyKG4saSxzLG8pLGVuZFBvczpzfX1wYXJzZURpY3QoZSl7bGV0IHQ9MDtmdW5jdGlvbiBwYXJzZU9wZXJhbmQoKXtsZXQgYT1lW3QrK107aWYoMzA9PT1hKXJldHVybiBmdW5jdGlvbiBwYXJzZUZsb2F0T3BlcmFuZCgpe2xldCBhPSIiO2NvbnN0IHI9MTUsbj1bIjAiLCIxIiwiMiIsIjMiLCI0IiwiNSIsIjYiLCI3IiwiOCIsIjkiLCIuIiwiRSIsIkUtIixudWxsLCItIl0saT1lLmxlbmd0aDtmb3IoO3Q8aTspe2NvbnN0IGk9ZVt0KytdLHM9aT4+NCxvPTE1Jmk7aWYocz09PXIpYnJlYWs7YSs9bltzXTtpZihvPT09cilicmVhazthKz1uW29dfXJldHVybiBwYXJzZUZsb2F0KGEpfSgpO2lmKDI4PT09YSl7YT1lW3QrK107YT0oYTw8MjR8ZVt0KytdPDwxNik+PjE2O3JldHVybiBhfWlmKDI5PT09YSl7YT1lW3QrK107YT1hPDw4fGVbdCsrXTthPWE8PDh8ZVt0KytdO2E9YTw8OHxlW3QrK107cmV0dXJuIGF9aWYoYT49MzImJmE8PTI0NilyZXR1cm4gYS0xMzk7aWYoYT49MjQ3JiZhPD0yNTApcmV0dXJuIDI1NiooYS0yNDcpK2VbdCsrXSsxMDg7aWYoYT49MjUxJiZhPD0yNTQpcmV0dXJuLTI1NiooYS0yNTEpLWVbdCsrXS0xMDg7KDAsci53YXJuKSgnQ0ZGUGFyc2VyX3BhcnNlRGljdDogIicrYSsnIiBpcyBhIHJlc2VydmVkIGNvbW1hbmQuJyk7cmV0dXJuIE5hTn1sZXQgYT1bXTtjb25zdCBuPVtdO3Q9MDtjb25zdCBpPWUubGVuZ3RoO2Zvcig7dDxpOyl7bGV0IHI9ZVt0XTtpZihyPD0yMSl7MTI9PT1yJiYocj1yPDw4fGVbKyt0XSk7bi5wdXNoKFtyLGFdKTthPVtdOysrdH1lbHNlIGEucHVzaChwYXJzZU9wZXJhbmQoKSl9cmV0dXJuIG59cGFyc2VJbmRleChlKXtjb25zdCB0PW5ldyBDRkZJbmRleCxhPXRoaXMuYnl0ZXMscj1hW2UrK108PDh8YVtlKytdLG49W107bGV0IGkscyxvPWU7aWYoMCE9PXIpe2NvbnN0IHQ9YVtlKytdLGM9ZSsocisxKSp0LTE7Zm9yKGk9MCxzPXIrMTtpPHM7KytpKXtsZXQgcj0wO2ZvcihsZXQgbj0wO248dDsrK24pe3I8PD04O3IrPWFbZSsrXX1uLnB1c2goYytyKX1vPW5bcl19Zm9yKGk9MCxzPW4ubGVuZ3RoLTE7aTxzOysraSl7Y29uc3QgZT1uW2ldLHI9bltpKzFdO3QuYWRkKGEuc3ViYXJyYXkoZSxyKSl9cmV0dXJue29iajp0LGVuZFBvczpvfX1wYXJzZU5hbWVJbmRleChlKXtjb25zdCB0PVtdO2ZvcihsZXQgYT0wLG49ZS5jb3VudDthPG47KythKXtjb25zdCBuPWUuZ2V0KGEpO3QucHVzaCgoMCxyLmJ5dGVzVG9TdHJpbmcpKG4pKX1yZXR1cm4gdH1wYXJzZVN0cmluZ0luZGV4KGUpe2NvbnN0IHQ9bmV3IENGRlN0cmluZ3M7Zm9yKGxldCBhPTAsbj1lLmNvdW50O2E8bjsrK2Epe2NvbnN0IG49ZS5nZXQoYSk7dC5hZGQoKDAsci5ieXRlc1RvU3RyaW5nKShuKSl9cmV0dXJuIHR9Y3JlYXRlRGljdChlLHQsYSl7Y29uc3Qgcj1uZXcgZShhKTtmb3IobGV0IGU9MCxhPXQubGVuZ3RoO2U8YTsrK2Upe2NvbnN0IGE9dFtlXSxuPWFbMF0saT1hWzFdO3Iuc2V0QnlLZXkobixpKX1yZXR1cm4gcn1wYXJzZUNoYXJTdHJpbmcoZSx0LGEsbil7aWYoIXR8fGUuY2FsbERlcHRoPjEwKXJldHVybiExO2xldCBpPWUuc3RhY2tTaXplO2NvbnN0IHM9ZS5zdGFjayxvPXQubGVuZ3RoO2ZvcihsZXQgaD0wO2g8bzspe2NvbnN0IG89dFtoKytdO2xldCB1PW51bGw7aWYoMTI9PT1vKXtjb25zdCBlPXRbaCsrXTtpZigwPT09ZSl7dFtoLTJdPTEzOTt0W2gtMV09MjI7aT0wfWVsc2UgdT1sW2VdfWVsc2UgaWYoMjg9PT1vKXtzW2ldPSh0W2hdPDwyNHx0W2grMV08PDE2KT4+MTY7aCs9MjtpKyt9ZWxzZSBpZigxND09PW8pe2lmKGk+PTQpe2ktPTQ7aWYodGhpcy5zZWFjQW5hbHlzaXNFbmFibGVkKXtlLnNlYWM9cy5zbGljZShpLGkrNCk7cmV0dXJuITF9fXU9Y1tvXX1lbHNlIGlmKG8+PTMyJiZvPD0yNDYpe3NbaV09by0xMzk7aSsrfWVsc2UgaWYobz49MjQ3JiZvPD0yNTQpe3NbaV09bzwyNTE/KG8tMjQ3PDw4KSt0W2hdKzEwODotKG8tMjUxPDw4KS10W2hdLTEwODtoKys7aSsrfWVsc2UgaWYoMjU1PT09byl7c1tpXT0odFtoXTw8MjR8dFtoKzFdPDwxNnx0W2grMl08PDh8dFtoKzNdKS82NTUzNjtoKz00O2krK31lbHNlIGlmKDE5PT09b3x8MjA9PT1vKXtlLmhpbnRzKz1pPj4xO2grPWUuaGludHMrNz4+MztpJT0yO3U9Y1tvXX1lbHNle2lmKDEwPT09b3x8Mjk9PT1vKXtsZXQgdDt0PTEwPT09bz9hOm47aWYoIXQpe3U9Y1tvXTsoMCxyLndhcm4pKCJNaXNzaW5nIHN1YnJzSW5kZXggZm9yICIrdS5pZCk7cmV0dXJuITF9bGV0IGw9MzI3Njg7dC5jb3VudDwxMjQwP2w9MTA3OnQuY291bnQ8MzM5MDAmJihsPTExMzEpO2NvbnN0IGg9c1stLWldK2w7aWYoaDwwfHxoPj10LmNvdW50fHxpc05hTihoKSl7dT1jW29dOygwLHIud2FybikoIk91dCBvZiBib3VuZHMgc3VickluZGV4IGZvciAiK3UuaWQpO3JldHVybiExfWUuc3RhY2tTaXplPWk7ZS5jYWxsRGVwdGgrKztpZighdGhpcy5wYXJzZUNoYXJTdHJpbmcoZSx0LmdldChoKSxhLG4pKXJldHVybiExO2UuY2FsbERlcHRoLS07aT1lLnN0YWNrU2l6ZTtjb250aW51ZX1pZigxMT09PW8pe2Uuc3RhY2tTaXplPWk7cmV0dXJuITB9aWYoMD09PW8mJmg9PT10Lmxlbmd0aCl7dFtoLTFdPTE0O3U9Y1sxNF19ZWxzZSB1PWNbb119aWYodSl7aWYodS5zdGVtKXtlLmhpbnRzKz1pPj4xO2lmKDM9PT1vfHwyMz09PW8pZS5oYXNWU3RlbXM9ITA7ZWxzZSBpZihlLmhhc1ZTdGVtcyYmKDE9PT1vfHwxOD09PW8pKXsoMCxyLndhcm4pKCJDRkYgc3RlbSBoaW50cyBhcmUgaW4gd3Jvbmcgb3JkZXIiKTt0W2gtMV09MT09PW8/MzoyM319aWYoIm1pbiJpbiB1JiYhZS51bmRlZlN0YWNrJiZpPHUubWluKXsoMCxyLndhcm4pKCJOb3QgZW5vdWdoIHBhcmFtZXRlcnMgZm9yICIrdS5pZCsiOyBhY3R1YWw6ICIraSsiLCBleHBlY3RlZDogIit1Lm1pbik7aWYoMD09PWkpe3RbaC0xXT0xNDtyZXR1cm4hMH1yZXR1cm4hMX1pZihlLmZpcnN0U3RhY2tDbGVhcmluZyYmdS5zdGFja0NsZWFyaW5nKXtlLmZpcnN0U3RhY2tDbGVhcmluZz0hMTtpLT11Lm1pbjtpPj0yJiZ1LnN0ZW0/aSU9MjppPjEmJigwLHIud2FybikoIkZvdW5kIHRvbyBtYW55IHBhcmFtZXRlcnMgZm9yIHN0YWNrLWNsZWFyaW5nIGNvbW1hbmQiKTtpPjAmJihlLndpZHRoPXNbaS0xXSl9aWYoInN0YWNrRGVsdGEiaW4gdSl7InN0YWNrRm4iaW4gdSYmdS5zdGFja0ZuKHMsaSk7aSs9dS5zdGFja0RlbHRhfWVsc2UgaWYodS5zdGFja0NsZWFyaW5nKWk9MDtlbHNlIGlmKHUucmVzZXRTdGFjayl7aT0wO2UudW5kZWZTdGFjaz0hMX1lbHNlIGlmKHUudW5kZWZTdGFjayl7aT0wO2UudW5kZWZTdGFjaz0hMDtlLmZpcnN0U3RhY2tDbGVhcmluZz0hMX19fWUuc3RhY2tTaXplPWk7cmV0dXJuITB9cGFyc2VDaGFyU3RyaW5ncyh7Y2hhclN0cmluZ3M6ZSxsb2NhbFN1YnJJbmRleDp0LGdsb2JhbFN1YnJJbmRleDphLGZkU2VsZWN0Om4sZmRBcnJheTppLHByaXZhdGVEaWN0OnN9KXtjb25zdCBvPVtdLGM9W10sbD1lLmNvdW50O2ZvcihsZXQgaD0wO2g8bDtoKyspe2NvbnN0IGw9ZS5nZXQoaCksdT17Y2FsbERlcHRoOjAsc3RhY2tTaXplOjAsc3RhY2s6W10sdW5kZWZTdGFjazohMCxoaW50czowLGZpcnN0U3RhY2tDbGVhcmluZzohMCxzZWFjOm51bGwsd2lkdGg6bnVsbCxoYXNWU3RlbXM6ITF9O2xldCBkPSEwLGY9bnVsbCxnPXM7aWYobiYmaS5sZW5ndGgpe2NvbnN0IGU9bi5nZXRGREluZGV4KGgpO2lmKC0xPT09ZSl7KDAsci53YXJuKSgiR2x5cGggaW5kZXggaXMgbm90IGluIGZkIHNlbGVjdC4iKTtkPSExfWlmKGU+PWkubGVuZ3RoKXsoMCxyLndhcm4pKCJJbnZhbGlkIGZkIGluZGV4IGZvciBnbHlwaCBpbmRleC4iKTtkPSExfWlmKGQpe2c9aVtlXS5wcml2YXRlRGljdDtmPWcuc3VicnNJbmRleH19ZWxzZSB0JiYoZj10KTtkJiYoZD10aGlzLnBhcnNlQ2hhclN0cmluZyh1LGwsZixhKSk7aWYobnVsbCE9PXUud2lkdGgpe2NvbnN0IGU9Zy5nZXRCeU5hbWUoIm5vbWluYWxXaWR0aFgiKTtjW2hdPWUrdS53aWR0aH1lbHNle2NvbnN0IGU9Zy5nZXRCeU5hbWUoImRlZmF1bHRXaWR0aFgiKTtjW2hdPWV9bnVsbCE9PXUuc2VhYyYmKG9baF09dS5zZWFjKTtkfHxlLnNldChoLG5ldyBVaW50OEFycmF5KFsxNF0pKX1yZXR1cm57Y2hhclN0cmluZ3M6ZSxzZWFjczpvLHdpZHRoczpjfX1lbXB0eVByaXZhdGVEaWN0aW9uYXJ5KGUpe2NvbnN0IHQ9dGhpcy5jcmVhdGVEaWN0KENGRlByaXZhdGVEaWN0LFtdLGUuc3RyaW5ncyk7ZS5zZXRCeUtleSgxOCxbMCwwXSk7ZS5wcml2YXRlRGljdD10fXBhcnNlUHJpdmF0ZURpY3QoZSl7aWYoIWUuaGFzTmFtZSgiUHJpdmF0ZSIpKXt0aGlzLmVtcHR5UHJpdmF0ZURpY3Rpb25hcnkoZSk7cmV0dXJufWNvbnN0IHQ9ZS5nZXRCeU5hbWUoIlByaXZhdGUiKTtpZighQXJyYXkuaXNBcnJheSh0KXx8MiE9PXQubGVuZ3RoKXtlLnJlbW92ZUJ5TmFtZSgiUHJpdmF0ZSIpO3JldHVybn1jb25zdCBhPXRbMF0scj10WzFdO2lmKDA9PT1hfHxyPj10aGlzLmJ5dGVzLmxlbmd0aCl7dGhpcy5lbXB0eVByaXZhdGVEaWN0aW9uYXJ5KGUpO3JldHVybn1jb25zdCBuPXIrYSxpPXRoaXMuYnl0ZXMuc3ViYXJyYXkocixuKSxzPXRoaXMucGFyc2VEaWN0KGkpLG89dGhpcy5jcmVhdGVEaWN0KENGRlByaXZhdGVEaWN0LHMsZS5zdHJpbmdzKTtlLnByaXZhdGVEaWN0PW87aWYoIW8uZ2V0QnlOYW1lKCJTdWJycyIpKXJldHVybjtjb25zdCBjPW8uZ2V0QnlOYW1lKCJTdWJycyIpLGw9citjO2lmKDA9PT1jfHxsPj10aGlzLmJ5dGVzLmxlbmd0aCl7dGhpcy5lbXB0eVByaXZhdGVEaWN0aW9uYXJ5KGUpO3JldHVybn1jb25zdCBoPXRoaXMucGFyc2VJbmRleChsKTtvLnN1YnJzSW5kZXg9aC5vYmp9cGFyc2VDaGFyc2V0cyhlLHQsYSxpKXtpZigwPT09ZSlyZXR1cm4gbmV3IENGRkNoYXJzZXQoITAsZC5JU09fQURPQkUsbi5JU09BZG9iZUNoYXJzZXQpO2lmKDE9PT1lKXJldHVybiBuZXcgQ0ZGQ2hhcnNldCghMCxkLkVYUEVSVCxuLkV4cGVydENoYXJzZXQpO2lmKDI9PT1lKXJldHVybiBuZXcgQ0ZGQ2hhcnNldCghMCxkLkVYUEVSVF9TVUJTRVQsbi5FeHBlcnRTdWJzZXRDaGFyc2V0KTtjb25zdCBzPXRoaXMuYnl0ZXMsbz1lLGM9c1tlKytdLGw9W2k/MDoiLm5vdGRlZiJdO2xldCBoLHUsZjt0LT0xO3N3aXRjaChjKXtjYXNlIDA6Zm9yKGY9MDtmPHQ7ZisrKXtoPXNbZSsrXTw8OHxzW2UrK107bC5wdXNoKGk/aDphLmdldChoKSl9YnJlYWs7Y2FzZSAxOmZvcig7bC5sZW5ndGg8PXQ7KXtoPXNbZSsrXTw8OHxzW2UrK107dT1zW2UrK107Zm9yKGY9MDtmPD11O2YrKylsLnB1c2goaT9oKys6YS5nZXQoaCsrKSl9YnJlYWs7Y2FzZSAyOmZvcig7bC5sZW5ndGg8PXQ7KXtoPXNbZSsrXTw8OHxzW2UrK107dT1zW2UrK108PDh8c1tlKytdO2ZvcihmPTA7Zjw9dTtmKyspbC5wdXNoKGk/aCsrOmEuZ2V0KGgrKykpfWJyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoIlVua25vd24gY2hhcnNldCBmb3JtYXQiKX1jb25zdCBnPWUscD1zLnN1YmFycmF5KG8sZyk7cmV0dXJuIG5ldyBDRkZDaGFyc2V0KCExLGMsbCxwKX1wYXJzZUVuY29kaW5nKGUsdCxhLG4pe2NvbnN0IHM9T2JqZWN0LmNyZWF0ZShudWxsKSxvPXRoaXMuYnl0ZXM7bGV0IGMsbCxoLHU9ITEsZD1udWxsO2lmKDA9PT1lfHwxPT09ZSl7dT0hMDtjPWU7Y29uc3QgdD1lP2kuRXhwZXJ0RW5jb2Rpbmc6aS5TdGFuZGFyZEVuY29kaW5nO2ZvcihsPTAsaD1uLmxlbmd0aDtsPGg7bCsrKXtjb25zdCBlPXQuaW5kZXhPZihuW2xdKTstMSE9PWUmJihzW2VdPWwpfX1lbHNle2NvbnN0IHQ9ZTtjPW9bZSsrXTtzd2l0Y2goMTI3JmMpe2Nhc2UgMDpjb25zdCB0PW9bZSsrXTtmb3IobD0xO2w8PXQ7bCsrKXNbb1tlKytdXT1sO2JyZWFrO2Nhc2UgMTpjb25zdCBhPW9bZSsrXTtsZXQgbj0xO2ZvcihsPTA7bDxhO2wrKyl7Y29uc3QgdD1vW2UrK10sYT1vW2UrK107Zm9yKGxldCBlPXQ7ZTw9dCthO2UrKylzW2VdPW4rK31icmVhaztkZWZhdWx0OnRocm93IG5ldyByLkZvcm1hdEVycm9yKGBVbmtub3duIGVuY29kaW5nIGZvcm1hdDogJHtjfSBpbiBDRkZgKX1jb25zdCBpPWU7aWYoMTI4JmMpe29bdF0mPTEyNzshZnVuY3Rpb24gcmVhZFN1cHBsZW1lbnQoKXtjb25zdCB0PW9bZSsrXTtmb3IobD0wO2w8dDtsKyspe2NvbnN0IHQ9b1tlKytdLHI9KG9bZSsrXTw8OCkrKDI1NSZvW2UrK10pO3NbdF09bi5pbmRleE9mKGEuZ2V0KHIpKX19KCl9ZD1vLnN1YmFycmF5KHQsaSl9YyY9MTI3O3JldHVybiBuZXcgQ0ZGRW5jb2RpbmcodSxjLHMsZCl9cGFyc2VGRFNlbGVjdChlLHQpe2NvbnN0IGE9dGhpcy5ieXRlcyxuPWFbZSsrXSxpPVtdO2xldCBzO3N3aXRjaChuKXtjYXNlIDA6Zm9yKHM9MDtzPHQ7KytzKXtjb25zdCB0PWFbZSsrXTtpLnB1c2godCl9YnJlYWs7Y2FzZSAzOmNvbnN0IG89YVtlKytdPDw4fGFbZSsrXTtmb3Iocz0wO3M8bzsrK3Mpe2xldCB0PWFbZSsrXTw8OHxhW2UrK107aWYoMD09PXMmJjAhPT10KXsoMCxyLndhcm4pKCJwYXJzZUZEU2VsZWN0OiBUaGUgZmlyc3QgcmFuZ2UgbXVzdCBoYXZlIGEgZmlyc3QgR0lEIG9mIDAgLS0gdHJ5aW5nIHRvIHJlY292ZXIuIik7dD0wfWNvbnN0IG49YVtlKytdLG89YVtlXTw8OHxhW2UrMV07Zm9yKGxldCBlPXQ7ZTxvOysrZSlpLnB1c2gobil9ZSs9MjticmVhaztkZWZhdWx0OnRocm93IG5ldyByLkZvcm1hdEVycm9yKGBwYXJzZUZEU2VsZWN0OiBVbmtub3duIGZvcm1hdCAiJHtufSIuYCl9aWYoaS5sZW5ndGghPT10KXRocm93IG5ldyByLkZvcm1hdEVycm9yKCJwYXJzZUZEU2VsZWN0OiBJbnZhbGlkIGZvbnQgZGF0YS4iKTtyZXR1cm4gbmV3IENGRkZEU2VsZWN0KG4saSl9fTtjbGFzcyBDRkZ7Y29uc3RydWN0b3IoKXt0aGlzLmhlYWRlcj1udWxsO3RoaXMubmFtZXM9W107dGhpcy50b3BEaWN0PW51bGw7dGhpcy5zdHJpbmdzPW5ldyBDRkZTdHJpbmdzO3RoaXMuZ2xvYmFsU3VickluZGV4PW51bGw7dGhpcy5lbmNvZGluZz1udWxsO3RoaXMuY2hhcnNldD1udWxsO3RoaXMuY2hhclN0cmluZ3M9bnVsbDt0aGlzLmZkQXJyYXk9W107dGhpcy5mZFNlbGVjdD1udWxsO3RoaXMuaXNDSURGb250PSExfWR1cGxpY2F0ZUZpcnN0R2x5cGgoKXtpZih0aGlzLmNoYXJTdHJpbmdzLmNvdW50Pj02NTUzNSl7KDAsci53YXJuKSgiTm90IGVub3VnaCBzcGFjZSBpbiBjaGFyc3RyaW5ncyB0byBkdXBsaWNhdGUgZmlyc3QgZ2x5cGguIik7cmV0dXJufWNvbnN0IGU9dGhpcy5jaGFyU3RyaW5ncy5nZXQoMCk7dGhpcy5jaGFyU3RyaW5ncy5hZGQoZSk7dGhpcy5pc0NJREZvbnQmJnRoaXMuZmRTZWxlY3QuZmRTZWxlY3QucHVzaCh0aGlzLmZkU2VsZWN0LmZkU2VsZWN0WzBdKX1oYXNHbHlwaElkKGUpe2lmKGU8MHx8ZT49dGhpcy5jaGFyU3RyaW5ncy5jb3VudClyZXR1cm4hMTtyZXR1cm4gdGhpcy5jaGFyU3RyaW5ncy5nZXQoZSkubGVuZ3RoPjB9fXQuQ0ZGPUNGRjtjbGFzcyBDRkZIZWFkZXJ7Y29uc3RydWN0b3IoZSx0LGEscil7dGhpcy5tYWpvcj1lO3RoaXMubWlub3I9dDt0aGlzLmhkclNpemU9YTt0aGlzLm9mZlNpemU9cn19dC5DRkZIZWFkZXI9Q0ZGSGVhZGVyO2NsYXNzIENGRlN0cmluZ3N7Y29uc3RydWN0b3IoKXt0aGlzLnN0cmluZ3M9W119Z2V0KGUpe3JldHVybiBlPj0wJiZlPD0zOTA/c1tlXTplLW88PXRoaXMuc3RyaW5ncy5sZW5ndGg/dGhpcy5zdHJpbmdzW2Utb106c1swXX1nZXRTSUQoZSl7bGV0IHQ9cy5pbmRleE9mKGUpO2lmKC0xIT09dClyZXR1cm4gdDt0PXRoaXMuc3RyaW5ncy5pbmRleE9mKGUpO3JldHVybi0xIT09dD90K286LTF9YWRkKGUpe3RoaXMuc3RyaW5ncy5wdXNoKGUpfWdldCBjb3VudCgpe3JldHVybiB0aGlzLnN0cmluZ3MubGVuZ3RofX10LkNGRlN0cmluZ3M9Q0ZGU3RyaW5ncztjbGFzcyBDRkZJbmRleHtjb25zdHJ1Y3Rvcigpe3RoaXMub2JqZWN0cz1bXTt0aGlzLmxlbmd0aD0wfWFkZChlKXt0aGlzLmxlbmd0aCs9ZS5sZW5ndGg7dGhpcy5vYmplY3RzLnB1c2goZSl9c2V0KGUsdCl7dGhpcy5sZW5ndGgrPXQubGVuZ3RoLXRoaXMub2JqZWN0c1tlXS5sZW5ndGg7dGhpcy5vYmplY3RzW2VdPXR9Z2V0KGUpe3JldHVybiB0aGlzLm9iamVjdHNbZV19Z2V0IGNvdW50KCl7cmV0dXJuIHRoaXMub2JqZWN0cy5sZW5ndGh9fXQuQ0ZGSW5kZXg9Q0ZGSW5kZXg7Y2xhc3MgQ0ZGRGljdHtjb25zdHJ1Y3RvcihlLHQpe3RoaXMua2V5VG9OYW1lTWFwPWUua2V5VG9OYW1lTWFwO3RoaXMubmFtZVRvS2V5TWFwPWUubmFtZVRvS2V5TWFwO3RoaXMuZGVmYXVsdHM9ZS5kZWZhdWx0czt0aGlzLnR5cGVzPWUudHlwZXM7dGhpcy5vcGNvZGVzPWUub3Bjb2Rlczt0aGlzLm9yZGVyPWUub3JkZXI7dGhpcy5zdHJpbmdzPXQ7dGhpcy52YWx1ZXM9T2JqZWN0LmNyZWF0ZShudWxsKX1zZXRCeUtleShlLHQpe2lmKCEoZSBpbiB0aGlzLmtleVRvTmFtZU1hcCkpcmV0dXJuITE7Y29uc3QgYT10Lmxlbmd0aDtpZigwPT09YSlyZXR1cm4hMDtmb3IobGV0IG49MDtuPGE7bisrKWlmKGlzTmFOKHRbbl0pKXsoMCxyLndhcm4pKCdJbnZhbGlkIENGRkRpY3QgdmFsdWU6ICInK3QrJyIgZm9yIGtleSAiJytlKyciLicpO3JldHVybiEwfWNvbnN0IG49dGhpcy50eXBlc1tlXTsibnVtIiE9PW4mJiJzaWQiIT09biYmIm9mZnNldCIhPT1ufHwodD10WzBdKTt0aGlzLnZhbHVlc1tlXT10O3JldHVybiEwfXNldEJ5TmFtZShlLHQpe2lmKCEoZSBpbiB0aGlzLm5hbWVUb0tleU1hcCkpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoYEludmFsaWQgZGljdGlvbmFyeSBuYW1lICIke2V9ImApO3RoaXMudmFsdWVzW3RoaXMubmFtZVRvS2V5TWFwW2VdXT10fWhhc05hbWUoZSl7cmV0dXJuIHRoaXMubmFtZVRvS2V5TWFwW2VdaW4gdGhpcy52YWx1ZXN9Z2V0QnlOYW1lKGUpe2lmKCEoZSBpbiB0aGlzLm5hbWVUb0tleU1hcCkpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoYEludmFsaWQgZGljdGlvbmFyeSBuYW1lICR7ZX0iYCk7Y29uc3QgdD10aGlzLm5hbWVUb0tleU1hcFtlXTtyZXR1cm4gdCBpbiB0aGlzLnZhbHVlcz90aGlzLnZhbHVlc1t0XTp0aGlzLmRlZmF1bHRzW3RdfXJlbW92ZUJ5TmFtZShlKXtkZWxldGUgdGhpcy52YWx1ZXNbdGhpcy5uYW1lVG9LZXlNYXBbZV1dfXN0YXRpYyBjcmVhdGVUYWJsZXMoZSl7Y29uc3QgdD17a2V5VG9OYW1lTWFwOnt9LG5hbWVUb0tleU1hcDp7fSxkZWZhdWx0czp7fSx0eXBlczp7fSxvcGNvZGVzOnt9LG9yZGVyOltdfTtmb3IobGV0IGE9MCxyPWUubGVuZ3RoO2E8cjsrK2Epe2NvbnN0IHI9ZVthXSxuPUFycmF5LmlzQXJyYXkoclswXSk/KHJbMF1bMF08PDgpK3JbMF1bMV06clswXTt0LmtleVRvTmFtZU1hcFtuXT1yWzFdO3QubmFtZVRvS2V5TWFwW3JbMV1dPW47dC50eXBlc1tuXT1yWzJdO3QuZGVmYXVsdHNbbl09clszXTt0Lm9wY29kZXNbbl09QXJyYXkuaXNBcnJheShyWzBdKT9yWzBdOltyWzBdXTt0Lm9yZGVyLnB1c2gobil9cmV0dXJuIHR9fWNvbnN0IGg9W1tbMTIsMzBdLCJST1MiLFsic2lkIiwic2lkIiwibnVtIl0sbnVsbF0sW1sxMiwyMF0sIlN5bnRoZXRpY0Jhc2UiLCJudW0iLG51bGxdLFswLCJ2ZXJzaW9uIiwic2lkIixudWxsXSxbMSwiTm90aWNlIiwic2lkIixudWxsXSxbWzEyLDBdLCJDb3B5cmlnaHQiLCJzaWQiLG51bGxdLFsyLCJGdWxsTmFtZSIsInNpZCIsbnVsbF0sWzMsIkZhbWlseU5hbWUiLCJzaWQiLG51bGxdLFs0LCJXZWlnaHQiLCJzaWQiLG51bGxdLFtbMTIsMV0sImlzRml4ZWRQaXRjaCIsIm51bSIsMF0sW1sxMiwyXSwiSXRhbGljQW5nbGUiLCJudW0iLDBdLFtbMTIsM10sIlVuZGVybGluZVBvc2l0aW9uIiwibnVtIiwtMTAwXSxbWzEyLDRdLCJVbmRlcmxpbmVUaGlja25lc3MiLCJudW0iLDUwXSxbWzEyLDVdLCJQYWludFR5cGUiLCJudW0iLDBdLFtbMTIsNl0sIkNoYXJzdHJpbmdUeXBlIiwibnVtIiwyXSxbWzEyLDddLCJGb250TWF0cml4IixbIm51bSIsIm51bSIsIm51bSIsIm51bSIsIm51bSIsIm51bSJdLFsuMDAxLDAsMCwuMDAxLDAsMF1dLFsxMywiVW5pcXVlSUQiLCJudW0iLG51bGxdLFs1LCJGb250QkJveCIsWyJudW0iLCJudW0iLCJudW0iLCJudW0iXSxbMCwwLDAsMF1dLFtbMTIsOF0sIlN0cm9rZVdpZHRoIiwibnVtIiwwXSxbMTQsIlhVSUQiLCJhcnJheSIsbnVsbF0sWzE1LCJjaGFyc2V0Iiwib2Zmc2V0IiwwXSxbMTYsIkVuY29kaW5nIiwib2Zmc2V0IiwwXSxbMTcsIkNoYXJTdHJpbmdzIiwib2Zmc2V0IiwwXSxbMTgsIlByaXZhdGUiLFsib2Zmc2V0Iiwib2Zmc2V0Il0sbnVsbF0sW1sxMiwyMV0sIlBvc3RTY3JpcHQiLCJzaWQiLG51bGxdLFtbMTIsMjJdLCJCYXNlRm9udE5hbWUiLCJzaWQiLG51bGxdLFtbMTIsMjNdLCJCYXNlRm9udEJsZW5kIiwiZGVsdGEiLG51bGxdLFtbMTIsMzFdLCJDSURGb250VmVyc2lvbiIsIm51bSIsMF0sW1sxMiwzMl0sIkNJREZvbnRSZXZpc2lvbiIsIm51bSIsMF0sW1sxMiwzM10sIkNJREZvbnRUeXBlIiwibnVtIiwwXSxbWzEyLDM0XSwiQ0lEQ291bnQiLCJudW0iLDg3MjBdLFtbMTIsMzVdLCJVSURCYXNlIiwibnVtIixudWxsXSxbWzEyLDM3XSwiRkRTZWxlY3QiLCJvZmZzZXQiLG51bGxdLFtbMTIsMzZdLCJGREFycmF5Iiwib2Zmc2V0IixudWxsXSxbWzEyLDM4XSwiRm9udE5hbWUiLCJzaWQiLG51bGxdXTtjbGFzcyBDRkZUb3BEaWN0IGV4dGVuZHMgQ0ZGRGljdHtzdGF0aWMgZ2V0IHRhYmxlcygpe3JldHVybigwLHIuc2hhZG93KSh0aGlzLCJ0YWJsZXMiLHRoaXMuY3JlYXRlVGFibGVzKGgpKX1jb25zdHJ1Y3RvcihlKXtzdXBlcihDRkZUb3BEaWN0LnRhYmxlcyxlKTt0aGlzLnByaXZhdGVEaWN0PW51bGx9fXQuQ0ZGVG9wRGljdD1DRkZUb3BEaWN0O2NvbnN0IHU9W1s2LCJCbHVlVmFsdWVzIiwiZGVsdGEiLG51bGxdLFs3LCJPdGhlckJsdWVzIiwiZGVsdGEiLG51bGxdLFs4LCJGYW1pbHlCbHVlcyIsImRlbHRhIixudWxsXSxbOSwiRmFtaWx5T3RoZXJCbHVlcyIsImRlbHRhIixudWxsXSxbWzEyLDldLCJCbHVlU2NhbGUiLCJudW0iLC4wMzk2MjVdLFtbMTIsMTBdLCJCbHVlU2hpZnQiLCJudW0iLDddLFtbMTIsMTFdLCJCbHVlRnV6eiIsIm51bSIsMV0sWzEwLCJTdGRIVyIsIm51bSIsbnVsbF0sWzExLCJTdGRWVyIsIm51bSIsbnVsbF0sW1sxMiwxMl0sIlN0ZW1TbmFwSCIsImRlbHRhIixudWxsXSxbWzEyLDEzXSwiU3RlbVNuYXBWIiwiZGVsdGEiLG51bGxdLFtbMTIsMTRdLCJGb3JjZUJvbGQiLCJudW0iLDBdLFtbMTIsMTddLCJMYW5ndWFnZUdyb3VwIiwibnVtIiwwXSxbWzEyLDE4XSwiRXhwYW5zaW9uRmFjdG9yIiwibnVtIiwuMDZdLFtbMTIsMTldLCJpbml0aWFsUmFuZG9tU2VlZCIsIm51bSIsMF0sWzIwLCJkZWZhdWx0V2lkdGhYIiwibnVtIiwwXSxbMjEsIm5vbWluYWxXaWR0aFgiLCJudW0iLDBdLFsxOSwiU3VicnMiLCJvZmZzZXQiLG51bGxdXTtjbGFzcyBDRkZQcml2YXRlRGljdCBleHRlbmRzIENGRkRpY3R7c3RhdGljIGdldCB0YWJsZXMoKXtyZXR1cm4oMCxyLnNoYWRvdykodGhpcywidGFibGVzIix0aGlzLmNyZWF0ZVRhYmxlcyh1KSl9Y29uc3RydWN0b3IoZSl7c3VwZXIoQ0ZGUHJpdmF0ZURpY3QudGFibGVzLGUpO3RoaXMuc3VicnNJbmRleD1udWxsfX10LkNGRlByaXZhdGVEaWN0PUNGRlByaXZhdGVEaWN0O2NvbnN0IGQ9e0lTT19BRE9CRTowLEVYUEVSVDoxLEVYUEVSVF9TVUJTRVQ6Mn07Y2xhc3MgQ0ZGQ2hhcnNldHtjb25zdHJ1Y3RvcihlLHQsYSxyKXt0aGlzLnByZWRlZmluZWQ9ZTt0aGlzLmZvcm1hdD10O3RoaXMuY2hhcnNldD1hO3RoaXMucmF3PXJ9fXQuQ0ZGQ2hhcnNldD1DRkZDaGFyc2V0O2NsYXNzIENGRkVuY29kaW5ne2NvbnN0cnVjdG9yKGUsdCxhLHIpe3RoaXMucHJlZGVmaW5lZD1lO3RoaXMuZm9ybWF0PXQ7dGhpcy5lbmNvZGluZz1hO3RoaXMucmF3PXJ9fWNsYXNzIENGRkZEU2VsZWN0e2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5mb3JtYXQ9ZTt0aGlzLmZkU2VsZWN0PXR9Z2V0RkRJbmRleChlKXtyZXR1cm4gZTwwfHxlPj10aGlzLmZkU2VsZWN0Lmxlbmd0aD8tMTp0aGlzLmZkU2VsZWN0W2VdfX10LkNGRkZEU2VsZWN0PUNGRkZEU2VsZWN0O2NsYXNzIENGRk9mZnNldFRyYWNrZXJ7Y29uc3RydWN0b3IoKXt0aGlzLm9mZnNldHM9T2JqZWN0LmNyZWF0ZShudWxsKX1pc1RyYWNraW5nKGUpe3JldHVybiBlIGluIHRoaXMub2Zmc2V0c310cmFjayhlLHQpe2lmKGUgaW4gdGhpcy5vZmZzZXRzKXRocm93IG5ldyByLkZvcm1hdEVycm9yKGBBbHJlYWR5IHRyYWNraW5nIGxvY2F0aW9uIG9mICR7ZX1gKTt0aGlzLm9mZnNldHNbZV09dH1vZmZzZXQoZSl7Zm9yKGNvbnN0IHQgaW4gdGhpcy5vZmZzZXRzKXRoaXMub2Zmc2V0c1t0XSs9ZX1zZXRFbnRyeUxvY2F0aW9uKGUsdCxhKXtpZighKGUgaW4gdGhpcy5vZmZzZXRzKSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcihgTm90IHRyYWNraW5nIGxvY2F0aW9uIG9mICR7ZX1gKTtjb25zdCBuPWEuZGF0YSxpPXRoaXMub2Zmc2V0c1tlXTtmb3IobGV0IGU9MCxhPXQubGVuZ3RoO2U8YTsrK2Upe2NvbnN0IGE9NSplK2kscz1hKzEsbz1hKzIsYz1hKzMsbD1hKzQ7aWYoMjkhPT1uW2FdfHwwIT09bltzXXx8MCE9PW5bb118fDAhPT1uW2NdfHwwIT09bltsXSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigid3JpdGluZyB0byBhbiBvZmZzZXQgdGhhdCBpcyBub3QgZW1wdHkiKTtjb25zdCBoPXRbZV07blthXT0yOTtuW3NdPWg+PjI0JjI1NTtuW29dPWg+PjE2JjI1NTtuW2NdPWg+PjgmMjU1O25bbF09MjU1Jmh9fX1jbGFzcyBDRkZDb21waWxlcntjb25zdHJ1Y3RvcihlKXt0aGlzLmNmZj1lfWNvbXBpbGUoKXtjb25zdCBlPXRoaXMuY2ZmLHQ9e2RhdGE6W10sbGVuZ3RoOjAsYWRkKGUpe3RoaXMuZGF0YT10aGlzLmRhdGEuY29uY2F0KGUpO3RoaXMubGVuZ3RoPXRoaXMuZGF0YS5sZW5ndGh9fSxhPXRoaXMuY29tcGlsZUhlYWRlcihlLmhlYWRlcik7dC5hZGQoYSk7Y29uc3Qgbj10aGlzLmNvbXBpbGVOYW1lSW5kZXgoZS5uYW1lcyk7dC5hZGQobik7aWYoZS5pc0NJREZvbnQmJmUudG9wRGljdC5oYXNOYW1lKCJGb250TWF0cml4Iikpe2NvbnN0IHQ9ZS50b3BEaWN0LmdldEJ5TmFtZSgiRm9udE1hdHJpeCIpO2UudG9wRGljdC5yZW1vdmVCeU5hbWUoIkZvbnRNYXRyaXgiKTtmb3IobGV0IGE9MCxuPWUuZmRBcnJheS5sZW5ndGg7YTxuO2ErKyl7Y29uc3Qgbj1lLmZkQXJyYXlbYV07bGV0IGk9dC5zbGljZSgwKTtuLmhhc05hbWUoIkZvbnRNYXRyaXgiKSYmKGk9ci5VdGlsLnRyYW5zZm9ybShpLG4uZ2V0QnlOYW1lKCJGb250TWF0cml4IikpKTtuLnNldEJ5TmFtZSgiRm9udE1hdHJpeCIsaSl9fWNvbnN0IGk9ZS50b3BEaWN0LmdldEJ5TmFtZSgiWFVJRCIpO2kmJmkubGVuZ3RoPjE2JiZlLnRvcERpY3QucmVtb3ZlQnlOYW1lKCJYVUlEIik7ZS50b3BEaWN0LnNldEJ5TmFtZSgiY2hhcnNldCIsMCk7bGV0IHM9dGhpcy5jb21waWxlVG9wRGljdHMoW2UudG9wRGljdF0sdC5sZW5ndGgsZS5pc0NJREZvbnQpO3QuYWRkKHMub3V0cHV0KTtjb25zdCBvPXMudHJhY2tlcnNbMF0sYz10aGlzLmNvbXBpbGVTdHJpbmdJbmRleChlLnN0cmluZ3Muc3RyaW5ncyk7dC5hZGQoYyk7Y29uc3QgbD10aGlzLmNvbXBpbGVJbmRleChlLmdsb2JhbFN1YnJJbmRleCk7dC5hZGQobCk7aWYoZS5lbmNvZGluZyYmZS50b3BEaWN0Lmhhc05hbWUoIkVuY29kaW5nIikpaWYoZS5lbmNvZGluZy5wcmVkZWZpbmVkKW8uc2V0RW50cnlMb2NhdGlvbigiRW5jb2RpbmciLFtlLmVuY29kaW5nLmZvcm1hdF0sdCk7ZWxzZXtjb25zdCBhPXRoaXMuY29tcGlsZUVuY29kaW5nKGUuZW5jb2RpbmcpO28uc2V0RW50cnlMb2NhdGlvbigiRW5jb2RpbmciLFt0Lmxlbmd0aF0sdCk7dC5hZGQoYSl9Y29uc3QgaD10aGlzLmNvbXBpbGVDaGFyc2V0KGUuY2hhcnNldCxlLmNoYXJTdHJpbmdzLmNvdW50LGUuc3RyaW5ncyxlLmlzQ0lERm9udCk7by5zZXRFbnRyeUxvY2F0aW9uKCJjaGFyc2V0IixbdC5sZW5ndGhdLHQpO3QuYWRkKGgpO2NvbnN0IHU9dGhpcy5jb21waWxlQ2hhclN0cmluZ3MoZS5jaGFyU3RyaW5ncyk7by5zZXRFbnRyeUxvY2F0aW9uKCJDaGFyU3RyaW5ncyIsW3QubGVuZ3RoXSx0KTt0LmFkZCh1KTtpZihlLmlzQ0lERm9udCl7by5zZXRFbnRyeUxvY2F0aW9uKCJGRFNlbGVjdCIsW3QubGVuZ3RoXSx0KTtjb25zdCBhPXRoaXMuY29tcGlsZUZEU2VsZWN0KGUuZmRTZWxlY3QpO3QuYWRkKGEpO3M9dGhpcy5jb21waWxlVG9wRGljdHMoZS5mZEFycmF5LHQubGVuZ3RoLCEwKTtvLnNldEVudHJ5TG9jYXRpb24oIkZEQXJyYXkiLFt0Lmxlbmd0aF0sdCk7dC5hZGQocy5vdXRwdXQpO2NvbnN0IHI9cy50cmFja2Vyczt0aGlzLmNvbXBpbGVQcml2YXRlRGljdHMoZS5mZEFycmF5LHIsdCl9dGhpcy5jb21waWxlUHJpdmF0ZURpY3RzKFtlLnRvcERpY3RdLFtvXSx0KTt0LmFkZChbMF0pO3JldHVybiB0LmRhdGF9ZW5jb2RlTnVtYmVyKGUpe3JldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGUpP3RoaXMuZW5jb2RlSW50ZWdlcihlKTp0aGlzLmVuY29kZUZsb2F0KGUpfXN0YXRpYyBnZXQgRW5jb2RlRmxvYXRSZWdFeHAoKXtyZXR1cm4oMCxyLnNoYWRvdykodGhpcywiRW5jb2RlRmxvYXRSZWdFeHAiLC9cLihcZCo/KSg/Ojl7NSwyMH18MHs1LDIwfSlcZHswLDJ9KD86ZSguKyl8JCkvKX1lbmNvZGVGbG9hdChlKXtsZXQgdD1lLnRvU3RyaW5nKCk7Y29uc3QgYT1DRkZDb21waWxlci5FbmNvZGVGbG9hdFJlZ0V4cC5leGVjKHQpO2lmKGEpe2NvbnN0IHI9cGFyc2VGbG9hdCgiMWUiKygoYVsyXT8rYVsyXTowKSthWzFdLmxlbmd0aCkpO3Q9KE1hdGgucm91bmQoZSpyKS9yKS50b1N0cmluZygpfWxldCByLG4saT0iIjtmb3Iocj0wLG49dC5sZW5ndGg7cjxuOysrcil7Y29uc3QgZT10W3JdO2krPSJlIj09PWU/Ii0iPT09dFsrK3JdPyJjIjoiYiI6Ii4iPT09ZT8iYSI6Ii0iPT09ZT8iZSI6ZX1pKz0xJmkubGVuZ3RoPyJmIjoiZmYiO2NvbnN0IHM9WzMwXTtmb3Iocj0wLG49aS5sZW5ndGg7cjxuO3IrPTIpcy5wdXNoKHBhcnNlSW50KGkuc3Vic3RyaW5nKHIscisyKSwxNikpO3JldHVybiBzfWVuY29kZUludGVnZXIoZSl7bGV0IHQ7dD1lPj0tMTA3JiZlPD0xMDc/W2UrMTM5XTplPj0xMDgmJmU8PTExMzE/WzI0NysoKGUtPTEwOCk+PjgpLDI1NSZlXTplPj0tMTEzMSYmZTw9LTEwOD9bMjUxKygoZT0tZS0xMDgpPj44KSwyNTUmZV06ZT49LTMyNzY4JiZlPD0zMjc2Nz9bMjgsZT4+OCYyNTUsMjU1JmVdOlsyOSxlPj4yNCYyNTUsZT4+MTYmMjU1LGU+PjgmMjU1LDI1NSZlXTtyZXR1cm4gdH1jb21waWxlSGVhZGVyKGUpe3JldHVybltlLm1ham9yLGUubWlub3IsNCxlLm9mZlNpemVdfWNvbXBpbGVOYW1lSW5kZXgoZSl7Y29uc3QgdD1uZXcgQ0ZGSW5kZXg7Zm9yKGxldCBhPTAsbj1lLmxlbmd0aDthPG47KythKXtjb25zdCBuPWVbYV0saT1NYXRoLm1pbihuLmxlbmd0aCwxMjcpO2xldCBzPW5ldyBBcnJheShpKTtmb3IobGV0IGU9MDtlPGk7ZSsrKXtsZXQgdD1uW2VdOyh0PCIhInx8dD4ifiJ8fCJbIj09PXR8fCJdIj09PXR8fCIoIj09PXR8fCIpIj09PXR8fCJ7Ij09PXR8fCJ9Ij09PXR8fCI8Ij09PXR8fCI+Ij09PXR8fCIvIj09PXR8fCIlIj09PXQpJiYodD0iXyIpO3NbZV09dH1zPXMuam9pbigiIik7IiI9PT1zJiYocz0iQmFkX0ZvbnRfTmFtZSIpO3QuYWRkKCgwLHIuc3RyaW5nVG9CeXRlcykocykpfXJldHVybiB0aGlzLmNvbXBpbGVJbmRleCh0KX1jb21waWxlVG9wRGljdHMoZSx0LGEpe2NvbnN0IHI9W107bGV0IG49bmV3IENGRkluZGV4O2ZvcihsZXQgaT0wLHM9ZS5sZW5ndGg7aTxzOysraSl7Y29uc3Qgcz1lW2ldO2lmKGEpe3MucmVtb3ZlQnlOYW1lKCJDSURGb250VmVyc2lvbiIpO3MucmVtb3ZlQnlOYW1lKCJDSURGb250UmV2aXNpb24iKTtzLnJlbW92ZUJ5TmFtZSgiQ0lERm9udFR5cGUiKTtzLnJlbW92ZUJ5TmFtZSgiQ0lEQ291bnQiKTtzLnJlbW92ZUJ5TmFtZSgiVUlEQmFzZSIpfWNvbnN0IG89bmV3IENGRk9mZnNldFRyYWNrZXIsYz10aGlzLmNvbXBpbGVEaWN0KHMsbyk7ci5wdXNoKG8pO24uYWRkKGMpO28ub2Zmc2V0KHQpfW49dGhpcy5jb21waWxlSW5kZXgobixyKTtyZXR1cm57dHJhY2tlcnM6cixvdXRwdXQ6bn19Y29tcGlsZVByaXZhdGVEaWN0cyhlLHQsYSl7Zm9yKGxldCBuPTAsaT1lLmxlbmd0aDtuPGk7KytuKXtjb25zdCBpPWVbbl0scz1pLnByaXZhdGVEaWN0O2lmKCFzfHwhaS5oYXNOYW1lKCJQcml2YXRlIikpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoIlRoZXJlIG11c3QgYmUgYSBwcml2YXRlIGRpY3Rpb25hcnkuIik7Y29uc3Qgbz1uZXcgQ0ZGT2Zmc2V0VHJhY2tlcixjPXRoaXMuY29tcGlsZURpY3QocyxvKTtsZXQgbD1hLmxlbmd0aDtvLm9mZnNldChsKTtjLmxlbmd0aHx8KGw9MCk7dFtuXS5zZXRFbnRyeUxvY2F0aW9uKCJQcml2YXRlIixbYy5sZW5ndGgsbF0sYSk7YS5hZGQoYyk7aWYocy5zdWJyc0luZGV4JiZzLmhhc05hbWUoIlN1YnJzIikpe2NvbnN0IGU9dGhpcy5jb21waWxlSW5kZXgocy5zdWJyc0luZGV4KTtvLnNldEVudHJ5TG9jYXRpb24oIlN1YnJzIixbYy5sZW5ndGhdLGEpO2EuYWRkKGUpfX19Y29tcGlsZURpY3QoZSx0KXtjb25zdCBhPVtdO2Zvcihjb25zdCBuIG9mIGUub3JkZXIpe2lmKCEobiBpbiBlLnZhbHVlcykpY29udGludWU7bGV0IGk9ZS52YWx1ZXNbbl0scz1lLnR5cGVzW25dO0FycmF5LmlzQXJyYXkocyl8fChzPVtzXSk7QXJyYXkuaXNBcnJheShpKXx8KGk9W2ldKTtpZigwIT09aS5sZW5ndGgpe2ZvcihsZXQgbz0wLGM9cy5sZW5ndGg7bzxjOysrbyl7Y29uc3QgYz1zW29dLGw9aVtvXTtzd2l0Y2goYyl7Y2FzZSJudW0iOmNhc2Uic2lkIjphLnB1c2goLi4udGhpcy5lbmNvZGVOdW1iZXIobCkpO2JyZWFrO2Nhc2Uib2Zmc2V0Ijpjb25zdCBzPWUua2V5VG9OYW1lTWFwW25dO3QuaXNUcmFja2luZyhzKXx8dC50cmFjayhzLGEubGVuZ3RoKTthLnB1c2goMjksMCwwLDAsMCk7YnJlYWs7Y2FzZSJhcnJheSI6Y2FzZSJkZWx0YSI6YS5wdXNoKC4uLnRoaXMuZW5jb2RlTnVtYmVyKGwpKTtmb3IobGV0IGU9MSx0PWkubGVuZ3RoO2U8dDsrK2UpYS5wdXNoKC4uLnRoaXMuZW5jb2RlTnVtYmVyKGlbZV0pKTticmVhaztkZWZhdWx0OnRocm93IG5ldyByLkZvcm1hdEVycm9yKGBVbmtub3duIGRhdGEgdHlwZSBvZiAke2N9YCl9fWEucHVzaCguLi5lLm9wY29kZXNbbl0pfX1yZXR1cm4gYX1jb21waWxlU3RyaW5nSW5kZXgoZSl7Y29uc3QgdD1uZXcgQ0ZGSW5kZXg7Zm9yKGxldCBhPTAsbj1lLmxlbmd0aDthPG47KythKXQuYWRkKCgwLHIuc3RyaW5nVG9CeXRlcykoZVthXSkpO3JldHVybiB0aGlzLmNvbXBpbGVJbmRleCh0KX1jb21waWxlR2xvYmFsU3VickluZGV4KCl7Y29uc3QgZT10aGlzLmNmZi5nbG9iYWxTdWJySW5kZXg7dGhpcy5vdXQud3JpdGVCeXRlQXJyYXkodGhpcy5jb21waWxlSW5kZXgoZSkpfWNvbXBpbGVDaGFyU3RyaW5ncyhlKXtjb25zdCB0PW5ldyBDRkZJbmRleDtmb3IobGV0IGE9MDthPGUuY291bnQ7YSsrKXtjb25zdCByPWUuZ2V0KGEpOzAhPT1yLmxlbmd0aD90LmFkZChyKTp0LmFkZChuZXcgVWludDhBcnJheShbMTM5LDE0XSkpfXJldHVybiB0aGlzLmNvbXBpbGVJbmRleCh0KX1jb21waWxlQ2hhcnNldChlLHQsYSxuKXtsZXQgaTtjb25zdCBzPXQtMTtpZihuKWk9bmV3IFVpbnQ4QXJyYXkoWzIsMCwwLHM+PjgmMjU1LDI1NSZzXSk7ZWxzZXtpPW5ldyBVaW50OEFycmF5KDErMipzKTtpWzBdPTA7bGV0IHQ9MDtjb25zdCBuPWUuY2hhcnNldC5sZW5ndGg7bGV0IG89ITE7Zm9yKGxldCBzPTE7czxpLmxlbmd0aDtzKz0yKXtsZXQgYz0wO2lmKHQ8bil7Y29uc3Qgbj1lLmNoYXJzZXRbdCsrXTtjPWEuZ2V0U0lEKG4pO2lmKC0xPT09Yyl7Yz0wO2lmKCFvKXtvPSEwOygwLHIud2FybikoYENvdWxkbid0IGZpbmQgJHtufSBpbiBDRkYgc3RyaW5nc2ApfX19aVtzXT1jPj44JjI1NTtpW3MrMV09MjU1JmN9fXJldHVybiB0aGlzLmNvbXBpbGVUeXBlZEFycmF5KGkpfWNvbXBpbGVFbmNvZGluZyhlKXtyZXR1cm4gdGhpcy5jb21waWxlVHlwZWRBcnJheShlLnJhdyl9Y29tcGlsZUZEU2VsZWN0KGUpe2NvbnN0IHQ9ZS5mb3JtYXQ7bGV0IGEscjtzd2l0Y2godCl7Y2FzZSAwOmE9bmV3IFVpbnQ4QXJyYXkoMStlLmZkU2VsZWN0Lmxlbmd0aCk7YVswXT10O2ZvcihyPTA7cjxlLmZkU2VsZWN0Lmxlbmd0aDtyKyspYVtyKzFdPWUuZmRTZWxlY3Rbcl07YnJlYWs7Y2FzZSAzOmNvbnN0IG49MDtsZXQgaT1lLmZkU2VsZWN0WzBdO2NvbnN0IHM9W3QsMCwwLG4+PjgmMjU1LDI1NSZuLGldO2ZvcihyPTE7cjxlLmZkU2VsZWN0Lmxlbmd0aDtyKyspe2NvbnN0IHQ9ZS5mZFNlbGVjdFtyXTtpZih0IT09aSl7cy5wdXNoKHI+PjgmMjU1LDI1NSZyLHQpO2k9dH19Y29uc3Qgbz0ocy5sZW5ndGgtMykvMztzWzFdPW8+PjgmMjU1O3NbMl09MjU1Jm87cy5wdXNoKHI+PjgmMjU1LDI1NSZyKTthPW5ldyBVaW50OEFycmF5KHMpfXJldHVybiB0aGlzLmNvbXBpbGVUeXBlZEFycmF5KGEpfWNvbXBpbGVUeXBlZEFycmF5KGUpe2NvbnN0IHQ9W107Zm9yKGxldCBhPTAscj1lLmxlbmd0aDthPHI7KythKXRbYV09ZVthXTtyZXR1cm4gdH1jb21waWxlSW5kZXgoZSx0PVtdKXtjb25zdCBhPWUub2JqZWN0cyxyPWEubGVuZ3RoO2lmKDA9PT1yKXJldHVyblswLDBdO2NvbnN0IG49W3I+PjgmMjU1LDI1NSZyXTtsZXQgaSxzLG89MTtmb3IoaT0wO2k8cjsrK2kpbys9YVtpXS5sZW5ndGg7cz1vPDI1Nj8xOm88NjU1MzY/MjpvPDE2Nzc3MjE2PzM6NDtuLnB1c2gocyk7bGV0IGM9MTtmb3IoaT0wO2k8cisxO2krKyl7MT09PXM/bi5wdXNoKDI1NSZjKToyPT09cz9uLnB1c2goYz4+OCYyNTUsMjU1JmMpOjM9PT1zP24ucHVzaChjPj4xNiYyNTUsYz4+OCYyNTUsMjU1JmMpOm4ucHVzaChjPj4+MjQmMjU1LGM+PjE2JjI1NSxjPj44JjI1NSwyNTUmYyk7YVtpXSYmKGMrPWFbaV0ubGVuZ3RoKX1mb3IoaT0wO2k8cjtpKyspe3RbaV0mJnRbaV0ub2Zmc2V0KG4ubGVuZ3RoKTtmb3IobGV0IGU9MCx0PWFbaV0ubGVuZ3RoO2U8dDtlKyspbi5wdXNoKGFbaV1bZV0pfXJldHVybiBufX10LkNGRkNvbXBpbGVyPUNGRkNvbXBpbGVyfSwoZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LklTT0Fkb2JlQ2hhcnNldD10LkV4cGVydFN1YnNldENoYXJzZXQ9dC5FeHBlcnRDaGFyc2V0PXZvaWQgMDt0LklTT0Fkb2JlQ2hhcnNldD1bIi5ub3RkZWYiLCJzcGFjZSIsImV4Y2xhbSIsInF1b3RlZGJsIiwibnVtYmVyc2lnbiIsImRvbGxhciIsInBlcmNlbnQiLCJhbXBlcnNhbmQiLCJxdW90ZXJpZ2h0IiwicGFyZW5sZWZ0IiwicGFyZW5yaWdodCIsImFzdGVyaXNrIiwicGx1cyIsImNvbW1hIiwiaHlwaGVuIiwicGVyaW9kIiwic2xhc2giLCJ6ZXJvIiwib25lIiwidHdvIiwidGhyZWUiLCJmb3VyIiwiZml2ZSIsInNpeCIsInNldmVuIiwiZWlnaHQiLCJuaW5lIiwiY29sb24iLCJzZW1pY29sb24iLCJsZXNzIiwiZXF1YWwiLCJncmVhdGVyIiwicXVlc3Rpb24iLCJhdCIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJIIiwiSSIsIkoiLCJLIiwiTCIsIk0iLCJOIiwiTyIsIlAiLCJRIiwiUiIsIlMiLCJUIiwiVSIsIlYiLCJXIiwiWCIsIlkiLCJaIiwiYnJhY2tldGxlZnQiLCJiYWNrc2xhc2giLCJicmFja2V0cmlnaHQiLCJhc2NpaWNpcmN1bSIsInVuZGVyc2NvcmUiLCJxdW90ZWxlZnQiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnIiwiaCIsImkiLCJqIiwiayIsImwiLCJtIiwibiIsIm8iLCJwIiwicSIsInIiLCJzIiwidCIsInUiLCJ2IiwidyIsIngiLCJ5IiwieiIsImJyYWNlbGVmdCIsImJhciIsImJyYWNlcmlnaHQiLCJhc2NpaXRpbGRlIiwiZXhjbGFtZG93biIsImNlbnQiLCJzdGVybGluZyIsImZyYWN0aW9uIiwieWVuIiwiZmxvcmluIiwic2VjdGlvbiIsImN1cnJlbmN5IiwicXVvdGVzaW5nbGUiLCJxdW90ZWRibGxlZnQiLCJndWlsbGVtb3RsZWZ0IiwiZ3VpbHNpbmdsbGVmdCIsImd1aWxzaW5nbHJpZ2h0IiwiZmkiLCJmbCIsImVuZGFzaCIsImRhZ2dlciIsImRhZ2dlcmRibCIsInBlcmlvZGNlbnRlcmVkIiwicGFyYWdyYXBoIiwiYnVsbGV0IiwicXVvdGVzaW5nbGJhc2UiLCJxdW90ZWRibGJhc2UiLCJxdW90ZWRibHJpZ2h0IiwiZ3VpbGxlbW90cmlnaHQiLCJlbGxpcHNpcyIsInBlcnRob3VzYW5kIiwicXVlc3Rpb25kb3duIiwiZ3JhdmUiLCJhY3V0ZSIsImNpcmN1bWZsZXgiLCJ0aWxkZSIsIm1hY3JvbiIsImJyZXZlIiwiZG90YWNjZW50IiwiZGllcmVzaXMiLCJyaW5nIiwiY2VkaWxsYSIsImh1bmdhcnVtbGF1dCIsIm9nb25layIsImNhcm9uIiwiZW1kYXNoIiwiQUUiLCJvcmRmZW1pbmluZSIsIkxzbGFzaCIsIk9zbGFzaCIsIk9FIiwib3JkbWFzY3VsaW5lIiwiYWUiLCJkb3RsZXNzaSIsImxzbGFzaCIsIm9zbGFzaCIsIm9lIiwiZ2VybWFuZGJscyIsIm9uZXN1cGVyaW9yIiwibG9naWNhbG5vdCIsIm11IiwidHJhZGVtYXJrIiwiRXRoIiwib25laGFsZiIsInBsdXNtaW51cyIsIlRob3JuIiwib25lcXVhcnRlciIsImRpdmlkZSIsImJyb2tlbmJhciIsImRlZ3JlZSIsInRob3JuIiwidGhyZWVxdWFydGVycyIsInR3b3N1cGVyaW9yIiwicmVnaXN0ZXJlZCIsIm1pbnVzIiwiZXRoIiwibXVsdGlwbHkiLCJ0aHJlZXN1cGVyaW9yIiwiY29weXJpZ2h0IiwiQWFjdXRlIiwiQWNpcmN1bWZsZXgiLCJBZGllcmVzaXMiLCJBZ3JhdmUiLCJBcmluZyIsIkF0aWxkZSIsIkNjZWRpbGxhIiwiRWFjdXRlIiwiRWNpcmN1bWZsZXgiLCJFZGllcmVzaXMiLCJFZ3JhdmUiLCJJYWN1dGUiLCJJY2lyY3VtZmxleCIsIklkaWVyZXNpcyIsIklncmF2ZSIsIk50aWxkZSIsIk9hY3V0ZSIsIk9jaXJjdW1mbGV4IiwiT2RpZXJlc2lzIiwiT2dyYXZlIiwiT3RpbGRlIiwiU2Nhcm9uIiwiVWFjdXRlIiwiVWNpcmN1bWZsZXgiLCJVZGllcmVzaXMiLCJVZ3JhdmUiLCJZYWN1dGUiLCJZZGllcmVzaXMiLCJaY2Fyb24iLCJhYWN1dGUiLCJhY2lyY3VtZmxleCIsImFkaWVyZXNpcyIsImFncmF2ZSIsImFyaW5nIiwiYXRpbGRlIiwiY2NlZGlsbGEiLCJlYWN1dGUiLCJlY2lyY3VtZmxleCIsImVkaWVyZXNpcyIsImVncmF2ZSIsImlhY3V0ZSIsImljaXJjdW1mbGV4IiwiaWRpZXJlc2lzIiwiaWdyYXZlIiwibnRpbGRlIiwib2FjdXRlIiwib2NpcmN1bWZsZXgiLCJvZGllcmVzaXMiLCJvZ3JhdmUiLCJvdGlsZGUiLCJzY2Fyb24iLCJ1YWN1dGUiLCJ1Y2lyY3VtZmxleCIsInVkaWVyZXNpcyIsInVncmF2ZSIsInlhY3V0ZSIsInlkaWVyZXNpcyIsInpjYXJvbiJdO3QuRXhwZXJ0Q2hhcnNldD1bIi5ub3RkZWYiLCJzcGFjZSIsImV4Y2xhbXNtYWxsIiwiSHVuZ2FydW1sYXV0c21hbGwiLCJkb2xsYXJvbGRzdHlsZSIsImRvbGxhcnN1cGVyaW9yIiwiYW1wZXJzYW5kc21hbGwiLCJBY3V0ZXNtYWxsIiwicGFyZW5sZWZ0c3VwZXJpb3IiLCJwYXJlbnJpZ2h0c3VwZXJpb3IiLCJ0d29kb3RlbmxlYWRlciIsIm9uZWRvdGVubGVhZGVyIiwiY29tbWEiLCJoeXBoZW4iLCJwZXJpb2QiLCJmcmFjdGlvbiIsInplcm9vbGRzdHlsZSIsIm9uZW9sZHN0eWxlIiwidHdvb2xkc3R5bGUiLCJ0aHJlZW9sZHN0eWxlIiwiZm91cm9sZHN0eWxlIiwiZml2ZW9sZHN0eWxlIiwic2l4b2xkc3R5bGUiLCJzZXZlbm9sZHN0eWxlIiwiZWlnaHRvbGRzdHlsZSIsIm5pbmVvbGRzdHlsZSIsImNvbG9uIiwic2VtaWNvbG9uIiwiY29tbWFzdXBlcmlvciIsInRocmVlcXVhcnRlcnNlbWRhc2giLCJwZXJpb2RzdXBlcmlvciIsInF1ZXN0aW9uc21hbGwiLCJhc3VwZXJpb3IiLCJic3VwZXJpb3IiLCJjZW50c3VwZXJpb3IiLCJkc3VwZXJpb3IiLCJlc3VwZXJpb3IiLCJpc3VwZXJpb3IiLCJsc3VwZXJpb3IiLCJtc3VwZXJpb3IiLCJuc3VwZXJpb3IiLCJvc3VwZXJpb3IiLCJyc3VwZXJpb3IiLCJzc3VwZXJpb3IiLCJ0c3VwZXJpb3IiLCJmZiIsImZpIiwiZmwiLCJmZmkiLCJmZmwiLCJwYXJlbmxlZnRpbmZlcmlvciIsInBhcmVucmlnaHRpbmZlcmlvciIsIkNpcmN1bWZsZXhzbWFsbCIsImh5cGhlbnN1cGVyaW9yIiwiR3JhdmVzbWFsbCIsIkFzbWFsbCIsIkJzbWFsbCIsIkNzbWFsbCIsIkRzbWFsbCIsIkVzbWFsbCIsIkZzbWFsbCIsIkdzbWFsbCIsIkhzbWFsbCIsIklzbWFsbCIsIkpzbWFsbCIsIktzbWFsbCIsIkxzbWFsbCIsIk1zbWFsbCIsIk5zbWFsbCIsIk9zbWFsbCIsIlBzbWFsbCIsIlFzbWFsbCIsIlJzbWFsbCIsIlNzbWFsbCIsIlRzbWFsbCIsIlVzbWFsbCIsIlZzbWFsbCIsIldzbWFsbCIsIlhzbWFsbCIsIllzbWFsbCIsIlpzbWFsbCIsImNvbG9ubW9uZXRhcnkiLCJvbmVmaXR0ZWQiLCJydXBpYWgiLCJUaWxkZXNtYWxsIiwiZXhjbGFtZG93bnNtYWxsIiwiY2VudG9sZHN0eWxlIiwiTHNsYXNoc21hbGwiLCJTY2Fyb25zbWFsbCIsIlpjYXJvbnNtYWxsIiwiRGllcmVzaXNzbWFsbCIsIkJyZXZlc21hbGwiLCJDYXJvbnNtYWxsIiwiRG90YWNjZW50c21hbGwiLCJNYWNyb25zbWFsbCIsImZpZ3VyZWRhc2giLCJoeXBoZW5pbmZlcmlvciIsIk9nb25la3NtYWxsIiwiUmluZ3NtYWxsIiwiQ2VkaWxsYXNtYWxsIiwib25lcXVhcnRlciIsIm9uZWhhbGYiLCJ0aHJlZXF1YXJ0ZXJzIiwicXVlc3Rpb25kb3duc21hbGwiLCJvbmVlaWdodGgiLCJ0aHJlZWVpZ2h0aHMiLCJmaXZlZWlnaHRocyIsInNldmVuZWlnaHRocyIsIm9uZXRoaXJkIiwidHdvdGhpcmRzIiwiemVyb3N1cGVyaW9yIiwib25lc3VwZXJpb3IiLCJ0d29zdXBlcmlvciIsInRocmVlc3VwZXJpb3IiLCJmb3Vyc3VwZXJpb3IiLCJmaXZlc3VwZXJpb3IiLCJzaXhzdXBlcmlvciIsInNldmVuc3VwZXJpb3IiLCJlaWdodHN1cGVyaW9yIiwibmluZXN1cGVyaW9yIiwiemVyb2luZmVyaW9yIiwib25laW5mZXJpb3IiLCJ0d29pbmZlcmlvciIsInRocmVlaW5mZXJpb3IiLCJmb3VyaW5mZXJpb3IiLCJmaXZlaW5mZXJpb3IiLCJzaXhpbmZlcmlvciIsInNldmVuaW5mZXJpb3IiLCJlaWdodGluZmVyaW9yIiwibmluZWluZmVyaW9yIiwiY2VudGluZmVyaW9yIiwiZG9sbGFyaW5mZXJpb3IiLCJwZXJpb2RpbmZlcmlvciIsImNvbW1haW5mZXJpb3IiLCJBZ3JhdmVzbWFsbCIsIkFhY3V0ZXNtYWxsIiwiQWNpcmN1bWZsZXhzbWFsbCIsIkF0aWxkZXNtYWxsIiwiQWRpZXJlc2lzc21hbGwiLCJBcmluZ3NtYWxsIiwiQUVzbWFsbCIsIkNjZWRpbGxhc21hbGwiLCJFZ3JhdmVzbWFsbCIsIkVhY3V0ZXNtYWxsIiwiRWNpcmN1bWZsZXhzbWFsbCIsIkVkaWVyZXNpc3NtYWxsIiwiSWdyYXZlc21hbGwiLCJJYWN1dGVzbWFsbCIsIkljaXJjdW1mbGV4c21hbGwiLCJJZGllcmVzaXNzbWFsbCIsIkV0aHNtYWxsIiwiTnRpbGRlc21hbGwiLCJPZ3JhdmVzbWFsbCIsIk9hY3V0ZXNtYWxsIiwiT2NpcmN1bWZsZXhzbWFsbCIsIk90aWxkZXNtYWxsIiwiT2RpZXJlc2lzc21hbGwiLCJPRXNtYWxsIiwiT3NsYXNoc21hbGwiLCJVZ3JhdmVzbWFsbCIsIlVhY3V0ZXNtYWxsIiwiVWNpcmN1bWZsZXhzbWFsbCIsIlVkaWVyZXNpc3NtYWxsIiwiWWFjdXRlc21hbGwiLCJUaG9ybnNtYWxsIiwiWWRpZXJlc2lzc21hbGwiXTt0LkV4cGVydFN1YnNldENoYXJzZXQ9WyIubm90ZGVmIiwic3BhY2UiLCJkb2xsYXJvbGRzdHlsZSIsImRvbGxhcnN1cGVyaW9yIiwicGFyZW5sZWZ0c3VwZXJpb3IiLCJwYXJlbnJpZ2h0c3VwZXJpb3IiLCJ0d29kb3RlbmxlYWRlciIsIm9uZWRvdGVubGVhZGVyIiwiY29tbWEiLCJoeXBoZW4iLCJwZXJpb2QiLCJmcmFjdGlvbiIsInplcm9vbGRzdHlsZSIsIm9uZW9sZHN0eWxlIiwidHdvb2xkc3R5bGUiLCJ0aHJlZW9sZHN0eWxlIiwiZm91cm9sZHN0eWxlIiwiZml2ZW9sZHN0eWxlIiwic2l4b2xkc3R5bGUiLCJzZXZlbm9sZHN0eWxlIiwiZWlnaHRvbGRzdHlsZSIsIm5pbmVvbGRzdHlsZSIsImNvbG9uIiwic2VtaWNvbG9uIiwiY29tbWFzdXBlcmlvciIsInRocmVlcXVhcnRlcnNlbWRhc2giLCJwZXJpb2RzdXBlcmlvciIsImFzdXBlcmlvciIsImJzdXBlcmlvciIsImNlbnRzdXBlcmlvciIsImRzdXBlcmlvciIsImVzdXBlcmlvciIsImlzdXBlcmlvciIsImxzdXBlcmlvciIsIm1zdXBlcmlvciIsIm5zdXBlcmlvciIsIm9zdXBlcmlvciIsInJzdXBlcmlvciIsInNzdXBlcmlvciIsInRzdXBlcmlvciIsImZmIiwiZmkiLCJmbCIsImZmaSIsImZmbCIsInBhcmVubGVmdGluZmVyaW9yIiwicGFyZW5yaWdodGluZmVyaW9yIiwiaHlwaGVuc3VwZXJpb3IiLCJjb2xvbm1vbmV0YXJ5Iiwib25lZml0dGVkIiwicnVwaWFoIiwiY2VudG9sZHN0eWxlIiwiZmlndXJlZGFzaCIsImh5cGhlbmluZmVyaW9yIiwib25lcXVhcnRlciIsIm9uZWhhbGYiLCJ0aHJlZXF1YXJ0ZXJzIiwib25lZWlnaHRoIiwidGhyZWVlaWdodGhzIiwiZml2ZWVpZ2h0aHMiLCJzZXZlbmVpZ2h0aHMiLCJvbmV0aGlyZCIsInR3b3RoaXJkcyIsInplcm9zdXBlcmlvciIsIm9uZXN1cGVyaW9yIiwidHdvc3VwZXJpb3IiLCJ0aHJlZXN1cGVyaW9yIiwiZm91cnN1cGVyaW9yIiwiZml2ZXN1cGVyaW9yIiwic2l4c3VwZXJpb3IiLCJzZXZlbnN1cGVyaW9yIiwiZWlnaHRzdXBlcmlvciIsIm5pbmVzdXBlcmlvciIsInplcm9pbmZlcmlvciIsIm9uZWluZmVyaW9yIiwidHdvaW5mZXJpb3IiLCJ0aHJlZWluZmVyaW9yIiwiZm91cmluZmVyaW9yIiwiZml2ZWluZmVyaW9yIiwic2l4aW5mZXJpb3IiLCJzZXZlbmluZmVyaW9yIiwiZWlnaHRpbmZlcmlvciIsIm5pbmVpbmZlcmlvciIsImNlbnRpbmZlcmlvciIsImRvbGxhcmluZmVyaW9yIiwicGVyaW9kaW5mZXJpb3IiLCJjb21tYWluZmVyaW9yIl19LChlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuWmFwZkRpbmdiYXRzRW5jb2Rpbmc9dC5XaW5BbnNpRW5jb2Rpbmc9dC5TeW1ib2xTZXRFbmNvZGluZz10LlN0YW5kYXJkRW5jb2Rpbmc9dC5NYWNSb21hbkVuY29kaW5nPXQuRXhwZXJ0RW5jb2Rpbmc9dm9pZCAwO3QuZ2V0RW5jb2Rpbmc9ZnVuY3Rpb24gZ2V0RW5jb2RpbmcoZSl7c3dpdGNoKGUpe2Nhc2UiV2luQW5zaUVuY29kaW5nIjpyZXR1cm4gcztjYXNlIlN0YW5kYXJkRW5jb2RpbmciOnJldHVybiBpO2Nhc2UiTWFjUm9tYW5FbmNvZGluZyI6cmV0dXJuIG47Y2FzZSJTeW1ib2xTZXRFbmNvZGluZyI6cmV0dXJuIG87Y2FzZSJaYXBmRGluZ2JhdHNFbmNvZGluZyI6cmV0dXJuIGM7Y2FzZSJFeHBlcnRFbmNvZGluZyI6cmV0dXJuIGE7Y2FzZSJNYWNFeHBlcnRFbmNvZGluZyI6cmV0dXJuIHI7ZGVmYXVsdDpyZXR1cm4gbnVsbH19O2NvbnN0IGE9WyIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCJzcGFjZSIsImV4Y2xhbXNtYWxsIiwiSHVuZ2FydW1sYXV0c21hbGwiLCIiLCJkb2xsYXJvbGRzdHlsZSIsImRvbGxhcnN1cGVyaW9yIiwiYW1wZXJzYW5kc21hbGwiLCJBY3V0ZXNtYWxsIiwicGFyZW5sZWZ0c3VwZXJpb3IiLCJwYXJlbnJpZ2h0c3VwZXJpb3IiLCJ0d29kb3RlbmxlYWRlciIsIm9uZWRvdGVubGVhZGVyIiwiY29tbWEiLCJoeXBoZW4iLCJwZXJpb2QiLCJmcmFjdGlvbiIsInplcm9vbGRzdHlsZSIsIm9uZW9sZHN0eWxlIiwidHdvb2xkc3R5bGUiLCJ0aHJlZW9sZHN0eWxlIiwiZm91cm9sZHN0eWxlIiwiZml2ZW9sZHN0eWxlIiwic2l4b2xkc3R5bGUiLCJzZXZlbm9sZHN0eWxlIiwiZWlnaHRvbGRzdHlsZSIsIm5pbmVvbGRzdHlsZSIsImNvbG9uIiwic2VtaWNvbG9uIiwiY29tbWFzdXBlcmlvciIsInRocmVlcXVhcnRlcnNlbWRhc2giLCJwZXJpb2RzdXBlcmlvciIsInF1ZXN0aW9uc21hbGwiLCIiLCJhc3VwZXJpb3IiLCJic3VwZXJpb3IiLCJjZW50c3VwZXJpb3IiLCJkc3VwZXJpb3IiLCJlc3VwZXJpb3IiLCIiLCIiLCIiLCJpc3VwZXJpb3IiLCIiLCIiLCJsc3VwZXJpb3IiLCJtc3VwZXJpb3IiLCJuc3VwZXJpb3IiLCJvc3VwZXJpb3IiLCIiLCIiLCJyc3VwZXJpb3IiLCJzc3VwZXJpb3IiLCJ0c3VwZXJpb3IiLCIiLCJmZiIsImZpIiwiZmwiLCJmZmkiLCJmZmwiLCJwYXJlbmxlZnRpbmZlcmlvciIsIiIsInBhcmVucmlnaHRpbmZlcmlvciIsIkNpcmN1bWZsZXhzbWFsbCIsImh5cGhlbnN1cGVyaW9yIiwiR3JhdmVzbWFsbCIsIkFzbWFsbCIsIkJzbWFsbCIsIkNzbWFsbCIsIkRzbWFsbCIsIkVzbWFsbCIsIkZzbWFsbCIsIkdzbWFsbCIsIkhzbWFsbCIsIklzbWFsbCIsIkpzbWFsbCIsIktzbWFsbCIsIkxzbWFsbCIsIk1zbWFsbCIsIk5zbWFsbCIsIk9zbWFsbCIsIlBzbWFsbCIsIlFzbWFsbCIsIlJzbWFsbCIsIlNzbWFsbCIsIlRzbWFsbCIsIlVzbWFsbCIsIlZzbWFsbCIsIldzbWFsbCIsIlhzbWFsbCIsIllzbWFsbCIsIlpzbWFsbCIsImNvbG9ubW9uZXRhcnkiLCJvbmVmaXR0ZWQiLCJydXBpYWgiLCJUaWxkZXNtYWxsIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiZXhjbGFtZG93bnNtYWxsIiwiY2VudG9sZHN0eWxlIiwiTHNsYXNoc21hbGwiLCIiLCIiLCJTY2Fyb25zbWFsbCIsIlpjYXJvbnNtYWxsIiwiRGllcmVzaXNzbWFsbCIsIkJyZXZlc21hbGwiLCJDYXJvbnNtYWxsIiwiIiwiRG90YWNjZW50c21hbGwiLCIiLCIiLCJNYWNyb25zbWFsbCIsIiIsIiIsImZpZ3VyZWRhc2giLCJoeXBoZW5pbmZlcmlvciIsIiIsIiIsIk9nb25la3NtYWxsIiwiUmluZ3NtYWxsIiwiQ2VkaWxsYXNtYWxsIiwiIiwiIiwiIiwib25lcXVhcnRlciIsIm9uZWhhbGYiLCJ0aHJlZXF1YXJ0ZXJzIiwicXVlc3Rpb25kb3duc21hbGwiLCJvbmVlaWdodGgiLCJ0aHJlZWVpZ2h0aHMiLCJmaXZlZWlnaHRocyIsInNldmVuZWlnaHRocyIsIm9uZXRoaXJkIiwidHdvdGhpcmRzIiwiIiwiIiwiemVyb3N1cGVyaW9yIiwib25lc3VwZXJpb3IiLCJ0d29zdXBlcmlvciIsInRocmVlc3VwZXJpb3IiLCJmb3Vyc3VwZXJpb3IiLCJmaXZlc3VwZXJpb3IiLCJzaXhzdXBlcmlvciIsInNldmVuc3VwZXJpb3IiLCJlaWdodHN1cGVyaW9yIiwibmluZXN1cGVyaW9yIiwiemVyb2luZmVyaW9yIiwib25laW5mZXJpb3IiLCJ0d29pbmZlcmlvciIsInRocmVlaW5mZXJpb3IiLCJmb3VyaW5mZXJpb3IiLCJmaXZlaW5mZXJpb3IiLCJzaXhpbmZlcmlvciIsInNldmVuaW5mZXJpb3IiLCJlaWdodGluZmVyaW9yIiwibmluZWluZmVyaW9yIiwiY2VudGluZmVyaW9yIiwiZG9sbGFyaW5mZXJpb3IiLCJwZXJpb2RpbmZlcmlvciIsImNvbW1haW5mZXJpb3IiLCJBZ3JhdmVzbWFsbCIsIkFhY3V0ZXNtYWxsIiwiQWNpcmN1bWZsZXhzbWFsbCIsIkF0aWxkZXNtYWxsIiwiQWRpZXJlc2lzc21hbGwiLCJBcmluZ3NtYWxsIiwiQUVzbWFsbCIsIkNjZWRpbGxhc21hbGwiLCJFZ3JhdmVzbWFsbCIsIkVhY3V0ZXNtYWxsIiwiRWNpcmN1bWZsZXhzbWFsbCIsIkVkaWVyZXNpc3NtYWxsIiwiSWdyYXZlc21hbGwiLCJJYWN1dGVzbWFsbCIsIkljaXJjdW1mbGV4c21hbGwiLCJJZGllcmVzaXNzbWFsbCIsIkV0aHNtYWxsIiwiTnRpbGRlc21hbGwiLCJPZ3JhdmVzbWFsbCIsIk9hY3V0ZXNtYWxsIiwiT2NpcmN1bWZsZXhzbWFsbCIsIk90aWxkZXNtYWxsIiwiT2RpZXJlc2lzc21hbGwiLCJPRXNtYWxsIiwiT3NsYXNoc21hbGwiLCJVZ3JhdmVzbWFsbCIsIlVhY3V0ZXNtYWxsIiwiVWNpcmN1bWZsZXhzbWFsbCIsIlVkaWVyZXNpc3NtYWxsIiwiWWFjdXRlc21hbGwiLCJUaG9ybnNtYWxsIiwiWWRpZXJlc2lzc21hbGwiXTt0LkV4cGVydEVuY29kaW5nPWE7Y29uc3Qgcj1bIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsInNwYWNlIiwiZXhjbGFtc21hbGwiLCJIdW5nYXJ1bWxhdXRzbWFsbCIsImNlbnRvbGRzdHlsZSIsImRvbGxhcm9sZHN0eWxlIiwiZG9sbGFyc3VwZXJpb3IiLCJhbXBlcnNhbmRzbWFsbCIsIkFjdXRlc21hbGwiLCJwYXJlbmxlZnRzdXBlcmlvciIsInBhcmVucmlnaHRzdXBlcmlvciIsInR3b2RvdGVubGVhZGVyIiwib25lZG90ZW5sZWFkZXIiLCJjb21tYSIsImh5cGhlbiIsInBlcmlvZCIsImZyYWN0aW9uIiwiemVyb29sZHN0eWxlIiwib25lb2xkc3R5bGUiLCJ0d29vbGRzdHlsZSIsInRocmVlb2xkc3R5bGUiLCJmb3Vyb2xkc3R5bGUiLCJmaXZlb2xkc3R5bGUiLCJzaXhvbGRzdHlsZSIsInNldmVub2xkc3R5bGUiLCJlaWdodG9sZHN0eWxlIiwibmluZW9sZHN0eWxlIiwiY29sb24iLCJzZW1pY29sb24iLCIiLCJ0aHJlZXF1YXJ0ZXJzZW1kYXNoIiwiIiwicXVlc3Rpb25zbWFsbCIsIiIsIiIsIiIsIiIsIkV0aHNtYWxsIiwiIiwiIiwib25lcXVhcnRlciIsIm9uZWhhbGYiLCJ0aHJlZXF1YXJ0ZXJzIiwib25lZWlnaHRoIiwidGhyZWVlaWdodGhzIiwiZml2ZWVpZ2h0aHMiLCJzZXZlbmVpZ2h0aHMiLCJvbmV0aGlyZCIsInR3b3RoaXJkcyIsIiIsIiIsIiIsIiIsIiIsIiIsImZmIiwiZmkiLCJmbCIsImZmaSIsImZmbCIsInBhcmVubGVmdGluZmVyaW9yIiwiIiwicGFyZW5yaWdodGluZmVyaW9yIiwiQ2lyY3VtZmxleHNtYWxsIiwiaHlwaGVuaW5mZXJpb3IiLCJHcmF2ZXNtYWxsIiwiQXNtYWxsIiwiQnNtYWxsIiwiQ3NtYWxsIiwiRHNtYWxsIiwiRXNtYWxsIiwiRnNtYWxsIiwiR3NtYWxsIiwiSHNtYWxsIiwiSXNtYWxsIiwiSnNtYWxsIiwiS3NtYWxsIiwiTHNtYWxsIiwiTXNtYWxsIiwiTnNtYWxsIiwiT3NtYWxsIiwiUHNtYWxsIiwiUXNtYWxsIiwiUnNtYWxsIiwiU3NtYWxsIiwiVHNtYWxsIiwiVXNtYWxsIiwiVnNtYWxsIiwiV3NtYWxsIiwiWHNtYWxsIiwiWXNtYWxsIiwiWnNtYWxsIiwiY29sb25tb25ldGFyeSIsIm9uZWZpdHRlZCIsInJ1cGlhaCIsIlRpbGRlc21hbGwiLCIiLCIiLCJhc3VwZXJpb3IiLCJjZW50c3VwZXJpb3IiLCIiLCIiLCIiLCIiLCJBYWN1dGVzbWFsbCIsIkFncmF2ZXNtYWxsIiwiQWNpcmN1bWZsZXhzbWFsbCIsIkFkaWVyZXNpc3NtYWxsIiwiQXRpbGRlc21hbGwiLCJBcmluZ3NtYWxsIiwiQ2NlZGlsbGFzbWFsbCIsIkVhY3V0ZXNtYWxsIiwiRWdyYXZlc21hbGwiLCJFY2lyY3VtZmxleHNtYWxsIiwiRWRpZXJlc2lzc21hbGwiLCJJYWN1dGVzbWFsbCIsIklncmF2ZXNtYWxsIiwiSWNpcmN1bWZsZXhzbWFsbCIsIklkaWVyZXNpc3NtYWxsIiwiTnRpbGRlc21hbGwiLCJPYWN1dGVzbWFsbCIsIk9ncmF2ZXNtYWxsIiwiT2NpcmN1bWZsZXhzbWFsbCIsIk9kaWVyZXNpc3NtYWxsIiwiT3RpbGRlc21hbGwiLCJVYWN1dGVzbWFsbCIsIlVncmF2ZXNtYWxsIiwiVWNpcmN1bWZsZXhzbWFsbCIsIlVkaWVyZXNpc3NtYWxsIiwiIiwiZWlnaHRzdXBlcmlvciIsImZvdXJpbmZlcmlvciIsInRocmVlaW5mZXJpb3IiLCJzaXhpbmZlcmlvciIsImVpZ2h0aW5mZXJpb3IiLCJzZXZlbmluZmVyaW9yIiwiU2Nhcm9uc21hbGwiLCIiLCJjZW50aW5mZXJpb3IiLCJ0d29pbmZlcmlvciIsIiIsIkRpZXJlc2lzc21hbGwiLCIiLCJDYXJvbnNtYWxsIiwib3N1cGVyaW9yIiwiZml2ZWluZmVyaW9yIiwiIiwiY29tbWFpbmZlcmlvciIsInBlcmlvZGluZmVyaW9yIiwiWWFjdXRlc21hbGwiLCIiLCJkb2xsYXJpbmZlcmlvciIsIiIsIiIsIlRob3Juc21hbGwiLCIiLCJuaW5laW5mZXJpb3IiLCJ6ZXJvaW5mZXJpb3IiLCJaY2Fyb25zbWFsbCIsIkFFc21hbGwiLCJPc2xhc2hzbWFsbCIsInF1ZXN0aW9uZG93bnNtYWxsIiwib25laW5mZXJpb3IiLCJMc2xhc2hzbWFsbCIsIiIsIiIsIiIsIiIsIiIsIiIsIkNlZGlsbGFzbWFsbCIsIiIsIiIsIiIsIiIsIiIsIk9Fc21hbGwiLCJmaWd1cmVkYXNoIiwiaHlwaGVuc3VwZXJpb3IiLCIiLCIiLCIiLCIiLCJleGNsYW1kb3duc21hbGwiLCIiLCJZZGllcmVzaXNzbWFsbCIsIiIsIm9uZXN1cGVyaW9yIiwidHdvc3VwZXJpb3IiLCJ0aHJlZXN1cGVyaW9yIiwiZm91cnN1cGVyaW9yIiwiZml2ZXN1cGVyaW9yIiwic2l4c3VwZXJpb3IiLCJzZXZlbnN1cGVyaW9yIiwibmluZXN1cGVyaW9yIiwiemVyb3N1cGVyaW9yIiwiIiwiZXN1cGVyaW9yIiwicnN1cGVyaW9yIiwidHN1cGVyaW9yIiwiIiwiIiwiaXN1cGVyaW9yIiwic3N1cGVyaW9yIiwiZHN1cGVyaW9yIiwiIiwiIiwiIiwiIiwiIiwibHN1cGVyaW9yIiwiT2dvbmVrc21hbGwiLCJCcmV2ZXNtYWxsIiwiTWFjcm9uc21hbGwiLCJic3VwZXJpb3IiLCJuc3VwZXJpb3IiLCJtc3VwZXJpb3IiLCJjb21tYXN1cGVyaW9yIiwicGVyaW9kc3VwZXJpb3IiLCJEb3RhY2NlbnRzbWFsbCIsIlJpbmdzbWFsbCIsIiIsIiIsIiIsIiJdLG49WyIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCJzcGFjZSIsImV4Y2xhbSIsInF1b3RlZGJsIiwibnVtYmVyc2lnbiIsImRvbGxhciIsInBlcmNlbnQiLCJhbXBlcnNhbmQiLCJxdW90ZXNpbmdsZSIsInBhcmVubGVmdCIsInBhcmVucmlnaHQiLCJhc3RlcmlzayIsInBsdXMiLCJjb21tYSIsImh5cGhlbiIsInBlcmlvZCIsInNsYXNoIiwiemVybyIsIm9uZSIsInR3byIsInRocmVlIiwiZm91ciIsImZpdmUiLCJzaXgiLCJzZXZlbiIsImVpZ2h0IiwibmluZSIsImNvbG9uIiwic2VtaWNvbG9uIiwibGVzcyIsImVxdWFsIiwiZ3JlYXRlciIsInF1ZXN0aW9uIiwiYXQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsIkkiLCJKIiwiSyIsIkwiLCJNIiwiTiIsIk8iLCJQIiwiUSIsIlIiLCJTIiwiVCIsIlUiLCJWIiwiVyIsIlgiLCJZIiwiWiIsImJyYWNrZXRsZWZ0IiwiYmFja3NsYXNoIiwiYnJhY2tldHJpZ2h0IiwiYXNjaWljaXJjdW0iLCJ1bmRlcnNjb3JlIiwiZ3JhdmUiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnIiwiaCIsImkiLCJqIiwiayIsImwiLCJtIiwibiIsIm8iLCJwIiwicSIsInIiLCJzIiwidCIsInUiLCJ2IiwidyIsIngiLCJ5IiwieiIsImJyYWNlbGVmdCIsImJhciIsImJyYWNlcmlnaHQiLCJhc2NpaXRpbGRlIiwiIiwiQWRpZXJlc2lzIiwiQXJpbmciLCJDY2VkaWxsYSIsIkVhY3V0ZSIsIk50aWxkZSIsIk9kaWVyZXNpcyIsIlVkaWVyZXNpcyIsImFhY3V0ZSIsImFncmF2ZSIsImFjaXJjdW1mbGV4IiwiYWRpZXJlc2lzIiwiYXRpbGRlIiwiYXJpbmciLCJjY2VkaWxsYSIsImVhY3V0ZSIsImVncmF2ZSIsImVjaXJjdW1mbGV4IiwiZWRpZXJlc2lzIiwiaWFjdXRlIiwiaWdyYXZlIiwiaWNpcmN1bWZsZXgiLCJpZGllcmVzaXMiLCJudGlsZGUiLCJvYWN1dGUiLCJvZ3JhdmUiLCJvY2lyY3VtZmxleCIsIm9kaWVyZXNpcyIsIm90aWxkZSIsInVhY3V0ZSIsInVncmF2ZSIsInVjaXJjdW1mbGV4IiwidWRpZXJlc2lzIiwiZGFnZ2VyIiwiZGVncmVlIiwiY2VudCIsInN0ZXJsaW5nIiwic2VjdGlvbiIsImJ1bGxldCIsInBhcmFncmFwaCIsImdlcm1hbmRibHMiLCJyZWdpc3RlcmVkIiwiY29weXJpZ2h0IiwidHJhZGVtYXJrIiwiYWN1dGUiLCJkaWVyZXNpcyIsIm5vdGVxdWFsIiwiQUUiLCJPc2xhc2giLCJpbmZpbml0eSIsInBsdXNtaW51cyIsImxlc3NlcXVhbCIsImdyZWF0ZXJlcXVhbCIsInllbiIsIm11IiwicGFydGlhbGRpZmYiLCJzdW1tYXRpb24iLCJwcm9kdWN0IiwicGkiLCJpbnRlZ3JhbCIsIm9yZGZlbWluaW5lIiwib3JkbWFzY3VsaW5lIiwiT21lZ2EiLCJhZSIsIm9zbGFzaCIsInF1ZXN0aW9uZG93biIsImV4Y2xhbWRvd24iLCJsb2dpY2Fsbm90IiwicmFkaWNhbCIsImZsb3JpbiIsImFwcHJveGVxdWFsIiwiRGVsdGEiLCJndWlsbGVtb3RsZWZ0IiwiZ3VpbGxlbW90cmlnaHQiLCJlbGxpcHNpcyIsInNwYWNlIiwiQWdyYXZlIiwiQXRpbGRlIiwiT3RpbGRlIiwiT0UiLCJvZSIsImVuZGFzaCIsImVtZGFzaCIsInF1b3RlZGJsbGVmdCIsInF1b3RlZGJscmlnaHQiLCJxdW90ZWxlZnQiLCJxdW90ZXJpZ2h0IiwiZGl2aWRlIiwibG96ZW5nZSIsInlkaWVyZXNpcyIsIllkaWVyZXNpcyIsImZyYWN0aW9uIiwiY3VycmVuY3kiLCJndWlsc2luZ2xsZWZ0IiwiZ3VpbHNpbmdscmlnaHQiLCJmaSIsImZsIiwiZGFnZ2VyZGJsIiwicGVyaW9kY2VudGVyZWQiLCJxdW90ZXNpbmdsYmFzZSIsInF1b3RlZGJsYmFzZSIsInBlcnRob3VzYW5kIiwiQWNpcmN1bWZsZXgiLCJFY2lyY3VtZmxleCIsIkFhY3V0ZSIsIkVkaWVyZXNpcyIsIkVncmF2ZSIsIklhY3V0ZSIsIkljaXJjdW1mbGV4IiwiSWRpZXJlc2lzIiwiSWdyYXZlIiwiT2FjdXRlIiwiT2NpcmN1bWZsZXgiLCJhcHBsZSIsIk9ncmF2ZSIsIlVhY3V0ZSIsIlVjaXJjdW1mbGV4IiwiVWdyYXZlIiwiZG90bGVzc2kiLCJjaXJjdW1mbGV4IiwidGlsZGUiLCJtYWNyb24iLCJicmV2ZSIsImRvdGFjY2VudCIsInJpbmciLCJjZWRpbGxhIiwiaHVuZ2FydW1sYXV0Iiwib2dvbmVrIiwiY2Fyb24iXTt0Lk1hY1JvbWFuRW5jb2Rpbmc9bjtjb25zdCBpPVsiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwic3BhY2UiLCJleGNsYW0iLCJxdW90ZWRibCIsIm51bWJlcnNpZ24iLCJkb2xsYXIiLCJwZXJjZW50IiwiYW1wZXJzYW5kIiwicXVvdGVyaWdodCIsInBhcmVubGVmdCIsInBhcmVucmlnaHQiLCJhc3RlcmlzayIsInBsdXMiLCJjb21tYSIsImh5cGhlbiIsInBlcmlvZCIsInNsYXNoIiwiemVybyIsIm9uZSIsInR3byIsInRocmVlIiwiZm91ciIsImZpdmUiLCJzaXgiLCJzZXZlbiIsImVpZ2h0IiwibmluZSIsImNvbG9uIiwic2VtaWNvbG9uIiwibGVzcyIsImVxdWFsIiwiZ3JlYXRlciIsInF1ZXN0aW9uIiwiYXQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsIkkiLCJKIiwiSyIsIkwiLCJNIiwiTiIsIk8iLCJQIiwiUSIsIlIiLCJTIiwiVCIsIlUiLCJWIiwiVyIsIlgiLCJZIiwiWiIsImJyYWNrZXRsZWZ0IiwiYmFja3NsYXNoIiwiYnJhY2tldHJpZ2h0IiwiYXNjaWljaXJjdW0iLCJ1bmRlcnNjb3JlIiwicXVvdGVsZWZ0IiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImgiLCJpIiwiaiIsImsiLCJsIiwibSIsIm4iLCJvIiwicCIsInEiLCJyIiwicyIsInQiLCJ1IiwidiIsInciLCJ4IiwieSIsInoiLCJicmFjZWxlZnQiLCJiYXIiLCJicmFjZXJpZ2h0IiwiYXNjaWl0aWxkZSIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsImV4Y2xhbWRvd24iLCJjZW50Iiwic3RlcmxpbmciLCJmcmFjdGlvbiIsInllbiIsImZsb3JpbiIsInNlY3Rpb24iLCJjdXJyZW5jeSIsInF1b3Rlc2luZ2xlIiwicXVvdGVkYmxsZWZ0IiwiZ3VpbGxlbW90bGVmdCIsImd1aWxzaW5nbGxlZnQiLCJndWlsc2luZ2xyaWdodCIsImZpIiwiZmwiLCIiLCJlbmRhc2giLCJkYWdnZXIiLCJkYWdnZXJkYmwiLCJwZXJpb2RjZW50ZXJlZCIsIiIsInBhcmFncmFwaCIsImJ1bGxldCIsInF1b3Rlc2luZ2xiYXNlIiwicXVvdGVkYmxiYXNlIiwicXVvdGVkYmxyaWdodCIsImd1aWxsZW1vdHJpZ2h0IiwiZWxsaXBzaXMiLCJwZXJ0aG91c2FuZCIsIiIsInF1ZXN0aW9uZG93biIsIiIsImdyYXZlIiwiYWN1dGUiLCJjaXJjdW1mbGV4IiwidGlsZGUiLCJtYWNyb24iLCJicmV2ZSIsImRvdGFjY2VudCIsImRpZXJlc2lzIiwiIiwicmluZyIsImNlZGlsbGEiLCIiLCJodW5nYXJ1bWxhdXQiLCJvZ29uZWsiLCJjYXJvbiIsImVtZGFzaCIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIkFFIiwiIiwib3JkZmVtaW5pbmUiLCIiLCIiLCIiLCIiLCJMc2xhc2giLCJPc2xhc2giLCJPRSIsIm9yZG1hc2N1bGluZSIsIiIsIiIsIiIsIiIsIiIsImFlIiwiIiwiIiwiIiwiZG90bGVzc2kiLCIiLCIiLCJsc2xhc2giLCJvc2xhc2giLCJvZSIsImdlcm1hbmRibHMiLCIiLCIiLCIiLCIiXTt0LlN0YW5kYXJkRW5jb2Rpbmc9aTtjb25zdCBzPVsiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwic3BhY2UiLCJleGNsYW0iLCJxdW90ZWRibCIsIm51bWJlcnNpZ24iLCJkb2xsYXIiLCJwZXJjZW50IiwiYW1wZXJzYW5kIiwicXVvdGVzaW5nbGUiLCJwYXJlbmxlZnQiLCJwYXJlbnJpZ2h0IiwiYXN0ZXJpc2siLCJwbHVzIiwiY29tbWEiLCJoeXBoZW4iLCJwZXJpb2QiLCJzbGFzaCIsInplcm8iLCJvbmUiLCJ0d28iLCJ0aHJlZSIsImZvdXIiLCJmaXZlIiwic2l4Iiwic2V2ZW4iLCJlaWdodCIsIm5pbmUiLCJjb2xvbiIsInNlbWljb2xvbiIsImxlc3MiLCJlcXVhbCIsImdyZWF0ZXIiLCJxdWVzdGlvbiIsImF0IiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiRyIsIkgiLCJJIiwiSiIsIksiLCJMIiwiTSIsIk4iLCJPIiwiUCIsIlEiLCJSIiwiUyIsIlQiLCJVIiwiViIsIlciLCJYIiwiWSIsIloiLCJicmFja2V0bGVmdCIsImJhY2tzbGFzaCIsImJyYWNrZXRyaWdodCIsImFzY2lpY2lyY3VtIiwidW5kZXJzY29yZSIsImdyYXZlIiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImgiLCJpIiwiaiIsImsiLCJsIiwibSIsIm4iLCJvIiwicCIsInEiLCJyIiwicyIsInQiLCJ1IiwidiIsInciLCJ4IiwieSIsInoiLCJicmFjZWxlZnQiLCJiYXIiLCJicmFjZXJpZ2h0IiwiYXNjaWl0aWxkZSIsImJ1bGxldCIsIkV1cm8iLCJidWxsZXQiLCJxdW90ZXNpbmdsYmFzZSIsImZsb3JpbiIsInF1b3RlZGJsYmFzZSIsImVsbGlwc2lzIiwiZGFnZ2VyIiwiZGFnZ2VyZGJsIiwiY2lyY3VtZmxleCIsInBlcnRob3VzYW5kIiwiU2Nhcm9uIiwiZ3VpbHNpbmdsbGVmdCIsIk9FIiwiYnVsbGV0IiwiWmNhcm9uIiwiYnVsbGV0IiwiYnVsbGV0IiwicXVvdGVsZWZ0IiwicXVvdGVyaWdodCIsInF1b3RlZGJsbGVmdCIsInF1b3RlZGJscmlnaHQiLCJidWxsZXQiLCJlbmRhc2giLCJlbWRhc2giLCJ0aWxkZSIsInRyYWRlbWFyayIsInNjYXJvbiIsImd1aWxzaW5nbHJpZ2h0Iiwib2UiLCJidWxsZXQiLCJ6Y2Fyb24iLCJZZGllcmVzaXMiLCJzcGFjZSIsImV4Y2xhbWRvd24iLCJjZW50Iiwic3RlcmxpbmciLCJjdXJyZW5jeSIsInllbiIsImJyb2tlbmJhciIsInNlY3Rpb24iLCJkaWVyZXNpcyIsImNvcHlyaWdodCIsIm9yZGZlbWluaW5lIiwiZ3VpbGxlbW90bGVmdCIsImxvZ2ljYWxub3QiLCJoeXBoZW4iLCJyZWdpc3RlcmVkIiwibWFjcm9uIiwiZGVncmVlIiwicGx1c21pbnVzIiwidHdvc3VwZXJpb3IiLCJ0aHJlZXN1cGVyaW9yIiwiYWN1dGUiLCJtdSIsInBhcmFncmFwaCIsInBlcmlvZGNlbnRlcmVkIiwiY2VkaWxsYSIsIm9uZXN1cGVyaW9yIiwib3JkbWFzY3VsaW5lIiwiZ3VpbGxlbW90cmlnaHQiLCJvbmVxdWFydGVyIiwib25laGFsZiIsInRocmVlcXVhcnRlcnMiLCJxdWVzdGlvbmRvd24iLCJBZ3JhdmUiLCJBYWN1dGUiLCJBY2lyY3VtZmxleCIsIkF0aWxkZSIsIkFkaWVyZXNpcyIsIkFyaW5nIiwiQUUiLCJDY2VkaWxsYSIsIkVncmF2ZSIsIkVhY3V0ZSIsIkVjaXJjdW1mbGV4IiwiRWRpZXJlc2lzIiwiSWdyYXZlIiwiSWFjdXRlIiwiSWNpcmN1bWZsZXgiLCJJZGllcmVzaXMiLCJFdGgiLCJOdGlsZGUiLCJPZ3JhdmUiLCJPYWN1dGUiLCJPY2lyY3VtZmxleCIsIk90aWxkZSIsIk9kaWVyZXNpcyIsIm11bHRpcGx5IiwiT3NsYXNoIiwiVWdyYXZlIiwiVWFjdXRlIiwiVWNpcmN1bWZsZXgiLCJVZGllcmVzaXMiLCJZYWN1dGUiLCJUaG9ybiIsImdlcm1hbmRibHMiLCJhZ3JhdmUiLCJhYWN1dGUiLCJhY2lyY3VtZmxleCIsImF0aWxkZSIsImFkaWVyZXNpcyIsImFyaW5nIiwiYWUiLCJjY2VkaWxsYSIsImVncmF2ZSIsImVhY3V0ZSIsImVjaXJjdW1mbGV4IiwiZWRpZXJlc2lzIiwiaWdyYXZlIiwiaWFjdXRlIiwiaWNpcmN1bWZsZXgiLCJpZGllcmVzaXMiLCJldGgiLCJudGlsZGUiLCJvZ3JhdmUiLCJvYWN1dGUiLCJvY2lyY3VtZmxleCIsIm90aWxkZSIsIm9kaWVyZXNpcyIsImRpdmlkZSIsIm9zbGFzaCIsInVncmF2ZSIsInVhY3V0ZSIsInVjaXJjdW1mbGV4IiwidWRpZXJlc2lzIiwieWFjdXRlIiwidGhvcm4iLCJ5ZGllcmVzaXMiXTt0LldpbkFuc2lFbmNvZGluZz1zO2NvbnN0IG89WyIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCJzcGFjZSIsImV4Y2xhbSIsInVuaXZlcnNhbCIsIm51bWJlcnNpZ24iLCJleGlzdGVudGlhbCIsInBlcmNlbnQiLCJhbXBlcnNhbmQiLCJzdWNodGhhdCIsInBhcmVubGVmdCIsInBhcmVucmlnaHQiLCJhc3Rlcmlza21hdGgiLCJwbHVzIiwiY29tbWEiLCJtaW51cyIsInBlcmlvZCIsInNsYXNoIiwiemVybyIsIm9uZSIsInR3byIsInRocmVlIiwiZm91ciIsImZpdmUiLCJzaXgiLCJzZXZlbiIsImVpZ2h0IiwibmluZSIsImNvbG9uIiwic2VtaWNvbG9uIiwibGVzcyIsImVxdWFsIiwiZ3JlYXRlciIsInF1ZXN0aW9uIiwiY29uZ3J1ZW50IiwiQWxwaGEiLCJCZXRhIiwiQ2hpIiwiRGVsdGEiLCJFcHNpbG9uIiwiUGhpIiwiR2FtbWEiLCJFdGEiLCJJb3RhIiwidGhldGExIiwiS2FwcGEiLCJMYW1iZGEiLCJNdSIsIk51IiwiT21pY3JvbiIsIlBpIiwiVGhldGEiLCJSaG8iLCJTaWdtYSIsIlRhdSIsIlVwc2lsb24iLCJzaWdtYTEiLCJPbWVnYSIsIlhpIiwiUHNpIiwiWmV0YSIsImJyYWNrZXRsZWZ0IiwidGhlcmVmb3JlIiwiYnJhY2tldHJpZ2h0IiwicGVycGVuZGljdWxhciIsInVuZGVyc2NvcmUiLCJyYWRpY2FsZXgiLCJhbHBoYSIsImJldGEiLCJjaGkiLCJkZWx0YSIsImVwc2lsb24iLCJwaGkiLCJnYW1tYSIsImV0YSIsImlvdGEiLCJwaGkxIiwia2FwcGEiLCJsYW1iZGEiLCJtdSIsIm51Iiwib21pY3JvbiIsInBpIiwidGhldGEiLCJyaG8iLCJzaWdtYSIsInRhdSIsInVwc2lsb24iLCJvbWVnYTEiLCJvbWVnYSIsInhpIiwicHNpIiwiemV0YSIsImJyYWNlbGVmdCIsImJhciIsImJyYWNlcmlnaHQiLCJzaW1pbGFyIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiRXVybyIsIlVwc2lsb24xIiwibWludXRlIiwibGVzc2VxdWFsIiwiZnJhY3Rpb24iLCJpbmZpbml0eSIsImZsb3JpbiIsImNsdWIiLCJkaWFtb25kIiwiaGVhcnQiLCJzcGFkZSIsImFycm93Ym90aCIsImFycm93bGVmdCIsImFycm93dXAiLCJhcnJvd3JpZ2h0IiwiYXJyb3dkb3duIiwiZGVncmVlIiwicGx1c21pbnVzIiwic2Vjb25kIiwiZ3JlYXRlcmVxdWFsIiwibXVsdGlwbHkiLCJwcm9wb3J0aW9uYWwiLCJwYXJ0aWFsZGlmZiIsImJ1bGxldCIsImRpdmlkZSIsIm5vdGVxdWFsIiwiZXF1aXZhbGVuY2UiLCJhcHByb3hlcXVhbCIsImVsbGlwc2lzIiwiYXJyb3d2ZXJ0ZXgiLCJhcnJvd2hvcml6ZXgiLCJjYXJyaWFnZXJldHVybiIsImFsZXBoIiwiSWZyYWt0dXIiLCJSZnJha3R1ciIsIndlaWVyc3RyYXNzIiwiY2lyY2xlbXVsdGlwbHkiLCJjaXJjbGVwbHVzIiwiZW1wdHlzZXQiLCJpbnRlcnNlY3Rpb24iLCJ1bmlvbiIsInByb3BlcnN1cGVyc2V0IiwicmVmbGV4c3VwZXJzZXQiLCJub3RzdWJzZXQiLCJwcm9wZXJzdWJzZXQiLCJyZWZsZXhzdWJzZXQiLCJlbGVtZW50Iiwibm90ZWxlbWVudCIsImFuZ2xlIiwiZ3JhZGllbnQiLCJyZWdpc3RlcnNlcmlmIiwiY29weXJpZ2h0c2VyaWYiLCJ0cmFkZW1hcmtzZXJpZiIsInByb2R1Y3QiLCJyYWRpY2FsIiwiZG90bWF0aCIsImxvZ2ljYWxub3QiLCJsb2dpY2FsYW5kIiwibG9naWNhbG9yIiwiYXJyb3dkYmxib3RoIiwiYXJyb3dkYmxsZWZ0IiwiYXJyb3dkYmx1cCIsImFycm93ZGJscmlnaHQiLCJhcnJvd2RibGRvd24iLCJsb3plbmdlIiwiYW5nbGVsZWZ0IiwicmVnaXN0ZXJzYW5zIiwiY29weXJpZ2h0c2FucyIsInRyYWRlbWFya3NhbnMiLCJzdW1tYXRpb24iLCJwYXJlbmxlZnR0cCIsInBhcmVubGVmdGV4IiwicGFyZW5sZWZ0YnQiLCJicmFja2V0bGVmdHRwIiwiYnJhY2tldGxlZnRleCIsImJyYWNrZXRsZWZ0YnQiLCJicmFjZWxlZnR0cCIsImJyYWNlbGVmdG1pZCIsImJyYWNlbGVmdGJ0IiwiYnJhY2VleCIsIiIsImFuZ2xlcmlnaHQiLCJpbnRlZ3JhbCIsImludGVncmFsdHAiLCJpbnRlZ3JhbGV4IiwiaW50ZWdyYWxidCIsInBhcmVucmlnaHR0cCIsInBhcmVucmlnaHRleCIsInBhcmVucmlnaHRidCIsImJyYWNrZXRyaWdodHRwIiwiYnJhY2tldHJpZ2h0ZXgiLCJicmFja2V0cmlnaHRidCIsImJyYWNlcmlnaHR0cCIsImJyYWNlcmlnaHRtaWQiLCJicmFjZXJpZ2h0YnQiLCIiXTt0LlN5bWJvbFNldEVuY29kaW5nPW87Y29uc3QgYz1bIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsInNwYWNlIiwiYTEiLCJhMiIsImEyMDIiLCJhMyIsImE0IiwiYTUiLCJhMTE5IiwiYTExOCIsImExMTciLCJhMTEiLCJhMTIiLCJhMTMiLCJhMTQiLCJhMTUiLCJhMTYiLCJhMTA1IiwiYTE3IiwiYTE4IiwiYTE5IiwiYTIwIiwiYTIxIiwiYTIyIiwiYTIzIiwiYTI0IiwiYTI1IiwiYTI2IiwiYTI3IiwiYTI4IiwiYTYiLCJhNyIsImE4IiwiYTkiLCJhMTAiLCJhMjkiLCJhMzAiLCJhMzEiLCJhMzIiLCJhMzMiLCJhMzQiLCJhMzUiLCJhMzYiLCJhMzciLCJhMzgiLCJhMzkiLCJhNDAiLCJhNDEiLCJhNDIiLCJhNDMiLCJhNDQiLCJhNDUiLCJhNDYiLCJhNDciLCJhNDgiLCJhNDkiLCJhNTAiLCJhNTEiLCJhNTIiLCJhNTMiLCJhNTQiLCJhNTUiLCJhNTYiLCJhNTciLCJhNTgiLCJhNTkiLCJhNjAiLCJhNjEiLCJhNjIiLCJhNjMiLCJhNjQiLCJhNjUiLCJhNjYiLCJhNjciLCJhNjgiLCJhNjkiLCJhNzAiLCJhNzEiLCJhNzIiLCJhNzMiLCJhNzQiLCJhMjAzIiwiYTc1IiwiYTIwNCIsImE3NiIsImE3NyIsImE3OCIsImE3OSIsImE4MSIsImE4MiIsImE4MyIsImE4NCIsImE5NyIsImE5OCIsImE5OSIsImExMDAiLCIiLCJhODkiLCJhOTAiLCJhOTMiLCJhOTQiLCJhOTEiLCJhOTIiLCJhMjA1IiwiYTg1IiwiYTIwNiIsImE4NiIsImE4NyIsImE4OCIsImE5NSIsImE5NiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsImExMDEiLCJhMTAyIiwiYTEwMyIsImExMDQiLCJhMTA2IiwiYTEwNyIsImExMDgiLCJhMTEyIiwiYTExMSIsImExMTAiLCJhMTA5IiwiYTEyMCIsImExMjEiLCJhMTIyIiwiYTEyMyIsImExMjQiLCJhMTI1IiwiYTEyNiIsImExMjciLCJhMTI4IiwiYTEyOSIsImExMzAiLCJhMTMxIiwiYTEzMiIsImExMzMiLCJhMTM0IiwiYTEzNSIsImExMzYiLCJhMTM3IiwiYTEzOCIsImExMzkiLCJhMTQwIiwiYTE0MSIsImExNDIiLCJhMTQzIiwiYTE0NCIsImExNDUiLCJhMTQ2IiwiYTE0NyIsImExNDgiLCJhMTQ5IiwiYTE1MCIsImExNTEiLCJhMTUyIiwiYTE1MyIsImExNTQiLCJhMTU1IiwiYTE1NiIsImExNTciLCJhMTU4IiwiYTE1OSIsImExNjAiLCJhMTYxIiwiYTE2MyIsImExNjQiLCJhMTk2IiwiYTE2NSIsImExOTIiLCJhMTY2IiwiYTE2NyIsImExNjgiLCJhMTY5IiwiYTE3MCIsImExNzEiLCJhMTcyIiwiYTE3MyIsImExNjIiLCJhMTc0IiwiYTE3NSIsImExNzYiLCJhMTc3IiwiYTE3OCIsImExNzkiLCJhMTkzIiwiYTE4MCIsImExOTkiLCJhMTgxIiwiYTIwMCIsImExODIiLCIiLCJhMjAxIiwiYTE4MyIsImExODQiLCJhMTk3IiwiYTE4NSIsImExOTQiLCJhMTk4IiwiYTE4NiIsImExOTUiLCJhMTg3IiwiYTE4OCIsImExODkiLCJhMTkwIiwiYTE5MSIsIiJdO3QuWmFwZkRpbmdiYXRzRW5jb2Rpbmc9Y30sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LlNFQUNfQU5BTFlTSVNfRU5BQkxFRD10Lk1hY1N0YW5kYXJkR2x5cGhPcmRlcmluZz10LkZvbnRGbGFncz12b2lkIDA7dC5nZXRGb250VHlwZT1mdW5jdGlvbiBnZXRGb250VHlwZShlLHQsYT0hMSl7c3dpdGNoKGUpe2Nhc2UiVHlwZTEiOnJldHVybiBhP3IuRm9udFR5cGUuVFlQRTFTVEFOREFSRDoiVHlwZTFDIj09PXQ/ci5Gb250VHlwZS5UWVBFMUM6ci5Gb250VHlwZS5UWVBFMTtjYXNlIkNJREZvbnRUeXBlMCI6cmV0dXJuIkNJREZvbnRUeXBlMEMiPT09dD9yLkZvbnRUeXBlLkNJREZPTlRUWVBFMEM6ci5Gb250VHlwZS5DSURGT05UVFlQRTA7Y2FzZSJPcGVuVHlwZSI6cmV0dXJuIHIuRm9udFR5cGUuT1BFTlRZUEU7Y2FzZSJUcnVlVHlwZSI6cmV0dXJuIHIuRm9udFR5cGUuVFJVRVRZUEU7Y2FzZSJDSURGb250VHlwZTIiOnJldHVybiByLkZvbnRUeXBlLkNJREZPTlRUWVBFMjtjYXNlIk1NVHlwZTEiOnJldHVybiByLkZvbnRUeXBlLk1NVFlQRTE7Y2FzZSJUeXBlMCI6cmV0dXJuIHIuRm9udFR5cGUuVFlQRTA7ZGVmYXVsdDpyZXR1cm4gci5Gb250VHlwZS5VTktOT1dOfX07dC5ub3JtYWxpemVGb250TmFtZT1mdW5jdGlvbiBub3JtYWxpemVGb250TmFtZShlKXtyZXR1cm4gZS5yZXBsYWNlKC9bLF9dL2csIi0iKS5yZXBsYWNlKC9ccy9nLCIiKX07dC5yZWNvdmVyR2x5cGhOYW1lPXJlY292ZXJHbHlwaE5hbWU7dC50eXBlMUZvbnRHbHlwaE1hcHBpbmc9ZnVuY3Rpb24gdHlwZTFGb250R2x5cGhNYXBwaW5nKGUsdCxhKXtjb25zdCByPU9iamVjdC5jcmVhdGUobnVsbCk7bGV0IHMsYyxsO2NvbnN0IGg9ISEoZS5mbGFncyZvLlN5bWJvbGljKTtpZihlLmlzSW50ZXJuYWxGb250KXtsPXQ7Zm9yKGM9MDtjPGwubGVuZ3RoO2MrKyl7cz1hLmluZGV4T2YobFtjXSk7cltjXT1zPj0wP3M6MH19ZWxzZSBpZihlLmJhc2VFbmNvZGluZ05hbWUpe2w9KDAsbi5nZXRFbmNvZGluZykoZS5iYXNlRW5jb2RpbmdOYW1lKTtmb3IoYz0wO2M8bC5sZW5ndGg7YysrKXtzPWEuaW5kZXhPZihsW2NdKTtyW2NdPXM+PTA/czowfX1lbHNlIGlmKGgpZm9yKGMgaW4gdClyW2NdPXRbY107ZWxzZXtsPW4uU3RhbmRhcmRFbmNvZGluZztmb3IoYz0wO2M8bC5sZW5ndGg7YysrKXtzPWEuaW5kZXhPZihsW2NdKTtyW2NdPXM+PTA/czowfX1jb25zdCB1PWUuZGlmZmVyZW5jZXM7bGV0IGQ7aWYodSlmb3IoYyBpbiB1KXtjb25zdCBlPXVbY107cz1hLmluZGV4T2YoZSk7aWYoLTE9PT1zKXtkfHwoZD0oMCxpLmdldEdseXBoc1VuaWNvZGUpKCkpO2NvbnN0IHQ9cmVjb3ZlckdseXBoTmFtZShlLGQpO3QhPT1lJiYocz1hLmluZGV4T2YodCkpfXJbY109cz49MD9zOjB9cmV0dXJuIHJ9O3ZhciByPWEoMiksbj1hKDM3KSxpPWEoMzkpLHM9YSg0MCk7dC5TRUFDX0FOQUxZU0lTX0VOQUJMRUQ9ITA7Y29uc3Qgbz17Rml4ZWRQaXRjaDoxLFNlcmlmOjIsU3ltYm9saWM6NCxTY3JpcHQ6OCxOb25zeW1ib2xpYzozMixJdGFsaWM6NjQsQWxsQ2FwOjY1NTM2LFNtYWxsQ2FwOjEzMTA3MixGb3JjZUJvbGQ6MjYyMTQ0fTt0LkZvbnRGbGFncz1vO3QuTWFjU3RhbmRhcmRHbHlwaE9yZGVyaW5nPVsiLm5vdGRlZiIsIi5udWxsIiwibm9ubWFya2luZ3JldHVybiIsInNwYWNlIiwiZXhjbGFtIiwicXVvdGVkYmwiLCJudW1iZXJzaWduIiwiZG9sbGFyIiwicGVyY2VudCIsImFtcGVyc2FuZCIsInF1b3Rlc2luZ2xlIiwicGFyZW5sZWZ0IiwicGFyZW5yaWdodCIsImFzdGVyaXNrIiwicGx1cyIsImNvbW1hIiwiaHlwaGVuIiwicGVyaW9kIiwic2xhc2giLCJ6ZXJvIiwib25lIiwidHdvIiwidGhyZWUiLCJmb3VyIiwiZml2ZSIsInNpeCIsInNldmVuIiwiZWlnaHQiLCJuaW5lIiwiY29sb24iLCJzZW1pY29sb24iLCJsZXNzIiwiZXF1YWwiLCJncmVhdGVyIiwicXVlc3Rpb24iLCJhdCIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJIIiwiSSIsIkoiLCJLIiwiTCIsIk0iLCJOIiwiTyIsIlAiLCJRIiwiUiIsIlMiLCJUIiwiVSIsIlYiLCJXIiwiWCIsIlkiLCJaIiwiYnJhY2tldGxlZnQiLCJiYWNrc2xhc2giLCJicmFja2V0cmlnaHQiLCJhc2NpaWNpcmN1bSIsInVuZGVyc2NvcmUiLCJncmF2ZSIsImEiLCJiIiwiYyIsImQiLCJlIiwiZiIsImciLCJoIiwiaSIsImoiLCJrIiwibCIsIm0iLCJuIiwibyIsInAiLCJxIiwiciIsInMiLCJ0IiwidSIsInYiLCJ3IiwieCIsInkiLCJ6IiwiYnJhY2VsZWZ0IiwiYmFyIiwiYnJhY2VyaWdodCIsImFzY2lpdGlsZGUiLCJBZGllcmVzaXMiLCJBcmluZyIsIkNjZWRpbGxhIiwiRWFjdXRlIiwiTnRpbGRlIiwiT2RpZXJlc2lzIiwiVWRpZXJlc2lzIiwiYWFjdXRlIiwiYWdyYXZlIiwiYWNpcmN1bWZsZXgiLCJhZGllcmVzaXMiLCJhdGlsZGUiLCJhcmluZyIsImNjZWRpbGxhIiwiZWFjdXRlIiwiZWdyYXZlIiwiZWNpcmN1bWZsZXgiLCJlZGllcmVzaXMiLCJpYWN1dGUiLCJpZ3JhdmUiLCJpY2lyY3VtZmxleCIsImlkaWVyZXNpcyIsIm50aWxkZSIsIm9hY3V0ZSIsIm9ncmF2ZSIsIm9jaXJjdW1mbGV4Iiwib2RpZXJlc2lzIiwib3RpbGRlIiwidWFjdXRlIiwidWdyYXZlIiwidWNpcmN1bWZsZXgiLCJ1ZGllcmVzaXMiLCJkYWdnZXIiLCJkZWdyZWUiLCJjZW50Iiwic3RlcmxpbmciLCJzZWN0aW9uIiwiYnVsbGV0IiwicGFyYWdyYXBoIiwiZ2VybWFuZGJscyIsInJlZ2lzdGVyZWQiLCJjb3B5cmlnaHQiLCJ0cmFkZW1hcmsiLCJhY3V0ZSIsImRpZXJlc2lzIiwibm90ZXF1YWwiLCJBRSIsIk9zbGFzaCIsImluZmluaXR5IiwicGx1c21pbnVzIiwibGVzc2VxdWFsIiwiZ3JlYXRlcmVxdWFsIiwieWVuIiwibXUiLCJwYXJ0aWFsZGlmZiIsInN1bW1hdGlvbiIsInByb2R1Y3QiLCJwaSIsImludGVncmFsIiwib3JkZmVtaW5pbmUiLCJvcmRtYXNjdWxpbmUiLCJPbWVnYSIsImFlIiwib3NsYXNoIiwicXVlc3Rpb25kb3duIiwiZXhjbGFtZG93biIsImxvZ2ljYWxub3QiLCJyYWRpY2FsIiwiZmxvcmluIiwiYXBwcm94ZXF1YWwiLCJEZWx0YSIsImd1aWxsZW1vdGxlZnQiLCJndWlsbGVtb3RyaWdodCIsImVsbGlwc2lzIiwibm9uYnJlYWtpbmdzcGFjZSIsIkFncmF2ZSIsIkF0aWxkZSIsIk90aWxkZSIsIk9FIiwib2UiLCJlbmRhc2giLCJlbWRhc2giLCJxdW90ZWRibGxlZnQiLCJxdW90ZWRibHJpZ2h0IiwicXVvdGVsZWZ0IiwicXVvdGVyaWdodCIsImRpdmlkZSIsImxvemVuZ2UiLCJ5ZGllcmVzaXMiLCJZZGllcmVzaXMiLCJmcmFjdGlvbiIsImN1cnJlbmN5IiwiZ3VpbHNpbmdsbGVmdCIsImd1aWxzaW5nbHJpZ2h0IiwiZmkiLCJmbCIsImRhZ2dlcmRibCIsInBlcmlvZGNlbnRlcmVkIiwicXVvdGVzaW5nbGJhc2UiLCJxdW90ZWRibGJhc2UiLCJwZXJ0aG91c2FuZCIsIkFjaXJjdW1mbGV4IiwiRWNpcmN1bWZsZXgiLCJBYWN1dGUiLCJFZGllcmVzaXMiLCJFZ3JhdmUiLCJJYWN1dGUiLCJJY2lyY3VtZmxleCIsIklkaWVyZXNpcyIsIklncmF2ZSIsIk9hY3V0ZSIsIk9jaXJjdW1mbGV4IiwiYXBwbGUiLCJPZ3JhdmUiLCJVYWN1dGUiLCJVY2lyY3VtZmxleCIsIlVncmF2ZSIsImRvdGxlc3NpIiwiY2lyY3VtZmxleCIsInRpbGRlIiwibWFjcm9uIiwiYnJldmUiLCJkb3RhY2NlbnQiLCJyaW5nIiwiY2VkaWxsYSIsImh1bmdhcnVtbGF1dCIsIm9nb25layIsImNhcm9uIiwiTHNsYXNoIiwibHNsYXNoIiwiU2Nhcm9uIiwic2Nhcm9uIiwiWmNhcm9uIiwiemNhcm9uIiwiYnJva2VuYmFyIiwiRXRoIiwiZXRoIiwiWWFjdXRlIiwieWFjdXRlIiwiVGhvcm4iLCJ0aG9ybiIsIm1pbnVzIiwibXVsdGlwbHkiLCJvbmVzdXBlcmlvciIsInR3b3N1cGVyaW9yIiwidGhyZWVzdXBlcmlvciIsIm9uZWhhbGYiLCJvbmVxdWFydGVyIiwidGhyZWVxdWFydGVycyIsImZyYW5jIiwiR2JyZXZlIiwiZ2JyZXZlIiwiSWRvdGFjY2VudCIsIlNjZWRpbGxhIiwic2NlZGlsbGEiLCJDYWN1dGUiLCJjYWN1dGUiLCJDY2Fyb24iLCJjY2Fyb24iLCJkY3JvYXQiXTtmdW5jdGlvbiByZWNvdmVyR2x5cGhOYW1lKGUsdCl7aWYodm9pZCAwIT09dFtlXSlyZXR1cm4gZTtjb25zdCBhPSgwLHMuZ2V0VW5pY29kZUZvckdseXBoKShlLHQpO2lmKC0xIT09YSlmb3IoY29uc3QgZSBpbiB0KWlmKHRbZV09PT1hKXJldHVybiBlOygwLHIuaW5mbykoIlVuYWJsZSB0byByZWNvdmVyIGEgc3RhbmRhcmQgZ2x5cGggbmFtZSBmb3I6ICIrZSk7cmV0dXJuIGV9fSwoZSx0LGEpPT57YS5yKHQpO2EuZCh0LHtnZXREaW5nYmF0c0dseXBoc1VuaWNvZGU6KCk9PmksZ2V0R2x5cGhzVW5pY29kZTooKT0+bn0pO3ZhciByPWEoNik7Y29uc3Qgbj0oMCxyLmdldEFycmF5TG9va3VwVGFibGVGYWN0b3J5KSgoZnVuY3Rpb24oKXtyZXR1cm5bIkEiLDY1LCJBRSIsMTk4LCJBRWFjdXRlIiw1MDgsIkFFbWFjcm9uIiw0ODIsIkFFc21hbGwiLDYzNDYyLCJBYWN1dGUiLDE5MywiQWFjdXRlc21hbGwiLDYzNDU3LCJBYnJldmUiLDI1OCwiQWJyZXZlYWN1dGUiLDc4NTQsIkFicmV2ZWN5cmlsbGljIiwxMjMyLCJBYnJldmVkb3RiZWxvdyIsNzg2MiwiQWJyZXZlZ3JhdmUiLDc4NTYsIkFicmV2ZWhvb2thYm92ZSIsNzg1OCwiQWJyZXZldGlsZGUiLDc4NjAsIkFjYXJvbiIsNDYxLCJBY2lyY2xlIiw5Mzk4LCJBY2lyY3VtZmxleCIsMTk0LCJBY2lyY3VtZmxleGFjdXRlIiw3ODQ0LCJBY2lyY3VtZmxleGRvdGJlbG93Iiw3ODUyLCJBY2lyY3VtZmxleGdyYXZlIiw3ODQ2LCJBY2lyY3VtZmxleGhvb2thYm92ZSIsNzg0OCwiQWNpcmN1bWZsZXhzbWFsbCIsNjM0NTgsIkFjaXJjdW1mbGV4dGlsZGUiLDc4NTAsIkFjdXRlIiw2MzE3NywiQWN1dGVzbWFsbCIsNjM0MTIsIkFjeXJpbGxpYyIsMTA0MCwiQWRibGdyYXZlIiw1MTIsIkFkaWVyZXNpcyIsMTk2LCJBZGllcmVzaXNjeXJpbGxpYyIsMTIzNCwiQWRpZXJlc2lzbWFjcm9uIiw0NzgsIkFkaWVyZXNpc3NtYWxsIiw2MzQ2MCwiQWRvdGJlbG93Iiw3ODQwLCJBZG90bWFjcm9uIiw0ODAsIkFncmF2ZSIsMTkyLCJBZ3JhdmVzbWFsbCIsNjM0NTYsIkFob29rYWJvdmUiLDc4NDIsIkFpZWN5cmlsbGljIiwxMjM2LCJBaW52ZXJ0ZWRicmV2ZSIsNTE0LCJBbHBoYSIsOTEzLCJBbHBoYXRvbm9zIiw5MDIsIkFtYWNyb24iLDI1NiwiQW1vbm9zcGFjZSIsNjUzMTMsIkFvZ29uZWsiLDI2MCwiQXJpbmciLDE5NywiQXJpbmdhY3V0ZSIsNTA2LCJBcmluZ2JlbG93Iiw3NjgwLCJBcmluZ3NtYWxsIiw2MzQ2MSwiQXNtYWxsIiw2MzMyOSwiQXRpbGRlIiwxOTUsIkF0aWxkZXNtYWxsIiw2MzQ1OSwiQXliYXJtZW5pYW4iLDEzMjksIkIiLDY2LCJCY2lyY2xlIiw5Mzk5LCJCZG90YWNjZW50Iiw3NjgyLCJCZG90YmVsb3ciLDc2ODQsIkJlY3lyaWxsaWMiLDEwNDEsIkJlbmFybWVuaWFuIiwxMzMwLCJCZXRhIiw5MTQsIkJob29rIiwzODUsIkJsaW5lYmVsb3ciLDc2ODYsIkJtb25vc3BhY2UiLDY1MzE0LCJCcmV2ZXNtYWxsIiw2MzIyMCwiQnNtYWxsIiw2MzMzMCwiQnRvcGJhciIsMzg2LCJDIiw2NywiQ2Fhcm1lbmlhbiIsMTM0MiwiQ2FjdXRlIiwyNjIsIkNhcm9uIiw2MzE3OCwiQ2Fyb25zbWFsbCIsNjMyMjEsIkNjYXJvbiIsMjY4LCJDY2VkaWxsYSIsMTk5LCJDY2VkaWxsYWFjdXRlIiw3Njg4LCJDY2VkaWxsYXNtYWxsIiw2MzQ2MywiQ2NpcmNsZSIsOTQwMCwiQ2NpcmN1bWZsZXgiLDI2NCwiQ2RvdCIsMjY2LCJDZG90YWNjZW50IiwyNjYsIkNlZGlsbGFzbWFsbCIsNjM0MTYsIkNoYWFybWVuaWFuIiwxMzUzLCJDaGVhYmtoYXNpYW5jeXJpbGxpYyIsMTIxMiwiQ2hlY3lyaWxsaWMiLDEwNjMsIkNoZWRlc2NlbmRlcmFia2hhc2lhbmN5cmlsbGljIiwxMjE0LCJDaGVkZXNjZW5kZXJjeXJpbGxpYyIsMTIwNiwiQ2hlZGllcmVzaXNjeXJpbGxpYyIsMTI2OCwiQ2hlaGFybWVuaWFuIiwxMzQ3LCJDaGVraGFrYXNzaWFuY3lyaWxsaWMiLDEyMjcsIkNoZXZlcnRpY2Fsc3Ryb2tlY3lyaWxsaWMiLDEyMDgsIkNoaSIsOTM1LCJDaG9vayIsMzkxLCJDaXJjdW1mbGV4c21hbGwiLDYzMjIyLCJDbW9ub3NwYWNlIiw2NTMxNSwiQ29hcm1lbmlhbiIsMTM2MSwiQ3NtYWxsIiw2MzMzMSwiRCIsNjgsIkRaIiw0OTcsIkRaY2Fyb24iLDQ1MiwiRGFhcm1lbmlhbiIsMTMzMiwiRGFmcmljYW4iLDM5MywiRGNhcm9uIiwyNzAsIkRjZWRpbGxhIiw3Njk2LCJEY2lyY2xlIiw5NDAxLCJEY2lyY3VtZmxleGJlbG93Iiw3Njk4LCJEY3JvYXQiLDI3MiwiRGRvdGFjY2VudCIsNzY5MCwiRGRvdGJlbG93Iiw3NjkyLCJEZWN5cmlsbGljIiwxMDQ0LCJEZWljb3B0aWMiLDEwMDYsIkRlbHRhIiw4NzEwLCJEZWx0YWdyZWVrIiw5MTYsIkRob29rIiwzOTQsIkRpZXJlc2lzIiw2MzE3OSwiRGllcmVzaXNBY3V0ZSIsNjMxODAsIkRpZXJlc2lzR3JhdmUiLDYzMTgxLCJEaWVyZXNpc3NtYWxsIiw2MzQwMCwiRGlnYW1tYWdyZWVrIiw5ODgsIkRqZWN5cmlsbGljIiwxMDI2LCJEbGluZWJlbG93Iiw3Njk0LCJEbW9ub3NwYWNlIiw2NTMxNiwiRG90YWNjZW50c21hbGwiLDYzMjIzLCJEc2xhc2giLDI3MiwiRHNtYWxsIiw2MzMzMiwiRHRvcGJhciIsMzk1LCJEeiIsNDk4LCJEemNhcm9uIiw0NTMsIkR6ZWFia2hhc2lhbmN5cmlsbGljIiwxMjQ4LCJEemVjeXJpbGxpYyIsMTAyOSwiRHpoZWN5cmlsbGljIiwxMDM5LCJFIiw2OSwiRWFjdXRlIiwyMDEsIkVhY3V0ZXNtYWxsIiw2MzQ2NSwiRWJyZXZlIiwyNzYsIkVjYXJvbiIsMjgyLCJFY2VkaWxsYWJyZXZlIiw3NzA4LCJFY2hhcm1lbmlhbiIsMTMzMywiRWNpcmNsZSIsOTQwMiwiRWNpcmN1bWZsZXgiLDIwMiwiRWNpcmN1bWZsZXhhY3V0ZSIsNzg3MCwiRWNpcmN1bWZsZXhiZWxvdyIsNzcwNCwiRWNpcmN1bWZsZXhkb3RiZWxvdyIsNzg3OCwiRWNpcmN1bWZsZXhncmF2ZSIsNzg3MiwiRWNpcmN1bWZsZXhob29rYWJvdmUiLDc4NzQsIkVjaXJjdW1mbGV4c21hbGwiLDYzNDY2LCJFY2lyY3VtZmxleHRpbGRlIiw3ODc2LCJFY3lyaWxsaWMiLDEwMjgsIkVkYmxncmF2ZSIsNTE2LCJFZGllcmVzaXMiLDIwMywiRWRpZXJlc2lzc21hbGwiLDYzNDY3LCJFZG90IiwyNzgsIkVkb3RhY2NlbnQiLDI3OCwiRWRvdGJlbG93Iiw3ODY0LCJFZmN5cmlsbGljIiwxMDYwLCJFZ3JhdmUiLDIwMCwiRWdyYXZlc21hbGwiLDYzNDY0LCJFaGFybWVuaWFuIiwxMzM1LCJFaG9va2Fib3ZlIiw3ODY2LCJFaWdodHJvbWFuIiw4NTUxLCJFaW52ZXJ0ZWRicmV2ZSIsNTE4LCJFaW90aWZpZWRjeXJpbGxpYyIsMTEyNCwiRWxjeXJpbGxpYyIsMTA1MSwiRWxldmVucm9tYW4iLDg1NTQsIkVtYWNyb24iLDI3NCwiRW1hY3JvbmFjdXRlIiw3NzAyLCJFbWFjcm9uZ3JhdmUiLDc3MDAsIkVtY3lyaWxsaWMiLDEwNTIsIkVtb25vc3BhY2UiLDY1MzE3LCJFbmN5cmlsbGljIiwxMDUzLCJFbmRlc2NlbmRlcmN5cmlsbGljIiwxMTg2LCJFbmciLDMzMCwiRW5naGVjeXJpbGxpYyIsMTE4OCwiRW5ob29rY3lyaWxsaWMiLDEyMjMsIkVvZ29uZWsiLDI4MCwiRW9wZW4iLDQwMCwiRXBzaWxvbiIsOTE3LCJFcHNpbG9udG9ub3MiLDkwNCwiRXJjeXJpbGxpYyIsMTA1NiwiRXJldmVyc2VkIiwzOTgsIkVyZXZlcnNlZGN5cmlsbGljIiwxMDY5LCJFc2N5cmlsbGljIiwxMDU3LCJFc2Rlc2NlbmRlcmN5cmlsbGljIiwxMTk0LCJFc2giLDQyNSwiRXNtYWxsIiw2MzMzMywiRXRhIiw5MTksIkV0YXJtZW5pYW4iLDEzMzYsIkV0YXRvbm9zIiw5MDUsIkV0aCIsMjA4LCJFdGhzbWFsbCIsNjM0NzIsIkV0aWxkZSIsNzg2OCwiRXRpbGRlYmVsb3ciLDc3MDYsIkV1cm8iLDgzNjQsIkV6aCIsNDM5LCJFemhjYXJvbiIsNDk0LCJFemhyZXZlcnNlZCIsNDQwLCJGIiw3MCwiRmNpcmNsZSIsOTQwMywiRmRvdGFjY2VudCIsNzcxMCwiRmVoYXJtZW5pYW4iLDEzNjYsIkZlaWNvcHRpYyIsOTk2LCJGaG9vayIsNDAxLCJGaXRhY3lyaWxsaWMiLDExMzgsIkZpdmVyb21hbiIsODU0OCwiRm1vbm9zcGFjZSIsNjUzMTgsIkZvdXJyb21hbiIsODU0NywiRnNtYWxsIiw2MzMzNCwiRyIsNzEsIkdCc3F1YXJlIiwxMzE5MSwiR2FjdXRlIiw1MDAsIkdhbW1hIiw5MTUsIkdhbW1hYWZyaWNhbiIsNDA0LCJHYW5naWFjb3B0aWMiLDEwMDIsIkdicmV2ZSIsMjg2LCJHY2Fyb24iLDQ4NiwiR2NlZGlsbGEiLDI5MCwiR2NpcmNsZSIsOTQwNCwiR2NpcmN1bWZsZXgiLDI4NCwiR2NvbW1hYWNjZW50IiwyOTAsIkdkb3QiLDI4OCwiR2RvdGFjY2VudCIsMjg4LCJHZWN5cmlsbGljIiwxMDQzLCJHaGFkYXJtZW5pYW4iLDEzNDYsIkdoZW1pZGRsZWhvb2tjeXJpbGxpYyIsMTE3MiwiR2hlc3Ryb2tlY3lyaWxsaWMiLDExNzAsIkdoZXVwdHVybmN5cmlsbGljIiwxMTY4LCJHaG9vayIsNDAzLCJHaW1hcm1lbmlhbiIsMTMzMSwiR2plY3lyaWxsaWMiLDEwMjcsIkdtYWNyb24iLDc3MTIsIkdtb25vc3BhY2UiLDY1MzE5LCJHcmF2ZSIsNjMxODIsIkdyYXZlc21hbGwiLDYzMzI4LCJHc21hbGwiLDYzMzM1LCJHc21hbGxob29rIiw2NjcsIkdzdHJva2UiLDQ4NCwiSCIsNzIsIkgxODUzMyIsOTY3OSwiSDE4NTQzIiw5NjQyLCJIMTg1NTEiLDk2NDMsIkgyMjA3MyIsOTYzMywiSFBzcXVhcmUiLDEzMjU5LCJIYWFia2hhc2lhbmN5cmlsbGljIiwxMTkyLCJIYWRlc2NlbmRlcmN5cmlsbGljIiwxMjAyLCJIYXJkc2lnbmN5cmlsbGljIiwxMDY2LCJIYmFyIiwyOTQsIkhicmV2ZWJlbG93Iiw3NzIyLCJIY2VkaWxsYSIsNzcyMCwiSGNpcmNsZSIsOTQwNSwiSGNpcmN1bWZsZXgiLDI5MiwiSGRpZXJlc2lzIiw3NzE4LCJIZG90YWNjZW50Iiw3NzE0LCJIZG90YmVsb3ciLDc3MTYsIkhtb25vc3BhY2UiLDY1MzIwLCJIb2FybWVuaWFuIiwxMzQ0LCJIb3JpY29wdGljIiwxZTMsIkhzbWFsbCIsNjMzMzYsIkh1bmdhcnVtbGF1dCIsNjMxODMsIkh1bmdhcnVtbGF1dHNtYWxsIiw2MzIyNCwiSHpzcXVhcmUiLDEzMjAwLCJJIiw3MywiSUFjeXJpbGxpYyIsMTA3MSwiSUoiLDMwNiwiSVVjeXJpbGxpYyIsMTA3MCwiSWFjdXRlIiwyMDUsIklhY3V0ZXNtYWxsIiw2MzQ2OSwiSWJyZXZlIiwzMDAsIkljYXJvbiIsNDYzLCJJY2lyY2xlIiw5NDA2LCJJY2lyY3VtZmxleCIsMjA2LCJJY2lyY3VtZmxleHNtYWxsIiw2MzQ3MCwiSWN5cmlsbGljIiwxMDMwLCJJZGJsZ3JhdmUiLDUyMCwiSWRpZXJlc2lzIiwyMDcsIklkaWVyZXNpc2FjdXRlIiw3NzI2LCJJZGllcmVzaXNjeXJpbGxpYyIsMTI1MiwiSWRpZXJlc2lzc21hbGwiLDYzNDcxLCJJZG90IiwzMDQsIklkb3RhY2NlbnQiLDMwNCwiSWRvdGJlbG93Iiw3ODgyLCJJZWJyZXZlY3lyaWxsaWMiLDEyMzgsIkllY3lyaWxsaWMiLDEwNDUsIklmcmFrdHVyIiw4NDY1LCJJZ3JhdmUiLDIwNCwiSWdyYXZlc21hbGwiLDYzNDY4LCJJaG9va2Fib3ZlIiw3ODgwLCJJaWN5cmlsbGljIiwxMDQ4LCJJaW52ZXJ0ZWRicmV2ZSIsNTIyLCJJaXNob3J0Y3lyaWxsaWMiLDEwNDksIkltYWNyb24iLDI5OCwiSW1hY3JvbmN5cmlsbGljIiwxMjUwLCJJbW9ub3NwYWNlIiw2NTMyMSwiSW5pYXJtZW5pYW4iLDEzMzksIklvY3lyaWxsaWMiLDEwMjUsIklvZ29uZWsiLDMwMiwiSW90YSIsOTIxLCJJb3RhYWZyaWNhbiIsNDA2LCJJb3RhZGllcmVzaXMiLDkzOCwiSW90YXRvbm9zIiw5MDYsIklzbWFsbCIsNjMzMzcsIklzdHJva2UiLDQwNywiSXRpbGRlIiwyOTYsIkl0aWxkZWJlbG93Iiw3NzI0LCJJemhpdHNhY3lyaWxsaWMiLDExNDAsIkl6aGl0c2FkYmxncmF2ZWN5cmlsbGljIiwxMTQyLCJKIiw3NCwiSmFhcm1lbmlhbiIsMTM0NSwiSmNpcmNsZSIsOTQwNywiSmNpcmN1bWZsZXgiLDMwOCwiSmVjeXJpbGxpYyIsMTAzMiwiSmhlaGFybWVuaWFuIiwxMzU1LCJKbW9ub3NwYWNlIiw2NTMyMiwiSnNtYWxsIiw2MzMzOCwiSyIsNzUsIktCc3F1YXJlIiwxMzE4OSwiS0tzcXVhcmUiLDEzMjYxLCJLYWJhc2hraXJjeXJpbGxpYyIsMTE4NCwiS2FjdXRlIiw3NzI4LCJLYWN5cmlsbGljIiwxMDUwLCJLYWRlc2NlbmRlcmN5cmlsbGljIiwxMTc4LCJLYWhvb2tjeXJpbGxpYyIsMTIxOSwiS2FwcGEiLDkyMiwiS2FzdHJva2VjeXJpbGxpYyIsMTE4MiwiS2F2ZXJ0aWNhbHN0cm9rZWN5cmlsbGljIiwxMTgwLCJLY2Fyb24iLDQ4OCwiS2NlZGlsbGEiLDMxMCwiS2NpcmNsZSIsOTQwOCwiS2NvbW1hYWNjZW50IiwzMTAsIktkb3RiZWxvdyIsNzczMCwiS2VoYXJtZW5pYW4iLDEzNjQsIktlbmFybWVuaWFuIiwxMzQzLCJLaGFjeXJpbGxpYyIsMTA2MSwiS2hlaWNvcHRpYyIsOTk4LCJLaG9vayIsNDA4LCJLamVjeXJpbGxpYyIsMTAzNiwiS2xpbmViZWxvdyIsNzczMiwiS21vbm9zcGFjZSIsNjUzMjMsIktvcHBhY3lyaWxsaWMiLDExNTIsIktvcHBhZ3JlZWsiLDk5MCwiS3NpY3lyaWxsaWMiLDExMzQsIktzbWFsbCIsNjMzMzksIkwiLDc2LCJMSiIsNDU1LCJMTCIsNjMxNjcsIkxhY3V0ZSIsMzEzLCJMYW1iZGEiLDkyMywiTGNhcm9uIiwzMTcsIkxjZWRpbGxhIiwzMTUsIkxjaXJjbGUiLDk0MDksIkxjaXJjdW1mbGV4YmVsb3ciLDc3NDAsIkxjb21tYWFjY2VudCIsMzE1LCJMZG90IiwzMTksIkxkb3RhY2NlbnQiLDMxOSwiTGRvdGJlbG93Iiw3NzM0LCJMZG90YmVsb3dtYWNyb24iLDc3MzYsIkxpd25hcm1lbmlhbiIsMTM0MCwiTGoiLDQ1NiwiTGplY3lyaWxsaWMiLDEwMzMsIkxsaW5lYmVsb3ciLDc3MzgsIkxtb25vc3BhY2UiLDY1MzI0LCJMc2xhc2giLDMyMSwiTHNsYXNoc21hbGwiLDYzMjI1LCJMc21hbGwiLDYzMzQwLCJNIiw3NywiTUJzcXVhcmUiLDEzMTkwLCJNYWNyb24iLDYzMTg0LCJNYWNyb25zbWFsbCIsNjM0MDcsIk1hY3V0ZSIsNzc0MiwiTWNpcmNsZSIsOTQxMCwiTWRvdGFjY2VudCIsNzc0NCwiTWRvdGJlbG93Iiw3NzQ2LCJNZW5hcm1lbmlhbiIsMTM0OCwiTW1vbm9zcGFjZSIsNjUzMjUsIk1zbWFsbCIsNjMzNDEsIk10dXJuZWQiLDQxMiwiTXUiLDkyNCwiTiIsNzgsIk5KIiw0NTgsIk5hY3V0ZSIsMzIzLCJOY2Fyb24iLDMyNywiTmNlZGlsbGEiLDMyNSwiTmNpcmNsZSIsOTQxMSwiTmNpcmN1bWZsZXhiZWxvdyIsNzc1NCwiTmNvbW1hYWNjZW50IiwzMjUsIk5kb3RhY2NlbnQiLDc3NDgsIk5kb3RiZWxvdyIsNzc1MCwiTmhvb2tsZWZ0Iiw0MTMsIk5pbmVyb21hbiIsODU1MiwiTmoiLDQ1OSwiTmplY3lyaWxsaWMiLDEwMzQsIk5saW5lYmVsb3ciLDc3NTIsIk5tb25vc3BhY2UiLDY1MzI2LCJOb3dhcm1lbmlhbiIsMTM1MCwiTnNtYWxsIiw2MzM0MiwiTnRpbGRlIiwyMDksIk50aWxkZXNtYWxsIiw2MzQ3MywiTnUiLDkyNSwiTyIsNzksIk9FIiwzMzgsIk9Fc21hbGwiLDYzMjI2LCJPYWN1dGUiLDIxMSwiT2FjdXRlc21hbGwiLDYzNDc1LCJPYmFycmVkY3lyaWxsaWMiLDEyNTYsIk9iYXJyZWRkaWVyZXNpc2N5cmlsbGljIiwxMjU4LCJPYnJldmUiLDMzNCwiT2Nhcm9uIiw0NjUsIk9jZW50ZXJlZHRpbGRlIiw0MTUsIk9jaXJjbGUiLDk0MTIsIk9jaXJjdW1mbGV4IiwyMTIsIk9jaXJjdW1mbGV4YWN1dGUiLDc4ODgsIk9jaXJjdW1mbGV4ZG90YmVsb3ciLDc4OTYsIk9jaXJjdW1mbGV4Z3JhdmUiLDc4OTAsIk9jaXJjdW1mbGV4aG9va2Fib3ZlIiw3ODkyLCJPY2lyY3VtZmxleHNtYWxsIiw2MzQ3NiwiT2NpcmN1bWZsZXh0aWxkZSIsNzg5NCwiT2N5cmlsbGljIiwxMDU0LCJPZGJsYWN1dGUiLDMzNiwiT2RibGdyYXZlIiw1MjQsIk9kaWVyZXNpcyIsMjE0LCJPZGllcmVzaXNjeXJpbGxpYyIsMTI1NCwiT2RpZXJlc2lzc21hbGwiLDYzNDc4LCJPZG90YmVsb3ciLDc4ODQsIk9nb25la3NtYWxsIiw2MzIyNywiT2dyYXZlIiwyMTAsIk9ncmF2ZXNtYWxsIiw2MzQ3NCwiT2hhcm1lbmlhbiIsMTM2NSwiT2htIiw4NDg2LCJPaG9va2Fib3ZlIiw3ODg2LCJPaG9ybiIsNDE2LCJPaG9ybmFjdXRlIiw3ODk4LCJPaG9ybmRvdGJlbG93Iiw3OTA2LCJPaG9ybmdyYXZlIiw3OTAwLCJPaG9ybmhvb2thYm92ZSIsNzkwMiwiT2hvcm50aWxkZSIsNzkwNCwiT2h1bmdhcnVtbGF1dCIsMzM2LCJPaSIsNDE4LCJPaW52ZXJ0ZWRicmV2ZSIsNTI2LCJPbWFjcm9uIiwzMzIsIk9tYWNyb25hY3V0ZSIsNzc2MiwiT21hY3JvbmdyYXZlIiw3NzYwLCJPbWVnYSIsODQ4NiwiT21lZ2FjeXJpbGxpYyIsMTEyMCwiT21lZ2FncmVlayIsOTM3LCJPbWVnYXJvdW5kY3lyaWxsaWMiLDExNDYsIk9tZWdhdGl0bG9jeXJpbGxpYyIsMTE0OCwiT21lZ2F0b25vcyIsOTExLCJPbWljcm9uIiw5MjcsIk9taWNyb250b25vcyIsOTA4LCJPbW9ub3NwYWNlIiw2NTMyNywiT25lcm9tYW4iLDg1NDQsIk9vZ29uZWsiLDQ5MCwiT29nb25la21hY3JvbiIsNDkyLCJPb3BlbiIsMzkwLCJPc2xhc2giLDIxNiwiT3NsYXNoYWN1dGUiLDUxMCwiT3NsYXNoc21hbGwiLDYzNDgwLCJPc21hbGwiLDYzMzQzLCJPc3Ryb2tlYWN1dGUiLDUxMCwiT3RjeXJpbGxpYyIsMTE1MCwiT3RpbGRlIiwyMTMsIk90aWxkZWFjdXRlIiw3NzU2LCJPdGlsZGVkaWVyZXNpcyIsNzc1OCwiT3RpbGRlc21hbGwiLDYzNDc3LCJQIiw4MCwiUGFjdXRlIiw3NzY0LCJQY2lyY2xlIiw5NDEzLCJQZG90YWNjZW50Iiw3NzY2LCJQZWN5cmlsbGljIiwxMDU1LCJQZWhhcm1lbmlhbiIsMTM1NCwiUGVtaWRkbGVob29rY3lyaWxsaWMiLDExOTAsIlBoaSIsOTM0LCJQaG9vayIsNDIwLCJQaSIsOTI4LCJQaXdyYXJtZW5pYW4iLDEzNjMsIlBtb25vc3BhY2UiLDY1MzI4LCJQc2kiLDkzNiwiUHNpY3lyaWxsaWMiLDExMzYsIlBzbWFsbCIsNjMzNDQsIlEiLDgxLCJRY2lyY2xlIiw5NDE0LCJRbW9ub3NwYWNlIiw2NTMyOSwiUXNtYWxsIiw2MzM0NSwiUiIsODIsIlJhYXJtZW5pYW4iLDEzNTYsIlJhY3V0ZSIsMzQwLCJSY2Fyb24iLDM0NCwiUmNlZGlsbGEiLDM0MiwiUmNpcmNsZSIsOTQxNSwiUmNvbW1hYWNjZW50IiwzNDIsIlJkYmxncmF2ZSIsNTI4LCJSZG90YWNjZW50Iiw3NzY4LCJSZG90YmVsb3ciLDc3NzAsIlJkb3RiZWxvd21hY3JvbiIsNzc3MiwiUmVoYXJtZW5pYW4iLDEzNjAsIlJmcmFrdHVyIiw4NDc2LCJSaG8iLDkyOSwiUmluZ3NtYWxsIiw2MzIyOCwiUmludmVydGVkYnJldmUiLDUzMCwiUmxpbmViZWxvdyIsNzc3NCwiUm1vbm9zcGFjZSIsNjUzMzAsIlJzbWFsbCIsNjMzNDYsIlJzbWFsbGludmVydGVkIiw2NDEsIlJzbWFsbGludmVydGVkc3VwZXJpb3IiLDY5NCwiUyIsODMsIlNGMDEwMDAwIiw5NDg0LCJTRjAyMDAwMCIsOTQ5MiwiU0YwMzAwMDAiLDk0ODgsIlNGMDQwMDAwIiw5NDk2LCJTRjA1MDAwMCIsOTUzMiwiU0YwNjAwMDAiLDk1MTYsIlNGMDcwMDAwIiw5NTI0LCJTRjA4MDAwMCIsOTUwMCwiU0YwOTAwMDAiLDk1MDgsIlNGMTAwMDAwIiw5NDcyLCJTRjExMDAwMCIsOTQ3NCwiU0YxOTAwMDAiLDk1NjksIlNGMjAwMDAwIiw5NTcwLCJTRjIxMDAwMCIsOTU1OCwiU0YyMjAwMDAiLDk1NTcsIlNGMjMwMDAwIiw5NTcxLCJTRjI0MDAwMCIsOTU1MywiU0YyNTAwMDAiLDk1NTksIlNGMjYwMDAwIiw5NTY1LCJTRjI3MDAwMCIsOTU2NCwiU0YyODAwMDAiLDk1NjMsIlNGMzYwMDAwIiw5NTY2LCJTRjM3MDAwMCIsOTU2NywiU0YzODAwMDAiLDk1NjIsIlNGMzkwMDAwIiw5NTU2LCJTRjQwMDAwMCIsOTU3NywiU0Y0MTAwMDAiLDk1NzQsIlNGNDIwMDAwIiw5NTY4LCJTRjQzMDAwMCIsOTU1MiwiU0Y0NDAwMDAiLDk1ODAsIlNGNDUwMDAwIiw5NTc1LCJTRjQ2MDAwMCIsOTU3NiwiU0Y0NzAwMDAiLDk1NzIsIlNGNDgwMDAwIiw5NTczLCJTRjQ5MDAwMCIsOTU2MSwiU0Y1MDAwMDAiLDk1NjAsIlNGNTEwMDAwIiw5NTU0LCJTRjUyMDAwMCIsOTU1NSwiU0Y1MzAwMDAiLDk1NzksIlNGNTQwMDAwIiw5NTc4LCJTYWN1dGUiLDM0NiwiU2FjdXRlZG90YWNjZW50Iiw3NzgwLCJTYW1waWdyZWVrIiw5OTIsIlNjYXJvbiIsMzUyLCJTY2Fyb25kb3RhY2NlbnQiLDc3ODIsIlNjYXJvbnNtYWxsIiw2MzIyOSwiU2NlZGlsbGEiLDM1MCwiU2Nod2EiLDM5OSwiU2Nod2FjeXJpbGxpYyIsMTI0MCwiU2Nod2FkaWVyZXNpc2N5cmlsbGljIiwxMjQyLCJTY2lyY2xlIiw5NDE2LCJTY2lyY3VtZmxleCIsMzQ4LCJTY29tbWFhY2NlbnQiLDUzNiwiU2RvdGFjY2VudCIsNzc3NiwiU2RvdGJlbG93Iiw3Nzc4LCJTZG90YmVsb3dkb3RhY2NlbnQiLDc3ODQsIlNlaGFybWVuaWFuIiwxMzU3LCJTZXZlbnJvbWFuIiw4NTUwLCJTaGFhcm1lbmlhbiIsMTM1MSwiU2hhY3lyaWxsaWMiLDEwNjQsIlNoY2hhY3lyaWxsaWMiLDEwNjUsIlNoZWljb3B0aWMiLDk5NCwiU2hoYWN5cmlsbGljIiwxMjEwLCJTaGltYWNvcHRpYyIsMTAwNCwiU2lnbWEiLDkzMSwiU2l4cm9tYW4iLDg1NDksIlNtb25vc3BhY2UiLDY1MzMxLCJTb2Z0c2lnbmN5cmlsbGljIiwxMDY4LCJTc21hbGwiLDYzMzQ3LCJTdGlnbWFncmVlayIsOTg2LCJUIiw4NCwiVGF1Iiw5MzIsIlRiYXIiLDM1OCwiVGNhcm9uIiwzNTYsIlRjZWRpbGxhIiwzNTQsIlRjaXJjbGUiLDk0MTcsIlRjaXJjdW1mbGV4YmVsb3ciLDc3OTIsIlRjb21tYWFjY2VudCIsMzU0LCJUZG90YWNjZW50Iiw3Nzg2LCJUZG90YmVsb3ciLDc3ODgsIlRlY3lyaWxsaWMiLDEwNTgsIlRlZGVzY2VuZGVyY3lyaWxsaWMiLDExOTYsIlRlbnJvbWFuIiw4NTUzLCJUZXRzZWN5cmlsbGljIiwxMjA0LCJUaGV0YSIsOTIwLCJUaG9vayIsNDI4LCJUaG9ybiIsMjIyLCJUaG9ybnNtYWxsIiw2MzQ4NiwiVGhyZWVyb21hbiIsODU0NiwiVGlsZGVzbWFsbCIsNjMyMzAsIlRpd25hcm1lbmlhbiIsMTM1OSwiVGxpbmViZWxvdyIsNzc5MCwiVG1vbm9zcGFjZSIsNjUzMzIsIlRvYXJtZW5pYW4iLDEzMzcsIlRvbmVmaXZlIiw0NDQsIlRvbmVzaXgiLDM4OCwiVG9uZXR3byIsNDIzLCJUcmV0cm9mbGV4aG9vayIsNDMwLCJUc2VjeXJpbGxpYyIsMTA2MiwiVHNoZWN5cmlsbGljIiwxMDM1LCJUc21hbGwiLDYzMzQ4LCJUd2VsdmVyb21hbiIsODU1NSwiVHdvcm9tYW4iLDg1NDUsIlUiLDg1LCJVYWN1dGUiLDIxOCwiVWFjdXRlc21hbGwiLDYzNDgyLCJVYnJldmUiLDM2NCwiVWNhcm9uIiw0NjcsIlVjaXJjbGUiLDk0MTgsIlVjaXJjdW1mbGV4IiwyMTksIlVjaXJjdW1mbGV4YmVsb3ciLDc3OTgsIlVjaXJjdW1mbGV4c21hbGwiLDYzNDgzLCJVY3lyaWxsaWMiLDEwNTksIlVkYmxhY3V0ZSIsMzY4LCJVZGJsZ3JhdmUiLDUzMiwiVWRpZXJlc2lzIiwyMjAsIlVkaWVyZXNpc2FjdXRlIiw0NzEsIlVkaWVyZXNpc2JlbG93Iiw3Nzk0LCJVZGllcmVzaXNjYXJvbiIsNDczLCJVZGllcmVzaXNjeXJpbGxpYyIsMTI2NCwiVWRpZXJlc2lzZ3JhdmUiLDQ3NSwiVWRpZXJlc2lzbWFjcm9uIiw0NjksIlVkaWVyZXNpc3NtYWxsIiw2MzQ4NCwiVWRvdGJlbG93Iiw3OTA4LCJVZ3JhdmUiLDIxNywiVWdyYXZlc21hbGwiLDYzNDgxLCJVaG9va2Fib3ZlIiw3OTEwLCJVaG9ybiIsNDMxLCJVaG9ybmFjdXRlIiw3OTEyLCJVaG9ybmRvdGJlbG93Iiw3OTIwLCJVaG9ybmdyYXZlIiw3OTE0LCJVaG9ybmhvb2thYm92ZSIsNzkxNiwiVWhvcm50aWxkZSIsNzkxOCwiVWh1bmdhcnVtbGF1dCIsMzY4LCJVaHVuZ2FydW1sYXV0Y3lyaWxsaWMiLDEyNjYsIlVpbnZlcnRlZGJyZXZlIiw1MzQsIlVrY3lyaWxsaWMiLDExNDQsIlVtYWNyb24iLDM2MiwiVW1hY3JvbmN5cmlsbGljIiwxMjYyLCJVbWFjcm9uZGllcmVzaXMiLDc4MDIsIlVtb25vc3BhY2UiLDY1MzMzLCJVb2dvbmVrIiwzNzAsIlVwc2lsb24iLDkzMywiVXBzaWxvbjEiLDk3OCwiVXBzaWxvbmFjdXRlaG9va3N5bWJvbGdyZWVrIiw5NzksIlVwc2lsb25hZnJpY2FuIiw0MzMsIlVwc2lsb25kaWVyZXNpcyIsOTM5LCJVcHNpbG9uZGllcmVzaXNob29rc3ltYm9sZ3JlZWsiLDk4MCwiVXBzaWxvbmhvb2tzeW1ib2wiLDk3OCwiVXBzaWxvbnRvbm9zIiw5MTAsIlVyaW5nIiwzNjYsIlVzaG9ydGN5cmlsbGljIiwxMDM4LCJVc21hbGwiLDYzMzQ5LCJVc3RyYWlnaHRjeXJpbGxpYyIsMTE5OCwiVXN0cmFpZ2h0c3Ryb2tlY3lyaWxsaWMiLDEyMDAsIlV0aWxkZSIsMzYwLCJVdGlsZGVhY3V0ZSIsNzgwMCwiVXRpbGRlYmVsb3ciLDc3OTYsIlYiLDg2LCJWY2lyY2xlIiw5NDE5LCJWZG90YmVsb3ciLDc4MDYsIlZlY3lyaWxsaWMiLDEwNDIsIlZld2FybWVuaWFuIiwxMzU4LCJWaG9vayIsNDM0LCJWbW9ub3NwYWNlIiw2NTMzNCwiVm9hcm1lbmlhbiIsMTM1MiwiVnNtYWxsIiw2MzM1MCwiVnRpbGRlIiw3ODA0LCJXIiw4NywiV2FjdXRlIiw3ODEwLCJXY2lyY2xlIiw5NDIwLCJXY2lyY3VtZmxleCIsMzcyLCJXZGllcmVzaXMiLDc4MTIsIldkb3RhY2NlbnQiLDc4MTQsIldkb3RiZWxvdyIsNzgxNiwiV2dyYXZlIiw3ODA4LCJXbW9ub3NwYWNlIiw2NTMzNSwiV3NtYWxsIiw2MzM1MSwiWCIsODgsIlhjaXJjbGUiLDk0MjEsIlhkaWVyZXNpcyIsNzgyMCwiWGRvdGFjY2VudCIsNzgxOCwiWGVoYXJtZW5pYW4iLDEzNDEsIlhpIiw5MjYsIlhtb25vc3BhY2UiLDY1MzM2LCJYc21hbGwiLDYzMzUyLCJZIiw4OSwiWWFjdXRlIiwyMjEsIllhY3V0ZXNtYWxsIiw2MzQ4NSwiWWF0Y3lyaWxsaWMiLDExMjIsIlljaXJjbGUiLDk0MjIsIlljaXJjdW1mbGV4IiwzNzQsIllkaWVyZXNpcyIsMzc2LCJZZGllcmVzaXNzbWFsbCIsNjM0ODcsIllkb3RhY2NlbnQiLDc4MjIsIllkb3RiZWxvdyIsNzkyNCwiWWVyaWN5cmlsbGljIiwxMDY3LCJZZXJ1ZGllcmVzaXNjeXJpbGxpYyIsMTI3MiwiWWdyYXZlIiw3OTIyLCJZaG9vayIsNDM1LCJZaG9va2Fib3ZlIiw3OTI2LCJZaWFybWVuaWFuIiwxMzQ5LCJZaWN5cmlsbGljIiwxMDMxLCJZaXduYXJtZW5pYW4iLDEzNjIsIlltb25vc3BhY2UiLDY1MzM3LCJZc21hbGwiLDYzMzUzLCJZdGlsZGUiLDc5MjgsIll1c2JpZ2N5cmlsbGljIiwxMTMwLCJZdXNiaWdpb3RpZmllZGN5cmlsbGljIiwxMTMyLCJZdXNsaXR0bGVjeXJpbGxpYyIsMTEyNiwiWXVzbGl0dGxlaW90aWZpZWRjeXJpbGxpYyIsMTEyOCwiWiIsOTAsIlphYXJtZW5pYW4iLDEzMzQsIlphY3V0ZSIsMzc3LCJaY2Fyb24iLDM4MSwiWmNhcm9uc21hbGwiLDYzMjMxLCJaY2lyY2xlIiw5NDIzLCJaY2lyY3VtZmxleCIsNzgyNCwiWmRvdCIsMzc5LCJaZG90YWNjZW50IiwzNzksIlpkb3RiZWxvdyIsNzgyNiwiWmVjeXJpbGxpYyIsMTA0NywiWmVkZXNjZW5kZXJjeXJpbGxpYyIsMTE3NiwiWmVkaWVyZXNpc2N5cmlsbGljIiwxMjQ2LCJaZXRhIiw5MTgsIlpoZWFybWVuaWFuIiwxMzM4LCJaaGVicmV2ZWN5cmlsbGljIiwxMjE3LCJaaGVjeXJpbGxpYyIsMTA0NiwiWmhlZGVzY2VuZGVyY3lyaWxsaWMiLDExNzQsIlpoZWRpZXJlc2lzY3lyaWxsaWMiLDEyNDQsIlpsaW5lYmVsb3ciLDc4MjgsIlptb25vc3BhY2UiLDY1MzM4LCJac21hbGwiLDYzMzU0LCJac3Ryb2tlIiw0MzcsImEiLDk3LCJhYWJlbmdhbGkiLDI0MzgsImFhY3V0ZSIsMjI1LCJhYWRldmEiLDIzMTAsImFhZ3VqYXJhdGkiLDI2OTQsImFhZ3VybXVraGkiLDI1NjYsImFhbWF0cmFndXJtdWtoaSIsMjYyMiwiYWFydXNxdWFyZSIsMTMwNTksImFhdm93ZWxzaWduYmVuZ2FsaSIsMjQ5NCwiYWF2b3dlbHNpZ25kZXZhIiwyMzY2LCJhYXZvd2Vsc2lnbmd1amFyYXRpIiwyNzUwLCJhYmJyZXZpYXRpb25tYXJrYXJtZW5pYW4iLDEzNzUsImFiYnJldmlhdGlvbnNpZ25kZXZhIiwyNDE2LCJhYmVuZ2FsaSIsMjQzNywiYWJvcG9tb2ZvIiwxMjU3MCwiYWJyZXZlIiwyNTksImFicmV2ZWFjdXRlIiw3ODU1LCJhYnJldmVjeXJpbGxpYyIsMTIzMywiYWJyZXZlZG90YmVsb3ciLDc4NjMsImFicmV2ZWdyYXZlIiw3ODU3LCJhYnJldmVob29rYWJvdmUiLDc4NTksImFicmV2ZXRpbGRlIiw3ODYxLCJhY2Fyb24iLDQ2MiwiYWNpcmNsZSIsOTQyNCwiYWNpcmN1bWZsZXgiLDIyNiwiYWNpcmN1bWZsZXhhY3V0ZSIsNzg0NSwiYWNpcmN1bWZsZXhkb3RiZWxvdyIsNzg1MywiYWNpcmN1bWZsZXhncmF2ZSIsNzg0NywiYWNpcmN1bWZsZXhob29rYWJvdmUiLDc4NDksImFjaXJjdW1mbGV4dGlsZGUiLDc4NTEsImFjdXRlIiwxODAsImFjdXRlYmVsb3djbWIiLDc5MSwiYWN1dGVjbWIiLDc2OSwiYWN1dGVjb21iIiw3NjksImFjdXRlZGV2YSIsMjM4OCwiYWN1dGVsb3dtb2QiLDcxOSwiYWN1dGV0b25lY21iIiw4MzMsImFjeXJpbGxpYyIsMTA3MiwiYWRibGdyYXZlIiw1MTMsImFkZGFrZ3VybXVraGkiLDI2NzMsImFkZXZhIiwyMzA5LCJhZGllcmVzaXMiLDIyOCwiYWRpZXJlc2lzY3lyaWxsaWMiLDEyMzUsImFkaWVyZXNpc21hY3JvbiIsNDc5LCJhZG90YmVsb3ciLDc4NDEsImFkb3RtYWNyb24iLDQ4MSwiYWUiLDIzMCwiYWVhY3V0ZSIsNTA5LCJhZWtvcmVhbiIsMTI2MjQsImFlbWFjcm9uIiw0ODMsImFmaWkwMDIwOCIsODIxMywiYWZpaTA4OTQxIiw4MzU2LCJhZmlpMTAwMTciLDEwNDAsImFmaWkxMDAxOCIsMTA0MSwiYWZpaTEwMDE5IiwxMDQyLCJhZmlpMTAwMjAiLDEwNDMsImFmaWkxMDAyMSIsMTA0NCwiYWZpaTEwMDIyIiwxMDQ1LCJhZmlpMTAwMjMiLDEwMjUsImFmaWkxMDAyNCIsMTA0NiwiYWZpaTEwMDI1IiwxMDQ3LCJhZmlpMTAwMjYiLDEwNDgsImFmaWkxMDAyNyIsMTA0OSwiYWZpaTEwMDI4IiwxMDUwLCJhZmlpMTAwMjkiLDEwNTEsImFmaWkxMDAzMCIsMTA1MiwiYWZpaTEwMDMxIiwxMDUzLCJhZmlpMTAwMzIiLDEwNTQsImFmaWkxMDAzMyIsMTA1NSwiYWZpaTEwMDM0IiwxMDU2LCJhZmlpMTAwMzUiLDEwNTcsImFmaWkxMDAzNiIsMTA1OCwiYWZpaTEwMDM3IiwxMDU5LCJhZmlpMTAwMzgiLDEwNjAsImFmaWkxMDAzOSIsMTA2MSwiYWZpaTEwMDQwIiwxMDYyLCJhZmlpMTAwNDEiLDEwNjMsImFmaWkxMDA0MiIsMTA2NCwiYWZpaTEwMDQzIiwxMDY1LCJhZmlpMTAwNDQiLDEwNjYsImFmaWkxMDA0NSIsMTA2NywiYWZpaTEwMDQ2IiwxMDY4LCJhZmlpMTAwNDciLDEwNjksImFmaWkxMDA0OCIsMTA3MCwiYWZpaTEwMDQ5IiwxMDcxLCJhZmlpMTAwNTAiLDExNjgsImFmaWkxMDA1MSIsMTAyNiwiYWZpaTEwMDUyIiwxMDI3LCJhZmlpMTAwNTMiLDEwMjgsImFmaWkxMDA1NCIsMTAyOSwiYWZpaTEwMDU1IiwxMDMwLCJhZmlpMTAwNTYiLDEwMzEsImFmaWkxMDA1NyIsMTAzMiwiYWZpaTEwMDU4IiwxMDMzLCJhZmlpMTAwNTkiLDEwMzQsImFmaWkxMDA2MCIsMTAzNSwiYWZpaTEwMDYxIiwxMDM2LCJhZmlpMTAwNjIiLDEwMzgsImFmaWkxMDA2MyIsNjMxNzIsImFmaWkxMDA2NCIsNjMxNzMsImFmaWkxMDA2NSIsMTA3MiwiYWZpaTEwMDY2IiwxMDczLCJhZmlpMTAwNjciLDEwNzQsImFmaWkxMDA2OCIsMTA3NSwiYWZpaTEwMDY5IiwxMDc2LCJhZmlpMTAwNzAiLDEwNzcsImFmaWkxMDA3MSIsMTEwNSwiYWZpaTEwMDcyIiwxMDc4LCJhZmlpMTAwNzMiLDEwNzksImFmaWkxMDA3NCIsMTA4MCwiYWZpaTEwMDc1IiwxMDgxLCJhZmlpMTAwNzYiLDEwODIsImFmaWkxMDA3NyIsMTA4MywiYWZpaTEwMDc4IiwxMDg0LCJhZmlpMTAwNzkiLDEwODUsImFmaWkxMDA4MCIsMTA4NiwiYWZpaTEwMDgxIiwxMDg3LCJhZmlpMTAwODIiLDEwODgsImFmaWkxMDA4MyIsMTA4OSwiYWZpaTEwMDg0IiwxMDkwLCJhZmlpMTAwODUiLDEwOTEsImFmaWkxMDA4NiIsMTA5MiwiYWZpaTEwMDg3IiwxMDkzLCJhZmlpMTAwODgiLDEwOTQsImFmaWkxMDA4OSIsMTA5NSwiYWZpaTEwMDkwIiwxMDk2LCJhZmlpMTAwOTEiLDEwOTcsImFmaWkxMDA5MiIsMTA5OCwiYWZpaTEwMDkzIiwxMDk5LCJhZmlpMTAwOTQiLDExMDAsImFmaWkxMDA5NSIsMTEwMSwiYWZpaTEwMDk2IiwxMTAyLCJhZmlpMTAwOTciLDExMDMsImFmaWkxMDA5OCIsMTE2OSwiYWZpaTEwMDk5IiwxMTA2LCJhZmlpMTAxMDAiLDExMDcsImFmaWkxMDEwMSIsMTEwOCwiYWZpaTEwMTAyIiwxMTA5LCJhZmlpMTAxMDMiLDExMTAsImFmaWkxMDEwNCIsMTExMSwiYWZpaTEwMTA1IiwxMTEyLCJhZmlpMTAxMDYiLDExMTMsImFmaWkxMDEwNyIsMTExNCwiYWZpaTEwMTA4IiwxMTE1LCJhZmlpMTAxMDkiLDExMTYsImFmaWkxMDExMCIsMTExOCwiYWZpaTEwMTQ1IiwxMDM5LCJhZmlpMTAxNDYiLDExMjIsImFmaWkxMDE0NyIsMTEzOCwiYWZpaTEwMTQ4IiwxMTQwLCJhZmlpMTAxOTIiLDYzMTc0LCJhZmlpMTAxOTMiLDExMTksImFmaWkxMDE5NCIsMTEyMywiYWZpaTEwMTk1IiwxMTM5LCJhZmlpMTAxOTYiLDExNDEsImFmaWkxMDgzMSIsNjMxNzUsImFmaWkxMDgzMiIsNjMxNzYsImFmaWkxMDg0NiIsMTI0MSwiYWZpaTI5OSIsODIwNiwiYWZpaTMwMCIsODIwNywiYWZpaTMwMSIsODIwNSwiYWZpaTU3MzgxIiwxNjQyLCJhZmlpNTczODgiLDE1NDgsImFmaWk1NzM5MiIsMTYzMiwiYWZpaTU3MzkzIiwxNjMzLCJhZmlpNTczOTQiLDE2MzQsImFmaWk1NzM5NSIsMTYzNSwiYWZpaTU3Mzk2IiwxNjM2LCJhZmlpNTczOTciLDE2MzcsImFmaWk1NzM5OCIsMTYzOCwiYWZpaTU3Mzk5IiwxNjM5LCJhZmlpNTc0MDAiLDE2NDAsImFmaWk1NzQwMSIsMTY0MSwiYWZpaTU3NDAzIiwxNTYzLCJhZmlpNTc0MDciLDE1NjcsImFmaWk1NzQwOSIsMTU2OSwiYWZpaTU3NDEwIiwxNTcwLCJhZmlpNTc0MTEiLDE1NzEsImFmaWk1NzQxMiIsMTU3MiwiYWZpaTU3NDEzIiwxNTczLCJhZmlpNTc0MTQiLDE1NzQsImFmaWk1NzQxNSIsMTU3NSwiYWZpaTU3NDE2IiwxNTc2LCJhZmlpNTc0MTciLDE1NzcsImFmaWk1NzQxOCIsMTU3OCwiYWZpaTU3NDE5IiwxNTc5LCJhZmlpNTc0MjAiLDE1ODAsImFmaWk1NzQyMSIsMTU4MSwiYWZpaTU3NDIyIiwxNTgyLCJhZmlpNTc0MjMiLDE1ODMsImFmaWk1NzQyNCIsMTU4NCwiYWZpaTU3NDI1IiwxNTg1LCJhZmlpNTc0MjYiLDE1ODYsImFmaWk1NzQyNyIsMTU4NywiYWZpaTU3NDI4IiwxNTg4LCJhZmlpNTc0MjkiLDE1ODksImFmaWk1NzQzMCIsMTU5MCwiYWZpaTU3NDMxIiwxNTkxLCJhZmlpNTc0MzIiLDE1OTIsImFmaWk1NzQzMyIsMTU5MywiYWZpaTU3NDM0IiwxNTk0LCJhZmlpNTc0NDAiLDE2MDAsImFmaWk1NzQ0MSIsMTYwMSwiYWZpaTU3NDQyIiwxNjAyLCJhZmlpNTc0NDMiLDE2MDMsImFmaWk1NzQ0NCIsMTYwNCwiYWZpaTU3NDQ1IiwxNjA1LCJhZmlpNTc0NDYiLDE2MDYsImFmaWk1NzQ0OCIsMTYwOCwiYWZpaTU3NDQ5IiwxNjA5LCJhZmlpNTc0NTAiLDE2MTAsImFmaWk1NzQ1MSIsMTYxMSwiYWZpaTU3NDUyIiwxNjEyLCJhZmlpNTc0NTMiLDE2MTMsImFmaWk1NzQ1NCIsMTYxNCwiYWZpaTU3NDU1IiwxNjE1LCJhZmlpNTc0NTYiLDE2MTYsImFmaWk1NzQ1NyIsMTYxNywiYWZpaTU3NDU4IiwxNjE4LCJhZmlpNTc0NzAiLDE2MDcsImFmaWk1NzUwNSIsMTcwMCwiYWZpaTU3NTA2IiwxNjYyLCJhZmlpNTc1MDciLDE2NzAsImFmaWk1NzUwOCIsMTY4OCwiYWZpaTU3NTA5IiwxNzExLCJhZmlpNTc1MTEiLDE2NTcsImFmaWk1NzUxMiIsMTY3MiwiYWZpaTU3NTEzIiwxNjgxLCJhZmlpNTc1MTQiLDE3MjIsImFmaWk1NzUxOSIsMTc0NiwiYWZpaTU3NTM0IiwxNzQ5LCJhZmlpNTc2MzYiLDgzNjIsImFmaWk1NzY0NSIsMTQ3MCwiYWZpaTU3NjU4IiwxNDc1LCJhZmlpNTc2NjQiLDE0ODgsImFmaWk1NzY2NSIsMTQ4OSwiYWZpaTU3NjY2IiwxNDkwLCJhZmlpNTc2NjciLDE0OTEsImFmaWk1NzY2OCIsMTQ5MiwiYWZpaTU3NjY5IiwxNDkzLCJhZmlpNTc2NzAiLDE0OTQsImFmaWk1NzY3MSIsMTQ5NSwiYWZpaTU3NjcyIiwxNDk2LCJhZmlpNTc2NzMiLDE0OTcsImFmaWk1NzY3NCIsMTQ5OCwiYWZpaTU3Njc1IiwxNDk5LCJhZmlpNTc2NzYiLDE1MDAsImFmaWk1NzY3NyIsMTUwMSwiYWZpaTU3Njc4IiwxNTAyLCJhZmlpNTc2NzkiLDE1MDMsImFmaWk1NzY4MCIsMTUwNCwiYWZpaTU3NjgxIiwxNTA1LCJhZmlpNTc2ODIiLDE1MDYsImFmaWk1NzY4MyIsMTUwNywiYWZpaTU3Njg0IiwxNTA4LCJhZmlpNTc2ODUiLDE1MDksImFmaWk1NzY4NiIsMTUxMCwiYWZpaTU3Njg3IiwxNTExLCJhZmlpNTc2ODgiLDE1MTIsImFmaWk1NzY4OSIsMTUxMywiYWZpaTU3NjkwIiwxNTE0LCJhZmlpNTc2OTQiLDY0Mjk4LCJhZmlpNTc2OTUiLDY0Mjk5LCJhZmlpNTc3MDAiLDY0MzMxLCJhZmlpNTc3MDUiLDY0Mjg3LCJhZmlpNTc3MTYiLDE1MjAsImFmaWk1NzcxNyIsMTUyMSwiYWZpaTU3NzE4IiwxNTIyLCJhZmlpNTc3MjMiLDY0MzA5LCJhZmlpNTc3OTMiLDE0NjAsImFmaWk1Nzc5NCIsMTQ2MSwiYWZpaTU3Nzk1IiwxNDYyLCJhZmlpNTc3OTYiLDE0NjcsImFmaWk1Nzc5NyIsMTQ2NCwiYWZpaTU3Nzk4IiwxNDYzLCJhZmlpNTc3OTkiLDE0NTYsImFmaWk1NzgwMCIsMTQ1OCwiYWZpaTU3ODAxIiwxNDU3LCJhZmlpNTc4MDIiLDE0NTksImFmaWk1NzgwMyIsMTQ3NCwiYWZpaTU3ODA0IiwxNDczLCJhZmlpNTc4MDYiLDE0NjUsImFmaWk1NzgwNyIsMTQ2OCwiYWZpaTU3ODM5IiwxNDY5LCJhZmlpNTc4NDEiLDE0NzEsImFmaWk1Nzg0MiIsMTQ3MiwiYWZpaTU3OTI5Iiw3MDAsImFmaWk2MTI0OCIsODQ1MywiYWZpaTYxMjg5Iiw4NDY3LCJhZmlpNjEzNTIiLDg0NzAsImFmaWk2MTU3MyIsODIzNiwiYWZpaTYxNTc0Iiw4MjM3LCJhZmlpNjE1NzUiLDgyMzgsImFmaWk2MTY2NCIsODIwNCwiYWZpaTYzMTY3IiwxNjQ1LCJhZmlpNjQ5MzciLDcwMSwiYWdyYXZlIiwyMjQsImFndWphcmF0aSIsMjY5MywiYWd1cm11a2hpIiwyNTY1LCJhaGlyYWdhbmEiLDEyMzU0LCJhaG9va2Fib3ZlIiw3ODQzLCJhaWJlbmdhbGkiLDI0NDgsImFpYm9wb21vZm8iLDEyNTc0LCJhaWRldmEiLDIzMjAsImFpZWN5cmlsbGljIiwxMjM3LCJhaWd1amFyYXRpIiwyNzA0LCJhaWd1cm11a2hpIiwyNTc2LCJhaW1hdHJhZ3VybXVraGkiLDI2MzIsImFpbmFyYWJpYyIsMTU5MywiYWluZmluYWxhcmFiaWMiLDY1MjI2LCJhaW5pbml0aWFsYXJhYmljIiw2NTIyNywiYWlubWVkaWFsYXJhYmljIiw2NTIyOCwiYWludmVydGVkYnJldmUiLDUxNSwiYWl2b3dlbHNpZ25iZW5nYWxpIiwyNTA0LCJhaXZvd2Vsc2lnbmRldmEiLDIzNzYsImFpdm93ZWxzaWduZ3VqYXJhdGkiLDI3NjAsImFrYXRha2FuYSIsMTI0NTAsImFrYXRha2FuYWhhbGZ3aWR0aCIsNjUzOTMsImFrb3JlYW4iLDEyNjIzLCJhbGVmIiwxNDg4LCJhbGVmYXJhYmljIiwxNTc1LCJhbGVmZGFnZXNoaGVicmV3Iiw2NDMwNCwiYWxlZmZpbmFsYXJhYmljIiw2NTE2NiwiYWxlZmhhbXphYWJvdmVhcmFiaWMiLDE1NzEsImFsZWZoYW16YWFib3ZlZmluYWxhcmFiaWMiLDY1MTU2LCJhbGVmaGFtemFiZWxvd2FyYWJpYyIsMTU3MywiYWxlZmhhbXphYmVsb3dmaW5hbGFyYWJpYyIsNjUxNjAsImFsZWZoZWJyZXciLDE0ODgsImFsZWZsYW1lZGhlYnJldyIsNjQzMzUsImFsZWZtYWRkYWFib3ZlYXJhYmljIiwxNTcwLCJhbGVmbWFkZGFhYm92ZWZpbmFsYXJhYmljIiw2NTE1NCwiYWxlZm1ha3N1cmFhcmFiaWMiLDE2MDksImFsZWZtYWtzdXJhZmluYWxhcmFiaWMiLDY1MjY0LCJhbGVmbWFrc3VyYWluaXRpYWxhcmFiaWMiLDY1MjY3LCJhbGVmbWFrc3VyYW1lZGlhbGFyYWJpYyIsNjUyNjgsImFsZWZwYXRhaGhlYnJldyIsNjQzMDIsImFsZWZxYW1hdHNoZWJyZXciLDY0MzAzLCJhbGVwaCIsODUwMSwiYWxsZXF1YWwiLDg3ODAsImFscGhhIiw5NDUsImFscGhhdG9ub3MiLDk0MCwiYW1hY3JvbiIsMjU3LCJhbW9ub3NwYWNlIiw2NTM0NSwiYW1wZXJzYW5kIiwzOCwiYW1wZXJzYW5kbW9ub3NwYWNlIiw2NTI4NiwiYW1wZXJzYW5kc21hbGwiLDYzMjcwLCJhbXNxdWFyZSIsMTMyNTAsImFuYm9wb21vZm8iLDEyNTc4LCJhbmdib3BvbW9mbyIsMTI1ODAsImFuZ2JyYWNrZXRsZWZ0IiwxMjI5NiwiYW5nYnJhY2tldHJpZ2h0IiwxMjI5NywiYW5na2hhbmtodXRoYWkiLDM2NzQsImFuZ2xlIiw4NzM2LCJhbmdsZWJyYWNrZXRsZWZ0IiwxMjI5NiwiYW5nbGVicmFja2V0bGVmdHZlcnRpY2FsIiw2NTA4NywiYW5nbGVicmFja2V0cmlnaHQiLDEyMjk3LCJhbmdsZWJyYWNrZXRyaWdodHZlcnRpY2FsIiw2NTA4OCwiYW5nbGVsZWZ0Iiw5MDAxLCJhbmdsZXJpZ2h0Iiw5MDAyLCJhbmdzdHJvbSIsODQ5MSwiYW5vdGVsZWlhIiw5MDMsImFudWRhdHRhZGV2YSIsMjM4NiwiYW51c3ZhcmFiZW5nYWxpIiwyNDM0LCJhbnVzdmFyYWRldmEiLDIzMDYsImFudXN2YXJhZ3VqYXJhdGkiLDI2OTAsImFvZ29uZWsiLDI2MSwiYXBhYXRvc3F1YXJlIiwxMzA1NiwiYXBhcmVuIiw5MzcyLCJhcG9zdHJvcGhlYXJtZW5pYW4iLDEzNzAsImFwb3N0cm9waGVtb2QiLDcwMCwiYXBwbGUiLDYzNzQzLCJhcHByb2FjaGVzIiw4Nzg0LCJhcHByb3hlcXVhbCIsODc3NiwiYXBwcm94ZXF1YWxvcmltYWdlIiw4Nzg2LCJhcHByb3hpbWF0ZWx5ZXF1YWwiLDg3NzMsImFyYWVhZWtvcmVhbiIsMTI2ODYsImFyYWVha29yZWFuIiwxMjY4NSwiYXJjIiw4OTc4LCJhcmlnaHRoYWxmcmluZyIsNzgzNCwiYXJpbmciLDIyOSwiYXJpbmdhY3V0ZSIsNTA3LCJhcmluZ2JlbG93Iiw3NjgxLCJhcnJvd2JvdGgiLDg1OTYsImFycm93ZGFzaGRvd24iLDg2NzUsImFycm93ZGFzaGxlZnQiLDg2NzIsImFycm93ZGFzaHJpZ2h0Iiw4Njc0LCJhcnJvd2Rhc2h1cCIsODY3MywiYXJyb3dkYmxib3RoIiw4NjYwLCJhcnJvd2RibGRvd24iLDg2NTksImFycm93ZGJsbGVmdCIsODY1NiwiYXJyb3dkYmxyaWdodCIsODY1OCwiYXJyb3dkYmx1cCIsODY1NywiYXJyb3dkb3duIiw4NTk1LCJhcnJvd2Rvd25sZWZ0Iiw4NjAxLCJhcnJvd2Rvd25yaWdodCIsODYwMCwiYXJyb3dkb3dud2hpdGUiLDg2ODEsImFycm93aGVhZGRvd25tb2QiLDcwOSwiYXJyb3doZWFkbGVmdG1vZCIsNzA2LCJhcnJvd2hlYWRyaWdodG1vZCIsNzA3LCJhcnJvd2hlYWR1cG1vZCIsNzA4LCJhcnJvd2hvcml6ZXgiLDYzNzE5LCJhcnJvd2xlZnQiLDg1OTIsImFycm93bGVmdGRibCIsODY1NiwiYXJyb3dsZWZ0ZGJsc3Ryb2tlIiw4NjUzLCJhcnJvd2xlZnRvdmVycmlnaHQiLDg2NDYsImFycm93bGVmdHdoaXRlIiw4Njc4LCJhcnJvd3JpZ2h0Iiw4NTk0LCJhcnJvd3JpZ2h0ZGJsc3Ryb2tlIiw4NjU1LCJhcnJvd3JpZ2h0aGVhdnkiLDEwMTQyLCJhcnJvd3JpZ2h0b3ZlcmxlZnQiLDg2NDQsImFycm93cmlnaHR3aGl0ZSIsODY4MCwiYXJyb3d0YWJsZWZ0Iiw4Njc2LCJhcnJvd3RhYnJpZ2h0Iiw4Njc3LCJhcnJvd3VwIiw4NTkzLCJhcnJvd3VwZG4iLDg1OTcsImFycm93dXBkbmJzZSIsODYxNiwiYXJyb3d1cGRvd25iYXNlIiw4NjE2LCJhcnJvd3VwbGVmdCIsODU5OCwiYXJyb3d1cGxlZnRvZmRvd24iLDg2NDUsImFycm93dXByaWdodCIsODU5OSwiYXJyb3d1cHdoaXRlIiw4Njc5LCJhcnJvd3ZlcnRleCIsNjM3MTgsImFzY2lpY2lyY3VtIiw5NCwiYXNjaWljaXJjdW1tb25vc3BhY2UiLDY1MzQyLCJhc2NpaXRpbGRlIiwxMjYsImFzY2lpdGlsZGVtb25vc3BhY2UiLDY1Mzc0LCJhc2NyaXB0Iiw1OTMsImFzY3JpcHR0dXJuZWQiLDU5NCwiYXNtYWxsaGlyYWdhbmEiLDEyMzUzLCJhc21hbGxrYXRha2FuYSIsMTI0NDksImFzbWFsbGthdGFrYW5haGFsZndpZHRoIiw2NTM4MywiYXN0ZXJpc2siLDQyLCJhc3Rlcmlza2FsdG9uZWFyYWJpYyIsMTY0NSwiYXN0ZXJpc2thcmFiaWMiLDE2NDUsImFzdGVyaXNrbWF0aCIsODcyNywiYXN0ZXJpc2ttb25vc3BhY2UiLDY1MjkwLCJhc3Rlcmlza3NtYWxsIiw2NTEyMSwiYXN0ZXJpc20iLDgyNTgsImFzdXBlcmlvciIsNjMyMDksImFzeW1wdG90aWNhbGx5ZXF1YWwiLDg3NzEsImF0Iiw2NCwiYXRpbGRlIiwyMjcsImF0bW9ub3NwYWNlIiw2NTMxMiwiYXRzbWFsbCIsNjUxMzEsImF0dXJuZWQiLDU5MiwiYXViZW5nYWxpIiwyNDUyLCJhdWJvcG9tb2ZvIiwxMjU3NiwiYXVkZXZhIiwyMzI0LCJhdWd1amFyYXRpIiwyNzA4LCJhdWd1cm11a2hpIiwyNTgwLCJhdWxlbmd0aG1hcmtiZW5nYWxpIiwyNTE5LCJhdW1hdHJhZ3VybXVraGkiLDI2MzYsImF1dm93ZWxzaWduYmVuZ2FsaSIsMjUwOCwiYXV2b3dlbHNpZ25kZXZhIiwyMzgwLCJhdXZvd2Vsc2lnbmd1amFyYXRpIiwyNzY0LCJhdmFncmFoYWRldmEiLDIzNjUsImF5YmFybWVuaWFuIiwxMzc3LCJheWluIiwxNTA2LCJheWluYWx0b25laGVicmV3Iiw2NDI4OCwiYXlpbmhlYnJldyIsMTUwNiwiYiIsOTgsImJhYmVuZ2FsaSIsMjQ3NiwiYmFja3NsYXNoIiw5MiwiYmFja3NsYXNobW9ub3NwYWNlIiw2NTM0MCwiYmFkZXZhIiwyMzQ4LCJiYWd1amFyYXRpIiwyNzMyLCJiYWd1cm11a2hpIiwyNjA0LCJiYWhpcmFnYW5hIiwxMjQwMCwiYmFodHRoYWkiLDM2NDcsImJha2F0YWthbmEiLDEyNDk2LCJiYXIiLDEyNCwiYmFybW9ub3NwYWNlIiw2NTM3MiwiYmJvcG9tb2ZvIiwxMjU0OSwiYmNpcmNsZSIsOTQyNSwiYmRvdGFjY2VudCIsNzY4MywiYmRvdGJlbG93Iiw3Njg1LCJiZWFtZWRzaXh0ZWVudGhub3RlcyIsOTgzNiwiYmVjYXVzZSIsODc1NywiYmVjeXJpbGxpYyIsMTA3MywiYmVoYXJhYmljIiwxNTc2LCJiZWhmaW5hbGFyYWJpYyIsNjUxNjgsImJlaGluaXRpYWxhcmFiaWMiLDY1MTY5LCJiZWhpcmFnYW5hIiwxMjQwOSwiYmVobWVkaWFsYXJhYmljIiw2NTE3MCwiYmVobWVlbWluaXRpYWxhcmFiaWMiLDY0NjcxLCJiZWhtZWVtaXNvbGF0ZWRhcmFiaWMiLDY0NTIwLCJiZWhub29uZmluYWxhcmFiaWMiLDY0NjIxLCJiZWthdGFrYW5hIiwxMjUwNSwiYmVuYXJtZW5pYW4iLDEzNzgsImJldCIsMTQ4OSwiYmV0YSIsOTQ2LCJiZXRhc3ltYm9sZ3JlZWsiLDk3NiwiYmV0ZGFnZXNoIiw2NDMwNSwiYmV0ZGFnZXNoaGVicmV3Iiw2NDMwNSwiYmV0aGVicmV3IiwxNDg5LCJiZXRyYWZlaGVicmV3Iiw2NDMzMiwiYmhhYmVuZ2FsaSIsMjQ3NywiYmhhZGV2YSIsMjM0OSwiYmhhZ3VqYXJhdGkiLDI3MzMsImJoYWd1cm11a2hpIiwyNjA1LCJiaG9vayIsNTk1LCJiaWhpcmFnYW5hIiwxMjQwMywiYmlrYXRha2FuYSIsMTI0OTksImJpbGFiaWFsY2xpY2siLDY2NCwiYmluZGlndXJtdWtoaSIsMjU2MiwiYmlydXNxdWFyZSIsMTMxMDUsImJsYWNrY2lyY2xlIiw5Njc5LCJibGFja2RpYW1vbmQiLDk2NzAsImJsYWNrZG93bnBvaW50aW5ndHJpYW5nbGUiLDk2NjAsImJsYWNrbGVmdHBvaW50aW5ncG9pbnRlciIsOTY2OCwiYmxhY2tsZWZ0cG9pbnRpbmd0cmlhbmdsZSIsOTY2NCwiYmxhY2tsZW50aWN1bGFyYnJhY2tldGxlZnQiLDEyMzA0LCJibGFja2xlbnRpY3VsYXJicmFja2V0bGVmdHZlcnRpY2FsIiw2NTA4MywiYmxhY2tsZW50aWN1bGFyYnJhY2tldHJpZ2h0IiwxMjMwNSwiYmxhY2tsZW50aWN1bGFyYnJhY2tldHJpZ2h0dmVydGljYWwiLDY1MDg0LCJibGFja2xvd2VybGVmdHRyaWFuZ2xlIiw5Njk5LCJibGFja2xvd2VycmlnaHR0cmlhbmdsZSIsOTY5OCwiYmxhY2tyZWN0YW5nbGUiLDk2NDQsImJsYWNrcmlnaHRwb2ludGluZ3BvaW50ZXIiLDk2NTgsImJsYWNrcmlnaHRwb2ludGluZ3RyaWFuZ2xlIiw5NjU0LCJibGFja3NtYWxsc3F1YXJlIiw5NjQyLCJibGFja3NtaWxpbmdmYWNlIiw5Nzg3LCJibGFja3NxdWFyZSIsOTYzMiwiYmxhY2tzdGFyIiw5NzMzLCJibGFja3VwcGVybGVmdHRyaWFuZ2xlIiw5NzAwLCJibGFja3VwcGVycmlnaHR0cmlhbmdsZSIsOTcwMSwiYmxhY2t1cHBvaW50aW5nc21hbGx0cmlhbmdsZSIsOTY1MiwiYmxhY2t1cHBvaW50aW5ndHJpYW5nbGUiLDk2NTAsImJsYW5rIiw5MjUxLCJibGluZWJlbG93Iiw3Njg3LCJibG9jayIsOTYwOCwiYm1vbm9zcGFjZSIsNjUzNDYsImJvYmFpbWFpdGhhaSIsMzYxMCwiYm9oaXJhZ2FuYSIsMTI0MTIsImJva2F0YWthbmEiLDEyNTA4LCJicGFyZW4iLDkzNzMsImJxc3F1YXJlIiwxMzI1MSwiYnJhY2VleCIsNjM3MzIsImJyYWNlbGVmdCIsMTIzLCJicmFjZWxlZnRidCIsNjM3MzEsImJyYWNlbGVmdG1pZCIsNjM3MzAsImJyYWNlbGVmdG1vbm9zcGFjZSIsNjUzNzEsImJyYWNlbGVmdHNtYWxsIiw2NTExNSwiYnJhY2VsZWZ0dHAiLDYzNzI5LCJicmFjZWxlZnR2ZXJ0aWNhbCIsNjUwNzksImJyYWNlcmlnaHQiLDEyNSwiYnJhY2VyaWdodGJ0Iiw2Mzc0MiwiYnJhY2VyaWdodG1pZCIsNjM3NDEsImJyYWNlcmlnaHRtb25vc3BhY2UiLDY1MzczLCJicmFjZXJpZ2h0c21hbGwiLDY1MTE2LCJicmFjZXJpZ2h0dHAiLDYzNzQwLCJicmFjZXJpZ2h0dmVydGljYWwiLDY1MDgwLCJicmFja2V0bGVmdCIsOTEsImJyYWNrZXRsZWZ0YnQiLDYzNzI4LCJicmFja2V0bGVmdGV4Iiw2MzcyNywiYnJhY2tldGxlZnRtb25vc3BhY2UiLDY1MzM5LCJicmFja2V0bGVmdHRwIiw2MzcyNiwiYnJhY2tldHJpZ2h0Iiw5MywiYnJhY2tldHJpZ2h0YnQiLDYzNzM5LCJicmFja2V0cmlnaHRleCIsNjM3MzgsImJyYWNrZXRyaWdodG1vbm9zcGFjZSIsNjUzNDEsImJyYWNrZXRyaWdodHRwIiw2MzczNywiYnJldmUiLDcyOCwiYnJldmViZWxvd2NtYiIsODE0LCJicmV2ZWNtYiIsNzc0LCJicmV2ZWludmVydGVkYmVsb3djbWIiLDgxNSwiYnJldmVpbnZlcnRlZGNtYiIsNzg1LCJicmV2ZWludmVydGVkZG91YmxlY21iIiw4NjUsImJyaWRnZWJlbG93Y21iIiw4MTAsImJyaWRnZWludmVydGVkYmVsb3djbWIiLDgyNiwiYnJva2VuYmFyIiwxNjYsImJzdHJva2UiLDM4NCwiYnN1cGVyaW9yIiw2MzIxMCwiYnRvcGJhciIsMzg3LCJidWhpcmFnYW5hIiwxMjQwNiwiYnVrYXRha2FuYSIsMTI1MDIsImJ1bGxldCIsODIyNiwiYnVsbGV0aW52ZXJzZSIsOTY4OCwiYnVsbGV0b3BlcmF0b3IiLDg3MjksImJ1bGxzZXllIiw5Njc4LCJjIiw5OSwiY2Fhcm1lbmlhbiIsMTM5MCwiY2FiZW5nYWxpIiwyNDU4LCJjYWN1dGUiLDI2MywiY2FkZXZhIiwyMzMwLCJjYWd1amFyYXRpIiwyNzE0LCJjYWd1cm11a2hpIiwyNTg2LCJjYWxzcXVhcmUiLDEzMTkyLCJjYW5kcmFiaW5kdWJlbmdhbGkiLDI0MzMsImNhbmRyYWJpbmR1Y21iIiw3ODQsImNhbmRyYWJpbmR1ZGV2YSIsMjMwNSwiY2FuZHJhYmluZHVndWphcmF0aSIsMjY4OSwiY2Fwc2xvY2siLDg2ODIsImNhcmVvZiIsODQ1MywiY2Fyb24iLDcxMSwiY2Fyb25iZWxvd2NtYiIsODEyLCJjYXJvbmNtYiIsNzgwLCJjYXJyaWFnZXJldHVybiIsODYyOSwiY2JvcG9tb2ZvIiwxMjU2OCwiY2Nhcm9uIiwyNjksImNjZWRpbGxhIiwyMzEsImNjZWRpbGxhYWN1dGUiLDc2ODksImNjaXJjbGUiLDk0MjYsImNjaXJjdW1mbGV4IiwyNjUsImNjdXJsIiw1OTcsImNkb3QiLDI2NywiY2RvdGFjY2VudCIsMjY3LCJjZHNxdWFyZSIsMTMyNTMsImNlZGlsbGEiLDE4NCwiY2VkaWxsYWNtYiIsODA3LCJjZW50IiwxNjIsImNlbnRpZ3JhZGUiLDg0NTEsImNlbnRpbmZlcmlvciIsNjMxOTksImNlbnRtb25vc3BhY2UiLDY1NTA0LCJjZW50b2xkc3R5bGUiLDYzMzk0LCJjZW50c3VwZXJpb3IiLDYzMjAwLCJjaGFhcm1lbmlhbiIsMTQwMSwiY2hhYmVuZ2FsaSIsMjQ1OSwiY2hhZGV2YSIsMjMzMSwiY2hhZ3VqYXJhdGkiLDI3MTUsImNoYWd1cm11a2hpIiwyNTg3LCJjaGJvcG9tb2ZvIiwxMjU2NCwiY2hlYWJraGFzaWFuY3lyaWxsaWMiLDEyMTMsImNoZWNrbWFyayIsMTAwMDMsImNoZWN5cmlsbGljIiwxMDk1LCJjaGVkZXNjZW5kZXJhYmtoYXNpYW5jeXJpbGxpYyIsMTIxNSwiY2hlZGVzY2VuZGVyY3lyaWxsaWMiLDEyMDcsImNoZWRpZXJlc2lzY3lyaWxsaWMiLDEyNjksImNoZWhhcm1lbmlhbiIsMTM5NSwiY2hla2hha2Fzc2lhbmN5cmlsbGljIiwxMjI4LCJjaGV2ZXJ0aWNhbHN0cm9rZWN5cmlsbGljIiwxMjA5LCJjaGkiLDk2NywiY2hpZXVjaGFjaXJjbGVrb3JlYW4iLDEyOTE5LCJjaGlldWNoYXBhcmVua29yZWFuIiwxMjgyMywiY2hpZXVjaGNpcmNsZWtvcmVhbiIsMTI5MDUsImNoaWV1Y2hrb3JlYW4iLDEyNjE4LCJjaGlldWNocGFyZW5rb3JlYW4iLDEyODA5LCJjaG9jaGFuZ3RoYWkiLDM1OTQsImNob2NoYW50aGFpIiwzNTkyLCJjaG9jaGluZ3RoYWkiLDM1OTMsImNob2Nob2V0aGFpIiwzNTk2LCJjaG9vayIsMzkyLCJjaWV1Y2FjaXJjbGVrb3JlYW4iLDEyOTE4LCJjaWV1Y2FwYXJlbmtvcmVhbiIsMTI4MjIsImNpZXVjY2lyY2xla29yZWFuIiwxMjkwNCwiY2lldWNrb3JlYW4iLDEyNjE2LCJjaWV1Y3BhcmVua29yZWFuIiwxMjgwOCwiY2lldWN1cGFyZW5rb3JlYW4iLDEyODI4LCJjaXJjbGUiLDk2NzUsImNpcmNsZWNvcHlydCIsMTY5LCJjaXJjbGVtdWx0aXBseSIsODg1NSwiY2lyY2xlb3QiLDg4NTcsImNpcmNsZXBsdXMiLDg4NTMsImNpcmNsZXBvc3RhbG1hcmsiLDEyMzQyLCJjaXJjbGV3aXRobGVmdGhhbGZibGFjayIsOTY4MCwiY2lyY2xld2l0aHJpZ2h0aGFsZmJsYWNrIiw5NjgxLCJjaXJjdW1mbGV4Iiw3MTAsImNpcmN1bWZsZXhiZWxvd2NtYiIsODEzLCJjaXJjdW1mbGV4Y21iIiw3NzAsImNsZWFyIiw4OTk5LCJjbGlja2FsdmVvbGFyIiw0NTAsImNsaWNrZGVudGFsIiw0NDgsImNsaWNrbGF0ZXJhbCIsNDQ5LCJjbGlja3JldHJvZmxleCIsNDUxLCJjbHViIiw5ODI3LCJjbHVic3VpdGJsYWNrIiw5ODI3LCJjbHVic3VpdHdoaXRlIiw5ODMxLCJjbWN1YmVkc3F1YXJlIiwxMzIyMCwiY21vbm9zcGFjZSIsNjUzNDcsImNtc3F1YXJlZHNxdWFyZSIsMTMyMTYsImNvYXJtZW5pYW4iLDE0MDksImNvbG9uIiw1OCwiY29sb25tb25ldGFyeSIsODM1MywiY29sb25tb25vc3BhY2UiLDY1MzA2LCJjb2xvbnNpZ24iLDgzNTMsImNvbG9uc21hbGwiLDY1MTA5LCJjb2xvbnRyaWFuZ3VsYXJoYWxmbW9kIiw3MjEsImNvbG9udHJpYW5ndWxhcm1vZCIsNzIwLCJjb21tYSIsNDQsImNvbW1hYWJvdmVjbWIiLDc4NywiY29tbWFhYm92ZXJpZ2h0Y21iIiw3ODksImNvbW1hYWNjZW50Iiw2MzE3MSwiY29tbWFhcmFiaWMiLDE1NDgsImNvbW1hYXJtZW5pYW4iLDEzNzMsImNvbW1haW5mZXJpb3IiLDYzMjAxLCJjb21tYW1vbm9zcGFjZSIsNjUyOTIsImNvbW1hcmV2ZXJzZWRhYm92ZWNtYiIsNzg4LCJjb21tYXJldmVyc2VkbW9kIiw3MDEsImNvbW1hc21hbGwiLDY1MTA0LCJjb21tYXN1cGVyaW9yIiw2MzIwMiwiY29tbWF0dXJuZWRhYm92ZWNtYiIsNzg2LCJjb21tYXR1cm5lZG1vZCIsNjk5LCJjb21wYXNzIiw5Nzg4LCJjb25ncnVlbnQiLDg3NzMsImNvbnRvdXJpbnRlZ3JhbCIsODc1MCwiY29udHJvbCIsODk2MywiY29udHJvbEFDSyIsNiwiY29udHJvbEJFTCIsNywiY29udHJvbEJTIiw4LCJjb250cm9sQ0FOIiwyNCwiY29udHJvbENSIiwxMywiY29udHJvbERDMSIsMTcsImNvbnRyb2xEQzIiLDE4LCJjb250cm9sREMzIiwxOSwiY29udHJvbERDNCIsMjAsImNvbnRyb2xERUwiLDEyNywiY29udHJvbERMRSIsMTYsImNvbnRyb2xFTSIsMjUsImNvbnRyb2xFTlEiLDUsImNvbnRyb2xFT1QiLDQsImNvbnRyb2xFU0MiLDI3LCJjb250cm9sRVRCIiwyMywiY29udHJvbEVUWCIsMywiY29udHJvbEZGIiwxMiwiY29udHJvbEZTIiwyOCwiY29udHJvbEdTIiwyOSwiY29udHJvbEhUIiw5LCJjb250cm9sTEYiLDEwLCJjb250cm9sTkFLIiwyMSwiY29udHJvbE5VTEwiLDAsImNvbnRyb2xSUyIsMzAsImNvbnRyb2xTSSIsMTUsImNvbnRyb2xTTyIsMTQsImNvbnRyb2xTT1QiLDIsImNvbnRyb2xTVFgiLDEsImNvbnRyb2xTVUIiLDI2LCJjb250cm9sU1lOIiwyMiwiY29udHJvbFVTIiwzMSwiY29udHJvbFZUIiwxMSwiY29weXJpZ2h0IiwxNjksImNvcHlyaWdodHNhbnMiLDYzNzIxLCJjb3B5cmlnaHRzZXJpZiIsNjMxOTMsImNvcm5lcmJyYWNrZXRsZWZ0IiwxMjMwMCwiY29ybmVyYnJhY2tldGxlZnRoYWxmd2lkdGgiLDY1Mzc4LCJjb3JuZXJicmFja2V0bGVmdHZlcnRpY2FsIiw2NTA4OSwiY29ybmVyYnJhY2tldHJpZ2h0IiwxMjMwMSwiY29ybmVyYnJhY2tldHJpZ2h0aGFsZndpZHRoIiw2NTM3OSwiY29ybmVyYnJhY2tldHJpZ2h0dmVydGljYWwiLDY1MDkwLCJjb3Jwb3JhdGlvbnNxdWFyZSIsMTMxODMsImNvc3F1YXJlIiwxMzI1NSwiY292ZXJrZ3NxdWFyZSIsMTMyNTQsImNwYXJlbiIsOTM3NCwiY3J1emVpcm8iLDgzNTQsImNzdHJldGNoZWQiLDY2MywiY3VybHlhbmQiLDg5MTEsImN1cmx5b3IiLDg5MTAsImN1cnJlbmN5IiwxNjQsImN5ckJyZXZlIiw2MzE4NSwiY3lyRmxleCIsNjMxODYsImN5cmJyZXZlIiw2MzE4OCwiY3lyZmxleCIsNjMxODksImQiLDEwMCwiZGFhcm1lbmlhbiIsMTM4MCwiZGFiZW5nYWxpIiwyNDcwLCJkYWRhcmFiaWMiLDE1OTAsImRhZGV2YSIsMjM0MiwiZGFkZmluYWxhcmFiaWMiLDY1MjE0LCJkYWRpbml0aWFsYXJhYmljIiw2NTIxNSwiZGFkbWVkaWFsYXJhYmljIiw2NTIxNiwiZGFnZXNoIiwxNDY4LCJkYWdlc2hoZWJyZXciLDE0NjgsImRhZ2dlciIsODIyNCwiZGFnZ2VyZGJsIiw4MjI1LCJkYWd1amFyYXRpIiwyNzI2LCJkYWd1cm11a2hpIiwyNTk4LCJkYWhpcmFnYW5hIiwxMjM4NCwiZGFrYXRha2FuYSIsMTI0ODAsImRhbGFyYWJpYyIsMTU4MywiZGFsZXQiLDE0OTEsImRhbGV0ZGFnZXNoIiw2NDMwNywiZGFsZXRkYWdlc2hoZWJyZXciLDY0MzA3LCJkYWxldGhlYnJldyIsMTQ5MSwiZGFsZmluYWxhcmFiaWMiLDY1MTk0LCJkYW1tYWFyYWJpYyIsMTYxNSwiZGFtbWFsb3dhcmFiaWMiLDE2MTUsImRhbW1hdGFuYWx0b25lYXJhYmljIiwxNjEyLCJkYW1tYXRhbmFyYWJpYyIsMTYxMiwiZGFuZGEiLDI0MDQsImRhcmdhaGVicmV3IiwxNDQ3LCJkYXJnYWxlZnRoZWJyZXciLDE0NDcsImRhc2lhcG5ldW1hdGFjeXJpbGxpY2NtYiIsMTE1NywiZGJsR3JhdmUiLDYzMTg3LCJkYmxhbmdsZWJyYWNrZXRsZWZ0IiwxMjI5OCwiZGJsYW5nbGVicmFja2V0bGVmdHZlcnRpY2FsIiw2NTA4NSwiZGJsYW5nbGVicmFja2V0cmlnaHQiLDEyMjk5LCJkYmxhbmdsZWJyYWNrZXRyaWdodHZlcnRpY2FsIiw2NTA4NiwiZGJsYXJjaGludmVydGVkYmVsb3djbWIiLDgxMSwiZGJsYXJyb3dsZWZ0Iiw4NjYwLCJkYmxhcnJvd3JpZ2h0Iiw4NjU4LCJkYmxkYW5kYSIsMjQwNSwiZGJsZ3JhdmUiLDYzMTkwLCJkYmxncmF2ZWNtYiIsNzgzLCJkYmxpbnRlZ3JhbCIsODc0OCwiZGJsbG93bGluZSIsODIxNSwiZGJsbG93bGluZWNtYiIsODE5LCJkYmxvdmVybGluZWNtYiIsODMxLCJkYmxwcmltZW1vZCIsNjk4LCJkYmx2ZXJ0aWNhbGJhciIsODIxNCwiZGJsdmVydGljYWxsaW5lYWJvdmVjbWIiLDc4MiwiZGJvcG9tb2ZvIiwxMjU1MywiZGJzcXVhcmUiLDEzMjU2LCJkY2Fyb24iLDI3MSwiZGNlZGlsbGEiLDc2OTcsImRjaXJjbGUiLDk0MjcsImRjaXJjdW1mbGV4YmVsb3ciLDc2OTksImRjcm9hdCIsMjczLCJkZGFiZW5nYWxpIiwyNDY1LCJkZGFkZXZhIiwyMzM3LCJkZGFndWphcmF0aSIsMjcyMSwiZGRhZ3VybXVraGkiLDI1OTMsImRkYWxhcmFiaWMiLDE2NzIsImRkYWxmaW5hbGFyYWJpYyIsNjQzOTMsImRkZGhhZGV2YSIsMjM5NiwiZGRoYWJlbmdhbGkiLDI0NjYsImRkaGFkZXZhIiwyMzM4LCJkZGhhZ3VqYXJhdGkiLDI3MjIsImRkaGFndXJtdWtoaSIsMjU5NCwiZGRvdGFjY2VudCIsNzY5MSwiZGRvdGJlbG93Iiw3NjkzLCJkZWNpbWFsc2VwYXJhdG9yYXJhYmljIiwxNjQzLCJkZWNpbWFsc2VwYXJhdG9ycGVyc2lhbiIsMTY0MywiZGVjeXJpbGxpYyIsMTA3NiwiZGVncmVlIiwxNzYsImRlaGloZWJyZXciLDE0NTMsImRlaGlyYWdhbmEiLDEyMzkxLCJkZWljb3B0aWMiLDEwMDcsImRla2F0YWthbmEiLDEyNDg3LCJkZWxldGVsZWZ0Iiw5MDAzLCJkZWxldGVyaWdodCIsODk5OCwiZGVsdGEiLDk0OCwiZGVsdGF0dXJuZWQiLDM5NywiZGVub21pbmF0b3JtaW51c29uZW51bWVyYXRvcmJlbmdhbGkiLDI1NTIsImRlemgiLDY3NiwiZGhhYmVuZ2FsaSIsMjQ3MSwiZGhhZGV2YSIsMjM0MywiZGhhZ3VqYXJhdGkiLDI3MjcsImRoYWd1cm11a2hpIiwyNTk5LCJkaG9vayIsNTk5LCJkaWFseXRpa2F0b25vcyIsOTAxLCJkaWFseXRpa2F0b25vc2NtYiIsODM2LCJkaWFtb25kIiw5ODMwLCJkaWFtb25kc3VpdHdoaXRlIiw5ODI2LCJkaWVyZXNpcyIsMTY4LCJkaWVyZXNpc2FjdXRlIiw2MzE5MSwiZGllcmVzaXNiZWxvd2NtYiIsODA0LCJkaWVyZXNpc2NtYiIsNzc2LCJkaWVyZXNpc2dyYXZlIiw2MzE5MiwiZGllcmVzaXN0b25vcyIsOTAxLCJkaWhpcmFnYW5hIiwxMjM4NiwiZGlrYXRha2FuYSIsMTI0ODIsImRpdHRvbWFyayIsMTIyOTEsImRpdmlkZSIsMjQ3LCJkaXZpZGVzIiw4NzM5LCJkaXZpc2lvbnNsYXNoIiw4NzI1LCJkamVjeXJpbGxpYyIsMTEwNiwiZGtzaGFkZSIsOTYxOSwiZGxpbmViZWxvdyIsNzY5NSwiZGxzcXVhcmUiLDEzMjA3LCJkbWFjcm9uIiwyNzMsImRtb25vc3BhY2UiLDY1MzQ4LCJkbmJsb2NrIiw5NjA0LCJkb2NoYWRhdGhhaSIsMzU5OCwiZG9kZWt0aGFpIiwzNjA0LCJkb2hpcmFnYW5hIiwxMjM5MywiZG9rYXRha2FuYSIsMTI0ODksImRvbGxhciIsMzYsImRvbGxhcmluZmVyaW9yIiw2MzIwMywiZG9sbGFybW9ub3NwYWNlIiw2NTI4NCwiZG9sbGFyb2xkc3R5bGUiLDYzMjY4LCJkb2xsYXJzbWFsbCIsNjUxMjksImRvbGxhcnN1cGVyaW9yIiw2MzIwNCwiZG9uZyIsODM2MywiZG9ydXNxdWFyZSIsMTMwOTQsImRvdGFjY2VudCIsNzI5LCJkb3RhY2NlbnRjbWIiLDc3NSwiZG90YmVsb3djbWIiLDgwMywiZG90YmVsb3djb21iIiw4MDMsImRvdGthdGFrYW5hIiwxMjUzOSwiZG90bGVzc2kiLDMwNSwiZG90bGVzc2oiLDYzMTY2LCJkb3RsZXNzanN0cm9rZWhvb2siLDY0NCwiZG90bWF0aCIsODkwMSwiZG90dGVkY2lyY2xlIiw5Njc2LCJkb3VibGV5b2RwYXRhaCIsNjQyODcsImRvdWJsZXlvZHBhdGFoaGVicmV3Iiw2NDI4NywiZG93bnRhY2tiZWxvd2NtYiIsNzk4LCJkb3dudGFja21vZCIsNzI1LCJkcGFyZW4iLDkzNzUsImRzdXBlcmlvciIsNjMyMTEsImR0YWlsIiw1OTgsImR0b3BiYXIiLDM5NiwiZHVoaXJhZ2FuYSIsMTIzODksImR1a2F0YWthbmEiLDEyNDg1LCJkeiIsNDk5LCJkemFsdG9uZSIsNjc1LCJkemNhcm9uIiw0NTQsImR6Y3VybCIsNjc3LCJkemVhYmtoYXNpYW5jeXJpbGxpYyIsMTI0OSwiZHplY3lyaWxsaWMiLDExMDksImR6aGVjeXJpbGxpYyIsMTExOSwiZSIsMTAxLCJlYWN1dGUiLDIzMywiZWFydGgiLDk3OTMsImViZW5nYWxpIiwyNDQ3LCJlYm9wb21vZm8iLDEyNTcyLCJlYnJldmUiLDI3NywiZWNhbmRyYWRldmEiLDIzMTcsImVjYW5kcmFndWphcmF0aSIsMjcwMSwiZWNhbmRyYXZvd2Vsc2lnbmRldmEiLDIzNzMsImVjYW5kcmF2b3dlbHNpZ25ndWphcmF0aSIsMjc1NywiZWNhcm9uIiwyODMsImVjZWRpbGxhYnJldmUiLDc3MDksImVjaGFybWVuaWFuIiwxMzgxLCJlY2h5aXduYXJtZW5pYW4iLDE0MTUsImVjaXJjbGUiLDk0MjgsImVjaXJjdW1mbGV4IiwyMzQsImVjaXJjdW1mbGV4YWN1dGUiLDc4NzEsImVjaXJjdW1mbGV4YmVsb3ciLDc3MDUsImVjaXJjdW1mbGV4ZG90YmVsb3ciLDc4NzksImVjaXJjdW1mbGV4Z3JhdmUiLDc4NzMsImVjaXJjdW1mbGV4aG9va2Fib3ZlIiw3ODc1LCJlY2lyY3VtZmxleHRpbGRlIiw3ODc3LCJlY3lyaWxsaWMiLDExMDgsImVkYmxncmF2ZSIsNTE3LCJlZGV2YSIsMjMxOSwiZWRpZXJlc2lzIiwyMzUsImVkb3QiLDI3OSwiZWRvdGFjY2VudCIsMjc5LCJlZG90YmVsb3ciLDc4NjUsImVlZ3VybXVraGkiLDI1NzUsImVlbWF0cmFndXJtdWtoaSIsMjYzMSwiZWZjeXJpbGxpYyIsMTA5MiwiZWdyYXZlIiwyMzIsImVndWphcmF0aSIsMjcwMywiZWhhcm1lbmlhbiIsMTM4MywiZWhib3BvbW9mbyIsMTI1NzMsImVoaXJhZ2FuYSIsMTIzNjAsImVob29rYWJvdmUiLDc4NjcsImVpYm9wb21vZm8iLDEyNTc1LCJlaWdodCIsNTYsImVpZ2h0YXJhYmljIiwxNjQwLCJlaWdodGJlbmdhbGkiLDI1NDIsImVpZ2h0Y2lyY2xlIiw5MzE5LCJlaWdodGNpcmNsZWludmVyc2VzYW5zc2VyaWYiLDEwMTI5LCJlaWdodGRldmEiLDI0MTQsImVpZ2h0ZWVuY2lyY2xlIiw5MzI5LCJlaWdodGVlbnBhcmVuIiw5MzQ5LCJlaWdodGVlbnBlcmlvZCIsOTM2OSwiZWlnaHRndWphcmF0aSIsMjc5OCwiZWlnaHRndXJtdWtoaSIsMjY3MCwiZWlnaHRoYWNrYXJhYmljIiwxNjQwLCJlaWdodGhhbmd6aG91IiwxMjMyOCwiZWlnaHRobm90ZWJlYW1lZCIsOTgzNSwiZWlnaHRpZGVvZ3JhcGhpY3BhcmVuIiwxMjgzOSwiZWlnaHRpbmZlcmlvciIsODMyOCwiZWlnaHRtb25vc3BhY2UiLDY1MzA0LCJlaWdodG9sZHN0eWxlIiw2MzI4OCwiZWlnaHRwYXJlbiIsOTMzOSwiZWlnaHRwZXJpb2QiLDkzNTksImVpZ2h0cGVyc2lhbiIsMTc4NCwiZWlnaHRyb21hbiIsODU2NywiZWlnaHRzdXBlcmlvciIsODMxMiwiZWlnaHR0aGFpIiwzNjcyLCJlaW52ZXJ0ZWRicmV2ZSIsNTE5LCJlaW90aWZpZWRjeXJpbGxpYyIsMTEyNSwiZWthdGFrYW5hIiwxMjQ1NiwiZWthdGFrYW5haGFsZndpZHRoIiw2NTM5NiwiZWtvbmthcmd1cm11a2hpIiwyNjc2LCJla29yZWFuIiwxMjYyOCwiZWxjeXJpbGxpYyIsMTA4MywiZWxlbWVudCIsODcxMiwiZWxldmVuY2lyY2xlIiw5MzIyLCJlbGV2ZW5wYXJlbiIsOTM0MiwiZWxldmVucGVyaW9kIiw5MzYyLCJlbGV2ZW5yb21hbiIsODU3MCwiZWxsaXBzaXMiLDgyMzAsImVsbGlwc2lzdmVydGljYWwiLDg5NDIsImVtYWNyb24iLDI3NSwiZW1hY3JvbmFjdXRlIiw3NzAzLCJlbWFjcm9uZ3JhdmUiLDc3MDEsImVtY3lyaWxsaWMiLDEwODQsImVtZGFzaCIsODIxMiwiZW1kYXNodmVydGljYWwiLDY1MDczLCJlbW9ub3NwYWNlIiw2NTM0OSwiZW1waGFzaXNtYXJrYXJtZW5pYW4iLDEzNzEsImVtcHR5c2V0Iiw4NzA5LCJlbmJvcG9tb2ZvIiwxMjU3OSwiZW5jeXJpbGxpYyIsMTA4NSwiZW5kYXNoIiw4MjExLCJlbmRhc2h2ZXJ0aWNhbCIsNjUwNzQsImVuZGVzY2VuZGVyY3lyaWxsaWMiLDExODcsImVuZyIsMzMxLCJlbmdib3BvbW9mbyIsMTI1ODEsImVuZ2hlY3lyaWxsaWMiLDExODksImVuaG9va2N5cmlsbGljIiwxMjI0LCJlbnNwYWNlIiw4MTk0LCJlb2dvbmVrIiwyODEsImVva29yZWFuIiwxMjYyNywiZW9wZW4iLDYwMywiZW9wZW5jbG9zZWQiLDY2NiwiZW9wZW5yZXZlcnNlZCIsNjA0LCJlb3BlbnJldmVyc2VkY2xvc2VkIiw2MDYsImVvcGVucmV2ZXJzZWRob29rIiw2MDUsImVwYXJlbiIsOTM3NiwiZXBzaWxvbiIsOTQ5LCJlcHNpbG9udG9ub3MiLDk0MSwiZXF1YWwiLDYxLCJlcXVhbG1vbm9zcGFjZSIsNjUzMDksImVxdWFsc21hbGwiLDY1MTI2LCJlcXVhbHN1cGVyaW9yIiw4MzE2LCJlcXVpdmFsZW5jZSIsODgwMSwiZXJib3BvbW9mbyIsMTI1ODIsImVyY3lyaWxsaWMiLDEwODgsImVyZXZlcnNlZCIsNjAwLCJlcmV2ZXJzZWRjeXJpbGxpYyIsMTEwMSwiZXNjeXJpbGxpYyIsMTA4OSwiZXNkZXNjZW5kZXJjeXJpbGxpYyIsMTE5NSwiZXNoIiw2NDMsImVzaGN1cmwiLDY0NiwiZXNob3J0ZGV2YSIsMjMxOCwiZXNob3J0dm93ZWxzaWduZGV2YSIsMjM3NCwiZXNocmV2ZXJzZWRsb29wIiw0MjYsImVzaHNxdWF0cmV2ZXJzZWQiLDY0NSwiZXNtYWxsaGlyYWdhbmEiLDEyMzU5LCJlc21hbGxrYXRha2FuYSIsMTI0NTUsImVzbWFsbGthdGFrYW5haGFsZndpZHRoIiw2NTM4NiwiZXN0aW1hdGVkIiw4NDk0LCJlc3VwZXJpb3IiLDYzMjEyLCJldGEiLDk1MSwiZXRhcm1lbmlhbiIsMTM4NCwiZXRhdG9ub3MiLDk0MiwiZXRoIiwyNDAsImV0aWxkZSIsNzg2OSwiZXRpbGRlYmVsb3ciLDc3MDcsImV0bmFodGFmb3VraGhlYnJldyIsMTQyNSwiZXRuYWh0YWZvdWtobGVmdGhlYnJldyIsMTQyNSwiZXRuYWh0YWhlYnJldyIsMTQyNSwiZXRuYWh0YWxlZnRoZWJyZXciLDE0MjUsImV0dXJuZWQiLDQ3NywiZXVrb3JlYW4iLDEyNjQxLCJldXJvIiw4MzY0LCJldm93ZWxzaWduYmVuZ2FsaSIsMjUwMywiZXZvd2Vsc2lnbmRldmEiLDIzNzUsImV2b3dlbHNpZ25ndWphcmF0aSIsMjc1OSwiZXhjbGFtIiwzMywiZXhjbGFtYXJtZW5pYW4iLDEzNzIsImV4Y2xhbWRibCIsODI1MiwiZXhjbGFtZG93biIsMTYxLCJleGNsYW1kb3duc21hbGwiLDYzMzkzLCJleGNsYW1tb25vc3BhY2UiLDY1MjgxLCJleGNsYW1zbWFsbCIsNjMyNjUsImV4aXN0ZW50aWFsIiw4NzA3LCJlemgiLDY1OCwiZXpoY2Fyb24iLDQ5NSwiZXpoY3VybCIsNjU5LCJlemhyZXZlcnNlZCIsNDQxLCJlemh0YWlsIiw0NDIsImYiLDEwMiwiZmFkZXZhIiwyMzk4LCJmYWd1cm11a2hpIiwyNjU0LCJmYWhyZW5oZWl0Iiw4NDU3LCJmYXRoYWFyYWJpYyIsMTYxNCwiZmF0aGFsb3dhcmFiaWMiLDE2MTQsImZhdGhhdGFuYXJhYmljIiwxNjExLCJmYm9wb21vZm8iLDEyNTUyLCJmY2lyY2xlIiw5NDI5LCJmZG90YWNjZW50Iiw3NzExLCJmZWhhcmFiaWMiLDE2MDEsImZlaGFybWVuaWFuIiwxNDE0LCJmZWhmaW5hbGFyYWJpYyIsNjUyMzQsImZlaGluaXRpYWxhcmFiaWMiLDY1MjM1LCJmZWhtZWRpYWxhcmFiaWMiLDY1MjM2LCJmZWljb3B0aWMiLDk5NywiZmVtYWxlIiw5NzkyLCJmZiIsNjQyNTYsImZfZiIsNjQyNTYsImZmaSIsNjQyNTksImZmbCIsNjQyNjAsImZpIiw2NDI1NywiZmlmdGVlbmNpcmNsZSIsOTMyNiwiZmlmdGVlbnBhcmVuIiw5MzQ2LCJmaWZ0ZWVucGVyaW9kIiw5MzY2LCJmaWd1cmVkYXNoIiw4MjEwLCJmaWxsZWRib3giLDk2MzIsImZpbGxlZHJlY3QiLDk2NDQsImZpbmFsa2FmIiwxNDk4LCJmaW5hbGthZmRhZ2VzaCIsNjQzMTQsImZpbmFsa2FmZGFnZXNoaGVicmV3Iiw2NDMxNCwiZmluYWxrYWZoZWJyZXciLDE0OTgsImZpbmFsbWVtIiwxNTAxLCJmaW5hbG1lbWhlYnJldyIsMTUwMSwiZmluYWxudW4iLDE1MDMsImZpbmFsbnVuaGVicmV3IiwxNTAzLCJmaW5hbHBlIiwxNTA3LCJmaW5hbHBlaGVicmV3IiwxNTA3LCJmaW5hbHRzYWRpIiwxNTA5LCJmaW5hbHRzYWRpaGVicmV3IiwxNTA5LCJmaXJzdHRvbmVjaGluZXNlIiw3MTMsImZpc2hleWUiLDk2NzMsImZpdGFjeXJpbGxpYyIsMTEzOSwiZml2ZSIsNTMsImZpdmVhcmFiaWMiLDE2MzcsImZpdmViZW5nYWxpIiwyNTM5LCJmaXZlY2lyY2xlIiw5MzE2LCJmaXZlY2lyY2xlaW52ZXJzZXNhbnNzZXJpZiIsMTAxMjYsImZpdmVkZXZhIiwyNDExLCJmaXZlZWlnaHRocyIsODU0MSwiZml2ZWd1amFyYXRpIiwyNzk1LCJmaXZlZ3VybXVraGkiLDI2NjcsImZpdmVoYWNrYXJhYmljIiwxNjM3LCJmaXZlaGFuZ3pob3UiLDEyMzI1LCJmaXZlaWRlb2dyYXBoaWNwYXJlbiIsMTI4MzYsImZpdmVpbmZlcmlvciIsODMyNSwiZml2ZW1vbm9zcGFjZSIsNjUzMDEsImZpdmVvbGRzdHlsZSIsNjMyODUsImZpdmVwYXJlbiIsOTMzNiwiZml2ZXBlcmlvZCIsOTM1NiwiZml2ZXBlcnNpYW4iLDE3ODEsImZpdmVyb21hbiIsODU2NCwiZml2ZXN1cGVyaW9yIiw4MzA5LCJmaXZldGhhaSIsMzY2OSwiZmwiLDY0MjU4LCJmbG9yaW4iLDQwMiwiZm1vbm9zcGFjZSIsNjUzNTAsImZtc3F1YXJlIiwxMzIwOSwiZm9mYW50aGFpIiwzNjE1LCJmb2ZhdGhhaSIsMzYxMywiZm9uZ21hbnRoYWkiLDM2NjMsImZvcmFsbCIsODcwNCwiZm91ciIsNTIsImZvdXJhcmFiaWMiLDE2MzYsImZvdXJiZW5nYWxpIiwyNTM4LCJmb3VyY2lyY2xlIiw5MzE1LCJmb3VyY2lyY2xlaW52ZXJzZXNhbnNzZXJpZiIsMTAxMjUsImZvdXJkZXZhIiwyNDEwLCJmb3VyZ3VqYXJhdGkiLDI3OTQsImZvdXJndXJtdWtoaSIsMjY2NiwiZm91cmhhY2thcmFiaWMiLDE2MzYsImZvdXJoYW5nemhvdSIsMTIzMjQsImZvdXJpZGVvZ3JhcGhpY3BhcmVuIiwxMjgzNSwiZm91cmluZmVyaW9yIiw4MzI0LCJmb3VybW9ub3NwYWNlIiw2NTMwMCwiZm91cm51bWVyYXRvcmJlbmdhbGkiLDI1NTEsImZvdXJvbGRzdHlsZSIsNjMyODQsImZvdXJwYXJlbiIsOTMzNSwiZm91cnBlcmlvZCIsOTM1NSwiZm91cnBlcnNpYW4iLDE3ODAsImZvdXJyb21hbiIsODU2MywiZm91cnN1cGVyaW9yIiw4MzA4LCJmb3VydGVlbmNpcmNsZSIsOTMyNSwiZm91cnRlZW5wYXJlbiIsOTM0NSwiZm91cnRlZW5wZXJpb2QiLDkzNjUsImZvdXJ0aGFpIiwzNjY4LCJmb3VydGh0b25lY2hpbmVzZSIsNzE1LCJmcGFyZW4iLDkzNzcsImZyYWN0aW9uIiw4MjYwLCJmcmFuYyIsODM1NSwiZyIsMTAzLCJnYWJlbmdhbGkiLDI0NTUsImdhY3V0ZSIsNTAxLCJnYWRldmEiLDIzMjcsImdhZmFyYWJpYyIsMTcxMSwiZ2FmZmluYWxhcmFiaWMiLDY0NDAzLCJnYWZpbml0aWFsYXJhYmljIiw2NDQwNCwiZ2FmbWVkaWFsYXJhYmljIiw2NDQwNSwiZ2FndWphcmF0aSIsMjcxMSwiZ2FndXJtdWtoaSIsMjU4MywiZ2FoaXJhZ2FuYSIsMTIzNjQsImdha2F0YWthbmEiLDEyNDYwLCJnYW1tYSIsOTQ3LCJnYW1tYWxhdGluc21hbGwiLDYxMSwiZ2FtbWFzdXBlcmlvciIsNzM2LCJnYW5naWFjb3B0aWMiLDEwMDMsImdib3BvbW9mbyIsMTI1NTcsImdicmV2ZSIsMjg3LCJnY2Fyb24iLDQ4NywiZ2NlZGlsbGEiLDI5MSwiZ2NpcmNsZSIsOTQzMCwiZ2NpcmN1bWZsZXgiLDI4NSwiZ2NvbW1hYWNjZW50IiwyOTEsImdkb3QiLDI4OSwiZ2RvdGFjY2VudCIsMjg5LCJnZWN5cmlsbGljIiwxMDc1LCJnZWhpcmFnYW5hIiwxMjM3MCwiZ2VrYXRha2FuYSIsMTI0NjYsImdlb21ldHJpY2FsbHllcXVhbCIsODc4NSwiZ2VyZXNoYWNjZW50aGVicmV3IiwxNDM2LCJnZXJlc2hoZWJyZXciLDE1MjMsImdlcmVzaG11cWRhbWhlYnJldyIsMTQzNywiZ2VybWFuZGJscyIsMjIzLCJnZXJzaGF5aW1hY2NlbnRoZWJyZXciLDE0MzgsImdlcnNoYXlpbWhlYnJldyIsMTUyNCwiZ2V0YW1hcmsiLDEyMzA3LCJnaGFiZW5nYWxpIiwyNDU2LCJnaGFkYXJtZW5pYW4iLDEzOTQsImdoYWRldmEiLDIzMjgsImdoYWd1amFyYXRpIiwyNzEyLCJnaGFndXJtdWtoaSIsMjU4NCwiZ2hhaW5hcmFiaWMiLDE1OTQsImdoYWluZmluYWxhcmFiaWMiLDY1MjMwLCJnaGFpbmluaXRpYWxhcmFiaWMiLDY1MjMxLCJnaGFpbm1lZGlhbGFyYWJpYyIsNjUyMzIsImdoZW1pZGRsZWhvb2tjeXJpbGxpYyIsMTE3MywiZ2hlc3Ryb2tlY3lyaWxsaWMiLDExNzEsImdoZXVwdHVybmN5cmlsbGljIiwxMTY5LCJnaGhhZGV2YSIsMjM5NCwiZ2hoYWd1cm11a2hpIiwyNjUwLCJnaG9vayIsNjA4LCJnaHpzcXVhcmUiLDEzMjAzLCJnaWhpcmFnYW5hIiwxMjM2NiwiZ2lrYXRha2FuYSIsMTI0NjIsImdpbWFybWVuaWFuIiwxMzc5LCJnaW1lbCIsMTQ5MCwiZ2ltZWxkYWdlc2giLDY0MzA2LCJnaW1lbGRhZ2VzaGhlYnJldyIsNjQzMDYsImdpbWVsaGVicmV3IiwxNDkwLCJnamVjeXJpbGxpYyIsMTEwNywiZ2xvdHRhbGludmVydGVkc3Ryb2tlIiw0NDYsImdsb3R0YWxzdG9wIiw2NjAsImdsb3R0YWxzdG9waW52ZXJ0ZWQiLDY2MiwiZ2xvdHRhbHN0b3Btb2QiLDcwNCwiZ2xvdHRhbHN0b3ByZXZlcnNlZCIsNjYxLCJnbG90dGFsc3RvcHJldmVyc2VkbW9kIiw3MDUsImdsb3R0YWxzdG9wcmV2ZXJzZWRzdXBlcmlvciIsNzQwLCJnbG90dGFsc3RvcHN0cm9rZSIsNjczLCJnbG90dGFsc3RvcHN0cm9rZXJldmVyc2VkIiw2NzQsImdtYWNyb24iLDc3MTMsImdtb25vc3BhY2UiLDY1MzUxLCJnb2hpcmFnYW5hIiwxMjM3MiwiZ29rYXRha2FuYSIsMTI0NjgsImdwYXJlbiIsOTM3OCwiZ3Bhc3F1YXJlIiwxMzIyOCwiZ3JhZGllbnQiLDg3MTEsImdyYXZlIiw5NiwiZ3JhdmViZWxvd2NtYiIsNzkwLCJncmF2ZWNtYiIsNzY4LCJncmF2ZWNvbWIiLDc2OCwiZ3JhdmVkZXZhIiwyMzg3LCJncmF2ZWxvd21vZCIsNzE4LCJncmF2ZW1vbm9zcGFjZSIsNjUzNDQsImdyYXZldG9uZWNtYiIsODMyLCJncmVhdGVyIiw2MiwiZ3JlYXRlcmVxdWFsIiw4ODA1LCJncmVhdGVyZXF1YWxvcmxlc3MiLDg5MjMsImdyZWF0ZXJtb25vc3BhY2UiLDY1MzEwLCJncmVhdGVyb3JlcXVpdmFsZW50Iiw4ODE5LCJncmVhdGVyb3JsZXNzIiw4ODIzLCJncmVhdGVyb3ZlcmVxdWFsIiw4ODA3LCJncmVhdGVyc21hbGwiLDY1MTI1LCJnc2NyaXB0Iiw2MDksImdzdHJva2UiLDQ4NSwiZ3VoaXJhZ2FuYSIsMTIzNjgsImd1aWxsZW1vdGxlZnQiLDE3MSwiZ3VpbGxlbW90cmlnaHQiLDE4NywiZ3VpbHNpbmdsbGVmdCIsODI0OSwiZ3VpbHNpbmdscmlnaHQiLDgyNTAsImd1a2F0YWthbmEiLDEyNDY0LCJndXJhbXVzcXVhcmUiLDEzMDgwLCJneXNxdWFyZSIsMTMyNTcsImgiLDEwNCwiaGFhYmtoYXNpYW5jeXJpbGxpYyIsMTE5MywiaGFhbHRvbmVhcmFiaWMiLDE3MjksImhhYmVuZ2FsaSIsMjQ4OSwiaGFkZXNjZW5kZXJjeXJpbGxpYyIsMTIwMywiaGFkZXZhIiwyMzYxLCJoYWd1amFyYXRpIiwyNzQ1LCJoYWd1cm11a2hpIiwyNjE3LCJoYWhhcmFiaWMiLDE1ODEsImhhaGZpbmFsYXJhYmljIiw2NTE4NiwiaGFoaW5pdGlhbGFyYWJpYyIsNjUxODcsImhhaGlyYWdhbmEiLDEyMzk5LCJoYWhtZWRpYWxhcmFiaWMiLDY1MTg4LCJoYWl0dXNxdWFyZSIsMTMwOTgsImhha2F0YWthbmEiLDEyNDk1LCJoYWthdGFrYW5haGFsZndpZHRoIiw2NTQxOCwiaGFsYW50Z3VybXVraGkiLDI2MzcsImhhbXphYXJhYmljIiwxNTY5LCJoYW16YWxvd2FyYWJpYyIsMTU2OSwiaGFuZ3VsZmlsbGVyIiwxMjY0NCwiaGFyZHNpZ25jeXJpbGxpYyIsMTA5OCwiaGFycG9vbmxlZnRiYXJidXAiLDg2MzYsImhhcnBvb25yaWdodGJhcmJ1cCIsODY0MCwiaGFzcXVhcmUiLDEzMjU4LCJoYXRhZnBhdGFoIiwxNDU4LCJoYXRhZnBhdGFoMTYiLDE0NTgsImhhdGFmcGF0YWgyMyIsMTQ1OCwiaGF0YWZwYXRhaDJmIiwxNDU4LCJoYXRhZnBhdGFoaGVicmV3IiwxNDU4LCJoYXRhZnBhdGFobmFycm93aGVicmV3IiwxNDU4LCJoYXRhZnBhdGFocXVhcnRlcmhlYnJldyIsMTQ1OCwiaGF0YWZwYXRhaHdpZGVoZWJyZXciLDE0NTgsImhhdGFmcWFtYXRzIiwxNDU5LCJoYXRhZnFhbWF0czFiIiwxNDU5LCJoYXRhZnFhbWF0czI4IiwxNDU5LCJoYXRhZnFhbWF0czM0IiwxNDU5LCJoYXRhZnFhbWF0c2hlYnJldyIsMTQ1OSwiaGF0YWZxYW1hdHNuYXJyb3doZWJyZXciLDE0NTksImhhdGFmcWFtYXRzcXVhcnRlcmhlYnJldyIsMTQ1OSwiaGF0YWZxYW1hdHN3aWRlaGVicmV3IiwxNDU5LCJoYXRhZnNlZ29sIiwxNDU3LCJoYXRhZnNlZ29sMTciLDE0NTcsImhhdGFmc2Vnb2wyNCIsMTQ1NywiaGF0YWZzZWdvbDMwIiwxNDU3LCJoYXRhZnNlZ29saGVicmV3IiwxNDU3LCJoYXRhZnNlZ29sbmFycm93aGVicmV3IiwxNDU3LCJoYXRhZnNlZ29scXVhcnRlcmhlYnJldyIsMTQ1NywiaGF0YWZzZWdvbHdpZGVoZWJyZXciLDE0NTcsImhiYXIiLDI5NSwiaGJvcG9tb2ZvIiwxMjU1OSwiaGJyZXZlYmVsb3ciLDc3MjMsImhjZWRpbGxhIiw3NzIxLCJoY2lyY2xlIiw5NDMxLCJoY2lyY3VtZmxleCIsMjkzLCJoZGllcmVzaXMiLDc3MTksImhkb3RhY2NlbnQiLDc3MTUsImhkb3RiZWxvdyIsNzcxNywiaGUiLDE0OTIsImhlYXJ0Iiw5ODI5LCJoZWFydHN1aXRibGFjayIsOTgyOSwiaGVhcnRzdWl0d2hpdGUiLDk4MjUsImhlZGFnZXNoIiw2NDMwOCwiaGVkYWdlc2hoZWJyZXciLDY0MzA4LCJoZWhhbHRvbmVhcmFiaWMiLDE3MjksImhlaGFyYWJpYyIsMTYwNywiaGVoZWJyZXciLDE0OTIsImhlaGZpbmFsYWx0b25lYXJhYmljIiw2NDQyMywiaGVoZmluYWxhbHR0d29hcmFiaWMiLDY1MjU4LCJoZWhmaW5hbGFyYWJpYyIsNjUyNTgsImhlaGhhbXphYWJvdmVmaW5hbGFyYWJpYyIsNjQ0MjEsImhlaGhhbXphYWJvdmVpc29sYXRlZGFyYWJpYyIsNjQ0MjAsImhlaGluaXRpYWxhbHRvbmVhcmFiaWMiLDY0NDI0LCJoZWhpbml0aWFsYXJhYmljIiw2NTI1OSwiaGVoaXJhZ2FuYSIsMTI0MDgsImhlaG1lZGlhbGFsdG9uZWFyYWJpYyIsNjQ0MjUsImhlaG1lZGlhbGFyYWJpYyIsNjUyNjAsImhlaXNlaWVyYXNxdWFyZSIsMTMxNzksImhla2F0YWthbmEiLDEyNTA0LCJoZWthdGFrYW5haGFsZndpZHRoIiw2NTQyMSwiaGVrdXRhYXJ1c3F1YXJlIiwxMzExMCwiaGVuZ2hvb2siLDYxNSwiaGVydXR1c3F1YXJlIiwxMzExMywiaGV0IiwxNDk1LCJoZXRoZWJyZXciLDE0OTUsImhob29rIiw2MTQsImhob29rc3VwZXJpb3IiLDY4OSwiaGlldWhhY2lyY2xla29yZWFuIiwxMjkyMywiaGlldWhhcGFyZW5rb3JlYW4iLDEyODI3LCJoaWV1aGNpcmNsZWtvcmVhbiIsMTI5MDksImhpZXVoa29yZWFuIiwxMjYyMiwiaGlldWhwYXJlbmtvcmVhbiIsMTI4MTMsImhpaGlyYWdhbmEiLDEyNDAyLCJoaWthdGFrYW5hIiwxMjQ5OCwiaGlrYXRha2FuYWhhbGZ3aWR0aCIsNjU0MTksImhpcmlxIiwxNDYwLCJoaXJpcTE0IiwxNDYwLCJoaXJpcTIxIiwxNDYwLCJoaXJpcTJkIiwxNDYwLCJoaXJpcWhlYnJldyIsMTQ2MCwiaGlyaXFuYXJyb3doZWJyZXciLDE0NjAsImhpcmlxcXVhcnRlcmhlYnJldyIsMTQ2MCwiaGlyaXF3aWRlaGVicmV3IiwxNDYwLCJobGluZWJlbG93Iiw3ODMwLCJobW9ub3NwYWNlIiw2NTM1MiwiaG9hcm1lbmlhbiIsMTM5MiwiaG9oaXB0aGFpIiwzNjI3LCJob2hpcmFnYW5hIiwxMjQxMSwiaG9rYXRha2FuYSIsMTI1MDcsImhva2F0YWthbmFoYWxmd2lkdGgiLDY1NDIyLCJob2xhbSIsMTQ2NSwiaG9sYW0xOSIsMTQ2NSwiaG9sYW0yNiIsMTQ2NSwiaG9sYW0zMiIsMTQ2NSwiaG9sYW1oZWJyZXciLDE0NjUsImhvbGFtbmFycm93aGVicmV3IiwxNDY1LCJob2xhbXF1YXJ0ZXJoZWJyZXciLDE0NjUsImhvbGFtd2lkZWhlYnJldyIsMTQ2NSwiaG9ub2todWt0aGFpIiwzNjMwLCJob29rYWJvdmVjb21iIiw3NzcsImhvb2tjbWIiLDc3NywiaG9va3BhbGF0YWxpemVkYmVsb3djbWIiLDgwMSwiaG9va3JldHJvZmxleGJlbG93Y21iIiw4MDIsImhvb25zcXVhcmUiLDEzMTIyLCJob3JpY29wdGljIiwxMDAxLCJob3Jpem9udGFsYmFyIiw4MjEzLCJob3JuY21iIiw3OTUsImhvdHNwcmluZ3MiLDk4MzIsImhvdXNlIiw4OTYyLCJocGFyZW4iLDkzNzksImhzdXBlcmlvciIsNjg4LCJodHVybmVkIiw2MTMsImh1aGlyYWdhbmEiLDEyNDA1LCJodWlpdG9zcXVhcmUiLDEzMTA3LCJodWthdGFrYW5hIiwxMjUwMSwiaHVrYXRha2FuYWhhbGZ3aWR0aCIsNjU0MjAsImh1bmdhcnVtbGF1dCIsNzMzLCJodW5nYXJ1bWxhdXRjbWIiLDc3OSwiaHYiLDQwNSwiaHlwaGVuIiw0NSwiaHlwaGVuaW5mZXJpb3IiLDYzMjA1LCJoeXBoZW5tb25vc3BhY2UiLDY1MjkzLCJoeXBoZW5zbWFsbCIsNjUxMjMsImh5cGhlbnN1cGVyaW9yIiw2MzIwNiwiaHlwaGVudHdvIiw4MjA4LCJpIiwxMDUsImlhY3V0ZSIsMjM3LCJpYWN5cmlsbGljIiwxMTAzLCJpYmVuZ2FsaSIsMjQzOSwiaWJvcG9tb2ZvIiwxMjU4MywiaWJyZXZlIiwzMDEsImljYXJvbiIsNDY0LCJpY2lyY2xlIiw5NDMyLCJpY2lyY3VtZmxleCIsMjM4LCJpY3lyaWxsaWMiLDExMTAsImlkYmxncmF2ZSIsNTIxLCJpZGVvZ3JhcGhlYXJ0aGNpcmNsZSIsMTI5NDMsImlkZW9ncmFwaGZpcmVjaXJjbGUiLDEyOTM5LCJpZGVvZ3JhcGhpY2FsbGlhbmNlcGFyZW4iLDEyODYzLCJpZGVvZ3JhcGhpY2NhbGxwYXJlbiIsMTI4NTgsImlkZW9ncmFwaGljY2VudHJlY2lyY2xlIiwxMjk2NSwiaWRlb2dyYXBoaWNjbG9zZSIsMTIyOTQsImlkZW9ncmFwaGljY29tbWEiLDEyMjg5LCJpZGVvZ3JhcGhpY2NvbW1hbGVmdCIsNjUzODAsImlkZW9ncmFwaGljY29uZ3JhdHVsYXRpb25wYXJlbiIsMTI4NTUsImlkZW9ncmFwaGljY29ycmVjdGNpcmNsZSIsMTI5NjMsImlkZW9ncmFwaGljZWFydGhwYXJlbiIsMTI4NDcsImlkZW9ncmFwaGljZW50ZXJwcmlzZXBhcmVuIiwxMjg2MSwiaWRlb2dyYXBoaWNleGNlbGxlbnRjaXJjbGUiLDEyOTU3LCJpZGVvZ3JhcGhpY2Zlc3RpdmFscGFyZW4iLDEyODY0LCJpZGVvZ3JhcGhpY2ZpbmFuY2lhbGNpcmNsZSIsMTI5NTAsImlkZW9ncmFwaGljZmluYW5jaWFscGFyZW4iLDEyODU0LCJpZGVvZ3JhcGhpY2ZpcmVwYXJlbiIsMTI4NDMsImlkZW9ncmFwaGljaGF2ZXBhcmVuIiwxMjg1MCwiaWRlb2dyYXBoaWNoaWdoY2lyY2xlIiwxMjk2NCwiaWRlb2dyYXBoaWNpdGVyYXRpb25tYXJrIiwxMjI5MywiaWRlb2dyYXBoaWNsYWJvcmNpcmNsZSIsMTI5NTIsImlkZW9ncmFwaGljbGFib3JwYXJlbiIsMTI4NTYsImlkZW9ncmFwaGljbGVmdGNpcmNsZSIsMTI5NjcsImlkZW9ncmFwaGljbG93Y2lyY2xlIiwxMjk2NiwiaWRlb2dyYXBoaWNtZWRpY2luZWNpcmNsZSIsMTI5NjksImlkZW9ncmFwaGljbWV0YWxwYXJlbiIsMTI4NDYsImlkZW9ncmFwaGljbW9vbnBhcmVuIiwxMjg0MiwiaWRlb2dyYXBoaWNuYW1lcGFyZW4iLDEyODUyLCJpZGVvZ3JhcGhpY3BlcmlvZCIsMTIyOTAsImlkZW9ncmFwaGljcHJpbnRjaXJjbGUiLDEyOTU4LCJpZGVvZ3JhcGhpY3JlYWNocGFyZW4iLDEyODY3LCJpZGVvZ3JhcGhpY3JlcHJlc2VudHBhcmVuIiwxMjg1NywiaWRlb2dyYXBoaWNyZXNvdXJjZXBhcmVuIiwxMjg2MiwiaWRlb2dyYXBoaWNyaWdodGNpcmNsZSIsMTI5NjgsImlkZW9ncmFwaGljc2VjcmV0Y2lyY2xlIiwxMjk1MywiaWRlb2dyYXBoaWNzZWxmcGFyZW4iLDEyODY2LCJpZGVvZ3JhcGhpY3NvY2lldHlwYXJlbiIsMTI4NTEsImlkZW9ncmFwaGljc3BhY2UiLDEyMjg4LCJpZGVvZ3JhcGhpY3NwZWNpYWxwYXJlbiIsMTI4NTMsImlkZW9ncmFwaGljc3RvY2twYXJlbiIsMTI4NDksImlkZW9ncmFwaGljc3R1ZHlwYXJlbiIsMTI4NTksImlkZW9ncmFwaGljc3VucGFyZW4iLDEyODQ4LCJpZGVvZ3JhcGhpY3N1cGVydmlzZXBhcmVuIiwxMjg2MCwiaWRlb2dyYXBoaWN3YXRlcnBhcmVuIiwxMjg0NCwiaWRlb2dyYXBoaWN3b29kcGFyZW4iLDEyODQ1LCJpZGVvZ3JhcGhpY3plcm8iLDEyMjk1LCJpZGVvZ3JhcGhtZXRhbGNpcmNsZSIsMTI5NDIsImlkZW9ncmFwaG1vb25jaXJjbGUiLDEyOTM4LCJpZGVvZ3JhcGhuYW1lY2lyY2xlIiwxMjk0OCwiaWRlb2dyYXBoc3VuY2lyY2xlIiwxMjk0NCwiaWRlb2dyYXBod2F0ZXJjaXJjbGUiLDEyOTQwLCJpZGVvZ3JhcGh3b29kY2lyY2xlIiwxMjk0MSwiaWRldmEiLDIzMTEsImlkaWVyZXNpcyIsMjM5LCJpZGllcmVzaXNhY3V0ZSIsNzcyNywiaWRpZXJlc2lzY3lyaWxsaWMiLDEyNTMsImlkb3RiZWxvdyIsNzg4MywiaWVicmV2ZWN5cmlsbGljIiwxMjM5LCJpZWN5cmlsbGljIiwxMDc3LCJpZXVuZ2FjaXJjbGVrb3JlYW4iLDEyOTE3LCJpZXVuZ2FwYXJlbmtvcmVhbiIsMTI4MjEsImlldW5nY2lyY2xla29yZWFuIiwxMjkwMywiaWV1bmdrb3JlYW4iLDEyNjE1LCJpZXVuZ3BhcmVua29yZWFuIiwxMjgwNywiaWdyYXZlIiwyMzYsImlndWphcmF0aSIsMjY5NSwiaWd1cm11a2hpIiwyNTY3LCJpaGlyYWdhbmEiLDEyMzU2LCJpaG9va2Fib3ZlIiw3ODgxLCJpaWJlbmdhbGkiLDI0NDAsImlpY3lyaWxsaWMiLDEwODAsImlpZGV2YSIsMjMxMiwiaWlndWphcmF0aSIsMjY5NiwiaWlndXJtdWtoaSIsMjU2OCwiaWltYXRyYWd1cm11a2hpIiwyNjI0LCJpaW52ZXJ0ZWRicmV2ZSIsNTIzLCJpaXNob3J0Y3lyaWxsaWMiLDEwODEsImlpdm93ZWxzaWduYmVuZ2FsaSIsMjQ5NiwiaWl2b3dlbHNpZ25kZXZhIiwyMzY4LCJpaXZvd2Vsc2lnbmd1amFyYXRpIiwyNzUyLCJpaiIsMzA3LCJpa2F0YWthbmEiLDEyNDUyLCJpa2F0YWthbmFoYWxmd2lkdGgiLDY1Mzk0LCJpa29yZWFuIiwxMjY0MywiaWxkZSIsNzMyLCJpbHV5aGVicmV3IiwxNDUyLCJpbWFjcm9uIiwyOTksImltYWNyb25jeXJpbGxpYyIsMTI1MSwiaW1hZ2VvcmFwcHJveGltYXRlbHllcXVhbCIsODc4NywiaW1hdHJhZ3VybXVraGkiLDI2MjMsImltb25vc3BhY2UiLDY1MzUzLCJpbmNyZW1lbnQiLDg3MTAsImluZmluaXR5Iiw4NzM0LCJpbmlhcm1lbmlhbiIsMTM4NywiaW50ZWdyYWwiLDg3NDcsImludGVncmFsYm90dG9tIiw4OTkzLCJpbnRlZ3JhbGJ0Iiw4OTkzLCJpbnRlZ3JhbGV4Iiw2MzczMywiaW50ZWdyYWx0b3AiLDg5OTIsImludGVncmFsdHAiLDg5OTIsImludGVyc2VjdGlvbiIsODc0NSwiaW50aXNxdWFyZSIsMTMwNjEsImludmJ1bGxldCIsOTY4OCwiaW52Y2lyY2xlIiw5Njg5LCJpbnZzbWlsZWZhY2UiLDk3ODcsImlvY3lyaWxsaWMiLDExMDUsImlvZ29uZWsiLDMwMywiaW90YSIsOTUzLCJpb3RhZGllcmVzaXMiLDk3MCwiaW90YWRpZXJlc2lzdG9ub3MiLDkxMiwiaW90YWxhdGluIiw2MTcsImlvdGF0b25vcyIsOTQzLCJpcGFyZW4iLDkzODAsImlyaWd1cm11a2hpIiwyNjc0LCJpc21hbGxoaXJhZ2FuYSIsMTIzNTUsImlzbWFsbGthdGFrYW5hIiwxMjQ1MSwiaXNtYWxsa2F0YWthbmFoYWxmd2lkdGgiLDY1Mzg0LCJpc3NoYXJiZW5nYWxpIiwyNTU0LCJpc3Ryb2tlIiw2MTYsImlzdXBlcmlvciIsNjMyMTMsIml0ZXJhdGlvbmhpcmFnYW5hIiwxMjQ0NSwiaXRlcmF0aW9ua2F0YWthbmEiLDEyNTQxLCJpdGlsZGUiLDI5NywiaXRpbGRlYmVsb3ciLDc3MjUsIml1Ym9wb21vZm8iLDEyNTg1LCJpdWN5cmlsbGljIiwxMTAyLCJpdm93ZWxzaWduYmVuZ2FsaSIsMjQ5NSwiaXZvd2Vsc2lnbmRldmEiLDIzNjcsIml2b3dlbHNpZ25ndWphcmF0aSIsMjc1MSwiaXpoaXRzYWN5cmlsbGljIiwxMTQxLCJpemhpdHNhZGJsZ3JhdmVjeXJpbGxpYyIsMTE0MywiaiIsMTA2LCJqYWFybWVuaWFuIiwxMzkzLCJqYWJlbmdhbGkiLDI0NjAsImphZGV2YSIsMjMzMiwiamFndWphcmF0aSIsMjcxNiwiamFndXJtdWtoaSIsMjU4OCwiamJvcG9tb2ZvIiwxMjU2MCwiamNhcm9uIiw0OTYsImpjaXJjbGUiLDk0MzMsImpjaXJjdW1mbGV4IiwzMDksImpjcm9zc2VkdGFpbCIsNjY5LCJqZG90bGVzc3N0cm9rZSIsNjA3LCJqZWN5cmlsbGljIiwxMTEyLCJqZWVtYXJhYmljIiwxNTgwLCJqZWVtZmluYWxhcmFiaWMiLDY1MTgyLCJqZWVtaW5pdGlhbGFyYWJpYyIsNjUxODMsImplZW1tZWRpYWxhcmFiaWMiLDY1MTg0LCJqZWhhcmFiaWMiLDE2ODgsImplaGZpbmFsYXJhYmljIiw2NDM5NSwiamhhYmVuZ2FsaSIsMjQ2MSwiamhhZGV2YSIsMjMzMywiamhhZ3VqYXJhdGkiLDI3MTcsImpoYWd1cm11a2hpIiwyNTg5LCJqaGVoYXJtZW5pYW4iLDE0MDMsImppcyIsMTIyOTIsImptb25vc3BhY2UiLDY1MzU0LCJqcGFyZW4iLDkzODEsImpzdXBlcmlvciIsNjkwLCJrIiwxMDcsImthYmFzaGtpcmN5cmlsbGljIiwxMTg1LCJrYWJlbmdhbGkiLDI0NTMsImthY3V0ZSIsNzcyOSwia2FjeXJpbGxpYyIsMTA4Miwia2FkZXNjZW5kZXJjeXJpbGxpYyIsMTE3OSwia2FkZXZhIiwyMzI1LCJrYWYiLDE0OTksImthZmFyYWJpYyIsMTYwMywia2FmZGFnZXNoIiw2NDMxNSwia2FmZGFnZXNoaGVicmV3Iiw2NDMxNSwia2FmZmluYWxhcmFiaWMiLDY1MjQyLCJrYWZoZWJyZXciLDE0OTksImthZmluaXRpYWxhcmFiaWMiLDY1MjQzLCJrYWZtZWRpYWxhcmFiaWMiLDY1MjQ0LCJrYWZyYWZlaGVicmV3Iiw2NDMzMywia2FndWphcmF0aSIsMjcwOSwia2FndXJtdWtoaSIsMjU4MSwia2FoaXJhZ2FuYSIsMTIzNjMsImthaG9va2N5cmlsbGljIiwxMjIwLCJrYWthdGFrYW5hIiwxMjQ1OSwia2FrYXRha2FuYWhhbGZ3aWR0aCIsNjUzOTgsImthcHBhIiw5NTQsImthcHBhc3ltYm9sZ3JlZWsiLDEwMDgsImthcHllb3VubWlldW1rb3JlYW4iLDEyNjU3LCJrYXB5ZW91bnBoaWV1cGhrb3JlYW4iLDEyNjc2LCJrYXB5ZW91bnBpZXVwa29yZWFuIiwxMjY2NCwia2FweWVvdW5zc2FuZ3BpZXVwa29yZWFuIiwxMjY2NSwia2Fyb3JpaXNxdWFyZSIsMTMwNjksImthc2hpZGFhdXRvYXJhYmljIiwxNjAwLCJrYXNoaWRhYXV0b25vc2lkZWJlYXJpbmdhcmFiaWMiLDE2MDAsImthc21hbGxrYXRha2FuYSIsMTI1MzMsImthc3F1YXJlIiwxMzE4OCwia2FzcmFhcmFiaWMiLDE2MTYsImthc3JhdGFuYXJhYmljIiwxNjEzLCJrYXN0cm9rZWN5cmlsbGljIiwxMTgzLCJrYXRhaGlyYXByb2xvbmdtYXJraGFsZndpZHRoIiw2NTM5Miwia2F2ZXJ0aWNhbHN0cm9rZWN5cmlsbGljIiwxMTgxLCJrYm9wb21vZm8iLDEyNTU4LCJrY2Fsc3F1YXJlIiwxMzE5Mywia2Nhcm9uIiw0ODksImtjZWRpbGxhIiwzMTEsImtjaXJjbGUiLDk0MzQsImtjb21tYWFjY2VudCIsMzExLCJrZG90YmVsb3ciLDc3MzEsImtlaGFybWVuaWFuIiwxNDEyLCJrZWhpcmFnYW5hIiwxMjM2OSwia2VrYXRha2FuYSIsMTI0NjUsImtla2F0YWthbmFoYWxmd2lkdGgiLDY1NDAxLCJrZW5hcm1lbmlhbiIsMTM5MSwia2VzbWFsbGthdGFrYW5hIiwxMjUzNCwia2dyZWVubGFuZGljIiwzMTIsImtoYWJlbmdhbGkiLDI0NTQsImtoYWN5cmlsbGljIiwxMDkzLCJraGFkZXZhIiwyMzI2LCJraGFndWphcmF0aSIsMjcxMCwia2hhZ3VybXVraGkiLDI1ODIsImtoYWhhcmFiaWMiLDE1ODIsImtoYWhmaW5hbGFyYWJpYyIsNjUxOTAsImtoYWhpbml0aWFsYXJhYmljIiw2NTE5MSwia2hhaG1lZGlhbGFyYWJpYyIsNjUxOTIsImtoZWljb3B0aWMiLDk5OSwia2hoYWRldmEiLDIzOTMsImtoaGFndXJtdWtoaSIsMjY0OSwia2hpZXVraGFjaXJjbGVrb3JlYW4iLDEyOTIwLCJraGlldWtoYXBhcmVua29yZWFuIiwxMjgyNCwia2hpZXVraGNpcmNsZWtvcmVhbiIsMTI5MDYsImtoaWV1a2hrb3JlYW4iLDEyNjE5LCJraGlldWtocGFyZW5rb3JlYW4iLDEyODEwLCJraG9raGFpdGhhaSIsMzU4Niwia2hva2hvbnRoYWkiLDM1ODksImtob2todWF0dGhhaSIsMzU4Nywia2hva2h3YWl0aGFpIiwzNTg4LCJraG9tdXR0aGFpIiwzNjc1LCJraG9vayIsNDA5LCJraG9yYWtoYW5ndGhhaSIsMzU5MCwia2h6c3F1YXJlIiwxMzIwMSwia2loaXJhZ2FuYSIsMTIzNjUsImtpa2F0YWthbmEiLDEyNDYxLCJraWthdGFrYW5haGFsZndpZHRoIiw2NTM5OSwia2lyb2d1cmFtdXNxdWFyZSIsMTMwNzcsImtpcm9tZWV0b3J1c3F1YXJlIiwxMzA3OCwia2lyb3NxdWFyZSIsMTMwNzYsImtpeWVva2FjaXJjbGVrb3JlYW4iLDEyOTEwLCJraXllb2thcGFyZW5rb3JlYW4iLDEyODE0LCJraXllb2tjaXJjbGVrb3JlYW4iLDEyODk2LCJraXllb2trb3JlYW4iLDEyNTkzLCJraXllb2twYXJlbmtvcmVhbiIsMTI4MDAsImtpeWVva3Npb3Nrb3JlYW4iLDEyNTk1LCJramVjeXJpbGxpYyIsMTExNiwia2xpbmViZWxvdyIsNzczMywia2xzcXVhcmUiLDEzMjA4LCJrbWN1YmVkc3F1YXJlIiwxMzIyMiwia21vbm9zcGFjZSIsNjUzNTUsImttc3F1YXJlZHNxdWFyZSIsMTMyMTgsImtvaGlyYWdhbmEiLDEyMzcxLCJrb2htc3F1YXJlIiwxMzI0OCwia29rYWl0aGFpIiwzNTg1LCJrb2thdGFrYW5hIiwxMjQ2Nywia29rYXRha2FuYWhhbGZ3aWR0aCIsNjU0MDIsImtvb3Bvc3F1YXJlIiwxMzA4Niwia29wcGFjeXJpbGxpYyIsMTE1Mywia29yZWFuc3RhbmRhcmRzeW1ib2wiLDEyOTI3LCJrb3JvbmlzY21iIiw4MzUsImtwYXJlbiIsOTM4Miwia3Bhc3F1YXJlIiwxMzIyNiwia3NpY3lyaWxsaWMiLDExMzUsImt0c3F1YXJlIiwxMzI2Mywia3R1cm5lZCIsNjcwLCJrdWhpcmFnYW5hIiwxMjM2Nywia3VrYXRha2FuYSIsMTI0NjMsImt1a2F0YWthbmFoYWxmd2lkdGgiLDY1NDAwLCJrdnNxdWFyZSIsMTMyNDAsImt3c3F1YXJlIiwxMzI0NiwibCIsMTA4LCJsYWJlbmdhbGkiLDI0ODIsImxhY3V0ZSIsMzE0LCJsYWRldmEiLDIzNTQsImxhZ3VqYXJhdGkiLDI3MzgsImxhZ3VybXVraGkiLDI2MTAsImxha2toYW5neWFvdGhhaSIsMzY1MywibGFtYWxlZmZpbmFsYXJhYmljIiw2NTI3NiwibGFtYWxlZmhhbXphYWJvdmVmaW5hbGFyYWJpYyIsNjUyNzIsImxhbWFsZWZoYW16YWFib3ZlaXNvbGF0ZWRhcmFiaWMiLDY1MjcxLCJsYW1hbGVmaGFtemFiZWxvd2ZpbmFsYXJhYmljIiw2NTI3NCwibGFtYWxlZmhhbXphYmVsb3dpc29sYXRlZGFyYWJpYyIsNjUyNzMsImxhbWFsZWZpc29sYXRlZGFyYWJpYyIsNjUyNzUsImxhbWFsZWZtYWRkYWFib3ZlZmluYWxhcmFiaWMiLDY1MjcwLCJsYW1hbGVmbWFkZGFhYm92ZWlzb2xhdGVkYXJhYmljIiw2NTI2OSwibGFtYXJhYmljIiwxNjA0LCJsYW1iZGEiLDk1NSwibGFtYmRhc3Ryb2tlIiw0MTEsImxhbWVkIiwxNTAwLCJsYW1lZGRhZ2VzaCIsNjQzMTYsImxhbWVkZGFnZXNoaGVicmV3Iiw2NDMxNiwibGFtZWRoZWJyZXciLDE1MDAsImxhbWZpbmFsYXJhYmljIiw2NTI0NiwibGFtaGFoaW5pdGlhbGFyYWJpYyIsNjQ3MTQsImxhbWluaXRpYWxhcmFiaWMiLDY1MjQ3LCJsYW1qZWVtaW5pdGlhbGFyYWJpYyIsNjQ3MTMsImxhbWtoYWhpbml0aWFsYXJhYmljIiw2NDcxNSwibGFtbGFtaGVoaXNvbGF0ZWRhcmFiaWMiLDY1MDEwLCJsYW1tZWRpYWxhcmFiaWMiLDY1MjQ4LCJsYW1tZWVtaGFoaW5pdGlhbGFyYWJpYyIsNjQ5MDQsImxhbW1lZW1pbml0aWFsYXJhYmljIiw2NDcxNiwibGFyZ2VjaXJjbGUiLDk3MTEsImxiYXIiLDQxMCwibGJlbHQiLDYyMCwibGJvcG9tb2ZvIiwxMjU1NiwibGNhcm9uIiwzMTgsImxjZWRpbGxhIiwzMTYsImxjaXJjbGUiLDk0MzUsImxjaXJjdW1mbGV4YmVsb3ciLDc3NDEsImxjb21tYWFjY2VudCIsMzE2LCJsZG90IiwzMjAsImxkb3RhY2NlbnQiLDMyMCwibGRvdGJlbG93Iiw3NzM1LCJsZG90YmVsb3dtYWNyb24iLDc3MzcsImxlZnRhbmdsZWFib3ZlY21iIiw3OTQsImxlZnR0YWNrYmVsb3djbWIiLDc5MiwibGVzcyIsNjAsImxlc3NlcXVhbCIsODgwNCwibGVzc2VxdWFsb3JncmVhdGVyIiw4OTIyLCJsZXNzbW9ub3NwYWNlIiw2NTMwOCwibGVzc29yZXF1aXZhbGVudCIsODgxOCwibGVzc29yZ3JlYXRlciIsODgyMiwibGVzc292ZXJlcXVhbCIsODgwNiwibGVzc3NtYWxsIiw2NTEyNCwibGV6aCIsNjIyLCJsZmJsb2NrIiw5NjEyLCJsaG9va3JldHJvZmxleCIsNjIxLCJsaXJhIiw4MzU2LCJsaXduYXJtZW5pYW4iLDEzODgsImxqIiw0NTcsImxqZWN5cmlsbGljIiwxMTEzLCJsbCIsNjMxNjgsImxsYWRldmEiLDIzNTUsImxsYWd1amFyYXRpIiwyNzM5LCJsbGluZWJlbG93Iiw3NzM5LCJsbGxhZGV2YSIsMjM1NiwibGx2b2NhbGljYmVuZ2FsaSIsMjUyOSwibGx2b2NhbGljZGV2YSIsMjQwMSwibGx2b2NhbGljdm93ZWxzaWduYmVuZ2FsaSIsMjUzMSwibGx2b2NhbGljdm93ZWxzaWduZGV2YSIsMjQwMywibG1pZGRsZXRpbGRlIiw2MTksImxtb25vc3BhY2UiLDY1MzU2LCJsbXNxdWFyZSIsMTMyNjQsImxvY2h1bGF0aGFpIiwzNjI4LCJsb2dpY2FsYW5kIiw4NzQzLCJsb2dpY2Fsbm90IiwxNzIsImxvZ2ljYWxub3RyZXZlcnNlZCIsODk3NiwibG9naWNhbG9yIiw4NzQ0LCJsb2xpbmd0aGFpIiwzNjIxLCJsb25ncyIsMzgzLCJsb3dsaW5lY2VudGVybGluZSIsNjUxMDIsImxvd2xpbmVjbWIiLDgxOCwibG93bGluZWRhc2hlZCIsNjUxMDEsImxvemVuZ2UiLDk2NzQsImxwYXJlbiIsOTM4MywibHNsYXNoIiwzMjIsImxzcXVhcmUiLDg0NjcsImxzdXBlcmlvciIsNjMyMTQsImx0c2hhZGUiLDk2MTcsImx1dGhhaSIsMzYyMiwibHZvY2FsaWNiZW5nYWxpIiwyNDQ0LCJsdm9jYWxpY2RldmEiLDIzMTYsImx2b2NhbGljdm93ZWxzaWduYmVuZ2FsaSIsMjUzMCwibHZvY2FsaWN2b3dlbHNpZ25kZXZhIiwyNDAyLCJseHNxdWFyZSIsMTMyNjcsIm0iLDEwOSwibWFiZW5nYWxpIiwyNDc4LCJtYWNyb24iLDE3NSwibWFjcm9uYmVsb3djbWIiLDgxNywibWFjcm9uY21iIiw3NzIsIm1hY3Jvbmxvd21vZCIsNzE3LCJtYWNyb25tb25vc3BhY2UiLDY1NTA3LCJtYWN1dGUiLDc3NDMsIm1hZGV2YSIsMjM1MCwibWFndWphcmF0aSIsMjczNCwibWFndXJtdWtoaSIsMjYwNiwibWFoYXBha2hoZWJyZXciLDE0NDQsIm1haGFwYWtobGVmdGhlYnJldyIsMTQ0NCwibWFoaXJhZ2FuYSIsMTI0MTQsIm1haWNoYXR0YXdhbG93bGVmdHRoYWkiLDYzNjM3LCJtYWljaGF0dGF3YWxvd3JpZ2h0dGhhaSIsNjM2MzYsIm1haWNoYXR0YXdhdGhhaSIsMzY1OSwibWFpY2hhdHRhd2F1cHBlcmxlZnR0aGFpIiw2MzYzNSwibWFpZWtsb3dsZWZ0dGhhaSIsNjM2MjgsIm1haWVrbG93cmlnaHR0aGFpIiw2MzYyNywibWFpZWt0aGFpIiwzNjU2LCJtYWlla3VwcGVybGVmdHRoYWkiLDYzNjI2LCJtYWloYW5ha2F0bGVmdHRoYWkiLDYzNjIwLCJtYWloYW5ha2F0dGhhaSIsMzYzMywibWFpdGFpa2h1bGVmdHRoYWkiLDYzNjI1LCJtYWl0YWlraHV0aGFpIiwzNjU1LCJtYWl0aG9sb3dsZWZ0dGhhaSIsNjM2MzEsIm1haXRob2xvd3JpZ2h0dGhhaSIsNjM2MzAsIm1haXRob3RoYWkiLDM2NTcsIm1haXRob3VwcGVybGVmdHRoYWkiLDYzNjI5LCJtYWl0cmlsb3dsZWZ0dGhhaSIsNjM2MzQsIm1haXRyaWxvd3JpZ2h0dGhhaSIsNjM2MzMsIm1haXRyaXRoYWkiLDM2NTgsIm1haXRyaXVwcGVybGVmdHRoYWkiLDYzNjMyLCJtYWl5YW1va3RoYWkiLDM2NTQsIm1ha2F0YWthbmEiLDEyNTEwLCJtYWthdGFrYW5haGFsZndpZHRoIiw2NTQyMywibWFsZSIsOTc5NCwibWFuc3lvbnNxdWFyZSIsMTMxMjcsIm1hcWFmaGVicmV3IiwxNDcwLCJtYXJzIiw5Nzk0LCJtYXNvcmFjaXJjbGVoZWJyZXciLDE0NTUsIm1hc3F1YXJlIiwxMzE4NywibWJvcG9tb2ZvIiwxMjU1MSwibWJzcXVhcmUiLDEzMjY4LCJtY2lyY2xlIiw5NDM2LCJtY3ViZWRzcXVhcmUiLDEzMjIxLCJtZG90YWNjZW50Iiw3NzQ1LCJtZG90YmVsb3ciLDc3NDcsIm1lZW1hcmFiaWMiLDE2MDUsIm1lZW1maW5hbGFyYWJpYyIsNjUyNTAsIm1lZW1pbml0aWFsYXJhYmljIiw2NTI1MSwibWVlbW1lZGlhbGFyYWJpYyIsNjUyNTIsIm1lZW1tZWVtaW5pdGlhbGFyYWJpYyIsNjQ3MjEsIm1lZW1tZWVtaXNvbGF0ZWRhcmFiaWMiLDY0NTg0LCJtZWV0b3J1c3F1YXJlIiwxMzEzMywibWVoaXJhZ2FuYSIsMTI0MTcsIm1laXppZXJhc3F1YXJlIiwxMzE4MiwibWVrYXRha2FuYSIsMTI1MTMsIm1la2F0YWthbmFoYWxmd2lkdGgiLDY1NDI2LCJtZW0iLDE1MDIsIm1lbWRhZ2VzaCIsNjQzMTgsIm1lbWRhZ2VzaGhlYnJldyIsNjQzMTgsIm1lbWhlYnJldyIsMTUwMiwibWVuYXJtZW5pYW4iLDEzOTYsIm1lcmtoYWhlYnJldyIsMTQ0NSwibWVya2hha2VmdWxhaGVicmV3IiwxNDQ2LCJtZXJraGFrZWZ1bGFsZWZ0aGVicmV3IiwxNDQ2LCJtZXJraGFsZWZ0aGVicmV3IiwxNDQ1LCJtaG9vayIsNjI1LCJtaHpzcXVhcmUiLDEzMjAyLCJtaWRkbGVkb3RrYXRha2FuYWhhbGZ3aWR0aCIsNjUzODEsIm1pZGRvdCIsMTgzLCJtaWV1bWFjaXJjbGVrb3JlYW4iLDEyOTE0LCJtaWV1bWFwYXJlbmtvcmVhbiIsMTI4MTgsIm1pZXVtY2lyY2xla29yZWFuIiwxMjkwMCwibWlldW1rb3JlYW4iLDEyNjA5LCJtaWV1bXBhbnNpb3Nrb3JlYW4iLDEyNjU2LCJtaWV1bXBhcmVua29yZWFuIiwxMjgwNCwibWlldW1waWV1cGtvcmVhbiIsMTI2NTQsIm1pZXVtc2lvc2tvcmVhbiIsMTI2NTUsIm1paGlyYWdhbmEiLDEyNDE1LCJtaWthdGFrYW5hIiwxMjUxMSwibWlrYXRha2FuYWhhbGZ3aWR0aCIsNjU0MjQsIm1pbnVzIiw4NzIyLCJtaW51c2JlbG93Y21iIiw4MDAsIm1pbnVzY2lyY2xlIiw4ODU0LCJtaW51c21vZCIsNzI3LCJtaW51c3BsdXMiLDg3MjMsIm1pbnV0ZSIsODI0MiwibWlyaWJhYXJ1c3F1YXJlIiwxMzEzMCwibWlyaXNxdWFyZSIsMTMxMjksIm1sb25nbGVndHVybmVkIiw2MjQsIm1sc3F1YXJlIiwxMzIwNiwibW1jdWJlZHNxdWFyZSIsMTMyMTksIm1tb25vc3BhY2UiLDY1MzU3LCJtbXNxdWFyZWRzcXVhcmUiLDEzMjE1LCJtb2hpcmFnYW5hIiwxMjQxOCwibW9obXNxdWFyZSIsMTMyNDksIm1va2F0YWthbmEiLDEyNTE0LCJtb2thdGFrYW5haGFsZndpZHRoIiw2NTQyNywibW9sc3F1YXJlIiwxMzI3MCwibW9tYXRoYWkiLDM2MTcsIm1vdmVyc3NxdWFyZSIsMTMyMjMsIm1vdmVyc3NxdWFyZWRzcXVhcmUiLDEzMjI0LCJtcGFyZW4iLDkzODQsIm1wYXNxdWFyZSIsMTMyMjcsIm1zc3F1YXJlIiwxMzIzNSwibXN1cGVyaW9yIiw2MzIxNSwibXR1cm5lZCIsNjIzLCJtdSIsMTgxLCJtdTEiLDE4MSwibXVhc3F1YXJlIiwxMzE4NiwibXVjaGdyZWF0ZXIiLDg4MTEsIm11Y2hsZXNzIiw4ODEwLCJtdWZzcXVhcmUiLDEzMTk2LCJtdWdyZWVrIiw5NTYsIm11Z3NxdWFyZSIsMTMxOTcsIm11aGlyYWdhbmEiLDEyNDE2LCJtdWthdGFrYW5hIiwxMjUxMiwibXVrYXRha2FuYWhhbGZ3aWR0aCIsNjU0MjUsIm11bHNxdWFyZSIsMTMyMDUsIm11bHRpcGx5IiwyMTUsIm11bXNxdWFyZSIsMTMyMTEsIm11bmFoaGVicmV3IiwxNDQzLCJtdW5haGxlZnRoZWJyZXciLDE0NDMsIm11c2ljYWxub3RlIiw5ODM0LCJtdXNpY2Fsbm90ZWRibCIsOTgzNSwibXVzaWNmbGF0c2lnbiIsOTgzNywibXVzaWNzaGFycHNpZ24iLDk4MzksIm11c3NxdWFyZSIsMTMyMzQsIm11dnNxdWFyZSIsMTMyMzgsIm11d3NxdWFyZSIsMTMyNDQsIm12bWVnYXNxdWFyZSIsMTMyNDEsIm12c3F1YXJlIiwxMzIzOSwibXdtZWdhc3F1YXJlIiwxMzI0NywibXdzcXVhcmUiLDEzMjQ1LCJuIiwxMTAsIm5hYmVuZ2FsaSIsMjQ3MiwibmFibGEiLDg3MTEsIm5hY3V0ZSIsMzI0LCJuYWRldmEiLDIzNDQsIm5hZ3VqYXJhdGkiLDI3MjgsIm5hZ3VybXVraGkiLDI2MDAsIm5haGlyYWdhbmEiLDEyMzk0LCJuYWthdGFrYW5hIiwxMjQ5MCwibmFrYXRha2FuYWhhbGZ3aWR0aCIsNjU0MTMsIm5hcG9zdHJvcGhlIiwzMjksIm5hc3F1YXJlIiwxMzE4NSwibmJvcG9tb2ZvIiwxMjU1NSwibmJzcGFjZSIsMTYwLCJuY2Fyb24iLDMyOCwibmNlZGlsbGEiLDMyNiwibmNpcmNsZSIsOTQzNywibmNpcmN1bWZsZXhiZWxvdyIsNzc1NSwibmNvbW1hYWNjZW50IiwzMjYsIm5kb3RhY2NlbnQiLDc3NDksIm5kb3RiZWxvdyIsNzc1MSwibmVoaXJhZ2FuYSIsMTIzOTcsIm5la2F0YWthbmEiLDEyNDkzLCJuZWthdGFrYW5haGFsZndpZHRoIiw2NTQxNiwibmV3c2hlcWVsc2lnbiIsODM2MiwibmZzcXVhcmUiLDEzMTk1LCJuZ2FiZW5nYWxpIiwyNDU3LCJuZ2FkZXZhIiwyMzI5LCJuZ2FndWphcmF0aSIsMjcxMywibmdhZ3VybXVraGkiLDI1ODUsIm5nb25ndXRoYWkiLDM1OTEsIm5oaXJhZ2FuYSIsMTI0MzUsIm5ob29rbGVmdCIsNjI2LCJuaG9va3JldHJvZmxleCIsNjI3LCJuaWV1bmFjaXJjbGVrb3JlYW4iLDEyOTExLCJuaWV1bmFwYXJlbmtvcmVhbiIsMTI4MTUsIm5pZXVuY2lldWNrb3JlYW4iLDEyNTk3LCJuaWV1bmNpcmNsZWtvcmVhbiIsMTI4OTcsIm5pZXVuaGlldWhrb3JlYW4iLDEyNTk4LCJuaWV1bmtvcmVhbiIsMTI1OTYsIm5pZXVucGFuc2lvc2tvcmVhbiIsMTI2NDgsIm5pZXVucGFyZW5rb3JlYW4iLDEyODAxLCJuaWV1bnNpb3Nrb3JlYW4iLDEyNjQ3LCJuaWV1bnRpa2V1dGtvcmVhbiIsMTI2NDYsIm5paGlyYWdhbmEiLDEyMzk1LCJuaWthdGFrYW5hIiwxMjQ5MSwibmlrYXRha2FuYWhhbGZ3aWR0aCIsNjU0MTQsIm5pa2hhaGl0bGVmdHRoYWkiLDYzNjQxLCJuaWtoYWhpdHRoYWkiLDM2NjEsIm5pbmUiLDU3LCJuaW5lYXJhYmljIiwxNjQxLCJuaW5lYmVuZ2FsaSIsMjU0MywibmluZWNpcmNsZSIsOTMyMCwibmluZWNpcmNsZWludmVyc2VzYW5zc2VyaWYiLDEwMTMwLCJuaW5lZGV2YSIsMjQxNSwibmluZWd1amFyYXRpIiwyNzk5LCJuaW5lZ3VybXVraGkiLDI2NzEsIm5pbmVoYWNrYXJhYmljIiwxNjQxLCJuaW5laGFuZ3pob3UiLDEyMzI5LCJuaW5laWRlb2dyYXBoaWNwYXJlbiIsMTI4NDAsIm5pbmVpbmZlcmlvciIsODMyOSwibmluZW1vbm9zcGFjZSIsNjUzMDUsIm5pbmVvbGRzdHlsZSIsNjMyODksIm5pbmVwYXJlbiIsOTM0MCwibmluZXBlcmlvZCIsOTM2MCwibmluZXBlcnNpYW4iLDE3ODUsIm5pbmVyb21hbiIsODU2OCwibmluZXN1cGVyaW9yIiw4MzEzLCJuaW5ldGVlbmNpcmNsZSIsOTMzMCwibmluZXRlZW5wYXJlbiIsOTM1MCwibmluZXRlZW5wZXJpb2QiLDkzNzAsIm5pbmV0aGFpIiwzNjczLCJuaiIsNDYwLCJuamVjeXJpbGxpYyIsMTExNCwibmthdGFrYW5hIiwxMjUzMSwibmthdGFrYW5haGFsZndpZHRoIiw2NTQzNywibmxlZ3JpZ2h0bG9uZyIsNDE0LCJubGluZWJlbG93Iiw3NzUzLCJubW9ub3NwYWNlIiw2NTM1OCwibm1zcXVhcmUiLDEzMjEwLCJubmFiZW5nYWxpIiwyNDY3LCJubmFkZXZhIiwyMzM5LCJubmFndWphcmF0aSIsMjcyMywibm5hZ3VybXVraGkiLDI1OTUsIm5ubmFkZXZhIiwyMzQ1LCJub2hpcmFnYW5hIiwxMjM5OCwibm9rYXRha2FuYSIsMTI0OTQsIm5va2F0YWthbmFoYWxmd2lkdGgiLDY1NDE3LCJub25icmVha2luZ3NwYWNlIiwxNjAsIm5vbmVudGhhaSIsMzYwMywibm9udXRoYWkiLDM2MDksIm5vb25hcmFiaWMiLDE2MDYsIm5vb25maW5hbGFyYWJpYyIsNjUyNTQsIm5vb25naHVubmFhcmFiaWMiLDE3MjIsIm5vb25naHVubmFmaW5hbGFyYWJpYyIsNjQ0MTUsIm5vb25pbml0aWFsYXJhYmljIiw2NTI1NSwibm9vbmplZW1pbml0aWFsYXJhYmljIiw2NDcyMiwibm9vbmplZW1pc29sYXRlZGFyYWJpYyIsNjQ1ODcsIm5vb25tZWRpYWxhcmFiaWMiLDY1MjU2LCJub29ubWVlbWluaXRpYWxhcmFiaWMiLDY0NzI1LCJub29ubWVlbWlzb2xhdGVkYXJhYmljIiw2NDU5MCwibm9vbm5vb25maW5hbGFyYWJpYyIsNjQ2NTMsIm5vdGNvbnRhaW5zIiw4NzE2LCJub3RlbGVtZW50Iiw4NzEzLCJub3RlbGVtZW50b2YiLDg3MTMsIm5vdGVxdWFsIiw4ODAwLCJub3RncmVhdGVyIiw4ODE1LCJub3RncmVhdGVybm9yZXF1YWwiLDg4MTcsIm5vdGdyZWF0ZXJub3JsZXNzIiw4ODI1LCJub3RpZGVudGljYWwiLDg4MDIsIm5vdGxlc3MiLDg4MTQsIm5vdGxlc3Nub3JlcXVhbCIsODgxNiwibm90cGFyYWxsZWwiLDg3NDIsIm5vdHByZWNlZGVzIiw4ODMyLCJub3RzdWJzZXQiLDg4MzYsIm5vdHN1Y2NlZWRzIiw4ODMzLCJub3RzdXBlcnNldCIsODgzNywibm93YXJtZW5pYW4iLDEzOTgsIm5wYXJlbiIsOTM4NSwibnNzcXVhcmUiLDEzMjMzLCJuc3VwZXJpb3IiLDgzMTksIm50aWxkZSIsMjQxLCJudSIsOTU3LCJudWhpcmFnYW5hIiwxMjM5NiwibnVrYXRha2FuYSIsMTI0OTIsIm51a2F0YWthbmFoYWxmd2lkdGgiLDY1NDE1LCJudWt0YWJlbmdhbGkiLDI0OTIsIm51a3RhZGV2YSIsMjM2NCwibnVrdGFndWphcmF0aSIsMjc0OCwibnVrdGFndXJtdWtoaSIsMjYyMCwibnVtYmVyc2lnbiIsMzUsIm51bWJlcnNpZ25tb25vc3BhY2UiLDY1MjgzLCJudW1iZXJzaWduc21hbGwiLDY1MTE5LCJudW1lcmFsc2lnbmdyZWVrIiw4ODQsIm51bWVyYWxzaWdubG93ZXJncmVlayIsODg1LCJudW1lcm8iLDg0NzAsIm51biIsMTUwNCwibnVuZGFnZXNoIiw2NDMyMCwibnVuZGFnZXNoaGVicmV3Iiw2NDMyMCwibnVuaGVicmV3IiwxNTA0LCJudnNxdWFyZSIsMTMyMzcsIm53c3F1YXJlIiwxMzI0MywibnlhYmVuZ2FsaSIsMjQ2MiwibnlhZGV2YSIsMjMzNCwibnlhZ3VqYXJhdGkiLDI3MTgsIm55YWd1cm11a2hpIiwyNTkwLCJvIiwxMTEsIm9hY3V0ZSIsMjQzLCJvYW5ndGhhaSIsMzYyOSwib2JhcnJlZCIsNjI5LCJvYmFycmVkY3lyaWxsaWMiLDEyNTcsIm9iYXJyZWRkaWVyZXNpc2N5cmlsbGljIiwxMjU5LCJvYmVuZ2FsaSIsMjQ1MSwib2JvcG9tb2ZvIiwxMjU3MSwib2JyZXZlIiwzMzUsIm9jYW5kcmFkZXZhIiwyMzIxLCJvY2FuZHJhZ3VqYXJhdGkiLDI3MDUsIm9jYW5kcmF2b3dlbHNpZ25kZXZhIiwyMzc3LCJvY2FuZHJhdm93ZWxzaWduZ3VqYXJhdGkiLDI3NjEsIm9jYXJvbiIsNDY2LCJvY2lyY2xlIiw5NDM4LCJvY2lyY3VtZmxleCIsMjQ0LCJvY2lyY3VtZmxleGFjdXRlIiw3ODg5LCJvY2lyY3VtZmxleGRvdGJlbG93Iiw3ODk3LCJvY2lyY3VtZmxleGdyYXZlIiw3ODkxLCJvY2lyY3VtZmxleGhvb2thYm92ZSIsNzg5Mywib2NpcmN1bWZsZXh0aWxkZSIsNzg5NSwib2N5cmlsbGljIiwxMDg2LCJvZGJsYWN1dGUiLDMzNywib2RibGdyYXZlIiw1MjUsIm9kZXZhIiwyMzIzLCJvZGllcmVzaXMiLDI0Niwib2RpZXJlc2lzY3lyaWxsaWMiLDEyNTUsIm9kb3RiZWxvdyIsNzg4NSwib2UiLDMzOSwib2Vrb3JlYW4iLDEyNjM0LCJvZ29uZWsiLDczMSwib2dvbmVrY21iIiw4MDgsIm9ncmF2ZSIsMjQyLCJvZ3VqYXJhdGkiLDI3MDcsIm9oYXJtZW5pYW4iLDE0MTMsIm9oaXJhZ2FuYSIsMTIzNjIsIm9ob29rYWJvdmUiLDc4ODcsIm9ob3JuIiw0MTcsIm9ob3JuYWN1dGUiLDc4OTksIm9ob3JuZG90YmVsb3ciLDc5MDcsIm9ob3JuZ3JhdmUiLDc5MDEsIm9ob3JuaG9va2Fib3ZlIiw3OTAzLCJvaG9ybnRpbGRlIiw3OTA1LCJvaHVuZ2FydW1sYXV0IiwzMzcsIm9pIiw0MTksIm9pbnZlcnRlZGJyZXZlIiw1MjcsIm9rYXRha2FuYSIsMTI0NTgsIm9rYXRha2FuYWhhbGZ3aWR0aCIsNjUzOTcsIm9rb3JlYW4iLDEyNjMxLCJvbGVoZWJyZXciLDE0NTEsIm9tYWNyb24iLDMzMywib21hY3JvbmFjdXRlIiw3NzYzLCJvbWFjcm9uZ3JhdmUiLDc3NjEsIm9tZGV2YSIsMjM4NCwib21lZ2EiLDk2OSwib21lZ2ExIiw5ODIsIm9tZWdhY3lyaWxsaWMiLDExMjEsIm9tZWdhbGF0aW5jbG9zZWQiLDYzMSwib21lZ2Fyb3VuZGN5cmlsbGljIiwxMTQ3LCJvbWVnYXRpdGxvY3lyaWxsaWMiLDExNDksIm9tZWdhdG9ub3MiLDk3NCwib21ndWphcmF0aSIsMjc2OCwib21pY3JvbiIsOTU5LCJvbWljcm9udG9ub3MiLDk3Miwib21vbm9zcGFjZSIsNjUzNTksIm9uZSIsNDksIm9uZWFyYWJpYyIsMTYzMywib25lYmVuZ2FsaSIsMjUzNSwib25lY2lyY2xlIiw5MzEyLCJvbmVjaXJjbGVpbnZlcnNlc2Fuc3NlcmlmIiwxMDEyMiwib25lZGV2YSIsMjQwNywib25lZG90ZW5sZWFkZXIiLDgyMjgsIm9uZWVpZ2h0aCIsODUzOSwib25lZml0dGVkIiw2MzE5Niwib25lZ3VqYXJhdGkiLDI3OTEsIm9uZWd1cm11a2hpIiwyNjYzLCJvbmVoYWNrYXJhYmljIiwxNjMzLCJvbmVoYWxmIiwxODksIm9uZWhhbmd6aG91IiwxMjMyMSwib25laWRlb2dyYXBoaWNwYXJlbiIsMTI4MzIsIm9uZWluZmVyaW9yIiw4MzIxLCJvbmVtb25vc3BhY2UiLDY1Mjk3LCJvbmVudW1lcmF0b3JiZW5nYWxpIiwyNTQ4LCJvbmVvbGRzdHlsZSIsNjMyODEsIm9uZXBhcmVuIiw5MzMyLCJvbmVwZXJpb2QiLDkzNTIsIm9uZXBlcnNpYW4iLDE3NzcsIm9uZXF1YXJ0ZXIiLDE4OCwib25lcm9tYW4iLDg1NjAsIm9uZXN1cGVyaW9yIiwxODUsIm9uZXRoYWkiLDM2NjUsIm9uZXRoaXJkIiw4NTMxLCJvb2dvbmVrIiw0OTEsIm9vZ29uZWttYWNyb24iLDQ5Mywib29ndXJtdWtoaSIsMjU3OSwib29tYXRyYWd1cm11a2hpIiwyNjM1LCJvb3BlbiIsNTk2LCJvcGFyZW4iLDkzODYsIm9wZW5idWxsZXQiLDk3MDIsIm9wdGlvbiIsODk5Nywib3JkZmVtaW5pbmUiLDE3MCwib3JkbWFzY3VsaW5lIiwxODYsIm9ydGhvZ29uYWwiLDg3MzUsIm9zaG9ydGRldmEiLDIzMjIsIm9zaG9ydHZvd2Vsc2lnbmRldmEiLDIzNzgsIm9zbGFzaCIsMjQ4LCJvc2xhc2hhY3V0ZSIsNTExLCJvc21hbGxoaXJhZ2FuYSIsMTIzNjEsIm9zbWFsbGthdGFrYW5hIiwxMjQ1Nywib3NtYWxsa2F0YWthbmFoYWxmd2lkdGgiLDY1Mzg3LCJvc3Ryb2tlYWN1dGUiLDUxMSwib3N1cGVyaW9yIiw2MzIxNiwib3RjeXJpbGxpYyIsMTE1MSwib3RpbGRlIiwyNDUsIm90aWxkZWFjdXRlIiw3NzU3LCJvdGlsZGVkaWVyZXNpcyIsNzc1OSwib3Vib3BvbW9mbyIsMTI1NzcsIm92ZXJsaW5lIiw4MjU0LCJvdmVybGluZWNlbnRlcmxpbmUiLDY1MDk4LCJvdmVybGluZWNtYiIsNzczLCJvdmVybGluZWRhc2hlZCIsNjUwOTcsIm92ZXJsaW5lZGJsd2F2eSIsNjUxMDAsIm92ZXJsaW5ld2F2eSIsNjUwOTksIm92ZXJzY29yZSIsMTc1LCJvdm93ZWxzaWduYmVuZ2FsaSIsMjUwNywib3Zvd2Vsc2lnbmRldmEiLDIzNzksIm92b3dlbHNpZ25ndWphcmF0aSIsMjc2MywicCIsMTEyLCJwYWFtcHNzcXVhcmUiLDEzMTg0LCJwYWFzZW50b3NxdWFyZSIsMTMwOTksInBhYmVuZ2FsaSIsMjQ3NCwicGFjdXRlIiw3NzY1LCJwYWRldmEiLDIzNDYsInBhZ2Vkb3duIiw4NjcxLCJwYWdldXAiLDg2NzAsInBhZ3VqYXJhdGkiLDI3MzAsInBhZ3VybXVraGkiLDI2MDIsInBhaGlyYWdhbmEiLDEyNDAxLCJwYWl5YW5ub2l0aGFpIiwzNjMxLCJwYWthdGFrYW5hIiwxMjQ5NywicGFsYXRhbGl6YXRpb25jeXJpbGxpY2NtYiIsMTE1NiwicGFsb2Noa2FjeXJpbGxpYyIsMTIxNiwicGFuc2lvc2tvcmVhbiIsMTI2NzEsInBhcmFncmFwaCIsMTgyLCJwYXJhbGxlbCIsODc0MSwicGFyZW5sZWZ0Iiw0MCwicGFyZW5sZWZ0YWx0b25lYXJhYmljIiw2NDgzMCwicGFyZW5sZWZ0YnQiLDYzNzI1LCJwYXJlbmxlZnRleCIsNjM3MjQsInBhcmVubGVmdGluZmVyaW9yIiw4MzMzLCJwYXJlbmxlZnRtb25vc3BhY2UiLDY1Mjg4LCJwYXJlbmxlZnRzbWFsbCIsNjUxMTMsInBhcmVubGVmdHN1cGVyaW9yIiw4MzE3LCJwYXJlbmxlZnR0cCIsNjM3MjMsInBhcmVubGVmdHZlcnRpY2FsIiw2NTA3NywicGFyZW5yaWdodCIsNDEsInBhcmVucmlnaHRhbHRvbmVhcmFiaWMiLDY0ODMxLCJwYXJlbnJpZ2h0YnQiLDYzNzM2LCJwYXJlbnJpZ2h0ZXgiLDYzNzM1LCJwYXJlbnJpZ2h0aW5mZXJpb3IiLDgzMzQsInBhcmVucmlnaHRtb25vc3BhY2UiLDY1Mjg5LCJwYXJlbnJpZ2h0c21hbGwiLDY1MTE0LCJwYXJlbnJpZ2h0c3VwZXJpb3IiLDgzMTgsInBhcmVucmlnaHR0cCIsNjM3MzQsInBhcmVucmlnaHR2ZXJ0aWNhbCIsNjUwNzgsInBhcnRpYWxkaWZmIiw4NzA2LCJwYXNlcWhlYnJldyIsMTQ3MiwicGFzaHRhaGVicmV3IiwxNDMzLCJwYXNxdWFyZSIsMTMyMjUsInBhdGFoIiwxNDYzLCJwYXRhaDExIiwxNDYzLCJwYXRhaDFkIiwxNDYzLCJwYXRhaDJhIiwxNDYzLCJwYXRhaGhlYnJldyIsMTQ2MywicGF0YWhuYXJyb3doZWJyZXciLDE0NjMsInBhdGFocXVhcnRlcmhlYnJldyIsMTQ2MywicGF0YWh3aWRlaGVicmV3IiwxNDYzLCJwYXplcmhlYnJldyIsMTQ0MSwicGJvcG9tb2ZvIiwxMjU1MCwicGNpcmNsZSIsOTQzOSwicGRvdGFjY2VudCIsNzc2NywicGUiLDE1MDgsInBlY3lyaWxsaWMiLDEwODcsInBlZGFnZXNoIiw2NDMyNCwicGVkYWdlc2hoZWJyZXciLDY0MzI0LCJwZWV6aXNxdWFyZSIsMTMxMTUsInBlZmluYWxkYWdlc2hoZWJyZXciLDY0MzIzLCJwZWhhcmFiaWMiLDE2NjIsInBlaGFybWVuaWFuIiwxNDAyLCJwZWhlYnJldyIsMTUwOCwicGVoZmluYWxhcmFiaWMiLDY0MzQzLCJwZWhpbml0aWFsYXJhYmljIiw2NDM0NCwicGVoaXJhZ2FuYSIsMTI0MTAsInBlaG1lZGlhbGFyYWJpYyIsNjQzNDUsInBla2F0YWthbmEiLDEyNTA2LCJwZW1pZGRsZWhvb2tjeXJpbGxpYyIsMTE5MSwicGVyYWZlaGVicmV3Iiw2NDMzNCwicGVyY2VudCIsMzcsInBlcmNlbnRhcmFiaWMiLDE2NDIsInBlcmNlbnRtb25vc3BhY2UiLDY1Mjg1LCJwZXJjZW50c21hbGwiLDY1MTMwLCJwZXJpb2QiLDQ2LCJwZXJpb2Rhcm1lbmlhbiIsMTQxNywicGVyaW9kY2VudGVyZWQiLDE4MywicGVyaW9kaGFsZndpZHRoIiw2NTM3NywicGVyaW9kaW5mZXJpb3IiLDYzMjA3LCJwZXJpb2Rtb25vc3BhY2UiLDY1Mjk0LCJwZXJpb2RzbWFsbCIsNjUxMDYsInBlcmlvZHN1cGVyaW9yIiw2MzIwOCwicGVyaXNwb21lbmlncmVla2NtYiIsODM0LCJwZXJwZW5kaWN1bGFyIiw4ODY5LCJwZXJ0aG91c2FuZCIsODI0MCwicGVzZXRhIiw4MzU5LCJwZnNxdWFyZSIsMTMxOTQsInBoYWJlbmdhbGkiLDI0NzUsInBoYWRldmEiLDIzNDcsInBoYWd1amFyYXRpIiwyNzMxLCJwaGFndXJtdWtoaSIsMjYwMywicGhpIiw5NjYsInBoaTEiLDk4MSwicGhpZXVwaGFjaXJjbGVrb3JlYW4iLDEyOTIyLCJwaGlldXBoYXBhcmVua29yZWFuIiwxMjgyNiwicGhpZXVwaGNpcmNsZWtvcmVhbiIsMTI5MDgsInBoaWV1cGhrb3JlYW4iLDEyNjIxLCJwaGlldXBocGFyZW5rb3JlYW4iLDEyODEyLCJwaGlsYXRpbiIsNjMyLCJwaGludGh1dGhhaSIsMzY0MiwicGhpc3ltYm9sZ3JlZWsiLDk4MSwicGhvb2siLDQyMSwicGhvcGhhbnRoYWkiLDM2MTQsInBob3BodW5ndGhhaSIsMzYxMiwicGhvc2FtcGhhb3RoYWkiLDM2MTYsInBpIiw5NjAsInBpZXVwYWNpcmNsZWtvcmVhbiIsMTI5MTUsInBpZXVwYXBhcmVua29yZWFuIiwxMjgxOSwicGlldXBjaWV1Y2tvcmVhbiIsMTI2NjIsInBpZXVwY2lyY2xla29yZWFuIiwxMjkwMSwicGlldXBraXllb2trb3JlYW4iLDEyNjU4LCJwaWV1cGtvcmVhbiIsMTI2MTAsInBpZXVwcGFyZW5rb3JlYW4iLDEyODA1LCJwaWV1cHNpb3NraXllb2trb3JlYW4iLDEyNjYwLCJwaWV1cHNpb3Nrb3JlYW4iLDEyNjEyLCJwaWV1cHNpb3N0aWtldXRrb3JlYW4iLDEyNjYxLCJwaWV1cHRoaWV1dGhrb3JlYW4iLDEyNjYzLCJwaWV1cHRpa2V1dGtvcmVhbiIsMTI2NTksInBpaGlyYWdhbmEiLDEyNDA0LCJwaWthdGFrYW5hIiwxMjUwMCwicGlzeW1ib2xncmVlayIsOTgyLCJwaXdyYXJtZW5pYW4iLDE0MTEsInBsdXMiLDQzLCJwbHVzYmVsb3djbWIiLDc5OSwicGx1c2NpcmNsZSIsODg1MywicGx1c21pbnVzIiwxNzcsInBsdXNtb2QiLDcyNiwicGx1c21vbm9zcGFjZSIsNjUyOTEsInBsdXNzbWFsbCIsNjUxMjIsInBsdXNzdXBlcmlvciIsODMxNCwicG1vbm9zcGFjZSIsNjUzNjAsInBtc3F1YXJlIiwxMzI3MiwicG9oaXJhZ2FuYSIsMTI0MTMsInBvaW50aW5naW5kZXhkb3dud2hpdGUiLDk3NTksInBvaW50aW5naW5kZXhsZWZ0d2hpdGUiLDk3NTYsInBvaW50aW5naW5kZXhyaWdodHdoaXRlIiw5NzU4LCJwb2ludGluZ2luZGV4dXB3aGl0ZSIsOTc1NywicG9rYXRha2FuYSIsMTI1MDksInBvcGxhdGhhaSIsMzYxMSwicG9zdGFsbWFyayIsMTIzMDYsInBvc3RhbG1hcmtmYWNlIiwxMjMyMCwicHBhcmVuIiw5Mzg3LCJwcmVjZWRlcyIsODgyNiwicHJlc2NyaXB0aW9uIiw4NDc4LCJwcmltZW1vZCIsNjk3LCJwcmltZXJldmVyc2VkIiw4MjQ1LCJwcm9kdWN0Iiw4NzE5LCJwcm9qZWN0aXZlIiw4OTY1LCJwcm9sb25nZWRrYW5hIiwxMjU0MCwicHJvcGVsbG9yIiw4OTg0LCJwcm9wZXJzdWJzZXQiLDg4MzQsInByb3BlcnN1cGVyc2V0Iiw4ODM1LCJwcm9wb3J0aW9uIiw4NzU5LCJwcm9wb3J0aW9uYWwiLDg3MzMsInBzaSIsOTY4LCJwc2ljeXJpbGxpYyIsMTEzNywicHNpbGlwbmV1bWF0YWN5cmlsbGljY21iIiwxMTU4LCJwc3NxdWFyZSIsMTMyMzIsInB1aGlyYWdhbmEiLDEyNDA3LCJwdWthdGFrYW5hIiwxMjUwMywicHZzcXVhcmUiLDEzMjM2LCJwd3NxdWFyZSIsMTMyNDIsInEiLDExMywicWFkZXZhIiwyMzkyLCJxYWRtYWhlYnJldyIsMTQ0OCwicWFmYXJhYmljIiwxNjAyLCJxYWZmaW5hbGFyYWJpYyIsNjUyMzgsInFhZmluaXRpYWxhcmFiaWMiLDY1MjM5LCJxYWZtZWRpYWxhcmFiaWMiLDY1MjQwLCJxYW1hdHMiLDE0NjQsInFhbWF0czEwIiwxNDY0LCJxYW1hdHMxYSIsMTQ2NCwicWFtYXRzMWMiLDE0NjQsInFhbWF0czI3IiwxNDY0LCJxYW1hdHMyOSIsMTQ2NCwicWFtYXRzMzMiLDE0NjQsInFhbWF0c2RlIiwxNDY0LCJxYW1hdHNoZWJyZXciLDE0NjQsInFhbWF0c25hcnJvd2hlYnJldyIsMTQ2NCwicWFtYXRzcWF0YW5oZWJyZXciLDE0NjQsInFhbWF0c3FhdGFubmFycm93aGVicmV3IiwxNDY0LCJxYW1hdHNxYXRhbnF1YXJ0ZXJoZWJyZXciLDE0NjQsInFhbWF0c3FhdGFud2lkZWhlYnJldyIsMTQ2NCwicWFtYXRzcXVhcnRlcmhlYnJldyIsMTQ2NCwicWFtYXRzd2lkZWhlYnJldyIsMTQ2NCwicWFybmV5cGFyYWhlYnJldyIsMTQzOSwicWJvcG9tb2ZvIiwxMjU2MSwicWNpcmNsZSIsOTQ0MCwicWhvb2siLDY3MiwicW1vbm9zcGFjZSIsNjUzNjEsInFvZiIsMTUxMSwicW9mZGFnZXNoIiw2NDMyNywicW9mZGFnZXNoaGVicmV3Iiw2NDMyNywicW9maGVicmV3IiwxNTExLCJxcGFyZW4iLDkzODgsInF1YXJ0ZXJub3RlIiw5ODMzLCJxdWJ1dHMiLDE0NjcsInF1YnV0czE4IiwxNDY3LCJxdWJ1dHMyNSIsMTQ2NywicXVidXRzMzEiLDE0NjcsInF1YnV0c2hlYnJldyIsMTQ2NywicXVidXRzbmFycm93aGVicmV3IiwxNDY3LCJxdWJ1dHNxdWFydGVyaGVicmV3IiwxNDY3LCJxdWJ1dHN3aWRlaGVicmV3IiwxNDY3LCJxdWVzdGlvbiIsNjMsInF1ZXN0aW9uYXJhYmljIiwxNTY3LCJxdWVzdGlvbmFybWVuaWFuIiwxMzc0LCJxdWVzdGlvbmRvd24iLDE5MSwicXVlc3Rpb25kb3duc21hbGwiLDYzNDIzLCJxdWVzdGlvbmdyZWVrIiw4OTQsInF1ZXN0aW9ubW9ub3NwYWNlIiw2NTMxMSwicXVlc3Rpb25zbWFsbCIsNjMyOTUsInF1b3RlZGJsIiwzNCwicXVvdGVkYmxiYXNlIiw4MjIyLCJxdW90ZWRibGxlZnQiLDgyMjAsInF1b3RlZGJsbW9ub3NwYWNlIiw2NTI4MiwicXVvdGVkYmxwcmltZSIsMTIzMTgsInF1b3RlZGJscHJpbWVyZXZlcnNlZCIsMTIzMTcsInF1b3RlZGJscmlnaHQiLDgyMjEsInF1b3RlbGVmdCIsODIxNiwicXVvdGVsZWZ0cmV2ZXJzZWQiLDgyMTksInF1b3RlcmV2ZXJzZWQiLDgyMTksInF1b3RlcmlnaHQiLDgyMTcsInF1b3RlcmlnaHRuIiwzMjksInF1b3Rlc2luZ2xiYXNlIiw4MjE4LCJxdW90ZXNpbmdsZSIsMzksInF1b3Rlc2luZ2xlbW9ub3NwYWNlIiw2NTI4NywiciIsMTE0LCJyYWFybWVuaWFuIiwxNDA0LCJyYWJlbmdhbGkiLDI0ODAsInJhY3V0ZSIsMzQxLCJyYWRldmEiLDIzNTIsInJhZGljYWwiLDg3MzAsInJhZGljYWxleCIsNjM3MTcsInJhZG92ZXJzc3F1YXJlIiwxMzIzMCwicmFkb3ZlcnNzcXVhcmVkc3F1YXJlIiwxMzIzMSwicmFkc3F1YXJlIiwxMzIyOSwicmFmZSIsMTQ3MSwicmFmZWhlYnJldyIsMTQ3MSwicmFndWphcmF0aSIsMjczNiwicmFndXJtdWtoaSIsMjYwOCwicmFoaXJhZ2FuYSIsMTI0MjUsInJha2F0YWthbmEiLDEyNTIxLCJyYWthdGFrYW5haGFsZndpZHRoIiw2NTQzMSwicmFsb3dlcmRpYWdvbmFsYmVuZ2FsaSIsMjU0NSwicmFtaWRkbGVkaWFnb25hbGJlbmdhbGkiLDI1NDQsInJhbXNob3JuIiw2MTIsInJhdGlvIiw4NzU4LCJyYm9wb21vZm8iLDEyNTY2LCJyY2Fyb24iLDM0NSwicmNlZGlsbGEiLDM0MywicmNpcmNsZSIsOTQ0MSwicmNvbW1hYWNjZW50IiwzNDMsInJkYmxncmF2ZSIsNTI5LCJyZG90YWNjZW50Iiw3NzY5LCJyZG90YmVsb3ciLDc3NzEsInJkb3RiZWxvd21hY3JvbiIsNzc3MywicmVmZXJlbmNlbWFyayIsODI1MSwicmVmbGV4c3Vic2V0Iiw4ODM4LCJyZWZsZXhzdXBlcnNldCIsODgzOSwicmVnaXN0ZXJlZCIsMTc0LCJyZWdpc3RlcnNhbnMiLDYzNzIwLCJyZWdpc3RlcnNlcmlmIiw2MzE5NCwicmVoYXJhYmljIiwxNTg1LCJyZWhhcm1lbmlhbiIsMTQwOCwicmVoZmluYWxhcmFiaWMiLDY1MTk4LCJyZWhpcmFnYW5hIiwxMjQyOCwicmVrYXRha2FuYSIsMTI1MjQsInJla2F0YWthbmFoYWxmd2lkdGgiLDY1NDM0LCJyZXNoIiwxNTEyLCJyZXNoZGFnZXNoaGVicmV3Iiw2NDMyOCwicmVzaGhlYnJldyIsMTUxMiwicmV2ZXJzZWR0aWxkZSIsODc2NSwicmV2aWFoZWJyZXciLDE0MzEsInJldmlhbXVncmFzaGhlYnJldyIsMTQzMSwicmV2bG9naWNhbG5vdCIsODk3NiwicmZpc2hob29rIiw2MzgsInJmaXNoaG9va3JldmVyc2VkIiw2MzksInJoYWJlbmdhbGkiLDI1MjUsInJoYWRldmEiLDIzOTcsInJobyIsOTYxLCJyaG9vayIsNjM3LCJyaG9va3R1cm5lZCIsNjM1LCJyaG9va3R1cm5lZHN1cGVyaW9yIiw2OTMsInJob3N5bWJvbGdyZWVrIiwxMDA5LCJyaG90aWNob29rbW9kIiw3MzQsInJpZXVsYWNpcmNsZWtvcmVhbiIsMTI5MTMsInJpZXVsYXBhcmVua29yZWFuIiwxMjgxNywicmlldWxjaXJjbGVrb3JlYW4iLDEyODk5LCJyaWV1bGhpZXVoa29yZWFuIiwxMjYwOCwicmlldWxraXllb2trb3JlYW4iLDEyNjAyLCJyaWV1bGtpeWVva3Npb3Nrb3JlYW4iLDEyNjQ5LCJyaWV1bGtvcmVhbiIsMTI2MDEsInJpZXVsbWlldW1rb3JlYW4iLDEyNjAzLCJyaWV1bHBhbnNpb3Nrb3JlYW4iLDEyNjUyLCJyaWV1bHBhcmVua29yZWFuIiwxMjgwMywicmlldWxwaGlldXBoa29yZWFuIiwxMjYwNywicmlldWxwaWV1cGtvcmVhbiIsMTI2MDQsInJpZXVscGlldXBzaW9za29yZWFuIiwxMjY1MSwicmlldWxzaW9za29yZWFuIiwxMjYwNSwicmlldWx0aGlldXRoa29yZWFuIiwxMjYwNiwicmlldWx0aWtldXRrb3JlYW4iLDEyNjUwLCJyaWV1bHllb3JpbmhpZXVoa29yZWFuIiwxMjY1MywicmlnaHRhbmdsZSIsODczNSwicmlnaHR0YWNrYmVsb3djbWIiLDc5MywicmlnaHR0cmlhbmdsZSIsODg5NSwicmloaXJhZ2FuYSIsMTI0MjYsInJpa2F0YWthbmEiLDEyNTIyLCJyaWthdGFrYW5haGFsZndpZHRoIiw2NTQzMiwicmluZyIsNzMwLCJyaW5nYmVsb3djbWIiLDgwNSwicmluZ2NtYiIsNzc4LCJyaW5naGFsZmxlZnQiLDcwMywicmluZ2hhbGZsZWZ0YXJtZW5pYW4iLDEzNjksInJpbmdoYWxmbGVmdGJlbG93Y21iIiw3OTYsInJpbmdoYWxmbGVmdGNlbnRlcmVkIiw3MjMsInJpbmdoYWxmcmlnaHQiLDcwMiwicmluZ2hhbGZyaWdodGJlbG93Y21iIiw4MjUsInJpbmdoYWxmcmlnaHRjZW50ZXJlZCIsNzIyLCJyaW52ZXJ0ZWRicmV2ZSIsNTMxLCJyaXR0b3J1c3F1YXJlIiwxMzEzNywicmxpbmViZWxvdyIsNzc3NSwicmxvbmdsZWciLDYzNiwicmxvbmdsZWd0dXJuZWQiLDYzNCwicm1vbm9zcGFjZSIsNjUzNjIsInJvaGlyYWdhbmEiLDEyNDI5LCJyb2thdGFrYW5hIiwxMjUyNSwicm9rYXRha2FuYWhhbGZ3aWR0aCIsNjU0MzUsInJvcnVhdGhhaSIsMzYxOSwicnBhcmVuIiw5Mzg5LCJycmFiZW5nYWxpIiwyNTI0LCJycmFkZXZhIiwyMzUzLCJycmFndXJtdWtoaSIsMjY1MiwicnJlaGFyYWJpYyIsMTY4MSwicnJlaGZpbmFsYXJhYmljIiw2NDM5NywicnJ2b2NhbGljYmVuZ2FsaSIsMjUyOCwicnJ2b2NhbGljZGV2YSIsMjQwMCwicnJ2b2NhbGljZ3VqYXJhdGkiLDI3ODQsInJydm9jYWxpY3Zvd2Vsc2lnbmJlbmdhbGkiLDI1MDAsInJydm9jYWxpY3Zvd2Vsc2lnbmRldmEiLDIzNzIsInJydm9jYWxpY3Zvd2Vsc2lnbmd1amFyYXRpIiwyNzU2LCJyc3VwZXJpb3IiLDYzMjE3LCJydGJsb2NrIiw5NjE2LCJydHVybmVkIiw2MzMsInJ0dXJuZWRzdXBlcmlvciIsNjkyLCJydWhpcmFnYW5hIiwxMjQyNywicnVrYXRha2FuYSIsMTI1MjMsInJ1a2F0YWthbmFoYWxmd2lkdGgiLDY1NDMzLCJydXBlZW1hcmtiZW5nYWxpIiwyNTQ2LCJydXBlZXNpZ25iZW5nYWxpIiwyNTQ3LCJydXBpYWgiLDYzMTk3LCJydXRoYWkiLDM2MjAsInJ2b2NhbGljYmVuZ2FsaSIsMjQ0MywicnZvY2FsaWNkZXZhIiwyMzE1LCJydm9jYWxpY2d1amFyYXRpIiwyNjk5LCJydm9jYWxpY3Zvd2Vsc2lnbmJlbmdhbGkiLDI0OTksInJ2b2NhbGljdm93ZWxzaWduZGV2YSIsMjM3MSwicnZvY2FsaWN2b3dlbHNpZ25ndWphcmF0aSIsMjc1NSwicyIsMTE1LCJzYWJlbmdhbGkiLDI0ODgsInNhY3V0ZSIsMzQ3LCJzYWN1dGVkb3RhY2NlbnQiLDc3ODEsInNhZGFyYWJpYyIsMTU4OSwic2FkZXZhIiwyMzYwLCJzYWRmaW5hbGFyYWJpYyIsNjUyMTAsInNhZGluaXRpYWxhcmFiaWMiLDY1MjExLCJzYWRtZWRpYWxhcmFiaWMiLDY1MjEyLCJzYWd1amFyYXRpIiwyNzQ0LCJzYWd1cm11a2hpIiwyNjE2LCJzYWhpcmFnYW5hIiwxMjM3Mywic2FrYXRha2FuYSIsMTI0NjksInNha2F0YWthbmFoYWxmd2lkdGgiLDY1NDAzLCJzYWxsYWxsYWhvdWFsYXloZXdhc2FsbGFtYXJhYmljIiw2NTAxOCwic2FtZWtoIiwxNTA1LCJzYW1la2hkYWdlc2giLDY0MzIxLCJzYW1la2hkYWdlc2hoZWJyZXciLDY0MzIxLCJzYW1la2hoZWJyZXciLDE1MDUsInNhcmFhYXRoYWkiLDM2MzQsInNhcmFhZXRoYWkiLDM2NDksInNhcmFhaW1haW1hbGFpdGhhaSIsMzY1Miwic2FyYWFpbWFpbXVhbnRoYWkiLDM2NTEsInNhcmFhbXRoYWkiLDM2MzUsInNhcmFhdGhhaSIsMzYzMiwic2FyYWV0aGFpIiwzNjQ4LCJzYXJhaWlsZWZ0dGhhaSIsNjM2MjIsInNhcmFpaXRoYWkiLDM2MzcsInNhcmFpbGVmdHRoYWkiLDYzNjIxLCJzYXJhaXRoYWkiLDM2MzYsInNhcmFvdGhhaSIsMzY1MCwic2FyYXVlZWxlZnR0aGFpIiw2MzYyNCwic2FyYXVlZXRoYWkiLDM2MzksInNhcmF1ZWxlZnR0aGFpIiw2MzYyMywic2FyYXVldGhhaSIsMzYzOCwic2FyYXV0aGFpIiwzNjQwLCJzYXJhdXV0aGFpIiwzNjQxLCJzYm9wb21vZm8iLDEyNTY5LCJzY2Fyb24iLDM1Mywic2Nhcm9uZG90YWNjZW50Iiw3NzgzLCJzY2VkaWxsYSIsMzUxLCJzY2h3YSIsNjAxLCJzY2h3YWN5cmlsbGljIiwxMjQxLCJzY2h3YWRpZXJlc2lzY3lyaWxsaWMiLDEyNDMsInNjaHdhaG9vayIsNjAyLCJzY2lyY2xlIiw5NDQyLCJzY2lyY3VtZmxleCIsMzQ5LCJzY29tbWFhY2NlbnQiLDUzNywic2RvdGFjY2VudCIsNzc3Nywic2RvdGJlbG93Iiw3Nzc5LCJzZG90YmVsb3dkb3RhY2NlbnQiLDc3ODUsInNlYWd1bGxiZWxvd2NtYiIsODI4LCJzZWNvbmQiLDgyNDMsInNlY29uZHRvbmVjaGluZXNlIiw3MTQsInNlY3Rpb24iLDE2Nywic2VlbmFyYWJpYyIsMTU4Nywic2VlbmZpbmFsYXJhYmljIiw2NTIwMiwic2VlbmluaXRpYWxhcmFiaWMiLDY1MjAzLCJzZWVubWVkaWFsYXJhYmljIiw2NTIwNCwic2Vnb2wiLDE0NjIsInNlZ29sMTMiLDE0NjIsInNlZ29sMWYiLDE0NjIsInNlZ29sMmMiLDE0NjIsInNlZ29saGVicmV3IiwxNDYyLCJzZWdvbG5hcnJvd2hlYnJldyIsMTQ2Miwic2Vnb2xxdWFydGVyaGVicmV3IiwxNDYyLCJzZWdvbHRhaGVicmV3IiwxNDI2LCJzZWdvbHdpZGVoZWJyZXciLDE0NjIsInNlaGFybWVuaWFuIiwxNDA1LCJzZWhpcmFnYW5hIiwxMjM3OSwic2VrYXRha2FuYSIsMTI0NzUsInNla2F0YWthbmFoYWxmd2lkdGgiLDY1NDA2LCJzZW1pY29sb24iLDU5LCJzZW1pY29sb25hcmFiaWMiLDE1NjMsInNlbWljb2xvbm1vbm9zcGFjZSIsNjUzMDcsInNlbWljb2xvbnNtYWxsIiw2NTEwOCwic2VtaXZvaWNlZG1hcmtrYW5hIiwxMjQ0NCwic2VtaXZvaWNlZG1hcmtrYW5haGFsZndpZHRoIiw2NTQzOSwic2VudGlzcXVhcmUiLDEzMDkwLCJzZW50b3NxdWFyZSIsMTMwOTEsInNldmVuIiw1NSwic2V2ZW5hcmFiaWMiLDE2MzksInNldmVuYmVuZ2FsaSIsMjU0MSwic2V2ZW5jaXJjbGUiLDkzMTgsInNldmVuY2lyY2xlaW52ZXJzZXNhbnNzZXJpZiIsMTAxMjgsInNldmVuZGV2YSIsMjQxMywic2V2ZW5laWdodGhzIiw4NTQyLCJzZXZlbmd1amFyYXRpIiwyNzk3LCJzZXZlbmd1cm11a2hpIiwyNjY5LCJzZXZlbmhhY2thcmFiaWMiLDE2MzksInNldmVuaGFuZ3pob3UiLDEyMzI3LCJzZXZlbmlkZW9ncmFwaGljcGFyZW4iLDEyODM4LCJzZXZlbmluZmVyaW9yIiw4MzI3LCJzZXZlbm1vbm9zcGFjZSIsNjUzMDMsInNldmVub2xkc3R5bGUiLDYzMjg3LCJzZXZlbnBhcmVuIiw5MzM4LCJzZXZlbnBlcmlvZCIsOTM1OCwic2V2ZW5wZXJzaWFuIiwxNzgzLCJzZXZlbnJvbWFuIiw4NTY2LCJzZXZlbnN1cGVyaW9yIiw4MzExLCJzZXZlbnRlZW5jaXJjbGUiLDkzMjgsInNldmVudGVlbnBhcmVuIiw5MzQ4LCJzZXZlbnRlZW5wZXJpb2QiLDkzNjgsInNldmVudGhhaSIsMzY3MSwic2Z0aHlwaGVuIiwxNzMsInNoYWFybWVuaWFuIiwxMzk5LCJzaGFiZW5nYWxpIiwyNDg2LCJzaGFjeXJpbGxpYyIsMTA5Niwic2hhZGRhYXJhYmljIiwxNjE3LCJzaGFkZGFkYW1tYWFyYWJpYyIsNjQ2MDksInNoYWRkYWRhbW1hdGFuYXJhYmljIiw2NDYwNiwic2hhZGRhZmF0aGFhcmFiaWMiLDY0NjA4LCJzaGFkZGFrYXNyYWFyYWJpYyIsNjQ2MTAsInNoYWRkYWthc3JhdGFuYXJhYmljIiw2NDYwNywic2hhZGUiLDk2MTgsInNoYWRlZGFyayIsOTYxOSwic2hhZGVsaWdodCIsOTYxNywic2hhZGVtZWRpdW0iLDk2MTgsInNoYWRldmEiLDIzNTgsInNoYWd1amFyYXRpIiwyNzQyLCJzaGFndXJtdWtoaSIsMjYxNCwic2hhbHNoZWxldGhlYnJldyIsMTQyNywic2hib3BvbW9mbyIsMTI1NjUsInNoY2hhY3lyaWxsaWMiLDEwOTcsInNoZWVuYXJhYmljIiwxNTg4LCJzaGVlbmZpbmFsYXJhYmljIiw2NTIwNiwic2hlZW5pbml0aWFsYXJhYmljIiw2NTIwNywic2hlZW5tZWRpYWxhcmFiaWMiLDY1MjA4LCJzaGVpY29wdGljIiw5OTUsInNoZXFlbCIsODM2Miwic2hlcWVsaGVicmV3Iiw4MzYyLCJzaGV2YSIsMTQ1Niwic2hldmExMTUiLDE0NTYsInNoZXZhMTUiLDE0NTYsInNoZXZhMjIiLDE0NTYsInNoZXZhMmUiLDE0NTYsInNoZXZhaGVicmV3IiwxNDU2LCJzaGV2YW5hcnJvd2hlYnJldyIsMTQ1Niwic2hldmFxdWFydGVyaGVicmV3IiwxNDU2LCJzaGV2YXdpZGVoZWJyZXciLDE0NTYsInNoaGFjeXJpbGxpYyIsMTIxMSwic2hpbWFjb3B0aWMiLDEwMDUsInNoaW4iLDE1MTMsInNoaW5kYWdlc2giLDY0MzI5LCJzaGluZGFnZXNoaGVicmV3Iiw2NDMyOSwic2hpbmRhZ2VzaHNoaW5kb3QiLDY0MzAwLCJzaGluZGFnZXNoc2hpbmRvdGhlYnJldyIsNjQzMDAsInNoaW5kYWdlc2hzaW5kb3QiLDY0MzAxLCJzaGluZGFnZXNoc2luZG90aGVicmV3Iiw2NDMwMSwic2hpbmRvdGhlYnJldyIsMTQ3Mywic2hpbmhlYnJldyIsMTUxMywic2hpbnNoaW5kb3QiLDY0Mjk4LCJzaGluc2hpbmRvdGhlYnJldyIsNjQyOTgsInNoaW5zaW5kb3QiLDY0Mjk5LCJzaGluc2luZG90aGVicmV3Iiw2NDI5OSwic2hvb2siLDY0Miwic2lnbWEiLDk2Mywic2lnbWExIiw5NjIsInNpZ21hZmluYWwiLDk2Miwic2lnbWFsdW5hdGVzeW1ib2xncmVlayIsMTAxMCwic2loaXJhZ2FuYSIsMTIzNzUsInNpa2F0YWthbmEiLDEyNDcxLCJzaWthdGFrYW5haGFsZndpZHRoIiw2NTQwNCwic2lsdXFoZWJyZXciLDE0NjksInNpbHVxbGVmdGhlYnJldyIsMTQ2OSwic2ltaWxhciIsODc2NCwic2luZG90aGVicmV3IiwxNDc0LCJzaW9zYWNpcmNsZWtvcmVhbiIsMTI5MTYsInNpb3NhcGFyZW5rb3JlYW4iLDEyODIwLCJzaW9zY2lldWNrb3JlYW4iLDEyNjcwLCJzaW9zY2lyY2xla29yZWFuIiwxMjkwMiwic2lvc2tpeWVva2tvcmVhbiIsMTI2NjYsInNpb3Nrb3JlYW4iLDEyNjEzLCJzaW9zbmlldW5rb3JlYW4iLDEyNjY3LCJzaW9zcGFyZW5rb3JlYW4iLDEyODA2LCJzaW9zcGlldXBrb3JlYW4iLDEyNjY5LCJzaW9zdGlrZXV0a29yZWFuIiwxMjY2OCwic2l4Iiw1NCwic2l4YXJhYmljIiwxNjM4LCJzaXhiZW5nYWxpIiwyNTQwLCJzaXhjaXJjbGUiLDkzMTcsInNpeGNpcmNsZWludmVyc2VzYW5zc2VyaWYiLDEwMTI3LCJzaXhkZXZhIiwyNDEyLCJzaXhndWphcmF0aSIsMjc5Niwic2l4Z3VybXVraGkiLDI2NjgsInNpeGhhY2thcmFiaWMiLDE2MzgsInNpeGhhbmd6aG91IiwxMjMyNiwic2l4aWRlb2dyYXBoaWNwYXJlbiIsMTI4MzcsInNpeGluZmVyaW9yIiw4MzI2LCJzaXhtb25vc3BhY2UiLDY1MzAyLCJzaXhvbGRzdHlsZSIsNjMyODYsInNpeHBhcmVuIiw5MzM3LCJzaXhwZXJpb2QiLDkzNTcsInNpeHBlcnNpYW4iLDE3ODIsInNpeHJvbWFuIiw4NTY1LCJzaXhzdXBlcmlvciIsODMxMCwic2l4dGVlbmNpcmNsZSIsOTMyNywic2l4dGVlbmN1cnJlbmN5ZGVub21pbmF0b3JiZW5nYWxpIiwyNTUzLCJzaXh0ZWVucGFyZW4iLDkzNDcsInNpeHRlZW5wZXJpb2QiLDkzNjcsInNpeHRoYWkiLDM2NzAsInNsYXNoIiw0Nywic2xhc2htb25vc3BhY2UiLDY1Mjk1LCJzbG9uZyIsMzgzLCJzbG9uZ2RvdGFjY2VudCIsNzgzNSwic21pbGVmYWNlIiw5Nzg2LCJzbW9ub3NwYWNlIiw2NTM2Mywic29mcGFzdXFoZWJyZXciLDE0NzUsInNvZnRoeXBoZW4iLDE3Mywic29mdHNpZ25jeXJpbGxpYyIsMTEwMCwic29oaXJhZ2FuYSIsMTIzODEsInNva2F0YWthbmEiLDEyNDc3LCJzb2thdGFrYW5haGFsZndpZHRoIiw2NTQwNywic29saWR1c2xvbmdvdmVybGF5Y21iIiw4MjQsInNvbGlkdXNzaG9ydG92ZXJsYXljbWIiLDgyMywic29ydXNpdGhhaSIsMzYyNSwic29zYWxhdGhhaSIsMzYyNCwic29zb3RoYWkiLDM1OTUsInNvc3VhdGhhaSIsMzYyNiwic3BhY2UiLDMyLCJzcGFjZWhhY2thcmFiaWMiLDMyLCJzcGFkZSIsOTgyNCwic3BhZGVzdWl0YmxhY2siLDk4MjQsInNwYWRlc3VpdHdoaXRlIiw5ODI4LCJzcGFyZW4iLDkzOTAsInNxdWFyZWJlbG93Y21iIiw4MjcsInNxdWFyZWNjIiwxMzI1Miwic3F1YXJlY20iLDEzMjEzLCJzcXVhcmVkaWFnb25hbGNyb3NzaGF0Y2hmaWxsIiw5NjQxLCJzcXVhcmVob3Jpem9udGFsZmlsbCIsOTYzNiwic3F1YXJla2ciLDEzMTk5LCJzcXVhcmVrbSIsMTMyMTQsInNxdWFyZWttY2FwaXRhbCIsMTMyNjIsInNxdWFyZWxuIiwxMzI2NSwic3F1YXJlbG9nIiwxMzI2Niwic3F1YXJlbWciLDEzMTk4LCJzcXVhcmVtaWwiLDEzMjY5LCJzcXVhcmVtbSIsMTMyMTIsInNxdWFyZW1zcXVhcmVkIiwxMzIxNywic3F1YXJlb3J0aG9nb25hbGNyb3NzaGF0Y2hmaWxsIiw5NjM4LCJzcXVhcmV1cHBlcmxlZnR0b2xvd2VycmlnaHRmaWxsIiw5NjM5LCJzcXVhcmV1cHBlcnJpZ2h0dG9sb3dlcmxlZnRmaWxsIiw5NjQwLCJzcXVhcmV2ZXJ0aWNhbGZpbGwiLDk2MzcsInNxdWFyZXdoaXRld2l0aHNtYWxsYmxhY2siLDk2MzUsInNyc3F1YXJlIiwxMzI3NSwic3NhYmVuZ2FsaSIsMjQ4Nywic3NhZGV2YSIsMjM1OSwic3NhZ3VqYXJhdGkiLDI3NDMsInNzYW5nY2lldWNrb3JlYW4iLDEyNjE3LCJzc2FuZ2hpZXVoa29yZWFuIiwxMjY3Nywic3NhbmdpZXVuZ2tvcmVhbiIsMTI2NzIsInNzYW5na2l5ZW9ra29yZWFuIiwxMjU5NCwic3NhbmduaWV1bmtvcmVhbiIsMTI2NDUsInNzYW5ncGlldXBrb3JlYW4iLDEyNjExLCJzc2FuZ3Npb3Nrb3JlYW4iLDEyNjE0LCJzc2FuZ3Rpa2V1dGtvcmVhbiIsMTI2MDAsInNzdXBlcmlvciIsNjMyMTgsInN0ZXJsaW5nIiwxNjMsInN0ZXJsaW5nbW9ub3NwYWNlIiw2NTUwNSwic3Ryb2tlbG9uZ292ZXJsYXljbWIiLDgyMiwic3Ryb2tlc2hvcnRvdmVybGF5Y21iIiw4MjEsInN1YnNldCIsODgzNCwic3Vic2V0bm90ZXF1YWwiLDg4NDIsInN1YnNldG9yZXF1YWwiLDg4MzgsInN1Y2NlZWRzIiw4ODI3LCJzdWNodGhhdCIsODcxNSwic3VoaXJhZ2FuYSIsMTIzNzcsInN1a2F0YWthbmEiLDEyNDczLCJzdWthdGFrYW5haGFsZndpZHRoIiw2NTQwNSwic3VrdW5hcmFiaWMiLDE2MTgsInN1bW1hdGlvbiIsODcyMSwic3VuIiw5Nzg4LCJzdXBlcnNldCIsODgzNSwic3VwZXJzZXRub3RlcXVhbCIsODg0Mywic3VwZXJzZXRvcmVxdWFsIiw4ODM5LCJzdnNxdWFyZSIsMTMyNzYsInN5b3V3YWVyYXNxdWFyZSIsMTMxODAsInQiLDExNiwidGFiZW5nYWxpIiwyNDY4LCJ0YWNrZG93biIsODg2OCwidGFja2xlZnQiLDg4NjcsInRhZGV2YSIsMjM0MCwidGFndWphcmF0aSIsMjcyNCwidGFndXJtdWtoaSIsMjU5NiwidGFoYXJhYmljIiwxNTkxLCJ0YWhmaW5hbGFyYWJpYyIsNjUyMTgsInRhaGluaXRpYWxhcmFiaWMiLDY1MjE5LCJ0YWhpcmFnYW5hIiwxMjM4MywidGFobWVkaWFsYXJhYmljIiw2NTIyMCwidGFpc3lvdWVyYXNxdWFyZSIsMTMxODEsInRha2F0YWthbmEiLDEyNDc5LCJ0YWthdGFrYW5haGFsZndpZHRoIiw2NTQwOCwidGF0d2VlbGFyYWJpYyIsMTYwMCwidGF1Iiw5NjQsInRhdiIsMTUxNCwidGF2ZGFnZXMiLDY0MzMwLCJ0YXZkYWdlc2giLDY0MzMwLCJ0YXZkYWdlc2hoZWJyZXciLDY0MzMwLCJ0YXZoZWJyZXciLDE1MTQsInRiYXIiLDM1OSwidGJvcG9tb2ZvIiwxMjU1NCwidGNhcm9uIiwzNTcsInRjY3VybCIsNjgwLCJ0Y2VkaWxsYSIsMzU1LCJ0Y2hlaGFyYWJpYyIsMTY3MCwidGNoZWhmaW5hbGFyYWJpYyIsNjQzNzksInRjaGVoaW5pdGlhbGFyYWJpYyIsNjQzODAsInRjaGVobWVkaWFsYXJhYmljIiw2NDM4MSwidGNpcmNsZSIsOTQ0MywidGNpcmN1bWZsZXhiZWxvdyIsNzc5MywidGNvbW1hYWNjZW50IiwzNTUsInRkaWVyZXNpcyIsNzgzMSwidGRvdGFjY2VudCIsNzc4NywidGRvdGJlbG93Iiw3Nzg5LCJ0ZWN5cmlsbGljIiwxMDkwLCJ0ZWRlc2NlbmRlcmN5cmlsbGljIiwxMTk3LCJ0ZWhhcmFiaWMiLDE1NzgsInRlaGZpbmFsYXJhYmljIiw2NTE3NCwidGVoaGFoaW5pdGlhbGFyYWJpYyIsNjQ2NzQsInRlaGhhaGlzb2xhdGVkYXJhYmljIiw2NDUyNCwidGVoaW5pdGlhbGFyYWJpYyIsNjUxNzUsInRlaGlyYWdhbmEiLDEyMzkwLCJ0ZWhqZWVtaW5pdGlhbGFyYWJpYyIsNjQ2NzMsInRlaGplZW1pc29sYXRlZGFyYWJpYyIsNjQ1MjMsInRlaG1hcmJ1dGFhcmFiaWMiLDE1NzcsInRlaG1hcmJ1dGFmaW5hbGFyYWJpYyIsNjUxNzIsInRlaG1lZGlhbGFyYWJpYyIsNjUxNzYsInRlaG1lZW1pbml0aWFsYXJhYmljIiw2NDY3NiwidGVobWVlbWlzb2xhdGVkYXJhYmljIiw2NDUyNiwidGVobm9vbmZpbmFsYXJhYmljIiw2NDYyNywidGVrYXRha2FuYSIsMTI0ODYsInRla2F0YWthbmFoYWxmd2lkdGgiLDY1NDExLCJ0ZWxlcGhvbmUiLDg0ODEsInRlbGVwaG9uZWJsYWNrIiw5NzQyLCJ0ZWxpc2hhZ2Vkb2xhaGVicmV3IiwxNDQwLCJ0ZWxpc2hhcWV0YW5haGVicmV3IiwxNDQ5LCJ0ZW5jaXJjbGUiLDkzMjEsInRlbmlkZW9ncmFwaGljcGFyZW4iLDEyODQxLCJ0ZW5wYXJlbiIsOTM0MSwidGVucGVyaW9kIiw5MzYxLCJ0ZW5yb21hbiIsODU2OSwidGVzaCIsNjc5LCJ0ZXQiLDE0OTYsInRldGRhZ2VzaCIsNjQzMTIsInRldGRhZ2VzaGhlYnJldyIsNjQzMTIsInRldGhlYnJldyIsMTQ5NiwidGV0c2VjeXJpbGxpYyIsMTIwNSwidGV2aXJoZWJyZXciLDE0MzUsInRldmlybGVmdGhlYnJldyIsMTQzNSwidGhhYmVuZ2FsaSIsMjQ2OSwidGhhZGV2YSIsMjM0MSwidGhhZ3VqYXJhdGkiLDI3MjUsInRoYWd1cm11a2hpIiwyNTk3LCJ0aGFsYXJhYmljIiwxNTg0LCJ0aGFsZmluYWxhcmFiaWMiLDY1MTk2LCJ0aGFudGhha2hhdGxvd2xlZnR0aGFpIiw2MzY0MCwidGhhbnRoYWtoYXRsb3dyaWdodHRoYWkiLDYzNjM5LCJ0aGFudGhha2hhdHRoYWkiLDM2NjAsInRoYW50aGFraGF0dXBwZXJsZWZ0dGhhaSIsNjM2MzgsInRoZWhhcmFiaWMiLDE1NzksInRoZWhmaW5hbGFyYWJpYyIsNjUxNzgsInRoZWhpbml0aWFsYXJhYmljIiw2NTE3OSwidGhlaG1lZGlhbGFyYWJpYyIsNjUxODAsInRoZXJlZXhpc3RzIiw4NzA3LCJ0aGVyZWZvcmUiLDg3NTYsInRoZXRhIiw5NTIsInRoZXRhMSIsOTc3LCJ0aGV0YXN5bWJvbGdyZWVrIiw5NzcsInRoaWV1dGhhY2lyY2xla29yZWFuIiwxMjkyMSwidGhpZXV0aGFwYXJlbmtvcmVhbiIsMTI4MjUsInRoaWV1dGhjaXJjbGVrb3JlYW4iLDEyOTA3LCJ0aGlldXRoa29yZWFuIiwxMjYyMCwidGhpZXV0aHBhcmVua29yZWFuIiwxMjgxMSwidGhpcnRlZW5jaXJjbGUiLDkzMjQsInRoaXJ0ZWVucGFyZW4iLDkzNDQsInRoaXJ0ZWVucGVyaW9kIiw5MzY0LCJ0aG9uYW5nbW9udGhvdGhhaSIsMzYwMSwidGhvb2siLDQyOSwidGhvcGh1dGhhb3RoYWkiLDM2MDIsInRob3JuIiwyNTQsInRob3RoYWhhbnRoYWkiLDM2MDcsInRob3RoYW50aGFpIiwzNjAwLCJ0aG90aG9uZ3RoYWkiLDM2MDgsInRob3RodW5ndGhhaSIsMzYwNiwidGhvdXNhbmRjeXJpbGxpYyIsMTE1NCwidGhvdXNhbmRzc2VwYXJhdG9yYXJhYmljIiwxNjQ0LCJ0aG91c2FuZHNzZXBhcmF0b3JwZXJzaWFuIiwxNjQ0LCJ0aHJlZSIsNTEsInRocmVlYXJhYmljIiwxNjM1LCJ0aHJlZWJlbmdhbGkiLDI1MzcsInRocmVlY2lyY2xlIiw5MzE0LCJ0aHJlZWNpcmNsZWludmVyc2VzYW5zc2VyaWYiLDEwMTI0LCJ0aHJlZWRldmEiLDI0MDksInRocmVlZWlnaHRocyIsODU0MCwidGhyZWVndWphcmF0aSIsMjc5MywidGhyZWVndXJtdWtoaSIsMjY2NSwidGhyZWVoYWNrYXJhYmljIiwxNjM1LCJ0aHJlZWhhbmd6aG91IiwxMjMyMywidGhyZWVpZGVvZ3JhcGhpY3BhcmVuIiwxMjgzNCwidGhyZWVpbmZlcmlvciIsODMyMywidGhyZWVtb25vc3BhY2UiLDY1Mjk5LCJ0aHJlZW51bWVyYXRvcmJlbmdhbGkiLDI1NTAsInRocmVlb2xkc3R5bGUiLDYzMjgzLCJ0aHJlZXBhcmVuIiw5MzM0LCJ0aHJlZXBlcmlvZCIsOTM1NCwidGhyZWVwZXJzaWFuIiwxNzc5LCJ0aHJlZXF1YXJ0ZXJzIiwxOTAsInRocmVlcXVhcnRlcnNlbWRhc2giLDYzMTk4LCJ0aHJlZXJvbWFuIiw4NTYyLCJ0aHJlZXN1cGVyaW9yIiwxNzksInRocmVldGhhaSIsMzY2NywidGh6c3F1YXJlIiwxMzIwNCwidGloaXJhZ2FuYSIsMTIzODUsInRpa2F0YWthbmEiLDEyNDgxLCJ0aWthdGFrYW5haGFsZndpZHRoIiw2NTQwOSwidGlrZXV0YWNpcmNsZWtvcmVhbiIsMTI5MTIsInRpa2V1dGFwYXJlbmtvcmVhbiIsMTI4MTYsInRpa2V1dGNpcmNsZWtvcmVhbiIsMTI4OTgsInRpa2V1dGtvcmVhbiIsMTI1OTksInRpa2V1dHBhcmVua29yZWFuIiwxMjgwMiwidGlsZGUiLDczMiwidGlsZGViZWxvd2NtYiIsODE2LCJ0aWxkZWNtYiIsNzcxLCJ0aWxkZWNvbWIiLDc3MSwidGlsZGVkb3VibGVjbWIiLDg2NCwidGlsZGVvcGVyYXRvciIsODc2NCwidGlsZGVvdmVybGF5Y21iIiw4MjAsInRpbGRldmVydGljYWxjbWIiLDgzMCwidGltZXNjaXJjbGUiLDg4NTUsInRpcGVoYWhlYnJldyIsMTQzMCwidGlwZWhhbGVmdGhlYnJldyIsMTQzMCwidGlwcGlndXJtdWtoaSIsMjY3MiwidGl0bG9jeXJpbGxpY2NtYiIsMTE1NSwidGl3bmFybWVuaWFuIiwxNDA3LCJ0bGluZWJlbG93Iiw3NzkxLCJ0bW9ub3NwYWNlIiw2NTM2NCwidG9hcm1lbmlhbiIsMTM4NSwidG9oaXJhZ2FuYSIsMTIzOTIsInRva2F0YWthbmEiLDEyNDg4LCJ0b2thdGFrYW5haGFsZndpZHRoIiw2NTQxMiwidG9uZWJhcmV4dHJhaGlnaG1vZCIsNzQxLCJ0b25lYmFyZXh0cmFsb3dtb2QiLDc0NSwidG9uZWJhcmhpZ2htb2QiLDc0MiwidG9uZWJhcmxvd21vZCIsNzQ0LCJ0b25lYmFybWlkbW9kIiw3NDMsInRvbmVmaXZlIiw0NDUsInRvbmVzaXgiLDM4OSwidG9uZXR3byIsNDI0LCJ0b25vcyIsOTAwLCJ0b25zcXVhcmUiLDEzMDk1LCJ0b3BhdGFrdGhhaSIsMzU5OSwidG9ydG9pc2VzaGVsbGJyYWNrZXRsZWZ0IiwxMjMwOCwidG9ydG9pc2VzaGVsbGJyYWNrZXRsZWZ0c21hbGwiLDY1MTE3LCJ0b3J0b2lzZXNoZWxsYnJhY2tldGxlZnR2ZXJ0aWNhbCIsNjUwODEsInRvcnRvaXNlc2hlbGxicmFja2V0cmlnaHQiLDEyMzA5LCJ0b3J0b2lzZXNoZWxsYnJhY2tldHJpZ2h0c21hbGwiLDY1MTE4LCJ0b3J0b2lzZXNoZWxsYnJhY2tldHJpZ2h0dmVydGljYWwiLDY1MDgyLCJ0b3Rhb3RoYWkiLDM2MDUsInRwYWxhdGFsaG9vayIsNDI3LCJ0cGFyZW4iLDkzOTEsInRyYWRlbWFyayIsODQ4MiwidHJhZGVtYXJrc2FucyIsNjM3MjIsInRyYWRlbWFya3NlcmlmIiw2MzE5NSwidHJldHJvZmxleGhvb2siLDY0OCwidHJpYWdkbiIsOTY2MCwidHJpYWdsZiIsOTY2OCwidHJpYWdydCIsOTY1OCwidHJpYWd1cCIsOTY1MCwidHMiLDY3OCwidHNhZGkiLDE1MTAsInRzYWRpZGFnZXNoIiw2NDMyNiwidHNhZGlkYWdlc2hoZWJyZXciLDY0MzI2LCJ0c2FkaWhlYnJldyIsMTUxMCwidHNlY3lyaWxsaWMiLDEwOTQsInRzZXJlIiwxNDYxLCJ0c2VyZTEyIiwxNDYxLCJ0c2VyZTFlIiwxNDYxLCJ0c2VyZTJiIiwxNDYxLCJ0c2VyZWhlYnJldyIsMTQ2MSwidHNlcmVuYXJyb3doZWJyZXciLDE0NjEsInRzZXJlcXVhcnRlcmhlYnJldyIsMTQ2MSwidHNlcmV3aWRlaGVicmV3IiwxNDYxLCJ0c2hlY3lyaWxsaWMiLDExMTUsInRzdXBlcmlvciIsNjMyMTksInR0YWJlbmdhbGkiLDI0NjMsInR0YWRldmEiLDIzMzUsInR0YWd1amFyYXRpIiwyNzE5LCJ0dGFndXJtdWtoaSIsMjU5MSwidHRlaGFyYWJpYyIsMTY1NywidHRlaGZpbmFsYXJhYmljIiw2NDM1OSwidHRlaGluaXRpYWxhcmFiaWMiLDY0MzYwLCJ0dGVobWVkaWFsYXJhYmljIiw2NDM2MSwidHRoYWJlbmdhbGkiLDI0NjQsInR0aGFkZXZhIiwyMzM2LCJ0dGhhZ3VqYXJhdGkiLDI3MjAsInR0aGFndXJtdWtoaSIsMjU5MiwidHR1cm5lZCIsNjQ3LCJ0dWhpcmFnYW5hIiwxMjM4OCwidHVrYXRha2FuYSIsMTI0ODQsInR1a2F0YWthbmFoYWxmd2lkdGgiLDY1NDEwLCJ0dXNtYWxsaGlyYWdhbmEiLDEyMzg3LCJ0dXNtYWxsa2F0YWthbmEiLDEyNDgzLCJ0dXNtYWxsa2F0YWthbmFoYWxmd2lkdGgiLDY1MzkxLCJ0d2VsdmVjaXJjbGUiLDkzMjMsInR3ZWx2ZXBhcmVuIiw5MzQzLCJ0d2VsdmVwZXJpb2QiLDkzNjMsInR3ZWx2ZXJvbWFuIiw4NTcxLCJ0d2VudHljaXJjbGUiLDkzMzEsInR3ZW50eWhhbmd6aG91IiwyMTMxNiwidHdlbnR5cGFyZW4iLDkzNTEsInR3ZW50eXBlcmlvZCIsOTM3MSwidHdvIiw1MCwidHdvYXJhYmljIiwxNjM0LCJ0d29iZW5nYWxpIiwyNTM2LCJ0d29jaXJjbGUiLDkzMTMsInR3b2NpcmNsZWludmVyc2VzYW5zc2VyaWYiLDEwMTIzLCJ0d29kZXZhIiwyNDA4LCJ0d29kb3RlbmxlYWRlciIsODIyOSwidHdvZG90bGVhZGVyIiw4MjI5LCJ0d29kb3RsZWFkZXJ2ZXJ0aWNhbCIsNjUwNzIsInR3b2d1amFyYXRpIiwyNzkyLCJ0d29ndXJtdWtoaSIsMjY2NCwidHdvaGFja2FyYWJpYyIsMTYzNCwidHdvaGFuZ3pob3UiLDEyMzIyLCJ0d29pZGVvZ3JhcGhpY3BhcmVuIiwxMjgzMywidHdvaW5mZXJpb3IiLDgzMjIsInR3b21vbm9zcGFjZSIsNjUyOTgsInR3b251bWVyYXRvcmJlbmdhbGkiLDI1NDksInR3b29sZHN0eWxlIiw2MzI4MiwidHdvcGFyZW4iLDkzMzMsInR3b3BlcmlvZCIsOTM1MywidHdvcGVyc2lhbiIsMTc3OCwidHdvcm9tYW4iLDg1NjEsInR3b3N0cm9rZSIsNDQzLCJ0d29zdXBlcmlvciIsMTc4LCJ0d290aGFpIiwzNjY2LCJ0d290aGlyZHMiLDg1MzIsInUiLDExNywidWFjdXRlIiwyNTAsInViYXIiLDY0OSwidWJlbmdhbGkiLDI0NDEsInVib3BvbW9mbyIsMTI1ODQsInVicmV2ZSIsMzY1LCJ1Y2Fyb24iLDQ2OCwidWNpcmNsZSIsOTQ0NCwidWNpcmN1bWZsZXgiLDI1MSwidWNpcmN1bWZsZXhiZWxvdyIsNzc5OSwidWN5cmlsbGljIiwxMDkxLCJ1ZGF0dGFkZXZhIiwyMzg1LCJ1ZGJsYWN1dGUiLDM2OSwidWRibGdyYXZlIiw1MzMsInVkZXZhIiwyMzEzLCJ1ZGllcmVzaXMiLDI1MiwidWRpZXJlc2lzYWN1dGUiLDQ3MiwidWRpZXJlc2lzYmVsb3ciLDc3OTUsInVkaWVyZXNpc2Nhcm9uIiw0NzQsInVkaWVyZXNpc2N5cmlsbGljIiwxMjY1LCJ1ZGllcmVzaXNncmF2ZSIsNDc2LCJ1ZGllcmVzaXNtYWNyb24iLDQ3MCwidWRvdGJlbG93Iiw3OTA5LCJ1Z3JhdmUiLDI0OSwidWd1amFyYXRpIiwyNjk3LCJ1Z3VybXVraGkiLDI1NjksInVoaXJhZ2FuYSIsMTIzNTgsInVob29rYWJvdmUiLDc5MTEsInVob3JuIiw0MzIsInVob3JuYWN1dGUiLDc5MTMsInVob3JuZG90YmVsb3ciLDc5MjEsInVob3JuZ3JhdmUiLDc5MTUsInVob3JuaG9va2Fib3ZlIiw3OTE3LCJ1aG9ybnRpbGRlIiw3OTE5LCJ1aHVuZ2FydW1sYXV0IiwzNjksInVodW5nYXJ1bWxhdXRjeXJpbGxpYyIsMTI2NywidWludmVydGVkYnJldmUiLDUzNSwidWthdGFrYW5hIiwxMjQ1NCwidWthdGFrYW5haGFsZndpZHRoIiw2NTM5NSwidWtjeXJpbGxpYyIsMTE0NSwidWtvcmVhbiIsMTI2MzYsInVtYWNyb24iLDM2MywidW1hY3JvbmN5cmlsbGljIiwxMjYzLCJ1bWFjcm9uZGllcmVzaXMiLDc4MDMsInVtYXRyYWd1cm11a2hpIiwyNjI1LCJ1bW9ub3NwYWNlIiw2NTM2NSwidW5kZXJzY29yZSIsOTUsInVuZGVyc2NvcmVkYmwiLDgyMTUsInVuZGVyc2NvcmVtb25vc3BhY2UiLDY1MzQzLCJ1bmRlcnNjb3JldmVydGljYWwiLDY1MDc1LCJ1bmRlcnNjb3Jld2F2eSIsNjUxMDMsInVuaW9uIiw4NzQ2LCJ1bml2ZXJzYWwiLDg3MDQsInVvZ29uZWsiLDM3MSwidXBhcmVuIiw5MzkyLCJ1cGJsb2NrIiw5NjAwLCJ1cHBlcmRvdGhlYnJldyIsMTQ3NiwidXBzaWxvbiIsOTY1LCJ1cHNpbG9uZGllcmVzaXMiLDk3MSwidXBzaWxvbmRpZXJlc2lzdG9ub3MiLDk0NCwidXBzaWxvbmxhdGluIiw2NTAsInVwc2lsb250b25vcyIsOTczLCJ1cHRhY2tiZWxvd2NtYiIsNzk3LCJ1cHRhY2ttb2QiLDcyNCwidXJhZ3VybXVraGkiLDI2NzUsInVyaW5nIiwzNjcsInVzaG9ydGN5cmlsbGljIiwxMTE4LCJ1c21hbGxoaXJhZ2FuYSIsMTIzNTcsInVzbWFsbGthdGFrYW5hIiwxMjQ1MywidXNtYWxsa2F0YWthbmFoYWxmd2lkdGgiLDY1Mzg1LCJ1c3RyYWlnaHRjeXJpbGxpYyIsMTE5OSwidXN0cmFpZ2h0c3Ryb2tlY3lyaWxsaWMiLDEyMDEsInV0aWxkZSIsMzYxLCJ1dGlsZGVhY3V0ZSIsNzgwMSwidXRpbGRlYmVsb3ciLDc3OTcsInV1YmVuZ2FsaSIsMjQ0MiwidXVkZXZhIiwyMzE0LCJ1dWd1amFyYXRpIiwyNjk4LCJ1dWd1cm11a2hpIiwyNTcwLCJ1dW1hdHJhZ3VybXVraGkiLDI2MjYsInV1dm93ZWxzaWduYmVuZ2FsaSIsMjQ5OCwidXV2b3dlbHNpZ25kZXZhIiwyMzcwLCJ1dXZvd2Vsc2lnbmd1amFyYXRpIiwyNzU0LCJ1dm93ZWxzaWduYmVuZ2FsaSIsMjQ5NywidXZvd2Vsc2lnbmRldmEiLDIzNjksInV2b3dlbHNpZ25ndWphcmF0aSIsMjc1MywidiIsMTE4LCJ2YWRldmEiLDIzNTcsInZhZ3VqYXJhdGkiLDI3NDEsInZhZ3VybXVraGkiLDI2MTMsInZha2F0YWthbmEiLDEyNTM1LCJ2YXYiLDE0OTMsInZhdmRhZ2VzaCIsNjQzMDksInZhdmRhZ2VzaDY1Iiw2NDMwOSwidmF2ZGFnZXNoaGVicmV3Iiw2NDMwOSwidmF2aGVicmV3IiwxNDkzLCJ2YXZob2xhbSIsNjQzMzEsInZhdmhvbGFtaGVicmV3Iiw2NDMzMSwidmF2dmF2aGVicmV3IiwxNTIwLCJ2YXZ5b2RoZWJyZXciLDE1MjEsInZjaXJjbGUiLDk0NDUsInZkb3RiZWxvdyIsNzgwNywidmVjeXJpbGxpYyIsMTA3NCwidmVoYXJhYmljIiwxNzAwLCJ2ZWhmaW5hbGFyYWJpYyIsNjQzNjMsInZlaGluaXRpYWxhcmFiaWMiLDY0MzY0LCJ2ZWhtZWRpYWxhcmFiaWMiLDY0MzY1LCJ2ZWthdGFrYW5hIiwxMjUzNywidmVudXMiLDk3OTIsInZlcnRpY2FsYmFyIiwxMjQsInZlcnRpY2FsbGluZWFib3ZlY21iIiw3ODEsInZlcnRpY2FsbGluZWJlbG93Y21iIiw4MDksInZlcnRpY2FsbGluZWxvd21vZCIsNzE2LCJ2ZXJ0aWNhbGxpbmVtb2QiLDcxMiwidmV3YXJtZW5pYW4iLDE0MDYsInZob29rIiw2NTEsInZpa2F0YWthbmEiLDEyNTM2LCJ2aXJhbWFiZW5nYWxpIiwyNTA5LCJ2aXJhbWFkZXZhIiwyMzgxLCJ2aXJhbWFndWphcmF0aSIsMjc2NSwidmlzYXJnYWJlbmdhbGkiLDI0MzUsInZpc2FyZ2FkZXZhIiwyMzA3LCJ2aXNhcmdhZ3VqYXJhdGkiLDI2OTEsInZtb25vc3BhY2UiLDY1MzY2LCJ2b2FybWVuaWFuIiwxNDAwLCJ2b2ljZWRpdGVyYXRpb25oaXJhZ2FuYSIsMTI0NDYsInZvaWNlZGl0ZXJhdGlvbmthdGFrYW5hIiwxMjU0Miwidm9pY2VkbWFya2thbmEiLDEyNDQzLCJ2b2ljZWRtYXJra2FuYWhhbGZ3aWR0aCIsNjU0MzgsInZva2F0YWthbmEiLDEyNTM4LCJ2cGFyZW4iLDkzOTMsInZ0aWxkZSIsNzgwNSwidnR1cm5lZCIsNjUyLCJ2dWhpcmFnYW5hIiwxMjQzNiwidnVrYXRha2FuYSIsMTI1MzIsInciLDExOSwid2FjdXRlIiw3ODExLCJ3YWVrb3JlYW4iLDEyNjMzLCJ3YWhpcmFnYW5hIiwxMjQzMSwid2FrYXRha2FuYSIsMTI1MjcsIndha2F0YWthbmFoYWxmd2lkdGgiLDY1NDM2LCJ3YWtvcmVhbiIsMTI2MzIsIndhc21hbGxoaXJhZ2FuYSIsMTI0MzAsIndhc21hbGxrYXRha2FuYSIsMTI1MjYsIndhdHRvc3F1YXJlIiwxMzE0Mywid2F2ZWRhc2giLDEyMzE2LCJ3YXZ5dW5kZXJzY29yZXZlcnRpY2FsIiw2NTA3Niwid2F3YXJhYmljIiwxNjA4LCJ3YXdmaW5hbGFyYWJpYyIsNjUyNjIsIndhd2hhbXphYWJvdmVhcmFiaWMiLDE1NzIsIndhd2hhbXphYWJvdmVmaW5hbGFyYWJpYyIsNjUxNTgsIndic3F1YXJlIiwxMzI3Nywid2NpcmNsZSIsOTQ0Niwid2NpcmN1bWZsZXgiLDM3Mywid2RpZXJlc2lzIiw3ODEzLCJ3ZG90YWNjZW50Iiw3ODE1LCJ3ZG90YmVsb3ciLDc4MTcsIndlaGlyYWdhbmEiLDEyNDMzLCJ3ZWllcnN0cmFzcyIsODQ3Miwid2VrYXRha2FuYSIsMTI1MjksIndla29yZWFuIiwxMjYzOCwid2Vva29yZWFuIiwxMjYzNywid2dyYXZlIiw3ODA5LCJ3aGl0ZWJ1bGxldCIsOTcwMiwid2hpdGVjaXJjbGUiLDk2NzUsIndoaXRlY2lyY2xlaW52ZXJzZSIsOTY4OSwid2hpdGVjb3JuZXJicmFja2V0bGVmdCIsMTIzMDIsIndoaXRlY29ybmVyYnJhY2tldGxlZnR2ZXJ0aWNhbCIsNjUwOTEsIndoaXRlY29ybmVyYnJhY2tldHJpZ2h0IiwxMjMwMywid2hpdGVjb3JuZXJicmFja2V0cmlnaHR2ZXJ0aWNhbCIsNjUwOTIsIndoaXRlZGlhbW9uZCIsOTY3MSwid2hpdGVkaWFtb25kY29udGFpbmluZ2JsYWNrc21hbGxkaWFtb25kIiw5NjcyLCJ3aGl0ZWRvd25wb2ludGluZ3NtYWxsdHJpYW5nbGUiLDk2NjMsIndoaXRlZG93bnBvaW50aW5ndHJpYW5nbGUiLDk2NjEsIndoaXRlbGVmdHBvaW50aW5nc21hbGx0cmlhbmdsZSIsOTY2Nywid2hpdGVsZWZ0cG9pbnRpbmd0cmlhbmdsZSIsOTY2NSwid2hpdGVsZW50aWN1bGFyYnJhY2tldGxlZnQiLDEyMzEwLCJ3aGl0ZWxlbnRpY3VsYXJicmFja2V0cmlnaHQiLDEyMzExLCJ3aGl0ZXJpZ2h0cG9pbnRpbmdzbWFsbHRyaWFuZ2xlIiw5NjU3LCJ3aGl0ZXJpZ2h0cG9pbnRpbmd0cmlhbmdsZSIsOTY1NSwid2hpdGVzbWFsbHNxdWFyZSIsOTY0Mywid2hpdGVzbWlsaW5nZmFjZSIsOTc4Niwid2hpdGVzcXVhcmUiLDk2MzMsIndoaXRlc3RhciIsOTczNCwid2hpdGV0ZWxlcGhvbmUiLDk3NDMsIndoaXRldG9ydG9pc2VzaGVsbGJyYWNrZXRsZWZ0IiwxMjMxMiwid2hpdGV0b3J0b2lzZXNoZWxsYnJhY2tldHJpZ2h0IiwxMjMxMywid2hpdGV1cHBvaW50aW5nc21hbGx0cmlhbmdsZSIsOTY1Mywid2hpdGV1cHBvaW50aW5ndHJpYW5nbGUiLDk2NTEsIndpaGlyYWdhbmEiLDEyNDMyLCJ3aWthdGFrYW5hIiwxMjUyOCwid2lrb3JlYW4iLDEyNjM5LCJ3bW9ub3NwYWNlIiw2NTM2Nywid29oaXJhZ2FuYSIsMTI0MzQsIndva2F0YWthbmEiLDEyNTMwLCJ3b2thdGFrYW5haGFsZndpZHRoIiw2NTM4Miwid29uIiw4MzYxLCJ3b25tb25vc3BhY2UiLDY1NTEwLCJ3b3dhZW50aGFpIiwzNjIzLCJ3cGFyZW4iLDkzOTQsIndyaW5nIiw3ODMyLCJ3c3VwZXJpb3IiLDY5NSwid3R1cm5lZCIsNjUzLCJ3eW5uIiw0NDcsIngiLDEyMCwieGFib3ZlY21iIiw4MjksInhib3BvbW9mbyIsMTI1NjIsInhjaXJjbGUiLDk0NDcsInhkaWVyZXNpcyIsNzgyMSwieGRvdGFjY2VudCIsNzgxOSwieGVoYXJtZW5pYW4iLDEzODksInhpIiw5NTgsInhtb25vc3BhY2UiLDY1MzY4LCJ4cGFyZW4iLDkzOTUsInhzdXBlcmlvciIsNzM5LCJ5IiwxMjEsInlhYWRvc3F1YXJlIiwxMzEzNCwieWFiZW5nYWxpIiwyNDc5LCJ5YWN1dGUiLDI1MywieWFkZXZhIiwyMzUxLCJ5YWVrb3JlYW4iLDEyNjI2LCJ5YWd1amFyYXRpIiwyNzM1LCJ5YWd1cm11a2hpIiwyNjA3LCJ5YWhpcmFnYW5hIiwxMjQyMCwieWFrYXRha2FuYSIsMTI1MTYsInlha2F0YWthbmFoYWxmd2lkdGgiLDY1NDI4LCJ5YWtvcmVhbiIsMTI2MjUsInlhbWFra2FudGhhaSIsMzY2MiwieWFzbWFsbGhpcmFnYW5hIiwxMjQxOSwieWFzbWFsbGthdGFrYW5hIiwxMjUxNSwieWFzbWFsbGthdGFrYW5haGFsZndpZHRoIiw2NTM4OCwieWF0Y3lyaWxsaWMiLDExMjMsInljaXJjbGUiLDk0NDgsInljaXJjdW1mbGV4IiwzNzUsInlkaWVyZXNpcyIsMjU1LCJ5ZG90YWNjZW50Iiw3ODIzLCJ5ZG90YmVsb3ciLDc5MjUsInllaGFyYWJpYyIsMTYxMCwieWVoYmFycmVlYXJhYmljIiwxNzQ2LCJ5ZWhiYXJyZWVmaW5hbGFyYWJpYyIsNjQ0MzEsInllaGZpbmFsYXJhYmljIiw2NTI2NiwieWVoaGFtemFhYm92ZWFyYWJpYyIsMTU3NCwieWVoaGFtemFhYm92ZWZpbmFsYXJhYmljIiw2NTE2MiwieWVoaGFtemFhYm92ZWluaXRpYWxhcmFiaWMiLDY1MTYzLCJ5ZWhoYW16YWFib3ZlbWVkaWFsYXJhYmljIiw2NTE2NCwieWVoaW5pdGlhbGFyYWJpYyIsNjUyNjcsInllaG1lZGlhbGFyYWJpYyIsNjUyNjgsInllaG1lZW1pbml0aWFsYXJhYmljIiw2NDczMywieWVobWVlbWlzb2xhdGVkYXJhYmljIiw2NDYwMCwieWVobm9vbmZpbmFsYXJhYmljIiw2NDY2MCwieWVodGhyZWVkb3RzYmVsb3dhcmFiaWMiLDE3NDUsInlla29yZWFuIiwxMjYzMCwieWVuIiwxNjUsInllbm1vbm9zcGFjZSIsNjU1MDksInllb2tvcmVhbiIsMTI2MjksInllb3JpbmhpZXVoa29yZWFuIiwxMjY3OCwieWVyYWhiZW55b21vaGVicmV3IiwxNDUwLCJ5ZXJhaGJlbnlvbW9sZWZ0aGVicmV3IiwxNDUwLCJ5ZXJpY3lyaWxsaWMiLDEwOTksInllcnVkaWVyZXNpc2N5cmlsbGljIiwxMjczLCJ5ZXNpZXVuZ2tvcmVhbiIsMTI2NzMsInllc2lldW5ncGFuc2lvc2tvcmVhbiIsMTI2NzUsInllc2lldW5nc2lvc2tvcmVhbiIsMTI2NzQsInlldGl2aGVicmV3IiwxNDM0LCJ5Z3JhdmUiLDc5MjMsInlob29rIiw0MzYsInlob29rYWJvdmUiLDc5MjcsInlpYXJtZW5pYW4iLDEzOTcsInlpY3lyaWxsaWMiLDExMTEsInlpa29yZWFuIiwxMjY0MiwieWlueWFuZyIsOTc3NSwieWl3bmFybWVuaWFuIiwxNDEwLCJ5bW9ub3NwYWNlIiw2NTM2OSwieW9kIiwxNDk3LCJ5b2RkYWdlc2giLDY0MzEzLCJ5b2RkYWdlc2hoZWJyZXciLDY0MzEzLCJ5b2RoZWJyZXciLDE0OTcsInlvZHlvZGhlYnJldyIsMTUyMiwieW9keW9kcGF0YWhoZWJyZXciLDY0Mjg3LCJ5b2hpcmFnYW5hIiwxMjQyNCwieW9pa29yZWFuIiwxMjY4MSwieW9rYXRha2FuYSIsMTI1MjAsInlva2F0YWthbmFoYWxmd2lkdGgiLDY1NDMwLCJ5b2tvcmVhbiIsMTI2MzUsInlvc21hbGxoaXJhZ2FuYSIsMTI0MjMsInlvc21hbGxrYXRha2FuYSIsMTI1MTksInlvc21hbGxrYXRha2FuYWhhbGZ3aWR0aCIsNjUzOTAsInlvdGdyZWVrIiwxMDExLCJ5b3lhZWtvcmVhbiIsMTI2ODAsInlveWFrb3JlYW4iLDEyNjc5LCJ5b3lha3RoYWkiLDM2MTgsInlveWluZ3RoYWkiLDM1OTcsInlwYXJlbiIsOTM5NiwieXBvZ2VncmFtbWVuaSIsODkwLCJ5cG9nZWdyYW1tZW5pZ3JlZWtjbWIiLDgzNywieXIiLDQyMiwieXJpbmciLDc4MzMsInlzdXBlcmlvciIsNjk2LCJ5dGlsZGUiLDc5MjksInl0dXJuZWQiLDY1NCwieXVoaXJhZ2FuYSIsMTI0MjIsInl1aWtvcmVhbiIsMTI2ODQsInl1a2F0YWthbmEiLDEyNTE4LCJ5dWthdGFrYW5haGFsZndpZHRoIiw2NTQyOSwieXVrb3JlYW4iLDEyNjQwLCJ5dXNiaWdjeXJpbGxpYyIsMTEzMSwieXVzYmlnaW90aWZpZWRjeXJpbGxpYyIsMTEzMywieXVzbGl0dGxlY3lyaWxsaWMiLDExMjcsInl1c2xpdHRsZWlvdGlmaWVkY3lyaWxsaWMiLDExMjksInl1c21hbGxoaXJhZ2FuYSIsMTI0MjEsInl1c21hbGxrYXRha2FuYSIsMTI1MTcsInl1c21hbGxrYXRha2FuYWhhbGZ3aWR0aCIsNjUzODksInl1eWVrb3JlYW4iLDEyNjgzLCJ5dXllb2tvcmVhbiIsMTI2ODIsInl5YWJlbmdhbGkiLDI1MjcsInl5YWRldmEiLDIzOTksInoiLDEyMiwiemFhcm1lbmlhbiIsMTM4MiwiemFjdXRlIiwzNzgsInphZGV2YSIsMjM5NSwiemFndXJtdWtoaSIsMjY1MSwiemFoYXJhYmljIiwxNTkyLCJ6YWhmaW5hbGFyYWJpYyIsNjUyMjIsInphaGluaXRpYWxhcmFiaWMiLDY1MjIzLCJ6YWhpcmFnYW5hIiwxMjM3NCwiemFobWVkaWFsYXJhYmljIiw2NTIyNCwiemFpbmFyYWJpYyIsMTU4NiwiemFpbmZpbmFsYXJhYmljIiw2NTIwMCwiemFrYXRha2FuYSIsMTI0NzAsInphcWVmZ2Fkb2xoZWJyZXciLDE0MjksInphcWVmcWF0YW5oZWJyZXciLDE0MjgsInphcnFhaGVicmV3IiwxNDMyLCJ6YXlpbiIsMTQ5NCwiemF5aW5kYWdlc2giLDY0MzEwLCJ6YXlpbmRhZ2VzaGhlYnJldyIsNjQzMTAsInpheWluaGVicmV3IiwxNDk0LCJ6Ym9wb21vZm8iLDEyNTY3LCJ6Y2Fyb24iLDM4MiwiemNpcmNsZSIsOTQ0OSwiemNpcmN1bWZsZXgiLDc4MjUsInpjdXJsIiw2NTcsInpkb3QiLDM4MCwiemRvdGFjY2VudCIsMzgwLCJ6ZG90YmVsb3ciLDc4MjcsInplY3lyaWxsaWMiLDEwNzksInplZGVzY2VuZGVyY3lyaWxsaWMiLDExNzcsInplZGllcmVzaXNjeXJpbGxpYyIsMTI0NywiemVoaXJhZ2FuYSIsMTIzODAsInpla2F0YWthbmEiLDEyNDc2LCJ6ZXJvIiw0OCwiemVyb2FyYWJpYyIsMTYzMiwiemVyb2JlbmdhbGkiLDI1MzQsInplcm9kZXZhIiwyNDA2LCJ6ZXJvZ3VqYXJhdGkiLDI3OTAsInplcm9ndXJtdWtoaSIsMjY2MiwiemVyb2hhY2thcmFiaWMiLDE2MzIsInplcm9pbmZlcmlvciIsODMyMCwiemVyb21vbm9zcGFjZSIsNjUyOTYsInplcm9vbGRzdHlsZSIsNjMyODAsInplcm9wZXJzaWFuIiwxNzc2LCJ6ZXJvc3VwZXJpb3IiLDgzMDQsInplcm90aGFpIiwzNjY0LCJ6ZXJvd2lkdGhqb2luZXIiLDY1Mjc5LCJ6ZXJvd2lkdGhub25qb2luZXIiLDgyMDQsInplcm93aWR0aHNwYWNlIiw4MjAzLCJ6ZXRhIiw5NTAsInpoYm9wb21vZm8iLDEyNTYzLCJ6aGVhcm1lbmlhbiIsMTM4NiwiemhlYnJldmVjeXJpbGxpYyIsMTIxOCwiemhlY3lyaWxsaWMiLDEwNzgsInpoZWRlc2NlbmRlcmN5cmlsbGljIiwxMTc1LCJ6aGVkaWVyZXNpc2N5cmlsbGljIiwxMjQ1LCJ6aWhpcmFnYW5hIiwxMjM3NiwiemlrYXRha2FuYSIsMTI0NzIsInppbm9yaGVicmV3IiwxNDU0LCJ6bGluZWJlbG93Iiw3ODI5LCJ6bW9ub3NwYWNlIiw2NTM3MCwiem9oaXJhZ2FuYSIsMTIzODIsInpva2F0YWthbmEiLDEyNDc4LCJ6cGFyZW4iLDkzOTcsInpyZXRyb2ZsZXhob29rIiw2NTYsInpzdHJva2UiLDQzOCwienVoaXJhZ2FuYSIsMTIzNzgsInp1a2F0YWthbmEiLDEyNDc0LCIubm90ZGVmIiwwLCJhbmdicmFja2V0bGVmdGJpZyIsOTAwMSwiYW5nYnJhY2tldGxlZnRCaWciLDkwMDEsImFuZ2JyYWNrZXRsZWZ0YmlnZyIsOTAwMSwiYW5nYnJhY2tldGxlZnRCaWdnIiw5MDAxLCJhbmdicmFja2V0cmlnaHRCaWciLDkwMDIsImFuZ2JyYWNrZXRyaWdodGJpZyIsOTAwMiwiYW5nYnJhY2tldHJpZ2h0QmlnZyIsOTAwMiwiYW5nYnJhY2tldHJpZ2h0YmlnZyIsOTAwMiwiYXJyb3dob29rbGVmdCIsODYxOCwiYXJyb3dob29rcmlnaHQiLDg2MTcsImFycm93bGVmdHRvcGhhbGYiLDg2MzYsImFycm93bGVmdGJvdGhhbGYiLDg2MzcsImFycm93bm9ydGhlYXN0Iiw4NTk5LCJhcnJvd25vcnRod2VzdCIsODU5OCwiYXJyb3dyaWdodHRvcGhhbGYiLDg2NDAsImFycm93cmlnaHRib3RoYWxmIiw4NjQxLCJhcnJvd3NvdXRoZWFzdCIsODYwMCwiYXJyb3dzb3V0aHdlc3QiLDg2MDEsImJhY2tzbGFzaGJpZyIsODcyNiwiYmFja3NsYXNoQmlnIiw4NzI2LCJiYWNrc2xhc2hCaWdnIiw4NzI2LCJiYWNrc2xhc2hiaWdnIiw4NzI2LCJiYXJkYmwiLDgyMTQsImJyYWNlaHRpcGRvd25sZWZ0Iiw2NTA3OSwiYnJhY2VodGlwZG93bnJpZ2h0Iiw2NTA3OSwiYnJhY2VodGlwdXBsZWZ0Iiw2NTA4MCwiYnJhY2VodGlwdXByaWdodCIsNjUwODAsImJyYWNlbGVmdEJpZyIsMTIzLCJicmFjZWxlZnRiaWciLDEyMywiYnJhY2VsZWZ0YmlnZyIsMTIzLCJicmFjZWxlZnRCaWdnIiwxMjMsImJyYWNlcmlnaHRCaWciLDEyNSwiYnJhY2VyaWdodGJpZyIsMTI1LCJicmFjZXJpZ2h0YmlnZyIsMTI1LCJicmFjZXJpZ2h0QmlnZyIsMTI1LCJicmFja2V0bGVmdGJpZyIsOTEsImJyYWNrZXRsZWZ0QmlnIiw5MSwiYnJhY2tldGxlZnRiaWdnIiw5MSwiYnJhY2tldGxlZnRCaWdnIiw5MSwiYnJhY2tldHJpZ2h0QmlnIiw5MywiYnJhY2tldHJpZ2h0YmlnIiw5MywiYnJhY2tldHJpZ2h0YmlnZyIsOTMsImJyYWNrZXRyaWdodEJpZ2ciLDkzLCJjZWlsaW5nbGVmdGJpZyIsODk2OCwiY2VpbGluZ2xlZnRCaWciLDg5NjgsImNlaWxpbmdsZWZ0QmlnZyIsODk2OCwiY2VpbGluZ2xlZnRiaWdnIiw4OTY4LCJjZWlsaW5ncmlnaHRiaWciLDg5NjksImNlaWxpbmdyaWdodEJpZyIsODk2OSwiY2VpbGluZ3JpZ2h0YmlnZyIsODk2OSwiY2VpbGluZ3JpZ2h0QmlnZyIsODk2OSwiY2lyY2xlZG90ZGlzcGxheSIsODg1NywiY2lyY2xlZG90dGV4dCIsODg1NywiY2lyY2xlbXVsdGlwbHlkaXNwbGF5Iiw4ODU1LCJjaXJjbGVtdWx0aXBseXRleHQiLDg4NTUsImNpcmNsZXBsdXNkaXNwbGF5Iiw4ODUzLCJjaXJjbGVwbHVzdGV4dCIsODg1MywiY29udGludGVncmFsZGlzcGxheSIsODc1MCwiY29udGludGVncmFsdGV4dCIsODc1MCwiY29wcm9kdWN0ZGlzcGxheSIsODcyMCwiY29wcm9kdWN0dGV4dCIsODcyMCwiZmxvb3JsZWZ0QmlnIiw4OTcwLCJmbG9vcmxlZnRiaWciLDg5NzAsImZsb29ybGVmdGJpZ2ciLDg5NzAsImZsb29ybGVmdEJpZ2ciLDg5NzAsImZsb29ycmlnaHRiaWciLDg5NzEsImZsb29ycmlnaHRCaWciLDg5NzEsImZsb29ycmlnaHRCaWdnIiw4OTcxLCJmbG9vcnJpZ2h0YmlnZyIsODk3MSwiaGF0d2lkZSIsNzcwLCJoYXR3aWRlciIsNzcwLCJoYXR3aWRlc3QiLDc3MCwiaW50ZXJjYWwiLDc0ODgsImludGVncmFsZGlzcGxheSIsODc0NywiaW50ZWdyYWx0ZXh0Iiw4NzQ3LCJpbnRlcnNlY3Rpb25kaXNwbGF5Iiw4ODk4LCJpbnRlcnNlY3Rpb250ZXh0Iiw4ODk4LCJsb2dpY2FsYW5kZGlzcGxheSIsODc0MywibG9naWNhbGFuZHRleHQiLDg3NDMsImxvZ2ljYWxvcmRpc3BsYXkiLDg3NDQsImxvZ2ljYWxvcnRleHQiLDg3NDQsInBhcmVubGVmdEJpZyIsNDAsInBhcmVubGVmdGJpZyIsNDAsInBhcmVubGVmdEJpZ2ciLDQwLCJwYXJlbmxlZnRiaWdnIiw0MCwicGFyZW5yaWdodEJpZyIsNDEsInBhcmVucmlnaHRiaWciLDQxLCJwYXJlbnJpZ2h0QmlnZyIsNDEsInBhcmVucmlnaHRiaWdnIiw0MSwicHJpbWUiLDgyNDIsInByb2R1Y3RkaXNwbGF5Iiw4NzE5LCJwcm9kdWN0dGV4dCIsODcxOSwicmFkaWNhbGJpZyIsODczMCwicmFkaWNhbEJpZyIsODczMCwicmFkaWNhbEJpZ2ciLDg3MzAsInJhZGljYWxiaWdnIiw4NzMwLCJyYWRpY2FsYnQiLDg3MzAsInJhZGljYWx0cCIsODczMCwicmFkaWNhbHZlcnRleCIsODczMCwic2xhc2hiaWciLDQ3LCJzbGFzaEJpZyIsNDcsInNsYXNoQmlnZyIsNDcsInNsYXNoYmlnZyIsNDcsInN1bW1hdGlvbmRpc3BsYXkiLDg3MjEsInN1bW1hdGlvbnRleHQiLDg3MjEsInRpbGRld2lkZSIsNzMyLCJ0aWxkZXdpZGVyIiw3MzIsInRpbGRld2lkZXN0Iiw3MzIsInVuaW9uZGlzcGxheSIsODg5OSwidW5pb25tdWx0aWRpc3BsYXkiLDg4NDYsInVuaW9ubXVsdGl0ZXh0Iiw4ODQ2LCJ1bmlvbnNxZGlzcGxheSIsODg1MiwidW5pb25zcXRleHQiLDg4NTIsInVuaW9udGV4dCIsODg5OSwidmV4dGVuZGRvdWJsZSIsODc0MSwidmV4dGVuZHNpbmdsZSIsODczOV19KSksaT0oMCxyLmdldEFycmF5TG9va3VwVGFibGVGYWN0b3J5KSgoZnVuY3Rpb24oKXtyZXR1cm5bInNwYWNlIiwzMiwiYTEiLDk5ODUsImEyIiw5OTg2LCJhMjAyIiw5OTg3LCJhMyIsOTk4OCwiYTQiLDk3NDIsImE1Iiw5OTkwLCJhMTE5Iiw5OTkxLCJhMTE4Iiw5OTkyLCJhMTE3Iiw5OTkzLCJhMTEiLDk3NTUsImExMiIsOTc1OCwiYTEzIiw5OTk2LCJhMTQiLDk5OTcsImExNSIsOTk5OCwiYTE2Iiw5OTk5LCJhMTA1IiwxZTQsImExNyIsMTAwMDEsImExOCIsMTAwMDIsImExOSIsMTAwMDMsImEyMCIsMTAwMDQsImEyMSIsMTAwMDUsImEyMiIsMTAwMDYsImEyMyIsMTAwMDcsImEyNCIsMTAwMDgsImEyNSIsMTAwMDksImEyNiIsMTAwMTAsImEyNyIsMTAwMTEsImEyOCIsMTAwMTIsImE2IiwxMDAxMywiYTciLDEwMDE0LCJhOCIsMTAwMTUsImE5IiwxMDAxNiwiYTEwIiwxMDAxNywiYTI5IiwxMDAxOCwiYTMwIiwxMDAxOSwiYTMxIiwxMDAyMCwiYTMyIiwxMDAyMSwiYTMzIiwxMDAyMiwiYTM0IiwxMDAyMywiYTM1Iiw5NzMzLCJhMzYiLDEwMDI1LCJhMzciLDEwMDI2LCJhMzgiLDEwMDI3LCJhMzkiLDEwMDI4LCJhNDAiLDEwMDI5LCJhNDEiLDEwMDMwLCJhNDIiLDEwMDMxLCJhNDMiLDEwMDMyLCJhNDQiLDEwMDMzLCJhNDUiLDEwMDM0LCJhNDYiLDEwMDM1LCJhNDciLDEwMDM2LCJhNDgiLDEwMDM3LCJhNDkiLDEwMDM4LCJhNTAiLDEwMDM5LCJhNTEiLDEwMDQwLCJhNTIiLDEwMDQxLCJhNTMiLDEwMDQyLCJhNTQiLDEwMDQzLCJhNTUiLDEwMDQ0LCJhNTYiLDEwMDQ1LCJhNTciLDEwMDQ2LCJhNTgiLDEwMDQ3LCJhNTkiLDEwMDQ4LCJhNjAiLDEwMDQ5LCJhNjEiLDEwMDUwLCJhNjIiLDEwMDUxLCJhNjMiLDEwMDUyLCJhNjQiLDEwMDUzLCJhNjUiLDEwMDU0LCJhNjYiLDEwMDU1LCJhNjciLDEwMDU2LCJhNjgiLDEwMDU3LCJhNjkiLDEwMDU4LCJhNzAiLDEwMDU5LCJhNzEiLDk2NzksImE3MiIsMTAwNjEsImE3MyIsOTYzMiwiYTc0IiwxMDA2MywiYTIwMyIsMTAwNjQsImE3NSIsMTAwNjUsImEyMDQiLDEwMDY2LCJhNzYiLDk2NTAsImE3NyIsOTY2MCwiYTc4Iiw5NjcwLCJhNzkiLDEwMDcwLCJhODEiLDk2ODcsImE4MiIsMTAwNzIsImE4MyIsMTAwNzMsImE4NCIsMTAwNzQsImE5NyIsMTAwNzUsImE5OCIsMTAwNzYsImE5OSIsMTAwNzcsImExMDAiLDEwMDc4LCJhMTAxIiwxMDA4MSwiYTEwMiIsMTAwODIsImExMDMiLDEwMDgzLCJhMTA0IiwxMDA4NCwiYTEwNiIsMTAwODUsImExMDciLDEwMDg2LCJhMTA4IiwxMDA4NywiYTExMiIsOTgyNywiYTExMSIsOTgzMCwiYTExMCIsOTgyOSwiYTEwOSIsOTgyNCwiYTEyMCIsOTMxMiwiYTEyMSIsOTMxMywiYTEyMiIsOTMxNCwiYTEyMyIsOTMxNSwiYTEyNCIsOTMxNiwiYTEyNSIsOTMxNywiYTEyNiIsOTMxOCwiYTEyNyIsOTMxOSwiYTEyOCIsOTMyMCwiYTEyOSIsOTMyMSwiYTEzMCIsMTAxMDIsImExMzEiLDEwMTAzLCJhMTMyIiwxMDEwNCwiYTEzMyIsMTAxMDUsImExMzQiLDEwMTA2LCJhMTM1IiwxMDEwNywiYTEzNiIsMTAxMDgsImExMzciLDEwMTA5LCJhMTM4IiwxMDExMCwiYTEzOSIsMTAxMTEsImExNDAiLDEwMTEyLCJhMTQxIiwxMDExMywiYTE0MiIsMTAxMTQsImExNDMiLDEwMTE1LCJhMTQ0IiwxMDExNiwiYTE0NSIsMTAxMTcsImExNDYiLDEwMTE4LCJhMTQ3IiwxMDExOSwiYTE0OCIsMTAxMjAsImExNDkiLDEwMTIxLCJhMTUwIiwxMDEyMiwiYTE1MSIsMTAxMjMsImExNTIiLDEwMTI0LCJhMTUzIiwxMDEyNSwiYTE1NCIsMTAxMjYsImExNTUiLDEwMTI3LCJhMTU2IiwxMDEyOCwiYTE1NyIsMTAxMjksImExNTgiLDEwMTMwLCJhMTU5IiwxMDEzMSwiYTE2MCIsMTAxMzIsImExNjEiLDg1OTQsImExNjMiLDg1OTYsImExNjQiLDg1OTcsImExOTYiLDEwMTM2LCJhMTY1IiwxMDEzNywiYTE5MiIsMTAxMzgsImExNjYiLDEwMTM5LCJhMTY3IiwxMDE0MCwiYTE2OCIsMTAxNDEsImExNjkiLDEwMTQyLCJhMTcwIiwxMDE0MywiYTE3MSIsMTAxNDQsImExNzIiLDEwMTQ1LCJhMTczIiwxMDE0NiwiYTE2MiIsMTAxNDcsImExNzQiLDEwMTQ4LCJhMTc1IiwxMDE0OSwiYTE3NiIsMTAxNTAsImExNzciLDEwMTUxLCJhMTc4IiwxMDE1MiwiYTE3OSIsMTAxNTMsImExOTMiLDEwMTU0LCJhMTgwIiwxMDE1NSwiYTE5OSIsMTAxNTYsImExODEiLDEwMTU3LCJhMjAwIiwxMDE1OCwiYTE4MiIsMTAxNTksImEyMDEiLDEwMTYxLCJhMTgzIiwxMDE2MiwiYTE4NCIsMTAxNjMsImExOTciLDEwMTY0LCJhMTg1IiwxMDE2NSwiYTE5NCIsMTAxNjYsImExOTgiLDEwMTY3LCJhMTg2IiwxMDE2OCwiYTE5NSIsMTAxNjksImExODciLDEwMTcwLCJhMTg4IiwxMDE3MSwiYTE4OSIsMTAxNzIsImExOTAiLDEwMTczLCJhMTkxIiwxMDE3NCwiYTg5IiwxMDA4OCwiYTkwIiwxMDA4OSwiYTkzIiwxMDA5MCwiYTk0IiwxMDA5MSwiYTkxIiwxMDA5MiwiYTkyIiwxMDA5MywiYTIwNSIsMTAwOTQsImE4NSIsMTAwOTUsImEyMDYiLDEwMDk2LCJhODYiLDEwMDk3LCJhODciLDEwMDk4LCJhODgiLDEwMDk5LCJhOTUiLDEwMTAwLCJhOTYiLDEwMTAxLCIubm90ZGVmIiwwXX0pKX0sKGUsdCxhKT0+e2Eucih0KTthLmQodCx7Y2xlYXJVbmljb2RlQ2FjaGVzOigpPT5jbGVhclVuaWNvZGVDYWNoZXMsZ2V0Q2hhclVuaWNvZGVDYXRlZ29yeTooKT0+Z2V0Q2hhclVuaWNvZGVDYXRlZ29yeSxnZXROb3JtYWxpemVkVW5pY29kZXM6KCk9PnMsZ2V0VW5pY29kZUZvckdseXBoOigpPT5nZXRVbmljb2RlRm9yR2x5cGgsZ2V0VW5pY29kZVJhbmdlRm9yOigpPT5nZXRVbmljb2RlUmFuZ2VGb3IsbWFwU3BlY2lhbFVuaWNvZGVWYWx1ZXM6KCk9Pm1hcFNwZWNpYWxVbmljb2RlVmFsdWVzLHJldmVyc2VJZlJ0bDooKT0+cmV2ZXJzZUlmUnRsfSk7dmFyIHI9YSg2KTtjb25zdCBuPSgwLHIuZ2V0TG9va3VwVGFibGVGYWN0b3J5KSgoZnVuY3Rpb24oZSl7ZVs2MzcyMV09MTY5O2VbNjMxOTNdPTE2OTtlWzYzNzIwXT0xNzQ7ZVs2MzE5NF09MTc0O2VbNjM3MjJdPTg0ODI7ZVs2MzE5NV09ODQ4MjtlWzYzNzI5XT05MTI3O2VbNjM3MzBdPTkxMjg7ZVs2MzczMV09OTEyOTtlWzYzNzQwXT05MTMxO2VbNjM3NDFdPTkxMzI7ZVs2Mzc0Ml09OTEzMztlWzYzNzI2XT05MTIxO2VbNjM3MjddPTkxMjI7ZVs2MzcyOF09OTEyMztlWzYzNzM3XT05MTI0O2VbNjM3MzhdPTkxMjU7ZVs2MzczOV09OTEyNjtlWzYzNzIzXT05MTE1O2VbNjM3MjRdPTkxMTY7ZVs2MzcyNV09OTExNztlWzYzNzM0XT05MTE4O2VbNjM3MzVdPTkxMTk7ZVs2MzczNl09OTEyMH0pKTtmdW5jdGlvbiBtYXBTcGVjaWFsVW5pY29kZVZhbHVlcyhlKXtyZXR1cm4gZT49NjU1MjAmJmU8PTY1NTM1PzA6ZT49NjI5NzYmJmU8PTYzNzQzP24oKVtlXXx8ZToxNzM9PT1lPzQ1OmV9ZnVuY3Rpb24gZ2V0VW5pY29kZUZvckdseXBoKGUsdCl7bGV0IGE9dFtlXTtpZih2b2lkIDAhPT1hKXJldHVybiBhO2lmKCFlKXJldHVybi0xO2lmKCJ1Ij09PWVbMF0pe2NvbnN0IHQ9ZS5sZW5ndGg7bGV0IHI7aWYoNz09PXQmJiJuIj09PWVbMV0mJiJpIj09PWVbMl0pcj1lLnN1YnN0cmluZygzKTtlbHNle2lmKCEodD49NSYmdDw9NykpcmV0dXJuLTE7cj1lLnN1YnN0cmluZygxKX1pZihyPT09ci50b1VwcGVyQ2FzZSgpKXthPXBhcnNlSW50KHIsMTYpO2lmKGE+PTApcmV0dXJuIGF9fXJldHVybi0xfWNvbnN0IGk9W3tiZWdpbjowLGVuZDoxMjd9LHtiZWdpbjoxMjgsZW5kOjI1NX0se2JlZ2luOjI1NixlbmQ6MzgzfSx7YmVnaW46Mzg0LGVuZDo1OTF9LHtiZWdpbjo1OTIsZW5kOjY4N30se2JlZ2luOjY4OCxlbmQ6NzY3fSx7YmVnaW46NzY4LGVuZDo4Nzl9LHtiZWdpbjo4ODAsZW5kOjEwMjN9LHtiZWdpbjoxMTM5MixlbmQ6MTE1MTl9LHtiZWdpbjoxMDI0LGVuZDoxMjc5fSx7YmVnaW46MTMyOCxlbmQ6MTQyM30se2JlZ2luOjE0MjQsZW5kOjE1MzV9LHtiZWdpbjo0MjI0MCxlbmQ6NDI1NTl9LHtiZWdpbjoxNTM2LGVuZDoxNzkxfSx7YmVnaW46MTk4NCxlbmQ6MjA0N30se2JlZ2luOjIzMDQsZW5kOjI0MzF9LHtiZWdpbjoyNDMyLGVuZDoyNTU5fSx7YmVnaW46MjU2MCxlbmQ6MjY4N30se2JlZ2luOjI2ODgsZW5kOjI4MTV9LHtiZWdpbjoyODE2LGVuZDoyOTQzfSx7YmVnaW46Mjk0NCxlbmQ6MzA3MX0se2JlZ2luOjMwNzIsZW5kOjMxOTl9LHtiZWdpbjozMjAwLGVuZDozMzI3fSx7YmVnaW46MzMyOCxlbmQ6MzQ1NX0se2JlZ2luOjM1ODQsZW5kOjM3MTF9LHtiZWdpbjozNzEyLGVuZDozODM5fSx7YmVnaW46NDI1NixlbmQ6NDM1MX0se2JlZ2luOjY5MTIsZW5kOjcwMzl9LHtiZWdpbjo0MzUyLGVuZDo0NjA3fSx7YmVnaW46NzY4MCxlbmQ6NzkzNX0se2JlZ2luOjc5MzYsZW5kOjgxOTF9LHtiZWdpbjo4MTkyLGVuZDo4MzAzfSx7YmVnaW46ODMwNCxlbmQ6ODM1MX0se2JlZ2luOjgzNTIsZW5kOjgzOTl9LHtiZWdpbjo4NDAwLGVuZDo4NDQ3fSx7YmVnaW46ODQ0OCxlbmQ6ODUyN30se2JlZ2luOjg1MjgsZW5kOjg1OTF9LHtiZWdpbjo4NTkyLGVuZDo4NzAzfSx7YmVnaW46ODcwNCxlbmQ6ODk1OX0se2JlZ2luOjg5NjAsZW5kOjkyMTV9LHtiZWdpbjo5MjE2LGVuZDo5Mjc5fSx7YmVnaW46OTI4MCxlbmQ6OTMxMX0se2JlZ2luOjkzMTIsZW5kOjk0NzF9LHtiZWdpbjo5NDcyLGVuZDo5NTk5fSx7YmVnaW46OTYwMCxlbmQ6OTYzMX0se2JlZ2luOjk2MzIsZW5kOjk3Mjd9LHtiZWdpbjo5NzI4LGVuZDo5OTgzfSx7YmVnaW46OTk4NCxlbmQ6MTAxNzV9LHtiZWdpbjoxMjI4OCxlbmQ6MTIzNTF9LHtiZWdpbjoxMjM1MixlbmQ6MTI0NDd9LHtiZWdpbjoxMjQ0OCxlbmQ6MTI1NDN9LHtiZWdpbjoxMjU0NCxlbmQ6MTI1OTF9LHtiZWdpbjoxMjU5MixlbmQ6MTI2ODd9LHtiZWdpbjo0MzA3MixlbmQ6NDMxMzV9LHtiZWdpbjoxMjgwMCxlbmQ6MTMwNTV9LHtiZWdpbjoxMzA1NixlbmQ6MTMzMTF9LHtiZWdpbjo0NDAzMixlbmQ6NTUyMTV9LHtiZWdpbjo1NTI5NixlbmQ6NTczNDN9LHtiZWdpbjo2Nzg0MCxlbmQ6Njc4NzF9LHtiZWdpbjoxOTk2OCxlbmQ6NDA5NTl9LHtiZWdpbjo1NzM0NCxlbmQ6NjM3NDN9LHtiZWdpbjoxMjczNixlbmQ6MTI3ODN9LHtiZWdpbjo2NDI1NixlbmQ6NjQzMzV9LHtiZWdpbjo2NDMzNixlbmQ6NjUwMjN9LHtiZWdpbjo2NTA1NixlbmQ6NjUwNzF9LHtiZWdpbjo2NTA0MCxlbmQ6NjUwNTV9LHtiZWdpbjo2NTEwNCxlbmQ6NjUxMzV9LHtiZWdpbjo2NTEzNixlbmQ6NjUyNzl9LHtiZWdpbjo2NTI4MCxlbmQ6NjU1MTl9LHtiZWdpbjo2NTUyMCxlbmQ6NjU1MzV9LHtiZWdpbjozODQwLGVuZDo0MDk1fSx7YmVnaW46MTc5MixlbmQ6MTg3MX0se2JlZ2luOjE5MjAsZW5kOjE5ODN9LHtiZWdpbjozNDU2LGVuZDozNTgzfSx7YmVnaW46NDA5NixlbmQ6NDI1NX0se2JlZ2luOjQ2MDgsZW5kOjQ5OTF9LHtiZWdpbjo1MDI0LGVuZDo1MTE5fSx7YmVnaW46NTEyMCxlbmQ6NTc1OX0se2JlZ2luOjU3NjAsZW5kOjU3OTF9LHtiZWdpbjo1NzkyLGVuZDo1ODg3fSx7YmVnaW46NjAxNixlbmQ6NjE0M30se2JlZ2luOjYxNDQsZW5kOjYzMTl9LHtiZWdpbjoxMDI0MCxlbmQ6MTA0OTV9LHtiZWdpbjo0MDk2MCxlbmQ6NDIxMjd9LHtiZWdpbjo1ODg4LGVuZDo1OTE5fSx7YmVnaW46NjYzMDQsZW5kOjY2MzUxfSx7YmVnaW46NjYzNTIsZW5kOjY2MzgzfSx7YmVnaW46NjY1NjAsZW5kOjY2NjM5fSx7YmVnaW46MTE4Nzg0LGVuZDoxMTkwMzl9LHtiZWdpbjoxMTk4MDgsZW5kOjEyMDgzMX0se2JlZ2luOjEwNDQ0ODAsZW5kOjEwNDg1NzN9LHtiZWdpbjo2NTAyNCxlbmQ6NjUwMzl9LHtiZWdpbjo5MTc1MDQsZW5kOjkxNzYzMX0se2JlZ2luOjY0MDAsZW5kOjY0Nzl9LHtiZWdpbjo2NDgwLGVuZDo2NTI3fSx7YmVnaW46NjUyOCxlbmQ6NjYyM30se2JlZ2luOjY2NTYsZW5kOjY2ODd9LHtiZWdpbjoxMTI2NCxlbmQ6MTEzNTl9LHtiZWdpbjoxMTU2OCxlbmQ6MTE2NDd9LHtiZWdpbjoxOTkwNCxlbmQ6MTk5Njd9LHtiZWdpbjo0MzAwOCxlbmQ6NDMwNTV9LHtiZWdpbjo2NTUzNixlbmQ6NjU2NjN9LHtiZWdpbjo2NTg1NixlbmQ6NjU5MzV9LHtiZWdpbjo2NjQzMixlbmQ6NjY0NjN9LHtiZWdpbjo2NjQ2NCxlbmQ6NjY1Mjd9LHtiZWdpbjo2NjY0MCxlbmQ6NjY2ODd9LHtiZWdpbjo2NjY4OCxlbmQ6NjY3MzV9LHtiZWdpbjo2NzU4NCxlbmQ6Njc2NDd9LHtiZWdpbjo2ODA5NixlbmQ6NjgxOTF9LHtiZWdpbjoxMTk1NTIsZW5kOjExOTY0N30se2JlZ2luOjczNzI4LGVuZDo3NDc1MX0se2JlZ2luOjExOTY0OCxlbmQ6MTE5Njc5fSx7YmVnaW46NzA0MCxlbmQ6NzEwM30se2JlZ2luOjcxNjgsZW5kOjcyNDd9LHtiZWdpbjo3MjQ4LGVuZDo3Mjk1fSx7YmVnaW46NDMxMzYsZW5kOjQzMjMxfSx7YmVnaW46NDMyNjQsZW5kOjQzMzExfSx7YmVnaW46NDMzMTIsZW5kOjQzMzU5fSx7YmVnaW46NDM1MjAsZW5kOjQzNjE1fSx7YmVnaW46NjU5MzYsZW5kOjY1OTk5fSx7YmVnaW46NjZlMyxlbmQ6NjYwNDd9LHtiZWdpbjo2NjIwOCxlbmQ6NjYyNzF9LHtiZWdpbjoxMjcwMjQsZW5kOjEyNzEzNX1dO2Z1bmN0aW9uIGdldFVuaWNvZGVSYW5nZUZvcihlKXtmb3IobGV0IHQ9MCxhPWkubGVuZ3RoO3Q8YTt0Kyspe2NvbnN0IGE9aVt0XTtpZihlPj1hLmJlZ2luJiZlPGEuZW5kKXJldHVybiB0fXJldHVybi0xfWNvbnN0IHM9KDAsci5nZXRBcnJheUxvb2t1cFRhYmxlRmFjdG9yeSkoKGZ1bmN0aW9uKCl7cmV0dXJuWyLCqCIsIiDMiCIsIsKvIiwiIMyEIiwiwrQiLCIgzIEiLCLCtSIsIs68IiwiwrgiLCIgzKciLCLEsiIsIklKIiwixLMiLCJpaiIsIsS/IiwiTMK3IiwixYAiLCJswrciLCLFiSIsIsq8biIsIsW/IiwicyIsIseEIiwiRMW9Iiwix4UiLCJExb4iLCLHhiIsImTFviIsIseHIiwiTEoiLCLHiCIsIkxqIiwix4kiLCJsaiIsIseKIiwiTkoiLCLHiyIsIk5qIiwix4wiLCJuaiIsIsexIiwiRFoiLCLHsiIsIkR6Iiwix7MiLCJkeiIsIsuYIiwiIMyGIiwiy5kiLCIgzIciLCLLmiIsIiDMiiIsIsubIiwiIMyoIiwiy5wiLCIgzIMiLCLLnSIsIiDMiyIsIs26IiwiIM2FIiwizoQiLCIgzIEiLCLPkCIsIs6yIiwiz5EiLCLOuCIsIs+SIiwizqUiLCLPlSIsIs+GIiwiz5YiLCLPgCIsIs+wIiwizroiLCLPsSIsIs+BIiwiz7IiLCLPgiIsIs+0IiwizpgiLCLPtSIsIs61Iiwiz7kiLCLOoyIsItaHIiwi1aXWgiIsItm1Iiwi2KfZtCIsItm2Iiwi2YjZtCIsItm3Iiwi24fZtCIsItm4Iiwi2YrZtCIsIuC4syIsIuC5jeC4siIsIuC6syIsIuC7jeC6siIsIuC7nCIsIuC6q+C6mSIsIuC7nSIsIuC6q+C6oSIsIuC9tyIsIuC+suC+gSIsIuC9uSIsIuC+s+C+gSIsIuG6miIsImHKviIsIuG+vSIsIiDMkyIsIuG+vyIsIiDMkyIsIuG/gCIsIiDNgiIsIuG/viIsIiDMlCIsIuKAgiIsIiAiLCLigIMiLCIgIiwi4oCEIiwiICIsIuKAhSIsIiAiLCLigIYiLCIgIiwi4oCIIiwiICIsIuKAiSIsIiAiLCLigIoiLCIgIiwi4oCXIiwiIMyzIiwi4oCkIiwiLiIsIuKApSIsIi4uIiwi4oCmIiwiLi4uIiwi4oCzIiwi4oCy4oCyIiwi4oC0Iiwi4oCy4oCy4oCyIiwi4oC2Iiwi4oC14oC1Iiwi4oC3Iiwi4oC14oC14oC1Iiwi4oC8IiwiISEiLCLigL4iLCIgzIUiLCLigYciLCI/PyIsIuKBiCIsIj8hIiwi4oGJIiwiIT8iLCLigZciLCLigLLigLLigLLigLIiLCLigZ8iLCIgIiwi4oKoIiwiUnMiLCLihIAiLCJhL2MiLCLihIEiLCJhL3MiLCLihIMiLCLCsEMiLCLihIUiLCJjL28iLCLihIYiLCJjL3UiLCLihIciLCLGkCIsIuKEiSIsIsKwRiIsIuKEliIsIk5vIiwi4oShIiwiVEVMIiwi4oS1Iiwi15AiLCLihLYiLCLXkSIsIuKEtyIsIteSIiwi4oS4Iiwi15MiLCLihLsiLCJGQVgiLCLihaAiLCJJIiwi4oWhIiwiSUkiLCLihaIiLCJJSUkiLCLihaMiLCJJViIsIuKFpCIsIlYiLCLihaUiLCJWSSIsIuKFpiIsIlZJSSIsIuKFpyIsIlZJSUkiLCLihagiLCJJWCIsIuKFqSIsIlgiLCLihaoiLCJYSSIsIuKFqyIsIlhJSSIsIuKFrCIsIkwiLCLiha0iLCJDIiwi4oWuIiwiRCIsIuKFryIsIk0iLCLihbAiLCJpIiwi4oWxIiwiaWkiLCLihbIiLCJpaWkiLCLihbMiLCJpdiIsIuKFtCIsInYiLCLihbUiLCJ2aSIsIuKFtiIsInZpaSIsIuKFtyIsInZpaWkiLCLihbgiLCJpeCIsIuKFuSIsIngiLCLihboiLCJ4aSIsIuKFuyIsInhpaSIsIuKFvCIsImwiLCLihb0iLCJjIiwi4oW+IiwiZCIsIuKFvyIsIm0iLCLiiKwiLCLiiKviiKsiLCLiiK0iLCLiiKviiKviiKsiLCLiiK8iLCLiiK7iiK4iLCLiiLAiLCLiiK7iiK7iiK4iLCLikbQiLCIoMSkiLCLikbUiLCIoMikiLCLikbYiLCIoMykiLCLikbciLCIoNCkiLCLikbgiLCIoNSkiLCLikbkiLCIoNikiLCLikboiLCIoNykiLCLikbsiLCIoOCkiLCLikbwiLCIoOSkiLCLikb0iLCIoMTApIiwi4pG+IiwiKDExKSIsIuKRvyIsIigxMikiLCLikoAiLCIoMTMpIiwi4pKBIiwiKDE0KSIsIuKSgiIsIigxNSkiLCLikoMiLCIoMTYpIiwi4pKEIiwiKDE3KSIsIuKShSIsIigxOCkiLCLikoYiLCIoMTkpIiwi4pKHIiwiKDIwKSIsIuKSiCIsIjEuIiwi4pKJIiwiMi4iLCLikooiLCIzLiIsIuKSiyIsIjQuIiwi4pKMIiwiNS4iLCLiko0iLCI2LiIsIuKSjiIsIjcuIiwi4pKPIiwiOC4iLCLikpAiLCI5LiIsIuKSkSIsIjEwLiIsIuKSkiIsIjExLiIsIuKSkyIsIjEyLiIsIuKSlCIsIjEzLiIsIuKSlSIsIjE0LiIsIuKSliIsIjE1LiIsIuKSlyIsIjE2LiIsIuKSmCIsIjE3LiIsIuKSmSIsIjE4LiIsIuKSmiIsIjE5LiIsIuKSmyIsIjIwLiIsIuKSnCIsIihhKSIsIuKSnSIsIihiKSIsIuKSniIsIihjKSIsIuKSnyIsIihkKSIsIuKSoCIsIihlKSIsIuKSoSIsIihmKSIsIuKSoiIsIihnKSIsIuKSoyIsIihoKSIsIuKSpCIsIihpKSIsIuKSpSIsIihqKSIsIuKSpiIsIihrKSIsIuKSpyIsIihsKSIsIuKSqCIsIihtKSIsIuKSqSIsIihuKSIsIuKSqiIsIihvKSIsIuKSqyIsIihwKSIsIuKSrCIsIihxKSIsIuKSrSIsIihyKSIsIuKSriIsIihzKSIsIuKSryIsIih0KSIsIuKSsCIsIih1KSIsIuKSsSIsIih2KSIsIuKSsiIsIih3KSIsIuKSsyIsIih4KSIsIuKStCIsIih5KSIsIuKStSIsIih6KSIsIuKojCIsIuKIq+KIq+KIq+KIqyIsIuKptCIsIjo6PSIsIuKptSIsIj09Iiwi4qm2IiwiPT09Iiwi4rqfIiwi5q+NIiwi4ruzIiwi6b6fIiwi4ryAIiwi5LiAIiwi4ryBIiwi5LioIiwi4ryCIiwi5Li2Iiwi4ryDIiwi5Li/Iiwi4ryEIiwi5LmZIiwi4ryFIiwi5LqFIiwi4ryGIiwi5LqMIiwi4ryHIiwi5LqgIiwi4ryIIiwi5Lq6Iiwi4ryJIiwi5YS/Iiwi4ryKIiwi5YWlIiwi4ryLIiwi5YWrIiwi4ryMIiwi5YaCIiwi4ryNIiwi5YaWIiwi4ryOIiwi5YarIiwi4ryPIiwi5YegIiwi4ryQIiwi5Ye1Iiwi4ryRIiwi5YiAIiwi4rySIiwi5YqbIiwi4ryTIiwi5Yu5Iiwi4ryUIiwi5YyVIiwi4ryVIiwi5YyaIiwi4ryWIiwi5Yy4Iiwi4ryXIiwi5Y2BIiwi4ryYIiwi5Y2cIiwi4ryZIiwi5Y2pIiwi4ryaIiwi5Y6CIiwi4rybIiwi5Y62Iiwi4rycIiwi5Y+IIiwi4rydIiwi5Y+jIiwi4ryeIiwi5ZuXIiwi4ryfIiwi5ZyfIiwi4rygIiwi5aOrIiwi4ryhIiwi5aSCIiwi4ryiIiwi5aSKIiwi4ryjIiwi5aSVIiwi4rykIiwi5aSnIiwi4rylIiwi5aWzIiwi4rymIiwi5a2QIiwi4rynIiwi5a6AIiwi4ryoIiwi5a+4Iiwi4rypIiwi5bCPIiwi4ryqIiwi5bCiIiwi4ryrIiwi5bC4Iiwi4rysIiwi5bGuIiwi4rytIiwi5bGxIiwi4ryuIiwi5bebIiwi4ryvIiwi5belIiwi4rywIiwi5bexIiwi4ryxIiwi5be+Iiwi4ryyIiwi5bmyIiwi4ryzIiwi5bm6Iiwi4ry0Iiwi5bm/Iiwi4ry1Iiwi5bu0Iiwi4ry2Iiwi5bu+Iiwi4ry3Iiwi5byLIiwi4ry4Iiwi5byTIiwi4ry5Iiwi5b2QIiwi4ry6Iiwi5b2hIiwi4ry7Iiwi5b2zIiwi4ry8Iiwi5b+DIiwi4ry9Iiwi5oiIIiwi4ry+Iiwi5oi2Iiwi4ry/Iiwi5omLIiwi4r2AIiwi5pSvIiwi4r2BIiwi5pS0Iiwi4r2CIiwi5paHIiwi4r2DIiwi5paXIiwi4r2EIiwi5pakIiwi4r2FIiwi5pa5Iiwi4r2GIiwi5pegIiwi4r2HIiwi5pelIiwi4r2IIiwi5puwIiwi4r2JIiwi5pyIIiwi4r2KIiwi5pyoIiwi4r2LIiwi5qygIiwi4r2MIiwi5q2iIiwi4r2NIiwi5q25Iiwi4r2OIiwi5q6zIiwi4r2PIiwi5q+LIiwi4r2QIiwi5q+UIiwi4r2RIiwi5q+bIiwi4r2SIiwi5rCPIiwi4r2TIiwi5rCUIiwi4r2UIiwi5rC0Iiwi4r2VIiwi54GrIiwi4r2WIiwi54iqIiwi4r2XIiwi54i2Iiwi4r2YIiwi54i7Iiwi4r2ZIiwi54i/Iiwi4r2aIiwi54mHIiwi4r2bIiwi54mZIiwi4r2cIiwi54mbIiwi4r2dIiwi54qsIiwi4r2eIiwi546EIiwi4r2fIiwi546JIiwi4r2gIiwi55OcIiwi4r2hIiwi55OmIiwi4r2iIiwi55SYIiwi4r2jIiwi55SfIiwi4r2kIiwi55SoIiwi4r2lIiwi55SwIiwi4r2mIiwi55aLIiwi4r2nIiwi55aSIiwi4r2oIiwi55m2Iiwi4r2pIiwi55m9Iiwi4r2qIiwi55quIiwi4r2rIiwi55q/Iiwi4r2sIiwi55uuIiwi4r2tIiwi55+bIiwi4r2uIiwi55+iIiwi4r2vIiwi55+zIiwi4r2wIiwi56S6Iiwi4r2xIiwi56a4Iiwi4r2yIiwi56a+Iiwi4r2zIiwi56m0Iiwi4r20Iiwi56uLIiwi4r21Iiwi56u5Iiwi4r22Iiwi57GzIiwi4r23Iiwi57O4Iiwi4r24Iiwi57y2Iiwi4r25Iiwi572RIiwi4r26Iiwi576KIiwi4r27Iiwi5769Iiwi4r28Iiwi6ICBIiwi4r29Iiwi6ICMIiwi4r2+Iiwi6ICSIiwi4r2/Iiwi6ICzIiwi4r6AIiwi6IG/Iiwi4r6BIiwi6IKJIiwi4r6CIiwi6IejIiwi4r6DIiwi6IeqIiwi4r6EIiwi6IezIiwi4r6FIiwi6Ie8Iiwi4r6GIiwi6IiMIiwi4r6HIiwi6IibIiwi4r6IIiwi6IifIiwi4r6JIiwi6ImuIiwi4r6KIiwi6ImyIiwi4r6LIiwi6Im4Iiwi4r6MIiwi6JmNIiwi4r6NIiwi6JmrIiwi4r6OIiwi6KGAIiwi4r6PIiwi6KGMIiwi4r6QIiwi6KGjIiwi4r6RIiwi6KW+Iiwi4r6SIiwi6KaLIiwi4r6TIiwi6KeSIiwi4r6UIiwi6KiAIiwi4r6VIiwi6LC3Iiwi4r6WIiwi6LGGIiwi4r6XIiwi6LGVIiwi4r6YIiwi6LG4Iiwi4r6ZIiwi6LKdIiwi4r6aIiwi6LWkIiwi4r6bIiwi6LWwIiwi4r6cIiwi6LazIiwi4r6dIiwi6LqrIiwi4r6eIiwi6LuKIiwi4r6fIiwi6L6bIiwi4r6gIiwi6L6wIiwi4r6hIiwi6L61Iiwi4r6iIiwi6YKRIiwi4r6jIiwi6YWJIiwi4r6kIiwi6YeGIiwi4r6lIiwi6YeMIiwi4r6mIiwi6YeRIiwi4r6nIiwi6ZW3Iiwi4r6oIiwi6ZaAIiwi4r6pIiwi6ZicIiwi4r6qIiwi6Zq2Iiwi4r6rIiwi6Zq5Iiwi4r6sIiwi6ZuoIiwi4r6tIiwi6Z2RIiwi4r6uIiwi6Z2eIiwi4r6vIiwi6Z2iIiwi4r6wIiwi6Z2pIiwi4r6xIiwi6Z+LIiwi4r6yIiwi6Z+tIiwi4r6zIiwi6Z+zIiwi4r60Iiwi6aCBIiwi4r61Iiwi6aKoIiwi4r62Iiwi6aObIiwi4r63Iiwi6aOfIiwi4r64Iiwi6aaWIiwi4r65Iiwi6aaZIiwi4r66Iiwi6aasIiwi4r67Iiwi6aqoIiwi4r68Iiwi6auYIiwi4r69Iiwi6aufIiwi4r6+Iiwi6aylIiwi4r6/Iiwi6ayvIiwi4r+AIiwi6ayyIiwi4r+BIiwi6ay8Iiwi4r+CIiwi6a2aIiwi4r+DIiwi6bOlIiwi4r+EIiwi6bm1Iiwi4r+FIiwi6bm/Iiwi4r+GIiwi6bqlIiwi4r+HIiwi6bq7Iiwi4r+IIiwi6buDIiwi4r+JIiwi6buNIiwi4r+KIiwi6buRIiwi4r+LIiwi6bu5Iiwi4r+MIiwi6bu9Iiwi4r+NIiwi6byOIiwi4r+OIiwi6byTIiwi4r+PIiwi6bygIiwi4r+QIiwi6by7Iiwi4r+RIiwi6b2KIiwi4r+SIiwi6b2SIiwi4r+TIiwi6b6NIiwi4r+UIiwi6b6cIiwi4r+VIiwi6b6gIiwi44C2Iiwi44CSIiwi44C4Iiwi5Y2BIiwi44C5Iiwi5Y2EIiwi44C6Iiwi5Y2FIiwi44KbIiwiIOOCmSIsIuOCnCIsIiDjgpoiLCLjhLEiLCLhhIAiLCLjhLIiLCLhhIEiLCLjhLMiLCLhhqoiLCLjhLQiLCLhhIIiLCLjhLUiLCLhhqwiLCLjhLYiLCLhhq0iLCLjhLciLCLhhIMiLCLjhLgiLCLhhIQiLCLjhLkiLCLhhIUiLCLjhLoiLCLhhrAiLCLjhLsiLCLhhrEiLCLjhLwiLCLhhrIiLCLjhL0iLCLhhrMiLCLjhL4iLCLhhrQiLCLjhL8iLCLhhrUiLCLjhYAiLCLhhJoiLCLjhYEiLCLhhIYiLCLjhYIiLCLhhIciLCLjhYMiLCLhhIgiLCLjhYQiLCLhhKEiLCLjhYUiLCLhhIkiLCLjhYYiLCLhhIoiLCLjhYciLCLhhIsiLCLjhYgiLCLhhIwiLCLjhYkiLCLhhI0iLCLjhYoiLCLhhI4iLCLjhYsiLCLhhI8iLCLjhYwiLCLhhJAiLCLjhY0iLCLhhJEiLCLjhY4iLCLhhJIiLCLjhY8iLCLhhaEiLCLjhZAiLCLhhaIiLCLjhZEiLCLhhaMiLCLjhZIiLCLhhaQiLCLjhZMiLCLhhaUiLCLjhZQiLCLhhaYiLCLjhZUiLCLhhaciLCLjhZYiLCLhhagiLCLjhZciLCLhhakiLCLjhZgiLCLhhaoiLCLjhZkiLCLhhasiLCLjhZoiLCLhhawiLCLjhZsiLCLhha0iLCLjhZwiLCLhha4iLCLjhZ0iLCLhha8iLCLjhZ4iLCLhhbAiLCLjhZ8iLCLhhbEiLCLjhaAiLCLhhbIiLCLjhaEiLCLhhbMiLCLjhaIiLCLhhbQiLCLjhaMiLCLhhbUiLCLjhaQiLCLhhaAiLCLjhaUiLCLhhJQiLCLjhaYiLCLhhJUiLCLjhaciLCLhh4ciLCLjhagiLCLhh4giLCLjhakiLCLhh4wiLCLjhaoiLCLhh44iLCLjhasiLCLhh5MiLCLjhawiLCLhh5ciLCLjha0iLCLhh5kiLCLjha4iLCLhhJwiLCLjha8iLCLhh50iLCLjhbAiLCLhh58iLCLjhbEiLCLhhJ0iLCLjhbIiLCLhhJ4iLCLjhbMiLCLhhKAiLCLjhbQiLCLhhKIiLCLjhbUiLCLhhKMiLCLjhbYiLCLhhKciLCLjhbciLCLhhKkiLCLjhbgiLCLhhKsiLCLjhbkiLCLhhKwiLCLjhboiLCLhhK0iLCLjhbsiLCLhhK4iLCLjhbwiLCLhhK8iLCLjhb0iLCLhhLIiLCLjhb4iLCLhhLYiLCLjhb8iLCLhhYAiLCLjhoAiLCLhhYciLCLjhoEiLCLhhYwiLCLjhoIiLCLhh7EiLCLjhoMiLCLhh7IiLCLjhoQiLCLhhZciLCLjhoUiLCLhhZgiLCLjhoYiLCLhhZkiLCLjhociLCLhhoQiLCLjhogiLCLhhoUiLCLjhokiLCLhhogiLCLjhooiLCLhhpEiLCLjhosiLCLhhpIiLCLjhowiLCLhhpQiLCLjho0iLCLhhp4iLCLjho4iLCLhhqEiLCLjiIAiLCIo4YSAKSIsIuOIgSIsIijhhIIpIiwi44iCIiwiKOGEgykiLCLjiIMiLCIo4YSFKSIsIuOIhCIsIijhhIYpIiwi44iFIiwiKOGEhykiLCLjiIYiLCIo4YSJKSIsIuOIhyIsIijhhIspIiwi44iIIiwiKOGEjCkiLCLjiIkiLCIo4YSOKSIsIuOIiiIsIijhhI8pIiwi44iLIiwiKOGEkCkiLCLjiIwiLCIo4YSRKSIsIuOIjSIsIijhhJIpIiwi44iOIiwiKOGEgOGFoSkiLCLjiI8iLCIo4YSC4YWhKSIsIuOIkCIsIijhhIPhhaEpIiwi44iRIiwiKOGEheGFoSkiLCLjiJIiLCIo4YSG4YWhKSIsIuOIkyIsIijhhIfhhaEpIiwi44iUIiwiKOGEieGFoSkiLCLjiJUiLCIo4YSL4YWhKSIsIuOIliIsIijhhIzhhaEpIiwi44iXIiwiKOGEjuGFoSkiLCLjiJgiLCIo4YSP4YWhKSIsIuOImSIsIijhhJDhhaEpIiwi44iaIiwiKOGEkeGFoSkiLCLjiJsiLCIo4YSS4YWhKSIsIuOInCIsIijhhIzhha4pIiwi44idIiwiKOGEi+GFqeGEjOGFpeGGqykiLCLjiJ4iLCIo4YSL4YWp4YSS4YWuKSIsIuOIoCIsIijkuIApIiwi44ihIiwiKOS6jCkiLCLjiKIiLCIo5LiJKSIsIuOIoyIsIijlm5spIiwi44ikIiwiKOS6lCkiLCLjiKUiLCIo5YWtKSIsIuOIpiIsIijkuIMpIiwi44inIiwiKOWFqykiLCLjiKgiLCIo5LmdKSIsIuOIqSIsIijljYEpIiwi44iqIiwiKOaciCkiLCLjiKsiLCIo54GrKSIsIuOIrCIsIijmsLQpIiwi44itIiwiKOacqCkiLCLjiK4iLCIo6YeRKSIsIuOIryIsIijlnJ8pIiwi44iwIiwiKOaXpSkiLCLjiLEiLCIo5qCqKSIsIuOIsiIsIijmnIkpIiwi44izIiwiKOekvikiLCLjiLQiLCIo5ZCNKSIsIuOItSIsIijnibkpIiwi44i2IiwiKOiyoSkiLCLjiLciLCIo56WdKSIsIuOIuCIsIijlirQpIiwi44i5IiwiKOS7oykiLCLjiLoiLCIo5ZG8KSIsIuOIuyIsIijlraYpIiwi44i8IiwiKOeboykiLCLjiL0iLCIo5LyBKSIsIuOIviIsIijos4cpIiwi44i/IiwiKOWNlCkiLCLjiYAiLCIo56WtKSIsIuOJgSIsIijkvJEpIiwi44mCIiwiKOiHqikiLCLjiYMiLCIo6IezKSIsIuOLgCIsIjHmnIgiLCLji4EiLCIy5pyIIiwi44uCIiwiM+aciCIsIuOLgyIsIjTmnIgiLCLji4QiLCI15pyIIiwi44uFIiwiNuaciCIsIuOLhiIsIjfmnIgiLCLji4ciLCI45pyIIiwi44uIIiwiOeaciCIsIuOLiSIsIjEw5pyIIiwi44uKIiwiMTHmnIgiLCLji4siLCIxMuaciCIsIuONmCIsIjDngrkiLCLjjZkiLCIx54K5Iiwi442aIiwiMueCuSIsIuONmyIsIjPngrkiLCLjjZwiLCI054K5Iiwi442dIiwiNeeCuSIsIuONniIsIjbngrkiLCLjjZ8iLCI354K5Iiwi442gIiwiOOeCuSIsIuONoSIsIjnngrkiLCLjjaIiLCIxMOeCuSIsIuONoyIsIjEx54K5Iiwi442kIiwiMTLngrkiLCLjjaUiLCIxM+eCuSIsIuONpiIsIjE054K5Iiwi442nIiwiMTXngrkiLCLjjagiLCIxNueCuSIsIuONqSIsIjE354K5Iiwi442qIiwiMTjngrkiLCLjjasiLCIxOeeCuSIsIuONrCIsIjIw54K5Iiwi442tIiwiMjHngrkiLCLjja4iLCIyMueCuSIsIuONryIsIjIz54K5Iiwi442wIiwiMjTngrkiLCLjj6AiLCIx5pelIiwi44+hIiwiMuaXpSIsIuOPoiIsIjPml6UiLCLjj6MiLCI05pelIiwi44+kIiwiNeaXpSIsIuOPpSIsIjbml6UiLCLjj6YiLCI35pelIiwi44+nIiwiOOaXpSIsIuOPqCIsIjnml6UiLCLjj6kiLCIxMOaXpSIsIuOPqiIsIjEx5pelIiwi44+rIiwiMTLml6UiLCLjj6wiLCIxM+aXpSIsIuOPrSIsIjE05pelIiwi44+uIiwiMTXml6UiLCLjj68iLCIxNuaXpSIsIuOPsCIsIjE35pelIiwi44+xIiwiMTjml6UiLCLjj7IiLCIxOeaXpSIsIuOPsyIsIjIw5pelIiwi44+0IiwiMjHml6UiLCLjj7UiLCIyMuaXpSIsIuOPtiIsIjIz5pelIiwi44+3IiwiMjTml6UiLCLjj7giLCIyNeaXpSIsIuOPuSIsIjI25pelIiwi44+6IiwiMjfml6UiLCLjj7siLCIyOOaXpSIsIuOPvCIsIjI55pelIiwi44+9IiwiMzDml6UiLCLjj74iLCIzMeaXpSIsIu+sgCIsImZmIiwi76yBIiwiZmkiLCLvrIIiLCJmbCIsIu+sgyIsImZmaSIsIu+shCIsImZmbCIsIu+shSIsIsW/dCIsIu+shiIsInN0Iiwi76yTIiwi1bTVtiIsIu+slCIsItW01aUiLCLvrJUiLCLVtNWrIiwi76yWIiwi1b7VtiIsIu+slyIsItW01a0iLCLvrY8iLCLXkNecIiwi762QIiwi2bEiLCLvrZEiLCLZsSIsIu+tkiIsItm7Iiwi762TIiwi2bsiLCLvrZQiLCLZuyIsIu+tlSIsItm7Iiwi762WIiwi2b4iLCLvrZciLCLZviIsIu+tmCIsItm+Iiwi762ZIiwi2b4iLCLvrZoiLCLagCIsIu+tmyIsItqAIiwi762cIiwi2oAiLCLvrZ0iLCLagCIsIu+tniIsItm6Iiwi762fIiwi2boiLCLvraAiLCLZuiIsIu+toSIsItm6Iiwi762iIiwi2b8iLCLvraMiLCLZvyIsIu+tpCIsItm/Iiwi762lIiwi2b8iLCLvraYiLCLZuSIsIu+tpyIsItm5Iiwi762oIiwi2bkiLCLvrakiLCLZuSIsIu+tqiIsItqkIiwi762rIiwi2qQiLCLvrawiLCLapCIsIu+trSIsItqkIiwi762uIiwi2qYiLCLvra8iLCLapiIsIu+tsCIsItqmIiwi762xIiwi2qYiLCLvrbIiLCLahCIsIu+tsyIsItqEIiwi7620Iiwi2oQiLCLvrbUiLCLahCIsIu+ttiIsItqDIiwi7623Iiwi2oMiLCLvrbgiLCLagyIsIu+tuSIsItqDIiwi7626Iiwi2oYiLCLvrbsiLCLahiIsIu+tvCIsItqGIiwi7629Iiwi2oYiLCLvrb4iLCLahyIsIu+tvyIsItqHIiwi766AIiwi2ociLCLvroEiLCLahyIsIu+ugiIsItqNIiwi766DIiwi2o0iLCLvroQiLCLajCIsIu+uhSIsItqMIiwi766GIiwi2o4iLCLvrociLCLajiIsIu+uiCIsItqIIiwi766JIiwi2ogiLCLvrooiLCLamCIsIu+uiyIsItqYIiwi766MIiwi2pEiLCLvro0iLCLakSIsIu+ujiIsItqpIiwi766PIiwi2qkiLCLvrpAiLCLaqSIsIu+ukSIsItqpIiwi766SIiwi2q8iLCLvrpMiLCLaryIsIu+ulCIsItqvIiwi766VIiwi2q8iLCLvrpYiLCLasyIsIu+ulyIsItqzIiwi766YIiwi2rMiLCLvrpkiLCLasyIsIu+umiIsItqxIiwi766bIiwi2rEiLCLvrpwiLCLasSIsIu+unSIsItqxIiwi766eIiwi2roiLCLvrp8iLCLauiIsIu+uoCIsItq7Iiwi766hIiwi2rsiLCLvrqIiLCLauyIsIu+uoyIsItq7Iiwi766kIiwi24AiLCLvrqUiLCLbgCIsIu+upiIsItuBIiwi766nIiwi24EiLCLvrqgiLCLbgSIsIu+uqSIsItuBIiwi766qIiwi2r4iLCLvrqsiLCLaviIsIu+urCIsItq+Iiwi766tIiwi2r4iLCLvrq4iLCLbkiIsIu+uryIsItuSIiwi766wIiwi25MiLCLvrrEiLCLbkyIsIu+vkyIsItqtIiwi76+UIiwi2q0iLCLvr5UiLCLarSIsIu+vliIsItqtIiwi76+XIiwi24ciLCLvr5giLCLbhyIsIu+vmSIsItuGIiwi76+aIiwi24YiLCLvr5siLCLbiCIsIu+vnCIsItuIIiwi76+dIiwi2bciLCLvr54iLCLbiyIsIu+vnyIsItuLIiwi76+gIiwi24UiLCLvr6EiLCLbhSIsIu+voiIsItuJIiwi76+jIiwi24kiLCLvr6QiLCLbkCIsIu+vpSIsItuQIiwi76+mIiwi25AiLCLvr6ciLCLbkCIsIu+vqCIsItmJIiwi76+pIiwi2YkiLCLvr6oiLCLYptinIiwi76+rIiwi2KbYpyIsIu+vrCIsItim25UiLCLvr60iLCLYptuVIiwi76+uIiwi2KbZiCIsIu+vryIsItim2YgiLCLvr7AiLCLYptuHIiwi76+xIiwi2KbbhyIsIu+vsiIsItim24YiLCLvr7MiLCLYptuGIiwi76+0Iiwi2KbbiCIsIu+vtSIsItim24giLCLvr7YiLCLYptuQIiwi76+3Iiwi2KbbkCIsIu+vuCIsItim25AiLCLvr7kiLCLYptmJIiwi76+6Iiwi2KbZiSIsIu+vuyIsItim2YkiLCLvr7wiLCLbjCIsIu+vvSIsItuMIiwi76++Iiwi24wiLCLvr78iLCLbjCIsIu+wgCIsItim2KwiLCLvsIEiLCLYptitIiwi77CCIiwi2KbZhSIsIu+wgyIsItim2YkiLCLvsIQiLCLYptmKIiwi77CFIiwi2KjYrCIsIu+whiIsItio2K0iLCLvsIciLCLYqNiuIiwi77CIIiwi2KjZhSIsIu+wiSIsItio2YkiLCLvsIoiLCLYqNmKIiwi77CLIiwi2KrYrCIsIu+wjCIsItiq2K0iLCLvsI0iLCLYqtiuIiwi77COIiwi2KrZhSIsIu+wjyIsItiq2YkiLCLvsJAiLCLYqtmKIiwi77CRIiwi2KvYrCIsIu+wkiIsItir2YUiLCLvsJMiLCLYq9mJIiwi77CUIiwi2KvZiiIsIu+wlSIsItis2K0iLCLvsJYiLCLYrNmFIiwi77CXIiwi2K3YrCIsIu+wmCIsItit2YUiLCLvsJkiLCLYrtisIiwi77CaIiwi2K7YrSIsIu+wmyIsItiu2YUiLCLvsJwiLCLYs9isIiwi77CdIiwi2LPYrSIsIu+wniIsItiz2K4iLCLvsJ8iLCLYs9mFIiwi77CgIiwi2LXYrSIsIu+woSIsIti12YUiLCLvsKIiLCLYttisIiwi77CjIiwi2LbYrSIsIu+wpCIsIti22K4iLCLvsKUiLCLYttmFIiwi77CmIiwi2LfYrSIsIu+wpyIsIti32YUiLCLvsKgiLCLYuNmFIiwi77CpIiwi2LnYrCIsIu+wqiIsIti52YUiLCLvsKsiLCLYutisIiwi77CsIiwi2LrZhSIsIu+wrSIsItmB2KwiLCLvsK4iLCLZgditIiwi77CvIiwi2YHYriIsIu+wsCIsItmB2YUiLCLvsLEiLCLZgdmJIiwi77CyIiwi2YHZiiIsIu+wsyIsItmC2K0iLCLvsLQiLCLZgtmFIiwi77C1Iiwi2YLZiSIsIu+wtiIsItmC2YoiLCLvsLciLCLZg9inIiwi77C4Iiwi2YPYrCIsIu+wuSIsItmD2K0iLCLvsLoiLCLZg9iuIiwi77C7Iiwi2YPZhCIsIu+wvCIsItmD2YUiLCLvsL0iLCLZg9mJIiwi77C+Iiwi2YPZiiIsIu+wvyIsItmE2KwiLCLvsYAiLCLZhNitIiwi77GBIiwi2YTYriIsIu+xgiIsItmE2YUiLCLvsYMiLCLZhNmJIiwi77GEIiwi2YTZiiIsIu+xhSIsItmF2KwiLCLvsYYiLCLZhditIiwi77GHIiwi2YXYriIsIu+xiCIsItmF2YUiLCLvsYkiLCLZhdmJIiwi77GKIiwi2YXZiiIsIu+xiyIsItmG2KwiLCLvsYwiLCLZhtitIiwi77GNIiwi2YbYriIsIu+xjiIsItmG2YUiLCLvsY8iLCLZhtmJIiwi77GQIiwi2YbZiiIsIu+xkSIsItmH2KwiLCLvsZIiLCLZh9mFIiwi77GTIiwi2YfZiSIsIu+xlCIsItmH2YoiLCLvsZUiLCLZitisIiwi77GWIiwi2YrYrSIsIu+xlyIsItmK2K4iLCLvsZgiLCLZitmFIiwi77GZIiwi2YrZiSIsIu+xmiIsItmK2YoiLCLvsZsiLCLYsNmwIiwi77GcIiwi2LHZsCIsIu+xnSIsItmJ2bAiLCLvsZ4iLCIg2YzZkSIsIu+xnyIsIiDZjdmRIiwi77GgIiwiINmO2ZEiLCLvsaEiLCIg2Y/ZkSIsIu+xoiIsIiDZkNmRIiwi77GjIiwiINmR2bAiLCLvsaQiLCLYptixIiwi77GlIiwi2KbYsiIsIu+xpiIsItim2YUiLCLvsaciLCLYptmGIiwi77GoIiwi2KbZiSIsIu+xqSIsItim2YoiLCLvsaoiLCLYqNixIiwi77GrIiwi2KjYsiIsIu+xrCIsItio2YUiLCLvsa0iLCLYqNmGIiwi77GuIiwi2KjZiSIsIu+xryIsItio2YoiLCLvsbAiLCLYqtixIiwi77GxIiwi2KrYsiIsIu+xsiIsItiq2YUiLCLvsbMiLCLYqtmGIiwi77G0Iiwi2KrZiSIsIu+xtSIsItiq2YoiLCLvsbYiLCLYq9ixIiwi77G3Iiwi2KvYsiIsIu+xuCIsItir2YUiLCLvsbkiLCLYq9mGIiwi77G6Iiwi2KvZiSIsIu+xuyIsItir2YoiLCLvsbwiLCLZgdmJIiwi77G9Iiwi2YHZiiIsIu+xviIsItmC2YkiLCLvsb8iLCLZgtmKIiwi77KAIiwi2YPYpyIsIu+ygSIsItmD2YQiLCLvsoIiLCLZg9mFIiwi77KDIiwi2YPZiSIsIu+yhCIsItmD2YoiLCLvsoUiLCLZhNmFIiwi77KGIiwi2YTZiSIsIu+yhyIsItmE2YoiLCLvsogiLCLZhdinIiwi77KJIiwi2YXZhSIsIu+yiiIsItmG2LEiLCLvsosiLCLZhtiyIiwi77KMIiwi2YbZhSIsIu+yjSIsItmG2YYiLCLvso4iLCLZhtmJIiwi77KPIiwi2YbZiiIsIu+ykCIsItmJ2bAiLCLvspEiLCLZitixIiwi77KSIiwi2YrYsiIsIu+ykyIsItmK2YUiLCLvspQiLCLZitmGIiwi77KVIiwi2YrZiSIsIu+yliIsItmK2YoiLCLvspciLCLYptisIiwi77KYIiwi2KbYrSIsIu+ymSIsItim2K4iLCLvspoiLCLYptmFIiwi77KbIiwi2KbZhyIsIu+ynCIsItio2KwiLCLvsp0iLCLYqNitIiwi77KeIiwi2KjYriIsIu+ynyIsItio2YUiLCLvsqAiLCLYqNmHIiwi77KhIiwi2KrYrCIsIu+yoiIsItiq2K0iLCLvsqMiLCLYqtiuIiwi77KkIiwi2KrZhSIsIu+ypSIsItiq2YciLCLvsqYiLCLYq9mFIiwi77KnIiwi2KzYrSIsIu+yqCIsItis2YUiLCLvsqkiLCLYrdisIiwi77KqIiwi2K3ZhSIsIu+yqyIsItiu2KwiLCLvsqwiLCLYrtmFIiwi77KtIiwi2LPYrCIsIu+yriIsItiz2K0iLCLvsq8iLCLYs9iuIiwi77KwIiwi2LPZhSIsIu+ysSIsIti12K0iLCLvsrIiLCLYtdiuIiwi77KzIiwi2LXZhSIsIu+ytCIsIti22KwiLCLvsrUiLCLYttitIiwi77K2Iiwi2LbYriIsIu+ytyIsIti22YUiLCLvsrgiLCLYt9itIiwi77K5Iiwi2LjZhSIsIu+yuiIsIti52KwiLCLvsrsiLCLYudmFIiwi77K8Iiwi2LrYrCIsIu+yvSIsIti62YUiLCLvsr4iLCLZgdisIiwi77K/Iiwi2YHYrSIsIu+zgCIsItmB2K4iLCLvs4EiLCLZgdmFIiwi77OCIiwi2YLYrSIsIu+zgyIsItmC2YUiLCLvs4QiLCLZg9isIiwi77OFIiwi2YPYrSIsIu+zhiIsItmD2K4iLCLvs4ciLCLZg9mEIiwi77OIIiwi2YPZhSIsIu+ziSIsItmE2KwiLCLvs4oiLCLZhNitIiwi77OLIiwi2YTYriIsIu+zjCIsItmE2YUiLCLvs40iLCLZhNmHIiwi77OOIiwi2YXYrCIsIu+zjyIsItmF2K0iLCLvs5AiLCLZhdiuIiwi77ORIiwi2YXZhSIsIu+zkiIsItmG2KwiLCLvs5MiLCLZhtitIiwi77OUIiwi2YbYriIsIu+zlSIsItmG2YUiLCLvs5YiLCLZhtmHIiwi77OXIiwi2YfYrCIsIu+zmCIsItmH2YUiLCLvs5kiLCLZh9mwIiwi77OaIiwi2YrYrCIsIu+zmyIsItmK2K0iLCLvs5wiLCLZitiuIiwi77OdIiwi2YrZhSIsIu+zniIsItmK2YciLCLvs58iLCLYptmFIiwi77OgIiwi2KbZhyIsIu+zoSIsItio2YUiLCLvs6IiLCLYqNmHIiwi77OjIiwi2KrZhSIsIu+zpCIsItiq2YciLCLvs6UiLCLYq9mFIiwi77OmIiwi2KvZhyIsIu+zpyIsItiz2YUiLCLvs6giLCLYs9mHIiwi77OpIiwi2LTZhSIsIu+zqiIsIti02YciLCLvs6siLCLZg9mEIiwi77OsIiwi2YPZhSIsIu+zrSIsItmE2YUiLCLvs64iLCLZhtmFIiwi77OvIiwi2YbZhyIsIu+zsCIsItmK2YUiLCLvs7EiLCLZitmHIiwi77OyIiwi2YDZjtmRIiwi77OzIiwi2YDZj9mRIiwi77O0Iiwi2YDZkNmRIiwi77O1Iiwi2LfZiSIsIu+ztiIsIti32YoiLCLvs7ciLCLYudmJIiwi77O4Iiwi2LnZiiIsIu+zuSIsIti62YkiLCLvs7oiLCLYutmKIiwi77O7Iiwi2LPZiSIsIu+zvCIsItiz2YoiLCLvs70iLCLYtNmJIiwi77O+Iiwi2LTZiiIsIu+zvyIsItit2YkiLCLvtIAiLCLYrdmKIiwi77SBIiwi2KzZiSIsIu+0giIsItis2YoiLCLvtIMiLCLYrtmJIiwi77SEIiwi2K7ZiiIsIu+0hSIsIti12YkiLCLvtIYiLCLYtdmKIiwi77SHIiwi2LbZiSIsIu+0iCIsIti22YoiLCLvtIkiLCLYtNisIiwi77SKIiwi2LTYrSIsIu+0iyIsIti02K4iLCLvtIwiLCLYtNmFIiwi77SNIiwi2LTYsSIsIu+0jiIsItiz2LEiLCLvtI8iLCLYtdixIiwi77SQIiwi2LbYsSIsIu+0kSIsIti32YkiLCLvtJIiLCLYt9mKIiwi77STIiwi2LnZiSIsIu+0lCIsIti52YoiLCLvtJUiLCLYutmJIiwi77SWIiwi2LrZiiIsIu+0lyIsItiz2YkiLCLvtJgiLCLYs9mKIiwi77SZIiwi2LTZiSIsIu+0miIsIti02YoiLCLvtJsiLCLYrdmJIiwi77ScIiwi2K3ZiiIsIu+0nSIsItis2YkiLCLvtJ4iLCLYrNmKIiwi77SfIiwi2K7ZiSIsIu+0oCIsItiu2YoiLCLvtKEiLCLYtdmJIiwi77SiIiwi2LXZiiIsIu+0oyIsIti22YkiLCLvtKQiLCLYttmKIiwi77SlIiwi2LTYrCIsIu+0piIsIti02K0iLCLvtKciLCLYtNiuIiwi77SoIiwi2LTZhSIsIu+0qSIsIti02LEiLCLvtKoiLCLYs9ixIiwi77SrIiwi2LXYsSIsIu+0rCIsIti22LEiLCLvtK0iLCLYtNisIiwi77SuIiwi2LTYrSIsIu+0ryIsIti02K4iLCLvtLAiLCLYtNmFIiwi77SxIiwi2LPZhyIsIu+0siIsIti02YciLCLvtLMiLCLYt9mFIiwi77S0Iiwi2LPYrCIsIu+0tSIsItiz2K0iLCLvtLYiLCLYs9iuIiwi77S3Iiwi2LTYrCIsIu+0uCIsIti02K0iLCLvtLkiLCLYtNiuIiwi77S6Iiwi2LfZhSIsIu+0uyIsIti42YUiLCLvtLwiLCLYp9mLIiwi77S9Iiwi2KfZiyIsIu+1kCIsItiq2KzZhSIsIu+1kSIsItiq2K3YrCIsIu+1kiIsItiq2K3YrCIsIu+1kyIsItiq2K3ZhSIsIu+1lCIsItiq2K7ZhSIsIu+1lSIsItiq2YXYrCIsIu+1liIsItiq2YXYrSIsIu+1lyIsItiq2YXYriIsIu+1mCIsItis2YXYrSIsIu+1mSIsItis2YXYrSIsIu+1miIsItit2YXZiiIsIu+1myIsItit2YXZiSIsIu+1nCIsItiz2K3YrCIsIu+1nSIsItiz2KzYrSIsIu+1niIsItiz2KzZiSIsIu+1nyIsItiz2YXYrSIsIu+1oCIsItiz2YXYrSIsIu+1oSIsItiz2YXYrCIsIu+1oiIsItiz2YXZhSIsIu+1oyIsItiz2YXZhSIsIu+1pCIsIti12K3YrSIsIu+1pSIsIti12K3YrSIsIu+1piIsIti12YXZhSIsIu+1pyIsIti02K3ZhSIsIu+1qCIsIti02K3ZhSIsIu+1qSIsIti02KzZiiIsIu+1qiIsIti02YXYriIsIu+1qyIsIti02YXYriIsIu+1rCIsIti02YXZhSIsIu+1rSIsIti02YXZhSIsIu+1riIsIti22K3ZiSIsIu+1ryIsIti22K7ZhSIsIu+1sCIsIti22K7ZhSIsIu+1sSIsIti32YXYrSIsIu+1siIsIti32YXYrSIsIu+1syIsIti32YXZhSIsIu+1tCIsIti32YXZiiIsIu+1tSIsIti52KzZhSIsIu+1tiIsIti52YXZhSIsIu+1tyIsIti52YXZhSIsIu+1uCIsIti52YXZiSIsIu+1uSIsIti62YXZhSIsIu+1uiIsIti62YXZiiIsIu+1uyIsIti62YXZiSIsIu+1vCIsItmB2K7ZhSIsIu+1vSIsItmB2K7ZhSIsIu+1viIsItmC2YXYrSIsIu+1vyIsItmC2YXZhSIsIu+2gCIsItmE2K3ZhSIsIu+2gSIsItmE2K3ZiiIsIu+2giIsItmE2K3ZiSIsIu+2gyIsItmE2KzYrCIsIu+2hCIsItmE2KzYrCIsIu+2hSIsItmE2K7ZhSIsIu+2hiIsItmE2K7ZhSIsIu+2hyIsItmE2YXYrSIsIu+2iCIsItmE2YXYrSIsIu+2iSIsItmF2K3YrCIsIu+2iiIsItmF2K3ZhSIsIu+2iyIsItmF2K3ZiiIsIu+2jCIsItmF2KzYrSIsIu+2jSIsItmF2KzZhSIsIu+2jiIsItmF2K7YrCIsIu+2jyIsItmF2K7ZhSIsIu+2kiIsItmF2KzYriIsIu+2kyIsItmH2YXYrCIsIu+2lCIsItmH2YXZhSIsIu+2lSIsItmG2K3ZhSIsIu+2liIsItmG2K3ZiSIsIu+2lyIsItmG2KzZhSIsIu+2mCIsItmG2KzZhSIsIu+2mSIsItmG2KzZiSIsIu+2miIsItmG2YXZiiIsIu+2myIsItmG2YXZiSIsIu+2nCIsItmK2YXZhSIsIu+2nSIsItmK2YXZhSIsIu+2niIsItio2K7ZiiIsIu+2nyIsItiq2KzZiiIsIu+2oCIsItiq2KzZiSIsIu+2oSIsItiq2K7ZiiIsIu+2oiIsItiq2K7ZiSIsIu+2oyIsItiq2YXZiiIsIu+2pCIsItiq2YXZiSIsIu+2pSIsItis2YXZiiIsIu+2piIsItis2K3ZiSIsIu+2pyIsItis2YXZiSIsIu+2qCIsItiz2K7ZiSIsIu+2qSIsIti12K3ZiiIsIu+2qiIsIti02K3ZiiIsIu+2qyIsIti22K3ZiiIsIu+2rCIsItmE2KzZiiIsIu+2rSIsItmE2YXZiiIsIu+2riIsItmK2K3ZiiIsIu+2ryIsItmK2KzZiiIsIu+2sCIsItmK2YXZiiIsIu+2sSIsItmF2YXZiiIsIu+2siIsItmC2YXZiiIsIu+2syIsItmG2K3ZiiIsIu+2tCIsItmC2YXYrSIsIu+2tSIsItmE2K3ZhSIsIu+2tiIsIti52YXZiiIsIu+2tyIsItmD2YXZiiIsIu+2uCIsItmG2KzYrSIsIu+2uSIsItmF2K7ZiiIsIu+2uiIsItmE2KzZhSIsIu+2uyIsItmD2YXZhSIsIu+2vCIsItmE2KzZhSIsIu+2vSIsItmG2KzYrSIsIu+2viIsItis2K3ZiiIsIu+2vyIsItit2KzZiiIsIu+3gCIsItmF2KzZiiIsIu+3gSIsItmB2YXZiiIsIu+3giIsItio2K3ZiiIsIu+3gyIsItmD2YXZhSIsIu+3hCIsIti52KzZhSIsIu+3hSIsIti12YXZhSIsIu+3hiIsItiz2K7ZiiIsIu+3hyIsItmG2KzZiiIsIu+5iSIsIuKAviIsIu+5iiIsIuKAviIsIu+5iyIsIuKAviIsIu+5jCIsIuKAviIsIu+5jSIsIl8iLCLvuY4iLCJfIiwi77mPIiwiXyIsIu+6gCIsItihIiwi77qBIiwi2KIiLCLvuoIiLCLYoiIsIu+6gyIsItijIiwi77qEIiwi2KMiLCLvuoUiLCLYpCIsIu+6hiIsItikIiwi77qHIiwi2KUiLCLvuogiLCLYpSIsIu+6iSIsItimIiwi77qKIiwi2KYiLCLvuosiLCLYpiIsIu+6jCIsItimIiwi77qNIiwi2KciLCLvuo4iLCLYpyIsIu+6jyIsItioIiwi77qQIiwi2KgiLCLvupEiLCLYqCIsIu+6kiIsItioIiwi77qTIiwi2KkiLCLvupQiLCLYqSIsIu+6lSIsItiqIiwi77qWIiwi2KoiLCLvupciLCLYqiIsIu+6mCIsItiqIiwi77qZIiwi2KsiLCLvupoiLCLYqyIsIu+6myIsItirIiwi77qcIiwi2KsiLCLvup0iLCLYrCIsIu+6niIsItisIiwi77qfIiwi2KwiLCLvuqAiLCLYrCIsIu+6oSIsItitIiwi77qiIiwi2K0iLCLvuqMiLCLYrSIsIu+6pCIsItitIiwi77qlIiwi2K4iLCLvuqYiLCLYriIsIu+6pyIsItiuIiwi77qoIiwi2K4iLCLvuqkiLCLYryIsIu+6qiIsItivIiwi77qrIiwi2LAiLCLvuqwiLCLYsCIsIu+6rSIsItixIiwi77quIiwi2LEiLCLvuq8iLCLYsiIsIu+6sCIsItiyIiwi77qxIiwi2LMiLCLvurIiLCLYsyIsIu+6syIsItizIiwi77q0Iiwi2LMiLCLvurUiLCLYtCIsIu+6tiIsIti0Iiwi77q3Iiwi2LQiLCLvurgiLCLYtCIsIu+6uSIsIti1Iiwi77q6Iiwi2LUiLCLvursiLCLYtSIsIu+6vCIsIti1Iiwi77q9Iiwi2LYiLCLvur4iLCLYtiIsIu+6vyIsIti2Iiwi77uAIiwi2LYiLCLvu4EiLCLYtyIsIu+7giIsIti3Iiwi77uDIiwi2LciLCLvu4QiLCLYtyIsIu+7hSIsIti4Iiwi77uGIiwi2LgiLCLvu4ciLCLYuCIsIu+7iCIsIti4Iiwi77uJIiwi2LkiLCLvu4oiLCLYuSIsIu+7iyIsIti5Iiwi77uMIiwi2LkiLCLvu40iLCLYuiIsIu+7jiIsIti6Iiwi77uPIiwi2LoiLCLvu5AiLCLYuiIsIu+7kSIsItmBIiwi77uSIiwi2YEiLCLvu5MiLCLZgSIsIu+7lCIsItmBIiwi77uVIiwi2YIiLCLvu5YiLCLZgiIsIu+7lyIsItmCIiwi77uYIiwi2YIiLCLvu5kiLCLZgyIsIu+7miIsItmDIiwi77ubIiwi2YMiLCLvu5wiLCLZgyIsIu+7nSIsItmEIiwi77ueIiwi2YQiLCLvu58iLCLZhCIsIu+7oCIsItmEIiwi77uhIiwi2YUiLCLvu6IiLCLZhSIsIu+7oyIsItmFIiwi77ukIiwi2YUiLCLvu6UiLCLZhiIsIu+7piIsItmGIiwi77unIiwi2YYiLCLvu6giLCLZhiIsIu+7qSIsItmHIiwi77uqIiwi2YciLCLvu6siLCLZhyIsIu+7rCIsItmHIiwi77utIiwi2YgiLCLvu64iLCLZiCIsIu+7ryIsItmJIiwi77uwIiwi2YkiLCLvu7EiLCLZiiIsIu+7siIsItmKIiwi77uzIiwi2YoiLCLvu7QiLCLZiiIsIu+7tSIsItmE2KIiLCLvu7YiLCLZhNiiIiwi77u3Iiwi2YTYoyIsIu+7uCIsItmE2KMiLCLvu7kiLCLZhNilIiwi77u6Iiwi2YTYpSIsIu+7uyIsItmE2KciLCLvu7wiLCLZhNinIl19KSk7ZnVuY3Rpb24gcmV2ZXJzZUlmUnRsKGUpe2NvbnN0IHQ9ZS5sZW5ndGg7aWYodDw9MXx8IWZ1bmN0aW9uIGlzUlRMUmFuZ2VGb3IoZSl7bGV0IHQ9aVsxM107aWYoZT49dC5iZWdpbiYmZTx0LmVuZClyZXR1cm4hMDt0PWlbMTFdO3JldHVybiBlPj10LmJlZ2luJiZlPHQuZW5kfShlLmNoYXJDb2RlQXQoMCkpKXJldHVybiBlO2NvbnN0IGE9W107Zm9yKGxldCByPXQtMTtyPj0wO3ItLSlhLnB1c2goZVtyXSk7cmV0dXJuIGEuam9pbigiIil9Y29uc3Qgbz1uZXcgUmVnRXhwKCJeKFxccyl8KFxccHtNbn0pfChcXHB7Q2Z9KSQiLCJ1IiksYz1uZXcgTWFwO2Z1bmN0aW9uIGdldENoYXJVbmljb2RlQ2F0ZWdvcnkoZSl7Y29uc3QgdD1jLmdldChlKTtpZih0KXJldHVybiB0O2NvbnN0IGE9ZS5tYXRjaChvKSxyPXtpc1doaXRlc3BhY2U6ISghYXx8IWFbMV0pLGlzWmVyb1dpZHRoRGlhY3JpdGljOiEoIWF8fCFhWzJdKSxpc0ludmlzaWJsZUZvcm1hdE1hcms6ISghYXx8IWFbM10pfTtjLnNldChlLHIpO3JldHVybiByfWZ1bmN0aW9uIGNsZWFyVW5pY29kZUNhY2hlcygpe2MuY2xlYXIoKX19LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5nZXRTZXJpZkZvbnRzPXQuZ2V0Tm9uU3RkRm9udE1hcD10LmdldEdseXBoTWFwRm9yU3RhbmRhcmRGb250cz10LmdldEZvbnROYW1lVG9GaWxlTWFwPXZvaWQgMDt0LmdldFN0YW5kYXJkRm9udE5hbWU9ZnVuY3Rpb24gZ2V0U3RhbmRhcmRGb250TmFtZShlKXtjb25zdCB0PSgwLG4ubm9ybWFsaXplRm9udE5hbWUpKGUpO3JldHVybiBpKClbdF19O3QuZ2V0U3ltYm9sc0ZvbnRzPXQuZ2V0U3VwcGxlbWVudGFsR2x5cGhNYXBGb3JDYWxpYnJpPXQuZ2V0U3VwcGxlbWVudGFsR2x5cGhNYXBGb3JBcmlhbEJsYWNrPXQuZ2V0U3RkRm9udE1hcD12b2lkIDA7dmFyIHI9YSg2KSxuPWEoMzgpO2NvbnN0IGk9KDAsci5nZXRMb29rdXBUYWJsZUZhY3RvcnkpKChmdW5jdGlvbihlKXtlWyJUaW1lcy1Sb21hbiJdPSJUaW1lcy1Sb21hbiI7ZS5IZWx2ZXRpY2E9IkhlbHZldGljYSI7ZS5Db3VyaWVyPSJDb3VyaWVyIjtlLlN5bWJvbD0iU3ltYm9sIjtlWyJUaW1lcy1Cb2xkIl09IlRpbWVzLUJvbGQiO2VbIkhlbHZldGljYS1Cb2xkIl09IkhlbHZldGljYS1Cb2xkIjtlWyJDb3VyaWVyLUJvbGQiXT0iQ291cmllci1Cb2xkIjtlLlphcGZEaW5nYmF0cz0iWmFwZkRpbmdiYXRzIjtlWyJUaW1lcy1JdGFsaWMiXT0iVGltZXMtSXRhbGljIjtlWyJIZWx2ZXRpY2EtT2JsaXF1ZSJdPSJIZWx2ZXRpY2EtT2JsaXF1ZSI7ZVsiQ291cmllci1PYmxpcXVlIl09IkNvdXJpZXItT2JsaXF1ZSI7ZVsiVGltZXMtQm9sZEl0YWxpYyJdPSJUaW1lcy1Cb2xkSXRhbGljIjtlWyJIZWx2ZXRpY2EtQm9sZE9ibGlxdWUiXT0iSGVsdmV0aWNhLUJvbGRPYmxpcXVlIjtlWyJDb3VyaWVyLUJvbGRPYmxpcXVlIl09IkNvdXJpZXItQm9sZE9ibGlxdWUiO2UuQXJpYWxOYXJyb3c9IkhlbHZldGljYSI7ZVsiQXJpYWxOYXJyb3ctQm9sZCJdPSJIZWx2ZXRpY2EtQm9sZCI7ZVsiQXJpYWxOYXJyb3ctQm9sZEl0YWxpYyJdPSJIZWx2ZXRpY2EtQm9sZE9ibGlxdWUiO2VbIkFyaWFsTmFycm93LUl0YWxpYyJdPSJIZWx2ZXRpY2EtT2JsaXF1ZSI7ZS5BcmlhbEJsYWNrPSJIZWx2ZXRpY2EiO2VbIkFyaWFsQmxhY2stQm9sZCJdPSJIZWx2ZXRpY2EtQm9sZCI7ZVsiQXJpYWxCbGFjay1Cb2xkSXRhbGljIl09IkhlbHZldGljYS1Cb2xkT2JsaXF1ZSI7ZVsiQXJpYWxCbGFjay1JdGFsaWMiXT0iSGVsdmV0aWNhLU9ibGlxdWUiO2VbIkFyaWFsLUJsYWNrIl09IkhlbHZldGljYSI7ZVsiQXJpYWwtQmxhY2stQm9sZCJdPSJIZWx2ZXRpY2EtQm9sZCI7ZVsiQXJpYWwtQmxhY2stQm9sZEl0YWxpYyJdPSJIZWx2ZXRpY2EtQm9sZE9ibGlxdWUiO2VbIkFyaWFsLUJsYWNrLUl0YWxpYyJdPSJIZWx2ZXRpY2EtT2JsaXF1ZSI7ZS5BcmlhbD0iSGVsdmV0aWNhIjtlWyJBcmlhbC1Cb2xkIl09IkhlbHZldGljYS1Cb2xkIjtlWyJBcmlhbC1Cb2xkSXRhbGljIl09IkhlbHZldGljYS1Cb2xkT2JsaXF1ZSI7ZVsiQXJpYWwtSXRhbGljIl09IkhlbHZldGljYS1PYmxpcXVlIjtlLkFyaWFsTVQ9IkhlbHZldGljYSI7ZVsiQXJpYWwtQm9sZEl0YWxpY01UIl09IkhlbHZldGljYS1Cb2xkT2JsaXF1ZSI7ZVsiQXJpYWwtQm9sZE1UIl09IkhlbHZldGljYS1Cb2xkIjtlWyJBcmlhbC1JdGFsaWNNVCJdPSJIZWx2ZXRpY2EtT2JsaXF1ZSI7ZS5BcmlhbFVuaWNvZGVNUz0iSGVsdmV0aWNhIjtlWyJBcmlhbFVuaWNvZGVNUy1Cb2xkIl09IkhlbHZldGljYS1Cb2xkIjtlWyJBcmlhbFVuaWNvZGVNUy1Cb2xkSXRhbGljIl09IkhlbHZldGljYS1Cb2xkT2JsaXF1ZSI7ZVsiQXJpYWxVbmljb2RlTVMtSXRhbGljIl09IkhlbHZldGljYS1PYmxpcXVlIjtlWyJDb3VyaWVyLUJvbGRJdGFsaWMiXT0iQ291cmllci1Cb2xkT2JsaXF1ZSI7ZVsiQ291cmllci1JdGFsaWMiXT0iQ291cmllci1PYmxpcXVlIjtlLkNvdXJpZXJOZXc9IkNvdXJpZXIiO2VbIkNvdXJpZXJOZXctQm9sZCJdPSJDb3VyaWVyLUJvbGQiO2VbIkNvdXJpZXJOZXctQm9sZEl0YWxpYyJdPSJDb3VyaWVyLUJvbGRPYmxpcXVlIjtlWyJDb3VyaWVyTmV3LUl0YWxpYyJdPSJDb3VyaWVyLU9ibGlxdWUiO2VbIkNvdXJpZXJOZXdQUy1Cb2xkSXRhbGljTVQiXT0iQ291cmllci1Cb2xkT2JsaXF1ZSI7ZVsiQ291cmllck5ld1BTLUJvbGRNVCJdPSJDb3VyaWVyLUJvbGQiO2VbIkNvdXJpZXJOZXdQUy1JdGFsaWNNVCJdPSJDb3VyaWVyLU9ibGlxdWUiO2UuQ291cmllck5ld1BTTVQ9IkNvdXJpZXIiO2VbIkhlbHZldGljYS1Cb2xkSXRhbGljIl09IkhlbHZldGljYS1Cb2xkT2JsaXF1ZSI7ZVsiSGVsdmV0aWNhLUl0YWxpYyJdPSJIZWx2ZXRpY2EtT2JsaXF1ZSI7ZVsiU3ltYm9sLUJvbGQiXT0iU3ltYm9sIjtlWyJTeW1ib2wtQm9sZEl0YWxpYyJdPSJTeW1ib2wiO2VbIlN5bWJvbC1JdGFsaWMiXT0iU3ltYm9sIjtlLlRpbWVzTmV3Um9tYW49IlRpbWVzLVJvbWFuIjtlWyJUaW1lc05ld1JvbWFuLUJvbGQiXT0iVGltZXMtQm9sZCI7ZVsiVGltZXNOZXdSb21hbi1Cb2xkSXRhbGljIl09IlRpbWVzLUJvbGRJdGFsaWMiO2VbIlRpbWVzTmV3Um9tYW4tSXRhbGljIl09IlRpbWVzLUl0YWxpYyI7ZS5UaW1lc05ld1JvbWFuUFM9IlRpbWVzLVJvbWFuIjtlWyJUaW1lc05ld1JvbWFuUFMtQm9sZCJdPSJUaW1lcy1Cb2xkIjtlWyJUaW1lc05ld1JvbWFuUFMtQm9sZEl0YWxpYyJdPSJUaW1lcy1Cb2xkSXRhbGljIjtlWyJUaW1lc05ld1JvbWFuUFMtQm9sZEl0YWxpY01UIl09IlRpbWVzLUJvbGRJdGFsaWMiO2VbIlRpbWVzTmV3Um9tYW5QUy1Cb2xkTVQiXT0iVGltZXMtQm9sZCI7ZVsiVGltZXNOZXdSb21hblBTLUl0YWxpYyJdPSJUaW1lcy1JdGFsaWMiO2VbIlRpbWVzTmV3Um9tYW5QUy1JdGFsaWNNVCJdPSJUaW1lcy1JdGFsaWMiO2UuVGltZXNOZXdSb21hblBTTVQ9IlRpbWVzLVJvbWFuIjtlWyJUaW1lc05ld1JvbWFuUFNNVC1Cb2xkIl09IlRpbWVzLUJvbGQiO2VbIlRpbWVzTmV3Um9tYW5QU01ULUJvbGRJdGFsaWMiXT0iVGltZXMtQm9sZEl0YWxpYyI7ZVsiVGltZXNOZXdSb21hblBTTVQtSXRhbGljIl09IlRpbWVzLUl0YWxpYyJ9KSk7dC5nZXRTdGRGb250TWFwPWk7Y29uc3Qgcz0oMCxyLmdldExvb2t1cFRhYmxlRmFjdG9yeSkoKGZ1bmN0aW9uKGUpe2UuQ291cmllcj0iRm94aXRGaXhlZC5wZmIiO2VbIkNvdXJpZXItQm9sZCJdPSJGb3hpdEZpeGVkQm9sZC5wZmIiO2VbIkNvdXJpZXItQm9sZE9ibGlxdWUiXT0iRm94aXRGaXhlZEJvbGRJdGFsaWMucGZiIjtlWyJDb3VyaWVyLU9ibGlxdWUiXT0iRm94aXRGaXhlZEl0YWxpYy5wZmIiO2UuSGVsdmV0aWNhPSJGb3hpdFNhbnMucGZiIjtlWyJIZWx2ZXRpY2EtQm9sZCJdPSJGb3hpdFNhbnNCb2xkLnBmYiI7ZVsiSGVsdmV0aWNhLUJvbGRPYmxpcXVlIl09IkZveGl0U2Fuc0JvbGRJdGFsaWMucGZiIjtlWyJIZWx2ZXRpY2EtT2JsaXF1ZSJdPSJGb3hpdFNhbnNJdGFsaWMucGZiIjtlWyJUaW1lcy1Sb21hbiJdPSJGb3hpdFNlcmlmLnBmYiI7ZVsiVGltZXMtQm9sZCJdPSJGb3hpdFNlcmlmQm9sZC5wZmIiO2VbIlRpbWVzLUJvbGRJdGFsaWMiXT0iRm94aXRTZXJpZkJvbGRJdGFsaWMucGZiIjtlWyJUaW1lcy1JdGFsaWMiXT0iRm94aXRTZXJpZkl0YWxpYy5wZmIiO2UuU3ltYm9sPSJGb3hpdFN5bWJvbC5wZmIiO2UuWmFwZkRpbmdiYXRzPSJGb3hpdERpbmdiYXRzLnBmYiI7ZVsiTGliZXJhdGlvblNhbnMtUmVndWxhciJdPSJMaWJlcmF0aW9uU2Fucy1SZWd1bGFyLnR0ZiI7ZVsiTGliZXJhdGlvblNhbnMtQm9sZCJdPSJMaWJlcmF0aW9uU2Fucy1Cb2xkLnR0ZiI7ZVsiTGliZXJhdGlvblNhbnMtSXRhbGljIl09IkxpYmVyYXRpb25TYW5zLUl0YWxpYy50dGYiO2VbIkxpYmVyYXRpb25TYW5zLUJvbGRJdGFsaWMiXT0iTGliZXJhdGlvblNhbnMtQm9sZEl0YWxpYy50dGYifSkpO3QuZ2V0Rm9udE5hbWVUb0ZpbGVNYXA9cztjb25zdCBvPSgwLHIuZ2V0TG9va3VwVGFibGVGYWN0b3J5KSgoZnVuY3Rpb24oZSl7ZS5DYWxpYnJpPSJIZWx2ZXRpY2EiO2VbIkNhbGlicmktQm9sZCJdPSJIZWx2ZXRpY2EtQm9sZCI7ZVsiQ2FsaWJyaS1Cb2xkSXRhbGljIl09IkhlbHZldGljYS1Cb2xkT2JsaXF1ZSI7ZVsiQ2FsaWJyaS1JdGFsaWMiXT0iSGVsdmV0aWNhLU9ibGlxdWUiO2UuQ2VudHVyeUdvdGhpYz0iSGVsdmV0aWNhIjtlWyJDZW50dXJ5R290aGljLUJvbGQiXT0iSGVsdmV0aWNhLUJvbGQiO2VbIkNlbnR1cnlHb3RoaWMtQm9sZEl0YWxpYyJdPSJIZWx2ZXRpY2EtQm9sZE9ibGlxdWUiO2VbIkNlbnR1cnlHb3RoaWMtSXRhbGljIl09IkhlbHZldGljYS1PYmxpcXVlIjtlLkNvbWljU2Fuc01TPSJDb21pYyBTYW5zIE1TIjtlWyJDb21pY1NhbnNNUy1Cb2xkIl09IkNvbWljIFNhbnMgTVMtQm9sZCI7ZVsiQ29taWNTYW5zTVMtQm9sZEl0YWxpYyJdPSJDb21pYyBTYW5zIE1TLUJvbGRJdGFsaWMiO2VbIkNvbWljU2Fuc01TLUl0YWxpYyJdPSJDb21pYyBTYW5zIE1TLUl0YWxpYyI7ZVsiSXRjU3ltYm9sLUJvbGQiXT0iSGVsdmV0aWNhLUJvbGQiO2VbIkl0Y1N5bWJvbC1Cb2xkSXRhbGljIl09IkhlbHZldGljYS1Cb2xkT2JsaXF1ZSI7ZVsiSXRjU3ltYm9sLUJvb2siXT0iSGVsdmV0aWNhIjtlWyJJdGNTeW1ib2wtQm9va0l0YWxpYyJdPSJIZWx2ZXRpY2EtT2JsaXF1ZSI7ZVsiSXRjU3ltYm9sLU1lZGl1bSJdPSJIZWx2ZXRpY2EiO2VbIkl0Y1N5bWJvbC1NZWRpdW1JdGFsaWMiXT0iSGVsdmV0aWNhLU9ibGlxdWUiO2UuTHVjaWRhQ29uc29sZT0iQ291cmllciI7ZVsiTHVjaWRhQ29uc29sZS1Cb2xkIl09IkNvdXJpZXItQm9sZCI7ZVsiTHVjaWRhQ29uc29sZS1Cb2xkSXRhbGljIl09IkNvdXJpZXItQm9sZE9ibGlxdWUiO2VbIkx1Y2lkYUNvbnNvbGUtSXRhbGljIl09IkNvdXJpZXItT2JsaXF1ZSI7ZVsiTHVjaWRhU2Fucy1EZW1pIl09IkhlbHZldGljYS1Cb2xkIjtlWyJNUy1Hb3RoaWMiXT0iTVMgR290aGljIjtlWyJNUy1Hb3RoaWMtQm9sZCJdPSJNUyBHb3RoaWMtQm9sZCI7ZVsiTVMtR290aGljLUJvbGRJdGFsaWMiXT0iTVMgR290aGljLUJvbGRJdGFsaWMiO2VbIk1TLUdvdGhpYy1JdGFsaWMiXT0iTVMgR290aGljLUl0YWxpYyI7ZVsiTVMtTWluY2hvIl09Ik1TIE1pbmNobyI7ZVsiTVMtTWluY2hvLUJvbGQiXT0iTVMgTWluY2hvLUJvbGQiO2VbIk1TLU1pbmNoby1Cb2xkSXRhbGljIl09Ik1TIE1pbmNoby1Cb2xkSXRhbGljIjtlWyJNUy1NaW5jaG8tSXRhbGljIl09Ik1TIE1pbmNoby1JdGFsaWMiO2VbIk1TLVBHb3RoaWMiXT0iTVMgUEdvdGhpYyI7ZVsiTVMtUEdvdGhpYy1Cb2xkIl09Ik1TIFBHb3RoaWMtQm9sZCI7ZVsiTVMtUEdvdGhpYy1Cb2xkSXRhbGljIl09Ik1TIFBHb3RoaWMtQm9sZEl0YWxpYyI7ZVsiTVMtUEdvdGhpYy1JdGFsaWMiXT0iTVMgUEdvdGhpYy1JdGFsaWMiO2VbIk1TLVBNaW5jaG8iXT0iTVMgUE1pbmNobyI7ZVsiTVMtUE1pbmNoby1Cb2xkIl09Ik1TIFBNaW5jaG8tQm9sZCI7ZVsiTVMtUE1pbmNoby1Cb2xkSXRhbGljIl09Ik1TIFBNaW5jaG8tQm9sZEl0YWxpYyI7ZVsiTVMtUE1pbmNoby1JdGFsaWMiXT0iTVMgUE1pbmNoby1JdGFsaWMiO2UuTnVwdGlhbFNjcmlwdD0iVGltZXMtSXRhbGljIjtlLlNlZ29lVUlTeW1ib2w9IkhlbHZldGljYSI7ZS5XaW5nZGluZ3M9IlphcGZEaW5nYmF0cyI7ZVsiV2luZ2RpbmdzLVJlZ3VsYXIiXT0iWmFwZkRpbmdiYXRzIn0pKTt0LmdldE5vblN0ZEZvbnRNYXA9bztjb25zdCBjPSgwLHIuZ2V0TG9va3VwVGFibGVGYWN0b3J5KSgoZnVuY3Rpb24oZSl7ZVsiQWRvYmUgSmVuc29uIl09ITA7ZVsiQWRvYmUgVGV4dCJdPSEwO2UuQWxiZXJ0dXM9ITA7ZS5BbGR1cz0hMDtlLkFsZXhhbmRyaWE9ITA7ZS5BbGdlcmlhbj0hMDtlWyJBbWVyaWNhbiBUeXBld3JpdGVyIl09ITA7ZS5BbnRpcXVhPSEwO2UuQXBleD0hMDtlLkFybm89ITA7ZS5Bc3Rlcj0hMDtlLkF1cm9yYT0hMDtlLkJhc2tlcnZpbGxlPSEwO2UuQmVsbD0hMDtlLkJlbWJvPSEwO2VbIkJlbWJvIFNjaG9vbGJvb2siXT0hMDtlLkJlbmd1aWF0PSEwO2VbIkJlcmtlbGV5IE9sZCBTdHlsZSJdPSEwO2VbIkJlcm5oYXJkIE1vZGVybiJdPSEwO2VbIkJlcnRob2xkIENpdHkiXT0hMDtlLkJvZG9uaT0hMDtlWyJCYXVlciBCb2RvbmkiXT0hMDtlWyJCb29rIEFudGlxdWEiXT0hMDtlLkJvb2ttYW49ITA7ZVsiQm9yZGVhdXggUm9tYW4iXT0hMDtlWyJDYWxpZm9ybmlhbiBGQiJdPSEwO2UuQ2FsaXN0bz0hMDtlLkNhbHZlcnQ9ITA7ZS5DYXBpdGFscz0hMDtlLkNhbWJyaWE9ITA7ZS5DYXJ0aWVyPSEwO2UuQ2FzbG9uPSEwO2UuQ2F0dWxsPSEwO2UuQ2VudGF1cj0hMDtlWyJDZW50dXJ5IE9sZCBTdHlsZSJdPSEwO2VbIkNlbnR1cnkgU2Nob29sYm9vayJdPSEwO2UuQ2hhcGFycmFsPSEwO2VbIkNoYXJpcyBTSUwiXT0hMDtlLkNoZWx0ZW5oYW09ITA7ZVsiQ2hvbGxhIFNsYWIiXT0hMDtlLkNsYXJlbmRvbj0hMDtlLkNsZWFyZmFjZT0hMDtlLkNvY2hpbj0hMDtlLkNvbG9ubmE9ITA7ZVsiQ29tcHV0ZXIgTW9kZXJuIl09ITA7ZVsiQ29uY3JldGUgUm9tYW4iXT0hMDtlLkNvbnN0YW50aWE9ITA7ZVsiQ29vcGVyIEJsYWNrIl09ITA7ZS5Db3JvbmE9ITA7ZS5FY290eXBlPSEwO2UuRWd5cHRpZW5uZT0hMDtlLkVsZXBoYW50PSEwO2UuRXhjZWxzaW9yPSEwO2UuRmFpcmZpZWxkPSEwO2VbIkZGIFNjYWxhIl09ITA7ZS5Gb2xrYXJkPSEwO2UuRm9vdGxpZ2h0PSEwO2UuRnJlZVNlcmlmPSEwO2VbIkZyaXogUXVhZHJhdGEiXT0hMDtlLkdhcmFtb25kPSEwO2UuR2VudGl1bT0hMDtlLkdlb3JnaWE9ITA7ZS5HbG91Y2VzdGVyPSEwO2VbIkdvdWR5IE9sZCBTdHlsZSJdPSEwO2VbIkdvdWR5IFNjaG9vbGJvb2siXT0hMDtlWyJHb3VkeSBQcm8gRm9udCJdPSEwO2UuR3Jhbmpvbj0hMDtlWyJHdWFyZGlhbiBFZ3lwdGlhbiJdPSEwO2UuSGVhdGhlcj0hMDtlLkhlcmN1bGVzPSEwO2VbIkhpZ2ggVG93ZXIgVGV4dCJdPSEwO2UuSGlyb3NoaWdlPSEwO2VbIkhvZWZsZXIgVGV4dCJdPSEwO2VbIkh1bWFuYSBTZXJpZiJdPSEwO2UuSW1wcmludD0hMDtlWyJJb25pYyBOby4gNSJdPSEwO2UuSmFuc29uPSEwO2UuSm9hbm5hPSEwO2UuS29yaW5uYT0hMDtlLkxleGljb249ITA7ZS5MaWJlcmF0aW9uU2VyaWY9ITA7ZVsiTGliZXJhdGlvbiBTZXJpZiJdPSEwO2VbIkxpbnV4IExpYmVydGluZSJdPSEwO2UuTGl0ZXJhdHVybmF5YT0hMDtlLkx1Y2lkYT0hMDtlWyJMdWNpZGEgQnJpZ2h0Il09ITA7ZS5NZWxpb3I9ITA7ZS5NZW1waGlzPSEwO2UuTWlsbGVyPSEwO2UuTWluaW9uPSEwO2UuTW9kZXJuPSEwO2VbIk1vbmEgTGlzYSJdPSEwO2VbIk1ycyBFYXZlcyJdPSEwO2VbIk1TIFNlcmlmIl09ITA7ZVsiTXVzZW8gU2xhYiJdPSEwO2VbIk5ldyBZb3JrIl09ITA7ZVsiTmltYnVzIFJvbWFuIl09ITA7ZVsiTlBTIFJhd2xpbnNvbiBSb2Fkd2F5Il09ITA7ZS5OdXB0aWFsU2NyaXB0PSEwO2UuUGFsYXRpbm89ITA7ZS5QZXJwZXR1YT0hMDtlLlBsYW50aW49ITA7ZVsiUGxhbnRpbiBTY2hvb2xib29rIl09ITA7ZS5QbGF5YmlsbD0hMDtlWyJQb29yIFJpY2hhcmQiXT0hMDtlWyJSYXdsaW5zb24gUm9hZHdheSJdPSEwO2UuUmVuYXVsdD0hMDtlLlJlcXVpZW09ITA7ZS5Sb2Nrd2VsbD0hMDtlLlJvbWFuPSEwO2VbIlJvdGlzIFNlcmlmIl09ITA7ZS5TYWJvbj0hMDtlLlNjYWxhPSEwO2UuU2VhZ3VsbD0hMDtlLlNpc3RpbmE9ITA7ZS5Tb3V2ZW5pcj0hMDtlLlNUSVg9ITA7ZVsiU3RvbmUgSW5mb3JtYWwiXT0hMDtlWyJTdG9uZSBTZXJpZiJdPSEwO2UuU3lsZmFlbj0hMDtlLlRpbWVzPSEwO2UuVHJhamFuPSEwO2VbIlRyaW5pdMOpIl09ITA7ZVsiVHJ1bXAgTWVkaWFldmFsIl09ITA7ZS5VdG9waWE9ITA7ZVsiVmFsZSBUeXBlIl09ITA7ZVsiQml0c3RyZWFtIFZlcmEiXT0hMDtlWyJWZXJhIFNlcmlmIl09ITA7ZS5WZXJzYWlsbGVzPSEwO2UuV2FudGVkPSEwO2UuV2Vpc3M9ITA7ZVsiV2lkZSBMYXRpbiJdPSEwO2UuV2luZHNvcj0hMDtlLlhJVFM9ITB9KSk7dC5nZXRTZXJpZkZvbnRzPWM7Y29uc3QgbD0oMCxyLmdldExvb2t1cFRhYmxlRmFjdG9yeSkoKGZ1bmN0aW9uKGUpe2UuRGluZ2JhdHM9ITA7ZS5TeW1ib2w9ITA7ZS5aYXBmRGluZ2JhdHM9ITB9KSk7dC5nZXRTeW1ib2xzRm9udHM9bDtjb25zdCBoPSgwLHIuZ2V0TG9va3VwVGFibGVGYWN0b3J5KSgoZnVuY3Rpb24oZSl7ZVsyXT0xMDtlWzNdPTMyO2VbNF09MzM7ZVs1XT0zNDtlWzZdPTM1O2VbN109MzY7ZVs4XT0zNztlWzldPTM4O2VbMTBdPTM5O2VbMTFdPTQwO2VbMTJdPTQxO2VbMTNdPTQyO2VbMTRdPTQzO2VbMTVdPTQ0O2VbMTZdPTQ1O2VbMTddPTQ2O2VbMThdPTQ3O2VbMTldPTQ4O2VbMjBdPTQ5O2VbMjFdPTUwO2VbMjJdPTUxO2VbMjNdPTUyO2VbMjRdPTUzO2VbMjVdPTU0O2VbMjZdPTU1O2VbMjddPTU2O2VbMjhdPTU3O2VbMjldPTU4O2VbMzBdPTg5NDtlWzMxXT02MDtlWzMyXT02MTtlWzMzXT02MjtlWzM0XT02MztlWzM1XT02NDtlWzM2XT02NTtlWzM3XT02NjtlWzM4XT02NztlWzM5XT02ODtlWzQwXT02OTtlWzQxXT03MDtlWzQyXT03MTtlWzQzXT03MjtlWzQ0XT03MztlWzQ1XT03NDtlWzQ2XT03NTtlWzQ3XT03NjtlWzQ4XT03NztlWzQ5XT03ODtlWzUwXT03OTtlWzUxXT04MDtlWzUyXT04MTtlWzUzXT04MjtlWzU0XT04MztlWzU1XT04NDtlWzU2XT04NTtlWzU3XT04NjtlWzU4XT04NztlWzU5XT04ODtlWzYwXT04OTtlWzYxXT05MDtlWzYyXT05MTtlWzYzXT05MjtlWzY0XT05MztlWzY1XT05NDtlWzY2XT05NTtlWzY3XT05NjtlWzY4XT05NztlWzY5XT05ODtlWzcwXT05OTtlWzcxXT0xMDA7ZVs3Ml09MTAxO2VbNzNdPTEwMjtlWzc0XT0xMDM7ZVs3NV09MTA0O2VbNzZdPTEwNTtlWzc3XT0xMDY7ZVs3OF09MTA3O2VbNzldPTEwODtlWzgwXT0xMDk7ZVs4MV09MTEwO2VbODJdPTExMTtlWzgzXT0xMTI7ZVs4NF09MTEzO2VbODVdPTExNDtlWzg2XT0xMTU7ZVs4N109MTE2O2VbODhdPTExNztlWzg5XT0xMTg7ZVs5MF09MTE5O2VbOTFdPTEyMDtlWzkyXT0xMjE7ZVs5M109MTIyO2VbOTRdPTEyMztlWzk1XT0xMjQ7ZVs5Nl09MTI1O2VbOTddPTEyNjtlWzk4XT0xOTY7ZVs5OV09MTk3O2VbMTAwXT0xOTk7ZVsxMDFdPTIwMTtlWzEwMl09MjA5O2VbMTAzXT0yMTQ7ZVsxMDRdPTIyMDtlWzEwNV09MjI1O2VbMTA2XT0yMjQ7ZVsxMDddPTIyNjtlWzEwOF09MjI4O2VbMTA5XT0yMjc7ZVsxMTBdPTIyOTtlWzExMV09MjMxO2VbMTEyXT0yMzM7ZVsxMTNdPTIzMjtlWzExNF09MjM0O2VbMTE1XT0yMzU7ZVsxMTZdPTIzNztlWzExN109MjM2O2VbMTE4XT0yMzg7ZVsxMTldPTIzOTtlWzEyMF09MjQxO2VbMTIxXT0yNDM7ZVsxMjJdPTI0MjtlWzEyM109MjQ0O2VbMTI0XT0yNDY7ZVsxMjVdPTI0NTtlWzEyNl09MjUwO2VbMTI3XT0yNDk7ZVsxMjhdPTI1MTtlWzEyOV09MjUyO2VbMTMwXT04MjI0O2VbMTMxXT0xNzY7ZVsxMzJdPTE2MjtlWzEzM109MTYzO2VbMTM0XT0xNjc7ZVsxMzVdPTgyMjY7ZVsxMzZdPTE4MjtlWzEzN109MjIzO2VbMTM4XT0xNzQ7ZVsxMzldPTE2OTtlWzE0MF09ODQ4MjtlWzE0MV09MTgwO2VbMTQyXT0xNjg7ZVsxNDNdPTg4MDA7ZVsxNDRdPTE5ODtlWzE0NV09MjE2O2VbMTQ2XT04NzM0O2VbMTQ3XT0xNzc7ZVsxNDhdPTg4MDQ7ZVsxNDldPTg4MDU7ZVsxNTBdPTE2NTtlWzE1MV09MTgxO2VbMTUyXT04NzA2O2VbMTUzXT04NzIxO2VbMTU0XT04NzE5O2VbMTU2XT04NzQ3O2VbMTU3XT0xNzA7ZVsxNThdPTE4NjtlWzE1OV09ODQ4NjtlWzE2MF09MjMwO2VbMTYxXT0yNDg7ZVsxNjJdPTE5MTtlWzE2M109MTYxO2VbMTY0XT0xNzI7ZVsxNjVdPTg3MzA7ZVsxNjZdPTQwMjtlWzE2N109ODc3NjtlWzE2OF09ODcxMDtlWzE2OV09MTcxO2VbMTcwXT0xODc7ZVsxNzFdPTgyMzA7ZVsyMDBdPTE5MztlWzIwM109MjA1O2VbMjEwXT0yMTg7ZVsyMjNdPTcxMTtlWzIyNF09MzIxO2VbMjI1XT0zMjI7ZVsyMjZdPTM1MjtlWzIyN109MzUzO2VbMjI4XT0zODE7ZVsyMjldPTM4MjtlWzIzM109MjIxO2VbMjM0XT0yNTM7ZVsyNTJdPTI2MztlWzI1M109MjY4O2VbMjU0XT0yNjk7ZVsyNThdPTI1ODtlWzI2MF09MjYwO2VbMjYxXT0yNjE7ZVsyNjVdPTI4MDtlWzI2Nl09MjgxO2VbMjY3XT0yODI7ZVsyNjhdPTI4MztlWzI2OV09MzEzO2VbMjc1XT0zMjM7ZVsyNzZdPTMyNDtlWzI3OF09MzI4O2VbMjgzXT0zNDQ7ZVsyODRdPTM0NTtlWzI4NV09MzQ2O2VbMjg2XT0zNDc7ZVsyOTJdPTM2NztlWzI5NV09Mzc3O2VbMjk2XT0zNzg7ZVsyOThdPTM4MDtlWzMwNV09OTYzO2VbMzA2XT05NjQ7ZVszMDddPTk2NjtlWzMwOF09ODIxNTtlWzMwOV09ODI1MjtlWzMxMF09ODMxOTtlWzMxMV09ODM1OTtlWzMxMl09ODU5MjtlWzMxM109ODU5MztlWzMzN109OTU1MjtlWzQ5M109MTAzOTtlWzQ5NF09MTA0MDtlWzY3Ml09MTQ4ODtlWzY3M109MTQ4OTtlWzY3NF09MTQ5MDtlWzY3NV09MTQ5MTtlWzY3Nl09MTQ5MjtlWzY3N109MTQ5MztlWzY3OF09MTQ5NDtlWzY3OV09MTQ5NTtlWzY4MF09MTQ5NjtlWzY4MV09MTQ5NztlWzY4Ml09MTQ5ODtlWzY4M109MTQ5OTtlWzY4NF09MTUwMDtlWzY4NV09MTUwMTtlWzY4Nl09MTUwMjtlWzY4N109MTUwMztlWzY4OF09MTUwNDtlWzY4OV09MTUwNTtlWzY5MF09MTUwNjtlWzY5MV09MTUwNztlWzY5Ml09MTUwODtlWzY5M109MTUwOTtlWzY5NF09MTUxMDtlWzY5NV09MTUxMTtlWzY5Nl09MTUxMjtlWzY5N109MTUxMztlWzY5OF09MTUxNDtlWzcwNV09MTUyNDtlWzcwNl09ODM2MjtlWzcxMF09NjQyODg7ZVs3MTFdPTY0Mjk4O2VbNzU5XT0xNjE3O2VbNzYxXT0xNzc2O2VbNzYzXT0xNzc4O2VbNzc1XT0xNjUyO2VbNzc3XT0xNzY0O2VbNzc4XT0xNzgwO2VbNzc5XT0xNzgxO2VbNzgwXT0xNzgyO2VbNzgyXT03NzE7ZVs3ODNdPTY0NzI2O2VbNzg2XT04MzYzO2VbNzg4XT04NTMyO2VbNzkwXT03Njg7ZVs3OTFdPTc2OTtlWzc5Ml09NzY4O2VbNzk1XT04MDM7ZVs3OTddPTY0MzM2O2VbNzk4XT02NDMzNztlWzc5OV09NjQzNDI7ZVs4MDBdPTY0MzQzO2VbODAxXT02NDM0NDtlWzgwMl09NjQzNDU7ZVs4MDNdPTY0MzYyO2VbODA0XT02NDM2MztlWzgwNV09NjQzNjQ7ZVsyNDI0XT03ODIxO2VbMjQyNV09NzgyMjtlWzI0MjZdPTc4MjM7ZVsyNDI3XT03ODI0O2VbMjQyOF09NzgyNTtlWzI0MjldPTc4MjY7ZVsyNDMwXT03ODI3O2VbMjQzM109NzY4MjtlWzI2NzhdPTgwNDU7ZVsyNjc5XT04MDQ2O2VbMjgzMF09MTU1MjtlWzI4MzhdPTY4NjtlWzI4NDBdPTc1MTtlWzI4NDJdPTc1MztlWzI4NDNdPTc1NDtlWzI4NDRdPTc1NTtlWzI4NDZdPTc1NztlWzI4NTZdPTc2NztlWzI4NTddPTg0ODtlWzI4NThdPTg0OTtlWzI4NjJdPTg1MztlWzI4NjNdPTg1NDtlWzI4NjRdPTg1NTtlWzI4NjVdPTg2MTtlWzI4NjZdPTg2MjtlWzI5MDZdPTc0NjA7ZVsyOTA4XT03NDYyO2VbMjkwOV09NzQ2MztlWzI5MTBdPTc0NjQ7ZVsyOTEyXT03NDY2O2VbMjkxM109NzQ2NztlWzI5MTRdPTc0Njg7ZVsyOTE2XT03NDcwO2VbMjkxN109NzQ3MTtlWzI5MThdPTc0NzI7ZVsyOTIwXT03NDc0O2VbMjkyMV09NzQ3NTtlWzI5MjJdPTc0NzY7ZVsyOTI0XT03NDc4O2VbMjkyNV09NzQ3OTtlWzI5MjZdPTc0ODA7ZVsyOTI4XT03NDgyO2VbMjkyOV09NzQ4MztlWzI5MzBdPTc0ODQ7ZVsyOTMyXT03NDg2O2VbMjkzM109NzQ4NztlWzI5MzRdPTc0ODg7ZVsyOTM2XT03NDkwO2VbMjkzN109NzQ5MTtlWzI5MzhdPTc0OTI7ZVsyOTQwXT03NDk0O2VbMjk0MV09NzQ5NTtlWzI5NDJdPTc0OTY7ZVsyOTQ0XT03NDk4O2VbMjk0Nl09NzUwMDtlWzI5NDhdPTc1MDI7ZVsyOTUwXT03NTA0O2VbMjk1MV09NzUwNTtlWzI5NTJdPTc1MDY7ZVsyOTU0XT03NTA4O2VbMjk1NV09NzUwOTtlWzI5NTZdPTc1MTA7ZVsyOTU4XT03NTEyO2VbMjk1OV09NzUxMztlWzI5NjBdPTc1MTQ7ZVsyOTYyXT03NTE2O2VbMjk2M109NzUxNztlWzI5NjRdPTc1MTg7ZVsyOTY2XT03NTIwO2VbMjk2N109NzUyMTtlWzI5NjhdPTc1MjI7ZVsyOTcwXT03NTI0O2VbMjk3MV09NzUyNTtlWzI5NzJdPTc1MjY7ZVsyOTc0XT03NTI4O2VbMjk3NV09NzUyOTtlWzI5NzZdPTc1MzA7ZVsyOTc4XT0xNTM3O2VbMjk3OV09MTUzODtlWzI5ODBdPTE1Mzk7ZVsyOTgyXT0xNTQ5O2VbMjk4M109MTU1MTtlWzI5ODRdPTE1NTI7ZVsyOTg2XT0xNTU0O2VbMjk4N109MTU1NTtlWzI5ODhdPTE1NTY7ZVsyOTkwXT0xNjIzO2VbMjk5MV09MTYyNDtlWzI5OTVdPTE3NzU7ZVsyOTk5XT0xNzkxO2VbMzAwMl09NjQyOTA7ZVszMDAzXT02NDI5MTtlWzMwMDRdPTY0MjkyO2VbMzAwNl09NjQyOTQ7ZVszMDA3XT02NDI5NTtlWzMwMDhdPTY0Mjk2O2VbMzAxMV09MTkwMDtlWzMwMTRdPTgyMjM7ZVszMDE1XT04MjQ0O2VbMzAxN109NzUzMjtlWzMwMThdPTc1MzM7ZVszMDE5XT03NTM0O2VbMzA3NV09NzU5MDtlWzMwNzZdPTc1OTE7ZVszMDc5XT03NTk0O2VbMzA4MF09NzU5NTtlWzMwODNdPTc1OTg7ZVszMDg0XT03NTk5O2VbMzA4N109NzYwMjtlWzMwODhdPTc2MDM7ZVszMDkxXT03NjA2O2VbMzA5Ml09NzYwNztlWzMwOTVdPTc2MTA7ZVszMDk2XT03NjExO2VbMzA5OV09NzYxNDtlWzMxMDBdPTc2MTU7ZVszMTAzXT03NjE4O2VbMzEwNF09NzYxOTtlWzMxMDddPTgzMzc7ZVszMTA4XT04MzM4O2VbMzExNl09MTg4NDtlWzMxMTldPTE4ODU7ZVszMTIwXT0xODg1O2VbMzEyM109MTg4NjtlWzMxMjRdPTE4ODY7ZVszMTI3XT0xODg3O2VbMzEyOF09MTg4NztlWzMxMzFdPTE4ODg7ZVszMTMyXT0xODg4O2VbMzEzNV09MTg4OTtlWzMxMzZdPTE4ODk7ZVszMTM5XT0xODkwO2VbMzE0MF09MTg5MDtlWzMxNDNdPTE4OTE7ZVszMTQ0XT0xODkxO2VbMzE0N109MTg5MjtlWzMxNDhdPTE4OTI7ZVszMTUzXT01ODA7ZVszMTU0XT01ODE7ZVszMTU3XT01ODQ7ZVszMTU4XT01ODU7ZVszMTYxXT01ODg7ZVszMTYyXT01ODk7ZVszMTY1XT04OTE7ZVszMTY2XT04OTI7ZVszMTY5XT0xMjc0O2VbMzE3MF09MTI3NTtlWzMxNzNdPTEyNzg7ZVszMTc0XT0xMjc5O2VbMzE4MV09NzYyMjtlWzMxODJdPTc2MjM7ZVszMjgyXT0xMTc5OTtlWzMzMTZdPTU3ODtlWzMzNzldPTQyNzg1O2VbMzM5M109MTE1OTtlWzM0MTZdPTgzNzd9KSk7dC5nZXRHbHlwaE1hcEZvclN0YW5kYXJkRm9udHM9aDtjb25zdCB1PSgwLHIuZ2V0TG9va3VwVGFibGVGYWN0b3J5KSgoZnVuY3Rpb24oZSl7ZVsyMjddPTMyMjtlWzI2NF09MjYxO2VbMjkxXT0zNDZ9KSk7dC5nZXRTdXBwbGVtZW50YWxHbHlwaE1hcEZvckFyaWFsQmxhY2s9dTtjb25zdCBkPSgwLHIuZ2V0TG9va3VwVGFibGVGYWN0b3J5KSgoZnVuY3Rpb24oZSl7ZVsxXT0zMjtlWzRdPTY1O2VbNl09MTkzO2VbMTddPTY2O2VbMThdPTY3O2VbMjFdPTI2ODtlWzI0XT02ODtlWzI4XT02OTtlWzMwXT0yMDE7ZVszMl09MjgyO2VbMzhdPTcwO2VbMzldPTcxO2VbNDRdPTcyO2VbNDddPTczO2VbNDldPTIwNTtlWzU4XT03NDtlWzYwXT03NTtlWzYyXT03NjtlWzY4XT03NztlWzY5XT03ODtlWzc1XT03OTtlWzg3XT04MDtlWzg5XT04MTtlWzkwXT04MjtlWzkyXT0zNDQ7ZVs5NF09ODM7ZVs5N109MzUyO2VbMTAwXT04NDtlWzEwNF09ODU7ZVsxMTVdPTg2O2VbMTE2XT04NztlWzEyMV09ODg7ZVsxMjJdPTg5O2VbMTI0XT0yMjE7ZVsxMjddPTkwO2VbMTI5XT0zODE7ZVsyNThdPTk3O2VbMjYwXT0yMjU7ZVsyNjhdPTI2MTtlWzI3MV09OTg7ZVsyNzJdPTk5O2VbMjczXT0yNjM7ZVsyNzVdPTI2OTtlWzI4Ml09MTAwO2VbMjg2XT0xMDE7ZVsyODhdPTIzMztlWzI5MF09MjgzO2VbMjk1XT0yODE7ZVsyOTZdPTEwMjtlWzMzNl09MTAzO2VbMzQ2XT0xMDQ7ZVszNDldPTEwNTtlWzM1MV09MjM3O2VbMzYxXT0xMDY7ZVszNjRdPTEwNztlWzM2N109MTA4O2VbMzcxXT0zMjI7ZVszNzNdPTEwOTtlWzM3NF09MTEwO2VbMzgxXT0xMTE7ZVszODNdPTI0MztlWzM5M109MTEyO2VbMzk1XT0xMTM7ZVszOTZdPTExNDtlWzM5OF09MzQ1O2VbNDAwXT0xMTU7ZVs0MDFdPTM0NztlWzQwM109MzUzO2VbNDEwXT0xMTY7ZVs0MzddPTExNztlWzQ0OF09MTE4O2VbNDQ5XT0xMTk7ZVs0NTRdPTEyMDtlWzQ1NV09MTIxO2VbNDU3XT0yNTM7ZVs0NjBdPTEyMjtlWzQ2Ml09MzgyO2VbNDYzXT0zODA7ZVs4NTNdPTQ0O2VbODU1XT01ODtlWzg1Nl09NDY7ZVs4NzZdPTQ3O2VbODc4XT00NTtlWzg4Ml09NDU7ZVs4OTRdPTQwO2VbODk1XT00MTtlWzg5Nl09OTE7ZVs4OTddPTkzO2VbOTIzXT02NDtlWzEwMDRdPTQ4O2VbMTAwNV09NDk7ZVsxMDA2XT01MDtlWzEwMDddPTUxO2VbMTAwOF09NTI7ZVsxMDA5XT01MztlWzEwMTBdPTU0O2VbMTAxMV09NTU7ZVsxMDEyXT01NjtlWzEwMTNdPTU3O2VbMTA4MV09Mzc7ZVsxMDg1XT00MztlWzEwODZdPTQ1fSkpO3QuZ2V0U3VwcGxlbWVudGFsR2x5cGhNYXBGb3JDYWxpYnJpPWR9LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5Ub1VuaWNvZGVNYXA9dC5JZGVudGl0eVRvVW5pY29kZU1hcD12b2lkIDA7dmFyIHI9YSgyKTt0LlRvVW5pY29kZU1hcD1jbGFzcyBUb1VuaWNvZGVNYXB7Y29uc3RydWN0b3IoZT1bXSl7dGhpcy5fbWFwPWV9Z2V0IGxlbmd0aCgpe3JldHVybiB0aGlzLl9tYXAubGVuZ3RofWZvckVhY2goZSl7Zm9yKGNvbnN0IHQgaW4gdGhpcy5fbWFwKWUodCx0aGlzLl9tYXBbdF0uY2hhckNvZGVBdCgwKSl9aGFzKGUpe3JldHVybiB2b2lkIDAhPT10aGlzLl9tYXBbZV19Z2V0KGUpe3JldHVybiB0aGlzLl9tYXBbZV19Y2hhckNvZGVPZihlKXtjb25zdCB0PXRoaXMuX21hcDtpZih0Lmxlbmd0aDw9NjU1MzYpcmV0dXJuIHQuaW5kZXhPZihlKTtmb3IoY29uc3QgYSBpbiB0KWlmKHRbYV09PT1lKXJldHVybiAwfGE7cmV0dXJuLTF9YW1lbmQoZSl7Zm9yKGNvbnN0IHQgaW4gZSl0aGlzLl9tYXBbdF09ZVt0XX19O3QuSWRlbnRpdHlUb1VuaWNvZGVNYXA9Y2xhc3MgSWRlbnRpdHlUb1VuaWNvZGVNYXB7Y29uc3RydWN0b3IoZSx0KXt0aGlzLmZpcnN0Q2hhcj1lO3RoaXMubGFzdENoYXI9dH1nZXQgbGVuZ3RoKCl7cmV0dXJuIHRoaXMubGFzdENoYXIrMS10aGlzLmZpcnN0Q2hhcn1mb3JFYWNoKGUpe2ZvcihsZXQgdD10aGlzLmZpcnN0Q2hhcixhPXRoaXMubGFzdENoYXI7dDw9YTt0KyspZSh0LHQpfWhhcyhlKXtyZXR1cm4gdGhpcy5maXJzdENoYXI8PWUmJmU8PXRoaXMubGFzdENoYXJ9Z2V0KGUpe2lmKHRoaXMuZmlyc3RDaGFyPD1lJiZlPD10aGlzLmxhc3RDaGFyKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpfWNoYXJDb2RlT2YoZSl7cmV0dXJuIE51bWJlci5pc0ludGVnZXIoZSkmJmU+PXRoaXMuZmlyc3RDaGFyJiZlPD10aGlzLmxhc3RDaGFyP2U6LTF9YW1lbmQoZSl7KDAsci51bnJlYWNoYWJsZSkoIlNob3VsZCBub3QgY2FsbCBhbWVuZCgpIil9fX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LkNGRkZvbnQ9dm9pZCAwO3ZhciByPWEoMzUpLG49YSgzOCksaT1hKDIpO3QuQ0ZGRm9udD1jbGFzcyBDRkZGb250e2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5wcm9wZXJ0aWVzPXQ7Y29uc3QgYT1uZXcgci5DRkZQYXJzZXIoZSx0LG4uU0VBQ19BTkFMWVNJU19FTkFCTEVEKTt0aGlzLmNmZj1hLnBhcnNlKCk7dGhpcy5jZmYuZHVwbGljYXRlRmlyc3RHbHlwaCgpO2NvbnN0IHM9bmV3IHIuQ0ZGQ29tcGlsZXIodGhpcy5jZmYpO3RoaXMuc2VhY3M9dGhpcy5jZmYuc2VhY3M7dHJ5e3RoaXMuZGF0YT1zLmNvbXBpbGUoKX1jYXRjaChhKXsoMCxpLndhcm4pKCJGYWlsZWQgdG8gY29tcGlsZSBmb250ICIrdC5sb2FkZWROYW1lKTt0aGlzLmRhdGE9ZX10aGlzLl9jcmVhdGVCdWlsdEluRW5jb2RpbmcoKX1nZXQgbnVtR2x5cGhzKCl7cmV0dXJuIHRoaXMuY2ZmLmNoYXJTdHJpbmdzLmNvdW50fWdldENoYXJzZXQoKXtyZXR1cm4gdGhpcy5jZmYuY2hhcnNldC5jaGFyc2V0fWdldEdseXBoTWFwcGluZygpe2NvbnN0IGU9dGhpcy5jZmYsdD10aGlzLnByb3BlcnRpZXMsYT1lLmNoYXJzZXQuY2hhcnNldDtsZXQgcixpO2lmKHQuY29tcG9zaXRlKXtyPU9iamVjdC5jcmVhdGUobnVsbCk7bGV0IG47aWYoZS5pc0NJREZvbnQpZm9yKGk9MDtpPGEubGVuZ3RoO2krKyl7Y29uc3QgZT1hW2ldO249dC5jTWFwLmNoYXJDb2RlT2YoZSk7cltuXT1pfWVsc2UgZm9yKGk9MDtpPGUuY2hhclN0cmluZ3MuY291bnQ7aSsrKXtuPXQuY01hcC5jaGFyQ29kZU9mKGkpO3Jbbl09aX1yZXR1cm4gcn1sZXQgcz1lLmVuY29kaW5nP2UuZW5jb2RpbmcuZW5jb2Rpbmc6bnVsbDt0LmlzSW50ZXJuYWxGb250JiYocz10LmRlZmF1bHRFbmNvZGluZyk7cj0oMCxuLnR5cGUxRm9udEdseXBoTWFwcGluZykodCxzLGEpO3JldHVybiByfWhhc0dseXBoSWQoZSl7cmV0dXJuIHRoaXMuY2ZmLmhhc0dseXBoSWQoZSl9X2NyZWF0ZUJ1aWx0SW5FbmNvZGluZygpe2NvbnN0e2NoYXJzZXQ6ZSxlbmNvZGluZzp0fT10aGlzLmNmZjtpZighZXx8IXQpcmV0dXJuO2NvbnN0IGE9ZS5jaGFyc2V0LHI9dC5lbmNvZGluZyxuPVtdO2Zvcihjb25zdCBlIGluIHIpe2NvbnN0IHQ9cltlXTtpZih0Pj0wKXtjb25zdCByPWFbdF07ciYmKG5bZV09cil9fW4ubGVuZ3RoPjAmJih0aGlzLnByb3BlcnRpZXMuYnVpbHRJbkVuY29kaW5nPW4pfX19LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5Gb250UmVuZGVyZXJGYWN0b3J5PXZvaWQgMDt2YXIgcj1hKDIpLG49YSgzNSksaT1hKDM5KSxzPWEoMzcpLG89YSgxMCk7ZnVuY3Rpb24gZ2V0VWludDMyKGUsdCl7cmV0dXJuKGVbdF08PDI0fGVbdCsxXTw8MTZ8ZVt0KzJdPDw4fGVbdCszXSk+Pj4wfWZ1bmN0aW9uIGdldFVpbnQxNihlLHQpe3JldHVybiBlW3RdPDw4fGVbdCsxXX1mdW5jdGlvbiBnZXRJbnQxNihlLHQpe3JldHVybihlW3RdPDwyNHxlW3QrMV08PDE2KT4+MTZ9ZnVuY3Rpb24gZ2V0SW50OChlLHQpe3JldHVybiBlW3RdPDwyND4+MjR9ZnVuY3Rpb24gZ2V0RmxvYXQyMTQoZSx0KXtyZXR1cm4gZ2V0SW50MTYoZSx0KS8xNjM4NH1mdW5jdGlvbiBnZXRTdWJyb3V0aW5lQmlhcyhlKXtjb25zdCB0PWUubGVuZ3RoO2xldCBhPTMyNzY4O3Q8MTI0MD9hPTEwNzp0PDMzOTAwJiYoYT0xMTMxKTtyZXR1cm4gYX1mdW5jdGlvbiBwYXJzZUNtYXAoZSx0LGEpe2NvbnN0IG49MT09PWdldFVpbnQxNihlLHQrMik/Z2V0VWludDMyKGUsdCs4KTpnZXRVaW50MzIoZSx0KzE2KSxpPWdldFVpbnQxNihlLHQrbik7bGV0IHMsbyxjO2lmKDQ9PT1pKXtnZXRVaW50MTYoZSx0K24rMik7Y29uc3QgYT1nZXRVaW50MTYoZSx0K24rNik+PjE7bz10K24rMTQ7cz1bXTtmb3IoYz0wO2M8YTtjKyssbys9MilzW2NdPXtlbmQ6Z2V0VWludDE2KGUsbyl9O28rPTI7Zm9yKGM9MDtjPGE7YysrLG8rPTIpc1tjXS5zdGFydD1nZXRVaW50MTYoZSxvKTtmb3IoYz0wO2M8YTtjKyssbys9MilzW2NdLmlkRGVsdGE9Z2V0VWludDE2KGUsbyk7Zm9yKGM9MDtjPGE7YysrLG8rPTIpe2xldCB0PWdldFVpbnQxNihlLG8pO2lmKDAhPT10KXtzW2NdLmlkcz1bXTtmb3IobGV0IGE9MCxyPXNbY10uZW5kLXNbY10uc3RhcnQrMTthPHI7YSsrKXtzW2NdLmlkc1thXT1nZXRVaW50MTYoZSxvK3QpO3QrPTJ9fX1yZXR1cm4gc31pZigxMj09PWkpe2NvbnN0IGE9Z2V0VWludDMyKGUsdCtuKzEyKTtvPXQrbisxNjtzPVtdO2ZvcihjPTA7YzxhO2MrKyl7dD1nZXRVaW50MzIoZSxvKTtzLnB1c2goe3N0YXJ0OnQsZW5kOmdldFVpbnQzMihlLG8rNCksaWREZWx0YTpnZXRVaW50MzIoZSxvKzgpLXR9KTtvKz0xMn1yZXR1cm4gc310aHJvdyBuZXcgci5Gb3JtYXRFcnJvcihgdW5zdXBwb3J0ZWQgY21hcDogJHtpfWApfWZ1bmN0aW9uIHBhcnNlQ2ZmKGUsdCxhLHIpe2NvbnN0IGk9bmV3IG4uQ0ZGUGFyc2VyKG5ldyBvLlN0cmVhbShlLHQsYS10KSx7fSxyKS5wYXJzZSgpO3JldHVybntnbHlwaHM6aS5jaGFyU3RyaW5ncy5vYmplY3RzLHN1YnJzOmkudG9wRGljdC5wcml2YXRlRGljdCYmaS50b3BEaWN0LnByaXZhdGVEaWN0LnN1YnJzSW5kZXgmJmkudG9wRGljdC5wcml2YXRlRGljdC5zdWJyc0luZGV4Lm9iamVjdHMsZ3N1YnJzOmkuZ2xvYmFsU3VickluZGV4JiZpLmdsb2JhbFN1YnJJbmRleC5vYmplY3RzLGlzQ0ZGQ0lERm9udDppLmlzQ0lERm9udCxmZFNlbGVjdDppLmZkU2VsZWN0LGZkQXJyYXk6aS5mZEFycmF5fX1mdW5jdGlvbiBsb29rdXBDbWFwKGUsdCl7Y29uc3QgYT10LmNvZGVQb2ludEF0KDApO2xldCByPTAsbj0wLGk9ZS5sZW5ndGgtMTtmb3IoO248aTspe2NvbnN0IHQ9bitpKzE+PjE7YTxlW3RdLnN0YXJ0P2k9dC0xOm49dH1lW25dLnN0YXJ0PD1hJiZhPD1lW25dLmVuZCYmKHI9ZVtuXS5pZERlbHRhKyhlW25dLmlkcz9lW25dLmlkc1thLWVbbl0uc3RhcnRdOmEpJjY1NTM1KTtyZXR1cm57Y2hhckNvZGU6YSxnbHlwaElkOnJ9fWZ1bmN0aW9uIGNvbXBpbGVHbHlmKGUsdCxhKXtmdW5jdGlvbiBtb3ZlVG8oZSxhKXt0LnB1c2goe2NtZDoibW92ZVRvIixhcmdzOltlLGFdfSl9ZnVuY3Rpb24gbGluZVRvKGUsYSl7dC5wdXNoKHtjbWQ6ImxpbmVUbyIsYXJnczpbZSxhXX0pfWZ1bmN0aW9uIHF1YWRyYXRpY0N1cnZlVG8oZSxhLHIsbil7dC5wdXNoKHtjbWQ6InF1YWRyYXRpY0N1cnZlVG8iLGFyZ3M6W2UsYSxyLG5dfSl9bGV0IHI9MDtjb25zdCBuPWdldEludDE2KGUscik7bGV0IGkscz0wLG89MDtyKz0xMDtpZihuPDApZG97aT1nZXRVaW50MTYoZSxyKTtjb25zdCBuPWdldFVpbnQxNihlLHIrMik7cis9NDtsZXQgYyxsO2lmKDEmaSl7aWYoMiZpKXtjPWdldEludDE2KGUscik7bD1nZXRJbnQxNihlLHIrMil9ZWxzZXtjPWdldFVpbnQxNihlLHIpO2w9Z2V0VWludDE2KGUscisyKX1yKz00fWVsc2UgaWYoMiZpKXtjPWdldEludDgoZSxyKyspO2w9Z2V0SW50OChlLHIrKyl9ZWxzZXtjPWVbcisrXTtsPWVbcisrXX1pZigyJmkpe3M9YztvPWx9ZWxzZXtzPTA7bz0wfWxldCBoPTEsdT0xLGQ9MCxmPTA7aWYoOCZpKXtoPXU9Z2V0RmxvYXQyMTQoZSxyKTtyKz0yfWVsc2UgaWYoNjQmaSl7aD1nZXRGbG9hdDIxNChlLHIpO3U9Z2V0RmxvYXQyMTQoZSxyKzIpO3IrPTR9ZWxzZSBpZigxMjgmaSl7aD1nZXRGbG9hdDIxNChlLHIpO2Q9Z2V0RmxvYXQyMTQoZSxyKzIpO2Y9Z2V0RmxvYXQyMTQoZSxyKzQpO3U9Z2V0RmxvYXQyMTQoZSxyKzYpO3IrPTh9Y29uc3QgZz1hLmdseXBoc1tuXTtpZihnKXt0LnB1c2goe2NtZDoic2F2ZSJ9LHtjbWQ6InRyYW5zZm9ybSIsYXJnczpbaCxkLGYsdSxzLG9dfSk7Y29tcGlsZUdseWYoZyx0LGEpO3QucHVzaCh7Y21kOiJyZXN0b3JlIn0pfX13aGlsZSgzMiZpKTtlbHNle2NvbnN0IHQ9W107bGV0IGEsYztmb3IoYT0wO2E8bjthKyspe3QucHVzaChnZXRVaW50MTYoZSxyKSk7cis9Mn1yKz0yK2dldFVpbnQxNihlLHIpO2NvbnN0IGw9dC5hdCgtMSkrMSxoPVtdO2Zvcig7aC5sZW5ndGg8bDspe2k9ZVtyKytdO2xldCB0PTE7OCZpJiYodCs9ZVtyKytdKTtmb3IoO3QtLSA+MDspaC5wdXNoKHtmbGFnczppfSl9Zm9yKGE9MDthPGw7YSsrKXtzd2l0Y2goMTgmaFthXS5mbGFncyl7Y2FzZSAwOnMrPWdldEludDE2KGUscik7cis9MjticmVhaztjYXNlIDI6cy09ZVtyKytdO2JyZWFrO2Nhc2UgMTg6cys9ZVtyKytdfWhbYV0ueD1zfWZvcihhPTA7YTxsO2ErKyl7c3dpdGNoKDM2JmhbYV0uZmxhZ3Mpe2Nhc2UgMDpvKz1nZXRJbnQxNihlLHIpO3IrPTI7YnJlYWs7Y2FzZSA0Om8tPWVbcisrXTticmVhaztjYXNlIDM2Om8rPWVbcisrXX1oW2FdLnk9b31sZXQgdT0wO2ZvcihyPTA7cjxuO3IrKyl7Y29uc3QgZT10W3JdLG49aC5zbGljZSh1LGUrMSk7aWYoMSZuWzBdLmZsYWdzKW4ucHVzaChuWzBdKTtlbHNlIGlmKDEmbi5hdCgtMSkuZmxhZ3Mpbi51bnNoaWZ0KG4uYXQoLTEpKTtlbHNle2NvbnN0IGU9e2ZsYWdzOjEseDooblswXS54K24uYXQoLTEpLngpLzIseTooblswXS55K24uYXQoLTEpLnkpLzJ9O24udW5zaGlmdChlKTtuLnB1c2goZSl9bW92ZVRvKG5bMF0ueCxuWzBdLnkpO2ZvcihhPTEsYz1uLmxlbmd0aDthPGM7YSsrKWlmKDEmblthXS5mbGFncylsaW5lVG8oblthXS54LG5bYV0ueSk7ZWxzZSBpZigxJm5bYSsxXS5mbGFncyl7cXVhZHJhdGljQ3VydmVUbyhuW2FdLngsblthXS55LG5bYSsxXS54LG5bYSsxXS55KTthKyt9ZWxzZSBxdWFkcmF0aWNDdXJ2ZVRvKG5bYV0ueCxuW2FdLnksKG5bYV0ueCtuW2ErMV0ueCkvMiwoblthXS55K25bYSsxXS55KS8yKTt1PWUrMX19fWZ1bmN0aW9uIGNvbXBpbGVDaGFyU3RyaW5nKGUsdCxhLG4pe2Z1bmN0aW9uIG1vdmVUbyhlLGEpe3QucHVzaCh7Y21kOiJtb3ZlVG8iLGFyZ3M6W2UsYV19KX1mdW5jdGlvbiBsaW5lVG8oZSxhKXt0LnB1c2goe2NtZDoibGluZVRvIixhcmdzOltlLGFdfSl9ZnVuY3Rpb24gYmV6aWVyQ3VydmVUbyhlLGEscixuLGkscyl7dC5wdXNoKHtjbWQ6ImJlemllckN1cnZlVG8iLGFyZ3M6W2UsYSxyLG4saSxzXX0pfWNvbnN0IGk9W107bGV0IG89MCxjPTAsbD0wOyFmdW5jdGlvbiBwYXJzZShlKXtsZXQgaD0wO2Zvcig7aDxlLmxlbmd0aDspe2xldCB1LGQsZixnLHAsbSxiLHksdyxTPSExLHg9ZVtoKytdO3N3aXRjaCh4KXtjYXNlIDE6Y2FzZSAzOmNhc2UgMTg6Y2FzZSAyMzpsKz1pLmxlbmd0aD4+MTtTPSEwO2JyZWFrO2Nhc2UgNDpjKz1pLnBvcCgpO21vdmVUbyhvLGMpO1M9ITA7YnJlYWs7Y2FzZSA1OmZvcig7aS5sZW5ndGg+MDspe28rPWkuc2hpZnQoKTtjKz1pLnNoaWZ0KCk7bGluZVRvKG8sYyl9YnJlYWs7Y2FzZSA2OmZvcig7aS5sZW5ndGg+MDspe28rPWkuc2hpZnQoKTtsaW5lVG8obyxjKTtpZigwPT09aS5sZW5ndGgpYnJlYWs7Yys9aS5zaGlmdCgpO2xpbmVUbyhvLGMpfWJyZWFrO2Nhc2UgNzpmb3IoO2kubGVuZ3RoPjA7KXtjKz1pLnNoaWZ0KCk7bGluZVRvKG8sYyk7aWYoMD09PWkubGVuZ3RoKWJyZWFrO28rPWkuc2hpZnQoKTtsaW5lVG8obyxjKX1icmVhaztjYXNlIDg6Zm9yKDtpLmxlbmd0aD4wOyl7dT1vK2kuc2hpZnQoKTtmPWMraS5zaGlmdCgpO2Q9dStpLnNoaWZ0KCk7Zz1mK2kuc2hpZnQoKTtvPWQraS5zaGlmdCgpO2M9ZytpLnNoaWZ0KCk7YmV6aWVyQ3VydmVUbyh1LGYsZCxnLG8sYyl9YnJlYWs7Y2FzZSAxMDp5PWkucG9wKCk7dz1udWxsO2lmKGEuaXNDRkZDSURGb250KXtjb25zdCBlPWEuZmRTZWxlY3QuZ2V0RkRJbmRleChuKTtpZihlPj0wJiZlPGEuZmRBcnJheS5sZW5ndGgpe2NvbnN0IHQ9YS5mZEFycmF5W2VdO2xldCByO3QucHJpdmF0ZURpY3QmJnQucHJpdmF0ZURpY3Quc3VicnNJbmRleCYmKHI9dC5wcml2YXRlRGljdC5zdWJyc0luZGV4Lm9iamVjdHMpO2lmKHIpe3krPWdldFN1YnJvdXRpbmVCaWFzKHIpO3c9clt5XX19ZWxzZSgwLHIud2FybikoIkludmFsaWQgZmQgaW5kZXggZm9yIGdseXBoIGluZGV4LiIpfWVsc2Ugdz1hLnN1YnJzW3krYS5zdWJyc0JpYXNdO3cmJnBhcnNlKHcpO2JyZWFrO2Nhc2UgMTE6cmV0dXJuO2Nhc2UgMTI6eD1lW2grK107c3dpdGNoKHgpe2Nhc2UgMzQ6dT1vK2kuc2hpZnQoKTtkPXUraS5zaGlmdCgpO3A9YytpLnNoaWZ0KCk7bz1kK2kuc2hpZnQoKTtiZXppZXJDdXJ2ZVRvKHUsYyxkLHAsbyxwKTt1PW8raS5zaGlmdCgpO2Q9dStpLnNoaWZ0KCk7bz1kK2kuc2hpZnQoKTtiZXppZXJDdXJ2ZVRvKHUscCxkLGMsbyxjKTticmVhaztjYXNlIDM1OnU9bytpLnNoaWZ0KCk7Zj1jK2kuc2hpZnQoKTtkPXUraS5zaGlmdCgpO2c9ZitpLnNoaWZ0KCk7bz1kK2kuc2hpZnQoKTtjPWcraS5zaGlmdCgpO2JlemllckN1cnZlVG8odSxmLGQsZyxvLGMpO3U9bytpLnNoaWZ0KCk7Zj1jK2kuc2hpZnQoKTtkPXUraS5zaGlmdCgpO2c9ZitpLnNoaWZ0KCk7bz1kK2kuc2hpZnQoKTtjPWcraS5zaGlmdCgpO2JlemllckN1cnZlVG8odSxmLGQsZyxvLGMpO2kucG9wKCk7YnJlYWs7Y2FzZSAzNjp1PW8raS5zaGlmdCgpO3A9YytpLnNoaWZ0KCk7ZD11K2kuc2hpZnQoKTttPXAraS5zaGlmdCgpO289ZCtpLnNoaWZ0KCk7YmV6aWVyQ3VydmVUbyh1LHAsZCxtLG8sbSk7dT1vK2kuc2hpZnQoKTtkPXUraS5zaGlmdCgpO2I9bStpLnNoaWZ0KCk7bz1kK2kuc2hpZnQoKTtiZXppZXJDdXJ2ZVRvKHUsbSxkLGIsbyxjKTticmVhaztjYXNlIDM3OmNvbnN0IGU9byx0PWM7dT1vK2kuc2hpZnQoKTtmPWMraS5zaGlmdCgpO2Q9dStpLnNoaWZ0KCk7Zz1mK2kuc2hpZnQoKTtvPWQraS5zaGlmdCgpO2M9ZytpLnNoaWZ0KCk7YmV6aWVyQ3VydmVUbyh1LGYsZCxnLG8sYyk7dT1vK2kuc2hpZnQoKTtmPWMraS5zaGlmdCgpO2Q9dStpLnNoaWZ0KCk7Zz1mK2kuc2hpZnQoKTtvPWQ7Yz1nO01hdGguYWJzKG8tZSk+TWF0aC5hYnMoYy10KT9vKz1pLnNoaWZ0KCk6Yys9aS5zaGlmdCgpO2JlemllckN1cnZlVG8odSxmLGQsZyxvLGMpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoYHVua25vd24gb3BlcmF0b3I6IDEyICR7eH1gKX1icmVhaztjYXNlIDE0OmlmKGkubGVuZ3RoPj00KXtjb25zdCBlPWkucG9wKCkscj1pLnBvcCgpO2M9aS5wb3AoKTtvPWkucG9wKCk7dC5wdXNoKHtjbWQ6InNhdmUifSx7Y21kOiJ0cmFuc2xhdGUiLGFyZ3M6W28sY119KTtsZXQgbj1sb29rdXBDbWFwKGEuY21hcCxTdHJpbmcuZnJvbUNoYXJDb2RlKGEuZ2x5cGhOYW1lTWFwW3MuU3RhbmRhcmRFbmNvZGluZ1tlXV0pKTtjb21waWxlQ2hhclN0cmluZyhhLmdseXBoc1tuLmdseXBoSWRdLHQsYSxuLmdseXBoSWQpO3QucHVzaCh7Y21kOiJyZXN0b3JlIn0pO249bG9va3VwQ21hcChhLmNtYXAsU3RyaW5nLmZyb21DaGFyQ29kZShhLmdseXBoTmFtZU1hcFtzLlN0YW5kYXJkRW5jb2Rpbmdbcl1dKSk7Y29tcGlsZUNoYXJTdHJpbmcoYS5nbHlwaHNbbi5nbHlwaElkXSx0LGEsbi5nbHlwaElkKX1yZXR1cm47Y2FzZSAxOTpjYXNlIDIwOmwrPWkubGVuZ3RoPj4xO2grPWwrNz4+MztTPSEwO2JyZWFrO2Nhc2UgMjE6Yys9aS5wb3AoKTtvKz1pLnBvcCgpO21vdmVUbyhvLGMpO1M9ITA7YnJlYWs7Y2FzZSAyMjpvKz1pLnBvcCgpO21vdmVUbyhvLGMpO1M9ITA7YnJlYWs7Y2FzZSAyNDpmb3IoO2kubGVuZ3RoPjI7KXt1PW8raS5zaGlmdCgpO2Y9YytpLnNoaWZ0KCk7ZD11K2kuc2hpZnQoKTtnPWYraS5zaGlmdCgpO289ZCtpLnNoaWZ0KCk7Yz1nK2kuc2hpZnQoKTtiZXppZXJDdXJ2ZVRvKHUsZixkLGcsbyxjKX1vKz1pLnNoaWZ0KCk7Yys9aS5zaGlmdCgpO2xpbmVUbyhvLGMpO2JyZWFrO2Nhc2UgMjU6Zm9yKDtpLmxlbmd0aD42Oyl7bys9aS5zaGlmdCgpO2MrPWkuc2hpZnQoKTtsaW5lVG8obyxjKX11PW8raS5zaGlmdCgpO2Y9YytpLnNoaWZ0KCk7ZD11K2kuc2hpZnQoKTtnPWYraS5zaGlmdCgpO289ZCtpLnNoaWZ0KCk7Yz1nK2kuc2hpZnQoKTtiZXppZXJDdXJ2ZVRvKHUsZixkLGcsbyxjKTticmVhaztjYXNlIDI2OmkubGVuZ3RoJTImJihvKz1pLnNoaWZ0KCkpO2Zvcig7aS5sZW5ndGg+MDspe3U9bztmPWMraS5zaGlmdCgpO2Q9dStpLnNoaWZ0KCk7Zz1mK2kuc2hpZnQoKTtvPWQ7Yz1nK2kuc2hpZnQoKTtiZXppZXJDdXJ2ZVRvKHUsZixkLGcsbyxjKX1icmVhaztjYXNlIDI3OmkubGVuZ3RoJTImJihjKz1pLnNoaWZ0KCkpO2Zvcig7aS5sZW5ndGg+MDspe3U9bytpLnNoaWZ0KCk7Zj1jO2Q9dStpLnNoaWZ0KCk7Zz1mK2kuc2hpZnQoKTtvPWQraS5zaGlmdCgpO2M9ZztiZXppZXJDdXJ2ZVRvKHUsZixkLGcsbyxjKX1icmVhaztjYXNlIDI4OmkucHVzaCgoZVtoXTw8MjR8ZVtoKzFdPDwxNik+PjE2KTtoKz0yO2JyZWFrO2Nhc2UgMjk6eT1pLnBvcCgpK2EuZ3N1YnJzQmlhczt3PWEuZ3N1YnJzW3ldO3cmJnBhcnNlKHcpO2JyZWFrO2Nhc2UgMzA6Zm9yKDtpLmxlbmd0aD4wOyl7dT1vO2Y9YytpLnNoaWZ0KCk7ZD11K2kuc2hpZnQoKTtnPWYraS5zaGlmdCgpO289ZCtpLnNoaWZ0KCk7Yz1nKygxPT09aS5sZW5ndGg/aS5zaGlmdCgpOjApO2JlemllckN1cnZlVG8odSxmLGQsZyxvLGMpO2lmKDA9PT1pLmxlbmd0aClicmVhazt1PW8raS5zaGlmdCgpO2Y9YztkPXUraS5zaGlmdCgpO2c9ZitpLnNoaWZ0KCk7Yz1nK2kuc2hpZnQoKTtvPWQrKDE9PT1pLmxlbmd0aD9pLnNoaWZ0KCk6MCk7YmV6aWVyQ3VydmVUbyh1LGYsZCxnLG8sYyl9YnJlYWs7Y2FzZSAzMTpmb3IoO2kubGVuZ3RoPjA7KXt1PW8raS5zaGlmdCgpO2Y9YztkPXUraS5zaGlmdCgpO2c9ZitpLnNoaWZ0KCk7Yz1nK2kuc2hpZnQoKTtvPWQrKDE9PT1pLmxlbmd0aD9pLnNoaWZ0KCk6MCk7YmV6aWVyQ3VydmVUbyh1LGYsZCxnLG8sYyk7aWYoMD09PWkubGVuZ3RoKWJyZWFrO3U9bztmPWMraS5zaGlmdCgpO2Q9dStpLnNoaWZ0KCk7Zz1mK2kuc2hpZnQoKTtvPWQraS5zaGlmdCgpO2M9ZysoMT09PWkubGVuZ3RoP2kuc2hpZnQoKTowKTtiZXppZXJDdXJ2ZVRvKHUsZixkLGcsbyxjKX1icmVhaztkZWZhdWx0OmlmKHg8MzIpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoYHVua25vd24gb3BlcmF0b3I6ICR7eH1gKTtpZih4PDI0NylpLnB1c2goeC0xMzkpO2Vsc2UgaWYoeDwyNTEpaS5wdXNoKDI1NiooeC0yNDcpK2VbaCsrXSsxMDgpO2Vsc2UgaWYoeDwyNTUpaS5wdXNoKDI1NiotKHgtMjUxKS1lW2grK10tMTA4KTtlbHNle2kucHVzaCgoZVtoXTw8MjR8ZVtoKzFdPDwxNnxlW2grMl08PDh8ZVtoKzNdKS82NTUzNik7aCs9NH19UyYmKGkubGVuZ3RoPTApfX0oZSl9Y29uc3QgYz1bXTtjbGFzcyBDb21waWxlZEZvbnR7Y29uc3RydWN0b3IoZSl7dGhpcy5jb25zdHJ1Y3Rvcj09PUNvbXBpbGVkRm9udCYmKDAsci51bnJlYWNoYWJsZSkoIkNhbm5vdCBpbml0aWFsaXplIENvbXBpbGVkRm9udC4iKTt0aGlzLmZvbnRNYXRyaXg9ZTt0aGlzLmNvbXBpbGVkR2x5cGhzPU9iamVjdC5jcmVhdGUobnVsbCk7dGhpcy5jb21waWxlZENoYXJDb2RlVG9HbHlwaElkPU9iamVjdC5jcmVhdGUobnVsbCl9Z2V0UGF0aEpzKGUpe2NvbnN0e2NoYXJDb2RlOnQsZ2x5cGhJZDphfT1sb29rdXBDbWFwKHRoaXMuY21hcCxlKTtsZXQgcj10aGlzLmNvbXBpbGVkR2x5cGhzW2FdO2lmKCFyKXRyeXtyPXRoaXMuY29tcGlsZUdseXBoKHRoaXMuZ2x5cGhzW2FdLGEpO3RoaXMuY29tcGlsZWRHbHlwaHNbYV09cn1jYXRjaChlKXt0aGlzLmNvbXBpbGVkR2x5cGhzW2FdPWM7dm9pZCAwPT09dGhpcy5jb21waWxlZENoYXJDb2RlVG9HbHlwaElkW3RdJiYodGhpcy5jb21waWxlZENoYXJDb2RlVG9HbHlwaElkW3RdPWEpO3Rocm93IGV9dm9pZCAwPT09dGhpcy5jb21waWxlZENoYXJDb2RlVG9HbHlwaElkW3RdJiYodGhpcy5jb21waWxlZENoYXJDb2RlVG9HbHlwaElkW3RdPWEpO3JldHVybiByfWNvbXBpbGVHbHlwaChlLHQpe2lmKCFlfHwwPT09ZS5sZW5ndGh8fDE0PT09ZVswXSlyZXR1cm4gYztsZXQgYT10aGlzLmZvbnRNYXRyaXg7aWYodGhpcy5pc0NGRkNJREZvbnQpe2NvbnN0IGU9dGhpcy5mZFNlbGVjdC5nZXRGREluZGV4KHQpO2lmKGU+PTAmJmU8dGhpcy5mZEFycmF5Lmxlbmd0aCl7YT10aGlzLmZkQXJyYXlbZV0uZ2V0QnlOYW1lKCJGb250TWF0cml4Iil8fHIuRk9OVF9JREVOVElUWV9NQVRSSVh9ZWxzZSgwLHIud2FybikoIkludmFsaWQgZmQgaW5kZXggZm9yIGdseXBoIGluZGV4LiIpfWNvbnN0IG49W3tjbWQ6InNhdmUifSx7Y21kOiJ0cmFuc2Zvcm0iLGFyZ3M6YS5zbGljZSgpfSx7Y21kOiJzY2FsZSIsYXJnczpbInNpemUiLCItc2l6ZSJdfV07dGhpcy5jb21waWxlR2x5cGhJbXBsKGUsbix0KTtuLnB1c2goe2NtZDoicmVzdG9yZSJ9KTtyZXR1cm4gbn1jb21waWxlR2x5cGhJbXBsKCl7KDAsci51bnJlYWNoYWJsZSkoIkNoaWxkcmVuIGNsYXNzZXMgc2hvdWxkIGltcGxlbWVudCB0aGlzLiIpfWhhc0J1aWx0UGF0aChlKXtjb25zdHtjaGFyQ29kZTp0LGdseXBoSWQ6YX09bG9va3VwQ21hcCh0aGlzLmNtYXAsZSk7cmV0dXJuIHZvaWQgMCE9PXRoaXMuY29tcGlsZWRHbHlwaHNbYV0mJnZvaWQgMCE9PXRoaXMuY29tcGlsZWRDaGFyQ29kZVRvR2x5cGhJZFt0XX19Y2xhc3MgVHJ1ZVR5cGVDb21waWxlZCBleHRlbmRzIENvbXBpbGVkRm9udHtjb25zdHJ1Y3RvcihlLHQsYSl7c3VwZXIoYXx8WzQ4OGUtNiwwLDAsNDg4ZS02LDAsMF0pO3RoaXMuZ2x5cGhzPWU7dGhpcy5jbWFwPXR9Y29tcGlsZUdseXBoSW1wbChlLHQpe2NvbXBpbGVHbHlmKGUsdCx0aGlzKX19Y2xhc3MgVHlwZTJDb21waWxlZCBleHRlbmRzIENvbXBpbGVkRm9udHtjb25zdHJ1Y3RvcihlLHQsYSxyKXtzdXBlcihhfHxbLjAwMSwwLDAsLjAwMSwwLDBdKTt0aGlzLmdseXBocz1lLmdseXBoczt0aGlzLmdzdWJycz1lLmdzdWJyc3x8W107dGhpcy5zdWJycz1lLnN1YnJzfHxbXTt0aGlzLmNtYXA9dDt0aGlzLmdseXBoTmFtZU1hcD1yfHwoMCxpLmdldEdseXBoc1VuaWNvZGUpKCk7dGhpcy5nc3VicnNCaWFzPWdldFN1YnJvdXRpbmVCaWFzKHRoaXMuZ3N1YnJzKTt0aGlzLnN1YnJzQmlhcz1nZXRTdWJyb3V0aW5lQmlhcyh0aGlzLnN1YnJzKTt0aGlzLmlzQ0ZGQ0lERm9udD1lLmlzQ0ZGQ0lERm9udDt0aGlzLmZkU2VsZWN0PWUuZmRTZWxlY3Q7dGhpcy5mZEFycmF5PWUuZmRBcnJheX1jb21waWxlR2x5cGhJbXBsKGUsdCxhKXtjb21waWxlQ2hhclN0cmluZyhlLHQsdGhpcyxhKX19dC5Gb250UmVuZGVyZXJGYWN0b3J5PWNsYXNzIEZvbnRSZW5kZXJlckZhY3Rvcnl7c3RhdGljIGNyZWF0ZShlLHQpe2NvbnN0IGE9bmV3IFVpbnQ4QXJyYXkoZS5kYXRhKTtsZXQgbixpLHMsbyxjLGw7Y29uc3QgaD1nZXRVaW50MTYoYSw0KTtmb3IobGV0IGU9MCx1PTEyO2U8aDtlKyssdSs9MTYpe2NvbnN0IGU9KDAsci5ieXRlc1RvU3RyaW5nKShhLnN1YmFycmF5KHUsdSs0KSksaD1nZXRVaW50MzIoYSx1KzgpLGQ9Z2V0VWludDMyKGEsdSsxMik7c3dpdGNoKGUpe2Nhc2UiY21hcCI6bj1wYXJzZUNtYXAoYSxoKTticmVhaztjYXNlImdseWYiOmk9YS5zdWJhcnJheShoLGgrZCk7YnJlYWs7Y2FzZSJsb2NhIjpzPWEuc3ViYXJyYXkoaCxoK2QpO2JyZWFrO2Nhc2UiaGVhZCI6bD1nZXRVaW50MTYoYSxoKzE4KTtjPWdldFVpbnQxNihhLGgrNTApO2JyZWFrO2Nhc2UiQ0ZGICI6bz1wYXJzZUNmZihhLGgsaCtkLHQpfX1pZihpKXtjb25zdCB0PWw/WzEvbCwwLDAsMS9sLDAsMF06ZS5mb250TWF0cml4O3JldHVybiBuZXcgVHJ1ZVR5cGVDb21waWxlZChmdW5jdGlvbiBwYXJzZUdseWZUYWJsZShlLHQsYSl7bGV0IHIsbjtpZihhKXtyPTQ7bj1nZXRVaW50MzJ9ZWxzZXtyPTI7bj0oZSx0KT0+MipnZXRVaW50MTYoZSx0KX1jb25zdCBpPVtdO2xldCBzPW4odCwwKTtmb3IobGV0IGE9cjthPHQubGVuZ3RoO2ErPXIpe2NvbnN0IHI9bih0LGEpO2kucHVzaChlLnN1YmFycmF5KHMscikpO3M9cn1yZXR1cm4gaX0oaSxzLGMpLG4sdCl9cmV0dXJuIG5ldyBUeXBlMkNvbXBpbGVkKG8sbixlLmZvbnRNYXRyaXgsZS5nbHlwaE5hbWVNYXApfX19LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5nZXRNZXRyaWNzPXQuZ2V0Rm9udEJhc2ljTWV0cmljcz12b2lkIDA7dmFyIHI9YSg2KTtjb25zdCBuPSgwLHIuZ2V0TG9va3VwVGFibGVGYWN0b3J5KSgoZnVuY3Rpb24oZSl7ZS5Db3VyaWVyPTYwMDtlWyJDb3VyaWVyLUJvbGQiXT02MDA7ZVsiQ291cmllci1Cb2xkT2JsaXF1ZSJdPTYwMDtlWyJDb3VyaWVyLU9ibGlxdWUiXT02MDA7ZS5IZWx2ZXRpY2E9KDAsci5nZXRMb29rdXBUYWJsZUZhY3RvcnkpKChmdW5jdGlvbihlKXtlLnNwYWNlPTI3ODtlLmV4Y2xhbT0yNzg7ZS5xdW90ZWRibD0zNTU7ZS5udW1iZXJzaWduPTU1NjtlLmRvbGxhcj01NTY7ZS5wZXJjZW50PTg4OTtlLmFtcGVyc2FuZD02Njc7ZS5xdW90ZXJpZ2h0PTIyMjtlLnBhcmVubGVmdD0zMzM7ZS5wYXJlbnJpZ2h0PTMzMztlLmFzdGVyaXNrPTM4OTtlLnBsdXM9NTg0O2UuY29tbWE9Mjc4O2UuaHlwaGVuPTMzMztlLnBlcmlvZD0yNzg7ZS5zbGFzaD0yNzg7ZS56ZXJvPTU1NjtlLm9uZT01NTY7ZS50d289NTU2O2UudGhyZWU9NTU2O2UuZm91cj01NTY7ZS5maXZlPTU1NjtlLnNpeD01NTY7ZS5zZXZlbj01NTY7ZS5laWdodD01NTY7ZS5uaW5lPTU1NjtlLmNvbG9uPTI3ODtlLnNlbWljb2xvbj0yNzg7ZS5sZXNzPTU4NDtlLmVxdWFsPTU4NDtlLmdyZWF0ZXI9NTg0O2UucXVlc3Rpb249NTU2O2UuYXQ9MTAxNTtlLkE9NjY3O2UuQj02Njc7ZS5DPTcyMjtlLkQ9NzIyO2UuRT02Njc7ZS5GPTYxMTtlLkc9Nzc4O2UuSD03MjI7ZS5JPTI3ODtlLko9NTAwO2UuSz02Njc7ZS5MPTU1NjtlLk09ODMzO2UuTj03MjI7ZS5PPTc3ODtlLlA9NjY3O2UuUT03Nzg7ZS5SPTcyMjtlLlM9NjY3O2UuVD02MTE7ZS5VPTcyMjtlLlY9NjY3O2UuVz05NDQ7ZS5YPTY2NztlLlk9NjY3O2UuWj02MTE7ZS5icmFja2V0bGVmdD0yNzg7ZS5iYWNrc2xhc2g9Mjc4O2UuYnJhY2tldHJpZ2h0PTI3ODtlLmFzY2lpY2lyY3VtPTQ2OTtlLnVuZGVyc2NvcmU9NTU2O2UucXVvdGVsZWZ0PTIyMjtlLmE9NTU2O2UuYj01NTY7ZS5jPTUwMDtlLmQ9NTU2O2UuZT01NTY7ZS5mPTI3ODtlLmc9NTU2O2UuaD01NTY7ZS5pPTIyMjtlLmo9MjIyO2Uuaz01MDA7ZS5sPTIyMjtlLm09ODMzO2Uubj01NTY7ZS5vPTU1NjtlLnA9NTU2O2UucT01NTY7ZS5yPTMzMztlLnM9NTAwO2UudD0yNzg7ZS51PTU1NjtlLnY9NTAwO2Uudz03MjI7ZS54PTUwMDtlLnk9NTAwO2Uuej01MDA7ZS5icmFjZWxlZnQ9MzM0O2UuYmFyPTI2MDtlLmJyYWNlcmlnaHQ9MzM0O2UuYXNjaWl0aWxkZT01ODQ7ZS5leGNsYW1kb3duPTMzMztlLmNlbnQ9NTU2O2Uuc3Rlcmxpbmc9NTU2O2UuZnJhY3Rpb249MTY3O2UueWVuPTU1NjtlLmZsb3Jpbj01NTY7ZS5zZWN0aW9uPTU1NjtlLmN1cnJlbmN5PTU1NjtlLnF1b3Rlc2luZ2xlPTE5MTtlLnF1b3RlZGJsbGVmdD0zMzM7ZS5ndWlsbGVtb3RsZWZ0PTU1NjtlLmd1aWxzaW5nbGxlZnQ9MzMzO2UuZ3VpbHNpbmdscmlnaHQ9MzMzO2UuZmk9NTAwO2UuZmw9NTAwO2UuZW5kYXNoPTU1NjtlLmRhZ2dlcj01NTY7ZS5kYWdnZXJkYmw9NTU2O2UucGVyaW9kY2VudGVyZWQ9Mjc4O2UucGFyYWdyYXBoPTUzNztlLmJ1bGxldD0zNTA7ZS5xdW90ZXNpbmdsYmFzZT0yMjI7ZS5xdW90ZWRibGJhc2U9MzMzO2UucXVvdGVkYmxyaWdodD0zMzM7ZS5ndWlsbGVtb3RyaWdodD01NTY7ZS5lbGxpcHNpcz0xZTM7ZS5wZXJ0aG91c2FuZD0xZTM7ZS5xdWVzdGlvbmRvd249NjExO2UuZ3JhdmU9MzMzO2UuYWN1dGU9MzMzO2UuY2lyY3VtZmxleD0zMzM7ZS50aWxkZT0zMzM7ZS5tYWNyb249MzMzO2UuYnJldmU9MzMzO2UuZG90YWNjZW50PTMzMztlLmRpZXJlc2lzPTMzMztlLnJpbmc9MzMzO2UuY2VkaWxsYT0zMzM7ZS5odW5nYXJ1bWxhdXQ9MzMzO2Uub2dvbmVrPTMzMztlLmNhcm9uPTMzMztlLmVtZGFzaD0xZTM7ZS5BRT0xZTM7ZS5vcmRmZW1pbmluZT0zNzA7ZS5Mc2xhc2g9NTU2O2UuT3NsYXNoPTc3ODtlLk9FPTFlMztlLm9yZG1hc2N1bGluZT0zNjU7ZS5hZT04ODk7ZS5kb3RsZXNzaT0yNzg7ZS5sc2xhc2g9MjIyO2Uub3NsYXNoPTYxMTtlLm9lPTk0NDtlLmdlcm1hbmRibHM9NjExO2UuSWRpZXJlc2lzPTI3ODtlLmVhY3V0ZT01NTY7ZS5hYnJldmU9NTU2O2UudWh1bmdhcnVtbGF1dD01NTY7ZS5lY2Fyb249NTU2O2UuWWRpZXJlc2lzPTY2NztlLmRpdmlkZT01ODQ7ZS5ZYWN1dGU9NjY3O2UuQWNpcmN1bWZsZXg9NjY3O2UuYWFjdXRlPTU1NjtlLlVjaXJjdW1mbGV4PTcyMjtlLnlhY3V0ZT01MDA7ZS5zY29tbWFhY2NlbnQ9NTAwO2UuZWNpcmN1bWZsZXg9NTU2O2UuVXJpbmc9NzIyO2UuVWRpZXJlc2lzPTcyMjtlLmFvZ29uZWs9NTU2O2UuVWFjdXRlPTcyMjtlLnVvZ29uZWs9NTU2O2UuRWRpZXJlc2lzPTY2NztlLkRjcm9hdD03MjI7ZS5jb21tYWFjY2VudD0yNTA7ZS5jb3B5cmlnaHQ9NzM3O2UuRW1hY3Jvbj02Njc7ZS5jY2Fyb249NTAwO2UuYXJpbmc9NTU2O2UuTmNvbW1hYWNjZW50PTcyMjtlLmxhY3V0ZT0yMjI7ZS5hZ3JhdmU9NTU2O2UuVGNvbW1hYWNjZW50PTYxMTtlLkNhY3V0ZT03MjI7ZS5hdGlsZGU9NTU2O2UuRWRvdGFjY2VudD02Njc7ZS5zY2Fyb249NTAwO2Uuc2NlZGlsbGE9NTAwO2UuaWFjdXRlPTI3ODtlLmxvemVuZ2U9NDcxO2UuUmNhcm9uPTcyMjtlLkdjb21tYWFjY2VudD03Nzg7ZS51Y2lyY3VtZmxleD01NTY7ZS5hY2lyY3VtZmxleD01NTY7ZS5BbWFjcm9uPTY2NztlLnJjYXJvbj0zMzM7ZS5jY2VkaWxsYT01MDA7ZS5aZG90YWNjZW50PTYxMTtlLlRob3JuPTY2NztlLk9tYWNyb249Nzc4O2UuUmFjdXRlPTcyMjtlLlNhY3V0ZT02Njc7ZS5kY2Fyb249NjQzO2UuVW1hY3Jvbj03MjI7ZS51cmluZz01NTY7ZS50aHJlZXN1cGVyaW9yPTMzMztlLk9ncmF2ZT03Nzg7ZS5BZ3JhdmU9NjY3O2UuQWJyZXZlPTY2NztlLm11bHRpcGx5PTU4NDtlLnVhY3V0ZT01NTY7ZS5UY2Fyb249NjExO2UucGFydGlhbGRpZmY9NDc2O2UueWRpZXJlc2lzPTUwMDtlLk5hY3V0ZT03MjI7ZS5pY2lyY3VtZmxleD0yNzg7ZS5FY2lyY3VtZmxleD02Njc7ZS5hZGllcmVzaXM9NTU2O2UuZWRpZXJlc2lzPTU1NjtlLmNhY3V0ZT01MDA7ZS5uYWN1dGU9NTU2O2UudW1hY3Jvbj01NTY7ZS5OY2Fyb249NzIyO2UuSWFjdXRlPTI3ODtlLnBsdXNtaW51cz01ODQ7ZS5icm9rZW5iYXI9MjYwO2UucmVnaXN0ZXJlZD03Mzc7ZS5HYnJldmU9Nzc4O2UuSWRvdGFjY2VudD0yNzg7ZS5zdW1tYXRpb249NjAwO2UuRWdyYXZlPTY2NztlLnJhY3V0ZT0zMzM7ZS5vbWFjcm9uPTU1NjtlLlphY3V0ZT02MTE7ZS5aY2Fyb249NjExO2UuZ3JlYXRlcmVxdWFsPTU0OTtlLkV0aD03MjI7ZS5DY2VkaWxsYT03MjI7ZS5sY29tbWFhY2NlbnQ9MjIyO2UudGNhcm9uPTMxNztlLmVvZ29uZWs9NTU2O2UuVW9nb25laz03MjI7ZS5BYWN1dGU9NjY3O2UuQWRpZXJlc2lzPTY2NztlLmVncmF2ZT01NTY7ZS56YWN1dGU9NTAwO2UuaW9nb25laz0yMjI7ZS5PYWN1dGU9Nzc4O2Uub2FjdXRlPTU1NjtlLmFtYWNyb249NTU2O2Uuc2FjdXRlPTUwMDtlLmlkaWVyZXNpcz0yNzg7ZS5PY2lyY3VtZmxleD03Nzg7ZS5VZ3JhdmU9NzIyO2UuRGVsdGE9NjEyO2UudGhvcm49NTU2O2UudHdvc3VwZXJpb3I9MzMzO2UuT2RpZXJlc2lzPTc3ODtlLm11PTU1NjtlLmlncmF2ZT0yNzg7ZS5vaHVuZ2FydW1sYXV0PTU1NjtlLkVvZ29uZWs9NjY3O2UuZGNyb2F0PTU1NjtlLnRocmVlcXVhcnRlcnM9ODM0O2UuU2NlZGlsbGE9NjY3O2UubGNhcm9uPTI5OTtlLktjb21tYWFjY2VudD02Njc7ZS5MYWN1dGU9NTU2O2UudHJhZGVtYXJrPTFlMztlLmVkb3RhY2NlbnQ9NTU2O2UuSWdyYXZlPTI3ODtlLkltYWNyb249Mjc4O2UuTGNhcm9uPTU1NjtlLm9uZWhhbGY9ODM0O2UubGVzc2VxdWFsPTU0OTtlLm9jaXJjdW1mbGV4PTU1NjtlLm50aWxkZT01NTY7ZS5VaHVuZ2FydW1sYXV0PTcyMjtlLkVhY3V0ZT02Njc7ZS5lbWFjcm9uPTU1NjtlLmdicmV2ZT01NTY7ZS5vbmVxdWFydGVyPTgzNDtlLlNjYXJvbj02Njc7ZS5TY29tbWFhY2NlbnQ9NjY3O2UuT2h1bmdhcnVtbGF1dD03Nzg7ZS5kZWdyZWU9NDAwO2Uub2dyYXZlPTU1NjtlLkNjYXJvbj03MjI7ZS51Z3JhdmU9NTU2O2UucmFkaWNhbD00NTM7ZS5EY2Fyb249NzIyO2UucmNvbW1hYWNjZW50PTMzMztlLk50aWxkZT03MjI7ZS5vdGlsZGU9NTU2O2UuUmNvbW1hYWNjZW50PTcyMjtlLkxjb21tYWFjY2VudD01NTY7ZS5BdGlsZGU9NjY3O2UuQW9nb25laz02Njc7ZS5BcmluZz02Njc7ZS5PdGlsZGU9Nzc4O2UuemRvdGFjY2VudD01MDA7ZS5FY2Fyb249NjY3O2UuSW9nb25laz0yNzg7ZS5rY29tbWFhY2NlbnQ9NTAwO2UubWludXM9NTg0O2UuSWNpcmN1bWZsZXg9Mjc4O2UubmNhcm9uPTU1NjtlLnRjb21tYWFjY2VudD0yNzg7ZS5sb2dpY2Fsbm90PTU4NDtlLm9kaWVyZXNpcz01NTY7ZS51ZGllcmVzaXM9NTU2O2Uubm90ZXF1YWw9NTQ5O2UuZ2NvbW1hYWNjZW50PTU1NjtlLmV0aD01NTY7ZS56Y2Fyb249NTAwO2UubmNvbW1hYWNjZW50PTU1NjtlLm9uZXN1cGVyaW9yPTMzMztlLmltYWNyb249Mjc4O2UuRXVybz01NTZ9KSk7ZVsiSGVsdmV0aWNhLUJvbGQiXT0oMCxyLmdldExvb2t1cFRhYmxlRmFjdG9yeSkoKGZ1bmN0aW9uKGUpe2Uuc3BhY2U9Mjc4O2UuZXhjbGFtPTMzMztlLnF1b3RlZGJsPTQ3NDtlLm51bWJlcnNpZ249NTU2O2UuZG9sbGFyPTU1NjtlLnBlcmNlbnQ9ODg5O2UuYW1wZXJzYW5kPTcyMjtlLnF1b3RlcmlnaHQ9Mjc4O2UucGFyZW5sZWZ0PTMzMztlLnBhcmVucmlnaHQ9MzMzO2UuYXN0ZXJpc2s9Mzg5O2UucGx1cz01ODQ7ZS5jb21tYT0yNzg7ZS5oeXBoZW49MzMzO2UucGVyaW9kPTI3ODtlLnNsYXNoPTI3ODtlLnplcm89NTU2O2Uub25lPTU1NjtlLnR3bz01NTY7ZS50aHJlZT01NTY7ZS5mb3VyPTU1NjtlLmZpdmU9NTU2O2Uuc2l4PTU1NjtlLnNldmVuPTU1NjtlLmVpZ2h0PTU1NjtlLm5pbmU9NTU2O2UuY29sb249MzMzO2Uuc2VtaWNvbG9uPTMzMztlLmxlc3M9NTg0O2UuZXF1YWw9NTg0O2UuZ3JlYXRlcj01ODQ7ZS5xdWVzdGlvbj02MTE7ZS5hdD05NzU7ZS5BPTcyMjtlLkI9NzIyO2UuQz03MjI7ZS5EPTcyMjtlLkU9NjY3O2UuRj02MTE7ZS5HPTc3ODtlLkg9NzIyO2UuST0yNzg7ZS5KPTU1NjtlLks9NzIyO2UuTD02MTE7ZS5NPTgzMztlLk49NzIyO2UuTz03Nzg7ZS5QPTY2NztlLlE9Nzc4O2UuUj03MjI7ZS5TPTY2NztlLlQ9NjExO2UuVT03MjI7ZS5WPTY2NztlLlc9OTQ0O2UuWD02Njc7ZS5ZPTY2NztlLlo9NjExO2UuYnJhY2tldGxlZnQ9MzMzO2UuYmFja3NsYXNoPTI3ODtlLmJyYWNrZXRyaWdodD0zMzM7ZS5hc2NpaWNpcmN1bT01ODQ7ZS51bmRlcnNjb3JlPTU1NjtlLnF1b3RlbGVmdD0yNzg7ZS5hPTU1NjtlLmI9NjExO2UuYz01NTY7ZS5kPTYxMTtlLmU9NTU2O2UuZj0zMzM7ZS5nPTYxMTtlLmg9NjExO2UuaT0yNzg7ZS5qPTI3ODtlLms9NTU2O2UubD0yNzg7ZS5tPTg4OTtlLm49NjExO2Uubz02MTE7ZS5wPTYxMTtlLnE9NjExO2Uucj0zODk7ZS5zPTU1NjtlLnQ9MzMzO2UudT02MTE7ZS52PTU1NjtlLnc9Nzc4O2UueD01NTY7ZS55PTU1NjtlLno9NTAwO2UuYnJhY2VsZWZ0PTM4OTtlLmJhcj0yODA7ZS5icmFjZXJpZ2h0PTM4OTtlLmFzY2lpdGlsZGU9NTg0O2UuZXhjbGFtZG93bj0zMzM7ZS5jZW50PTU1NjtlLnN0ZXJsaW5nPTU1NjtlLmZyYWN0aW9uPTE2NztlLnllbj01NTY7ZS5mbG9yaW49NTU2O2Uuc2VjdGlvbj01NTY7ZS5jdXJyZW5jeT01NTY7ZS5xdW90ZXNpbmdsZT0yMzg7ZS5xdW90ZWRibGxlZnQ9NTAwO2UuZ3VpbGxlbW90bGVmdD01NTY7ZS5ndWlsc2luZ2xsZWZ0PTMzMztlLmd1aWxzaW5nbHJpZ2h0PTMzMztlLmZpPTYxMTtlLmZsPTYxMTtlLmVuZGFzaD01NTY7ZS5kYWdnZXI9NTU2O2UuZGFnZ2VyZGJsPTU1NjtlLnBlcmlvZGNlbnRlcmVkPTI3ODtlLnBhcmFncmFwaD01NTY7ZS5idWxsZXQ9MzUwO2UucXVvdGVzaW5nbGJhc2U9Mjc4O2UucXVvdGVkYmxiYXNlPTUwMDtlLnF1b3RlZGJscmlnaHQ9NTAwO2UuZ3VpbGxlbW90cmlnaHQ9NTU2O2UuZWxsaXBzaXM9MWUzO2UucGVydGhvdXNhbmQ9MWUzO2UucXVlc3Rpb25kb3duPTYxMTtlLmdyYXZlPTMzMztlLmFjdXRlPTMzMztlLmNpcmN1bWZsZXg9MzMzO2UudGlsZGU9MzMzO2UubWFjcm9uPTMzMztlLmJyZXZlPTMzMztlLmRvdGFjY2VudD0zMzM7ZS5kaWVyZXNpcz0zMzM7ZS5yaW5nPTMzMztlLmNlZGlsbGE9MzMzO2UuaHVuZ2FydW1sYXV0PTMzMztlLm9nb25laz0zMzM7ZS5jYXJvbj0zMzM7ZS5lbWRhc2g9MWUzO2UuQUU9MWUzO2Uub3JkZmVtaW5pbmU9MzcwO2UuTHNsYXNoPTYxMTtlLk9zbGFzaD03Nzg7ZS5PRT0xZTM7ZS5vcmRtYXNjdWxpbmU9MzY1O2UuYWU9ODg5O2UuZG90bGVzc2k9Mjc4O2UubHNsYXNoPTI3ODtlLm9zbGFzaD02MTE7ZS5vZT05NDQ7ZS5nZXJtYW5kYmxzPTYxMTtlLklkaWVyZXNpcz0yNzg7ZS5lYWN1dGU9NTU2O2UuYWJyZXZlPTU1NjtlLnVodW5nYXJ1bWxhdXQ9NjExO2UuZWNhcm9uPTU1NjtlLllkaWVyZXNpcz02Njc7ZS5kaXZpZGU9NTg0O2UuWWFjdXRlPTY2NztlLkFjaXJjdW1mbGV4PTcyMjtlLmFhY3V0ZT01NTY7ZS5VY2lyY3VtZmxleD03MjI7ZS55YWN1dGU9NTU2O2Uuc2NvbW1hYWNjZW50PTU1NjtlLmVjaXJjdW1mbGV4PTU1NjtlLlVyaW5nPTcyMjtlLlVkaWVyZXNpcz03MjI7ZS5hb2dvbmVrPTU1NjtlLlVhY3V0ZT03MjI7ZS51b2dvbmVrPTYxMTtlLkVkaWVyZXNpcz02Njc7ZS5EY3JvYXQ9NzIyO2UuY29tbWFhY2NlbnQ9MjUwO2UuY29weXJpZ2h0PTczNztlLkVtYWNyb249NjY3O2UuY2Nhcm9uPTU1NjtlLmFyaW5nPTU1NjtlLk5jb21tYWFjY2VudD03MjI7ZS5sYWN1dGU9Mjc4O2UuYWdyYXZlPTU1NjtlLlRjb21tYWFjY2VudD02MTE7ZS5DYWN1dGU9NzIyO2UuYXRpbGRlPTU1NjtlLkVkb3RhY2NlbnQ9NjY3O2Uuc2Nhcm9uPTU1NjtlLnNjZWRpbGxhPTU1NjtlLmlhY3V0ZT0yNzg7ZS5sb3plbmdlPTQ5NDtlLlJjYXJvbj03MjI7ZS5HY29tbWFhY2NlbnQ9Nzc4O2UudWNpcmN1bWZsZXg9NjExO2UuYWNpcmN1bWZsZXg9NTU2O2UuQW1hY3Jvbj03MjI7ZS5yY2Fyb249Mzg5O2UuY2NlZGlsbGE9NTU2O2UuWmRvdGFjY2VudD02MTE7ZS5UaG9ybj02Njc7ZS5PbWFjcm9uPTc3ODtlLlJhY3V0ZT03MjI7ZS5TYWN1dGU9NjY3O2UuZGNhcm9uPTc0MztlLlVtYWNyb249NzIyO2UudXJpbmc9NjExO2UudGhyZWVzdXBlcmlvcj0zMzM7ZS5PZ3JhdmU9Nzc4O2UuQWdyYXZlPTcyMjtlLkFicmV2ZT03MjI7ZS5tdWx0aXBseT01ODQ7ZS51YWN1dGU9NjExO2UuVGNhcm9uPTYxMTtlLnBhcnRpYWxkaWZmPTQ5NDtlLnlkaWVyZXNpcz01NTY7ZS5OYWN1dGU9NzIyO2UuaWNpcmN1bWZsZXg9Mjc4O2UuRWNpcmN1bWZsZXg9NjY3O2UuYWRpZXJlc2lzPTU1NjtlLmVkaWVyZXNpcz01NTY7ZS5jYWN1dGU9NTU2O2UubmFjdXRlPTYxMTtlLnVtYWNyb249NjExO2UuTmNhcm9uPTcyMjtlLklhY3V0ZT0yNzg7ZS5wbHVzbWludXM9NTg0O2UuYnJva2VuYmFyPTI4MDtlLnJlZ2lzdGVyZWQ9NzM3O2UuR2JyZXZlPTc3ODtlLklkb3RhY2NlbnQ9Mjc4O2Uuc3VtbWF0aW9uPTYwMDtlLkVncmF2ZT02Njc7ZS5yYWN1dGU9Mzg5O2Uub21hY3Jvbj02MTE7ZS5aYWN1dGU9NjExO2UuWmNhcm9uPTYxMTtlLmdyZWF0ZXJlcXVhbD01NDk7ZS5FdGg9NzIyO2UuQ2NlZGlsbGE9NzIyO2UubGNvbW1hYWNjZW50PTI3ODtlLnRjYXJvbj0zODk7ZS5lb2dvbmVrPTU1NjtlLlVvZ29uZWs9NzIyO2UuQWFjdXRlPTcyMjtlLkFkaWVyZXNpcz03MjI7ZS5lZ3JhdmU9NTU2O2UuemFjdXRlPTUwMDtlLmlvZ29uZWs9Mjc4O2UuT2FjdXRlPTc3ODtlLm9hY3V0ZT02MTE7ZS5hbWFjcm9uPTU1NjtlLnNhY3V0ZT01NTY7ZS5pZGllcmVzaXM9Mjc4O2UuT2NpcmN1bWZsZXg9Nzc4O2UuVWdyYXZlPTcyMjtlLkRlbHRhPTYxMjtlLnRob3JuPTYxMTtlLnR3b3N1cGVyaW9yPTMzMztlLk9kaWVyZXNpcz03Nzg7ZS5tdT02MTE7ZS5pZ3JhdmU9Mjc4O2Uub2h1bmdhcnVtbGF1dD02MTE7ZS5Fb2dvbmVrPTY2NztlLmRjcm9hdD02MTE7ZS50aHJlZXF1YXJ0ZXJzPTgzNDtlLlNjZWRpbGxhPTY2NztlLmxjYXJvbj00MDA7ZS5LY29tbWFhY2NlbnQ9NzIyO2UuTGFjdXRlPTYxMTtlLnRyYWRlbWFyaz0xZTM7ZS5lZG90YWNjZW50PTU1NjtlLklncmF2ZT0yNzg7ZS5JbWFjcm9uPTI3ODtlLkxjYXJvbj02MTE7ZS5vbmVoYWxmPTgzNDtlLmxlc3NlcXVhbD01NDk7ZS5vY2lyY3VtZmxleD02MTE7ZS5udGlsZGU9NjExO2UuVWh1bmdhcnVtbGF1dD03MjI7ZS5FYWN1dGU9NjY3O2UuZW1hY3Jvbj01NTY7ZS5nYnJldmU9NjExO2Uub25lcXVhcnRlcj04MzQ7ZS5TY2Fyb249NjY3O2UuU2NvbW1hYWNjZW50PTY2NztlLk9odW5nYXJ1bWxhdXQ9Nzc4O2UuZGVncmVlPTQwMDtlLm9ncmF2ZT02MTE7ZS5DY2Fyb249NzIyO2UudWdyYXZlPTYxMTtlLnJhZGljYWw9NTQ5O2UuRGNhcm9uPTcyMjtlLnJjb21tYWFjY2VudD0zODk7ZS5OdGlsZGU9NzIyO2Uub3RpbGRlPTYxMTtlLlJjb21tYWFjY2VudD03MjI7ZS5MY29tbWFhY2NlbnQ9NjExO2UuQXRpbGRlPTcyMjtlLkFvZ29uZWs9NzIyO2UuQXJpbmc9NzIyO2UuT3RpbGRlPTc3ODtlLnpkb3RhY2NlbnQ9NTAwO2UuRWNhcm9uPTY2NztlLklvZ29uZWs9Mjc4O2Uua2NvbW1hYWNjZW50PTU1NjtlLm1pbnVzPTU4NDtlLkljaXJjdW1mbGV4PTI3ODtlLm5jYXJvbj02MTE7ZS50Y29tbWFhY2NlbnQ9MzMzO2UubG9naWNhbG5vdD01ODQ7ZS5vZGllcmVzaXM9NjExO2UudWRpZXJlc2lzPTYxMTtlLm5vdGVxdWFsPTU0OTtlLmdjb21tYWFjY2VudD02MTE7ZS5ldGg9NjExO2UuemNhcm9uPTUwMDtlLm5jb21tYWFjY2VudD02MTE7ZS5vbmVzdXBlcmlvcj0zMzM7ZS5pbWFjcm9uPTI3ODtlLkV1cm89NTU2fSkpO2VbIkhlbHZldGljYS1Cb2xkT2JsaXF1ZSJdPSgwLHIuZ2V0TG9va3VwVGFibGVGYWN0b3J5KSgoZnVuY3Rpb24oZSl7ZS5zcGFjZT0yNzg7ZS5leGNsYW09MzMzO2UucXVvdGVkYmw9NDc0O2UubnVtYmVyc2lnbj01NTY7ZS5kb2xsYXI9NTU2O2UucGVyY2VudD04ODk7ZS5hbXBlcnNhbmQ9NzIyO2UucXVvdGVyaWdodD0yNzg7ZS5wYXJlbmxlZnQ9MzMzO2UucGFyZW5yaWdodD0zMzM7ZS5hc3Rlcmlzaz0zODk7ZS5wbHVzPTU4NDtlLmNvbW1hPTI3ODtlLmh5cGhlbj0zMzM7ZS5wZXJpb2Q9Mjc4O2Uuc2xhc2g9Mjc4O2UuemVybz01NTY7ZS5vbmU9NTU2O2UudHdvPTU1NjtlLnRocmVlPTU1NjtlLmZvdXI9NTU2O2UuZml2ZT01NTY7ZS5zaXg9NTU2O2Uuc2V2ZW49NTU2O2UuZWlnaHQ9NTU2O2UubmluZT01NTY7ZS5jb2xvbj0zMzM7ZS5zZW1pY29sb249MzMzO2UubGVzcz01ODQ7ZS5lcXVhbD01ODQ7ZS5ncmVhdGVyPTU4NDtlLnF1ZXN0aW9uPTYxMTtlLmF0PTk3NTtlLkE9NzIyO2UuQj03MjI7ZS5DPTcyMjtlLkQ9NzIyO2UuRT02Njc7ZS5GPTYxMTtlLkc9Nzc4O2UuSD03MjI7ZS5JPTI3ODtlLko9NTU2O2UuSz03MjI7ZS5MPTYxMTtlLk09ODMzO2UuTj03MjI7ZS5PPTc3ODtlLlA9NjY3O2UuUT03Nzg7ZS5SPTcyMjtlLlM9NjY3O2UuVD02MTE7ZS5VPTcyMjtlLlY9NjY3O2UuVz05NDQ7ZS5YPTY2NztlLlk9NjY3O2UuWj02MTE7ZS5icmFja2V0bGVmdD0zMzM7ZS5iYWNrc2xhc2g9Mjc4O2UuYnJhY2tldHJpZ2h0PTMzMztlLmFzY2lpY2lyY3VtPTU4NDtlLnVuZGVyc2NvcmU9NTU2O2UucXVvdGVsZWZ0PTI3ODtlLmE9NTU2O2UuYj02MTE7ZS5jPTU1NjtlLmQ9NjExO2UuZT01NTY7ZS5mPTMzMztlLmc9NjExO2UuaD02MTE7ZS5pPTI3ODtlLmo9Mjc4O2Uuaz01NTY7ZS5sPTI3ODtlLm09ODg5O2Uubj02MTE7ZS5vPTYxMTtlLnA9NjExO2UucT02MTE7ZS5yPTM4OTtlLnM9NTU2O2UudD0zMzM7ZS51PTYxMTtlLnY9NTU2O2Uudz03Nzg7ZS54PTU1NjtlLnk9NTU2O2Uuej01MDA7ZS5icmFjZWxlZnQ9Mzg5O2UuYmFyPTI4MDtlLmJyYWNlcmlnaHQ9Mzg5O2UuYXNjaWl0aWxkZT01ODQ7ZS5leGNsYW1kb3duPTMzMztlLmNlbnQ9NTU2O2Uuc3Rlcmxpbmc9NTU2O2UuZnJhY3Rpb249MTY3O2UueWVuPTU1NjtlLmZsb3Jpbj01NTY7ZS5zZWN0aW9uPTU1NjtlLmN1cnJlbmN5PTU1NjtlLnF1b3Rlc2luZ2xlPTIzODtlLnF1b3RlZGJsbGVmdD01MDA7ZS5ndWlsbGVtb3RsZWZ0PTU1NjtlLmd1aWxzaW5nbGxlZnQ9MzMzO2UuZ3VpbHNpbmdscmlnaHQ9MzMzO2UuZmk9NjExO2UuZmw9NjExO2UuZW5kYXNoPTU1NjtlLmRhZ2dlcj01NTY7ZS5kYWdnZXJkYmw9NTU2O2UucGVyaW9kY2VudGVyZWQ9Mjc4O2UucGFyYWdyYXBoPTU1NjtlLmJ1bGxldD0zNTA7ZS5xdW90ZXNpbmdsYmFzZT0yNzg7ZS5xdW90ZWRibGJhc2U9NTAwO2UucXVvdGVkYmxyaWdodD01MDA7ZS5ndWlsbGVtb3RyaWdodD01NTY7ZS5lbGxpcHNpcz0xZTM7ZS5wZXJ0aG91c2FuZD0xZTM7ZS5xdWVzdGlvbmRvd249NjExO2UuZ3JhdmU9MzMzO2UuYWN1dGU9MzMzO2UuY2lyY3VtZmxleD0zMzM7ZS50aWxkZT0zMzM7ZS5tYWNyb249MzMzO2UuYnJldmU9MzMzO2UuZG90YWNjZW50PTMzMztlLmRpZXJlc2lzPTMzMztlLnJpbmc9MzMzO2UuY2VkaWxsYT0zMzM7ZS5odW5nYXJ1bWxhdXQ9MzMzO2Uub2dvbmVrPTMzMztlLmNhcm9uPTMzMztlLmVtZGFzaD0xZTM7ZS5BRT0xZTM7ZS5vcmRmZW1pbmluZT0zNzA7ZS5Mc2xhc2g9NjExO2UuT3NsYXNoPTc3ODtlLk9FPTFlMztlLm9yZG1hc2N1bGluZT0zNjU7ZS5hZT04ODk7ZS5kb3RsZXNzaT0yNzg7ZS5sc2xhc2g9Mjc4O2Uub3NsYXNoPTYxMTtlLm9lPTk0NDtlLmdlcm1hbmRibHM9NjExO2UuSWRpZXJlc2lzPTI3ODtlLmVhY3V0ZT01NTY7ZS5hYnJldmU9NTU2O2UudWh1bmdhcnVtbGF1dD02MTE7ZS5lY2Fyb249NTU2O2UuWWRpZXJlc2lzPTY2NztlLmRpdmlkZT01ODQ7ZS5ZYWN1dGU9NjY3O2UuQWNpcmN1bWZsZXg9NzIyO2UuYWFjdXRlPTU1NjtlLlVjaXJjdW1mbGV4PTcyMjtlLnlhY3V0ZT01NTY7ZS5zY29tbWFhY2NlbnQ9NTU2O2UuZWNpcmN1bWZsZXg9NTU2O2UuVXJpbmc9NzIyO2UuVWRpZXJlc2lzPTcyMjtlLmFvZ29uZWs9NTU2O2UuVWFjdXRlPTcyMjtlLnVvZ29uZWs9NjExO2UuRWRpZXJlc2lzPTY2NztlLkRjcm9hdD03MjI7ZS5jb21tYWFjY2VudD0yNTA7ZS5jb3B5cmlnaHQ9NzM3O2UuRW1hY3Jvbj02Njc7ZS5jY2Fyb249NTU2O2UuYXJpbmc9NTU2O2UuTmNvbW1hYWNjZW50PTcyMjtlLmxhY3V0ZT0yNzg7ZS5hZ3JhdmU9NTU2O2UuVGNvbW1hYWNjZW50PTYxMTtlLkNhY3V0ZT03MjI7ZS5hdGlsZGU9NTU2O2UuRWRvdGFjY2VudD02Njc7ZS5zY2Fyb249NTU2O2Uuc2NlZGlsbGE9NTU2O2UuaWFjdXRlPTI3ODtlLmxvemVuZ2U9NDk0O2UuUmNhcm9uPTcyMjtlLkdjb21tYWFjY2VudD03Nzg7ZS51Y2lyY3VtZmxleD02MTE7ZS5hY2lyY3VtZmxleD01NTY7ZS5BbWFjcm9uPTcyMjtlLnJjYXJvbj0zODk7ZS5jY2VkaWxsYT01NTY7ZS5aZG90YWNjZW50PTYxMTtlLlRob3JuPTY2NztlLk9tYWNyb249Nzc4O2UuUmFjdXRlPTcyMjtlLlNhY3V0ZT02Njc7ZS5kY2Fyb249NzQzO2UuVW1hY3Jvbj03MjI7ZS51cmluZz02MTE7ZS50aHJlZXN1cGVyaW9yPTMzMztlLk9ncmF2ZT03Nzg7ZS5BZ3JhdmU9NzIyO2UuQWJyZXZlPTcyMjtlLm11bHRpcGx5PTU4NDtlLnVhY3V0ZT02MTE7ZS5UY2Fyb249NjExO2UucGFydGlhbGRpZmY9NDk0O2UueWRpZXJlc2lzPTU1NjtlLk5hY3V0ZT03MjI7ZS5pY2lyY3VtZmxleD0yNzg7ZS5FY2lyY3VtZmxleD02Njc7ZS5hZGllcmVzaXM9NTU2O2UuZWRpZXJlc2lzPTU1NjtlLmNhY3V0ZT01NTY7ZS5uYWN1dGU9NjExO2UudW1hY3Jvbj02MTE7ZS5OY2Fyb249NzIyO2UuSWFjdXRlPTI3ODtlLnBsdXNtaW51cz01ODQ7ZS5icm9rZW5iYXI9MjgwO2UucmVnaXN0ZXJlZD03Mzc7ZS5HYnJldmU9Nzc4O2UuSWRvdGFjY2VudD0yNzg7ZS5zdW1tYXRpb249NjAwO2UuRWdyYXZlPTY2NztlLnJhY3V0ZT0zODk7ZS5vbWFjcm9uPTYxMTtlLlphY3V0ZT02MTE7ZS5aY2Fyb249NjExO2UuZ3JlYXRlcmVxdWFsPTU0OTtlLkV0aD03MjI7ZS5DY2VkaWxsYT03MjI7ZS5sY29tbWFhY2NlbnQ9Mjc4O2UudGNhcm9uPTM4OTtlLmVvZ29uZWs9NTU2O2UuVW9nb25laz03MjI7ZS5BYWN1dGU9NzIyO2UuQWRpZXJlc2lzPTcyMjtlLmVncmF2ZT01NTY7ZS56YWN1dGU9NTAwO2UuaW9nb25laz0yNzg7ZS5PYWN1dGU9Nzc4O2Uub2FjdXRlPTYxMTtlLmFtYWNyb249NTU2O2Uuc2FjdXRlPTU1NjtlLmlkaWVyZXNpcz0yNzg7ZS5PY2lyY3VtZmxleD03Nzg7ZS5VZ3JhdmU9NzIyO2UuRGVsdGE9NjEyO2UudGhvcm49NjExO2UudHdvc3VwZXJpb3I9MzMzO2UuT2RpZXJlc2lzPTc3ODtlLm11PTYxMTtlLmlncmF2ZT0yNzg7ZS5vaHVuZ2FydW1sYXV0PTYxMTtlLkVvZ29uZWs9NjY3O2UuZGNyb2F0PTYxMTtlLnRocmVlcXVhcnRlcnM9ODM0O2UuU2NlZGlsbGE9NjY3O2UubGNhcm9uPTQwMDtlLktjb21tYWFjY2VudD03MjI7ZS5MYWN1dGU9NjExO2UudHJhZGVtYXJrPTFlMztlLmVkb3RhY2NlbnQ9NTU2O2UuSWdyYXZlPTI3ODtlLkltYWNyb249Mjc4O2UuTGNhcm9uPTYxMTtlLm9uZWhhbGY9ODM0O2UubGVzc2VxdWFsPTU0OTtlLm9jaXJjdW1mbGV4PTYxMTtlLm50aWxkZT02MTE7ZS5VaHVuZ2FydW1sYXV0PTcyMjtlLkVhY3V0ZT02Njc7ZS5lbWFjcm9uPTU1NjtlLmdicmV2ZT02MTE7ZS5vbmVxdWFydGVyPTgzNDtlLlNjYXJvbj02Njc7ZS5TY29tbWFhY2NlbnQ9NjY3O2UuT2h1bmdhcnVtbGF1dD03Nzg7ZS5kZWdyZWU9NDAwO2Uub2dyYXZlPTYxMTtlLkNjYXJvbj03MjI7ZS51Z3JhdmU9NjExO2UucmFkaWNhbD01NDk7ZS5EY2Fyb249NzIyO2UucmNvbW1hYWNjZW50PTM4OTtlLk50aWxkZT03MjI7ZS5vdGlsZGU9NjExO2UuUmNvbW1hYWNjZW50PTcyMjtlLkxjb21tYWFjY2VudD02MTE7ZS5BdGlsZGU9NzIyO2UuQW9nb25laz03MjI7ZS5BcmluZz03MjI7ZS5PdGlsZGU9Nzc4O2UuemRvdGFjY2VudD01MDA7ZS5FY2Fyb249NjY3O2UuSW9nb25laz0yNzg7ZS5rY29tbWFhY2NlbnQ9NTU2O2UubWludXM9NTg0O2UuSWNpcmN1bWZsZXg9Mjc4O2UubmNhcm9uPTYxMTtlLnRjb21tYWFjY2VudD0zMzM7ZS5sb2dpY2Fsbm90PTU4NDtlLm9kaWVyZXNpcz02MTE7ZS51ZGllcmVzaXM9NjExO2Uubm90ZXF1YWw9NTQ5O2UuZ2NvbW1hYWNjZW50PTYxMTtlLmV0aD02MTE7ZS56Y2Fyb249NTAwO2UubmNvbW1hYWNjZW50PTYxMTtlLm9uZXN1cGVyaW9yPTMzMztlLmltYWNyb249Mjc4O2UuRXVybz01NTZ9KSk7ZVsiSGVsdmV0aWNhLU9ibGlxdWUiXT0oMCxyLmdldExvb2t1cFRhYmxlRmFjdG9yeSkoKGZ1bmN0aW9uKGUpe2Uuc3BhY2U9Mjc4O2UuZXhjbGFtPTI3ODtlLnF1b3RlZGJsPTM1NTtlLm51bWJlcnNpZ249NTU2O2UuZG9sbGFyPTU1NjtlLnBlcmNlbnQ9ODg5O2UuYW1wZXJzYW5kPTY2NztlLnF1b3RlcmlnaHQ9MjIyO2UucGFyZW5sZWZ0PTMzMztlLnBhcmVucmlnaHQ9MzMzO2UuYXN0ZXJpc2s9Mzg5O2UucGx1cz01ODQ7ZS5jb21tYT0yNzg7ZS5oeXBoZW49MzMzO2UucGVyaW9kPTI3ODtlLnNsYXNoPTI3ODtlLnplcm89NTU2O2Uub25lPTU1NjtlLnR3bz01NTY7ZS50aHJlZT01NTY7ZS5mb3VyPTU1NjtlLmZpdmU9NTU2O2Uuc2l4PTU1NjtlLnNldmVuPTU1NjtlLmVpZ2h0PTU1NjtlLm5pbmU9NTU2O2UuY29sb249Mjc4O2Uuc2VtaWNvbG9uPTI3ODtlLmxlc3M9NTg0O2UuZXF1YWw9NTg0O2UuZ3JlYXRlcj01ODQ7ZS5xdWVzdGlvbj01NTY7ZS5hdD0xMDE1O2UuQT02Njc7ZS5CPTY2NztlLkM9NzIyO2UuRD03MjI7ZS5FPTY2NztlLkY9NjExO2UuRz03Nzg7ZS5IPTcyMjtlLkk9Mjc4O2UuSj01MDA7ZS5LPTY2NztlLkw9NTU2O2UuTT04MzM7ZS5OPTcyMjtlLk89Nzc4O2UuUD02Njc7ZS5RPTc3ODtlLlI9NzIyO2UuUz02Njc7ZS5UPTYxMTtlLlU9NzIyO2UuVj02Njc7ZS5XPTk0NDtlLlg9NjY3O2UuWT02Njc7ZS5aPTYxMTtlLmJyYWNrZXRsZWZ0PTI3ODtlLmJhY2tzbGFzaD0yNzg7ZS5icmFja2V0cmlnaHQ9Mjc4O2UuYXNjaWljaXJjdW09NDY5O2UudW5kZXJzY29yZT01NTY7ZS5xdW90ZWxlZnQ9MjIyO2UuYT01NTY7ZS5iPTU1NjtlLmM9NTAwO2UuZD01NTY7ZS5lPTU1NjtlLmY9Mjc4O2UuZz01NTY7ZS5oPTU1NjtlLmk9MjIyO2Uuaj0yMjI7ZS5rPTUwMDtlLmw9MjIyO2UubT04MzM7ZS5uPTU1NjtlLm89NTU2O2UucD01NTY7ZS5xPTU1NjtlLnI9MzMzO2Uucz01MDA7ZS50PTI3ODtlLnU9NTU2O2Uudj01MDA7ZS53PTcyMjtlLng9NTAwO2UueT01MDA7ZS56PTUwMDtlLmJyYWNlbGVmdD0zMzQ7ZS5iYXI9MjYwO2UuYnJhY2VyaWdodD0zMzQ7ZS5hc2NpaXRpbGRlPTU4NDtlLmV4Y2xhbWRvd249MzMzO2UuY2VudD01NTY7ZS5zdGVybGluZz01NTY7ZS5mcmFjdGlvbj0xNjc7ZS55ZW49NTU2O2UuZmxvcmluPTU1NjtlLnNlY3Rpb249NTU2O2UuY3VycmVuY3k9NTU2O2UucXVvdGVzaW5nbGU9MTkxO2UucXVvdGVkYmxsZWZ0PTMzMztlLmd1aWxsZW1vdGxlZnQ9NTU2O2UuZ3VpbHNpbmdsbGVmdD0zMzM7ZS5ndWlsc2luZ2xyaWdodD0zMzM7ZS5maT01MDA7ZS5mbD01MDA7ZS5lbmRhc2g9NTU2O2UuZGFnZ2VyPTU1NjtlLmRhZ2dlcmRibD01NTY7ZS5wZXJpb2RjZW50ZXJlZD0yNzg7ZS5wYXJhZ3JhcGg9NTM3O2UuYnVsbGV0PTM1MDtlLnF1b3Rlc2luZ2xiYXNlPTIyMjtlLnF1b3RlZGJsYmFzZT0zMzM7ZS5xdW90ZWRibHJpZ2h0PTMzMztlLmd1aWxsZW1vdHJpZ2h0PTU1NjtlLmVsbGlwc2lzPTFlMztlLnBlcnRob3VzYW5kPTFlMztlLnF1ZXN0aW9uZG93bj02MTE7ZS5ncmF2ZT0zMzM7ZS5hY3V0ZT0zMzM7ZS5jaXJjdW1mbGV4PTMzMztlLnRpbGRlPTMzMztlLm1hY3Jvbj0zMzM7ZS5icmV2ZT0zMzM7ZS5kb3RhY2NlbnQ9MzMzO2UuZGllcmVzaXM9MzMzO2UucmluZz0zMzM7ZS5jZWRpbGxhPTMzMztlLmh1bmdhcnVtbGF1dD0zMzM7ZS5vZ29uZWs9MzMzO2UuY2Fyb249MzMzO2UuZW1kYXNoPTFlMztlLkFFPTFlMztlLm9yZGZlbWluaW5lPTM3MDtlLkxzbGFzaD01NTY7ZS5Pc2xhc2g9Nzc4O2UuT0U9MWUzO2Uub3JkbWFzY3VsaW5lPTM2NTtlLmFlPTg4OTtlLmRvdGxlc3NpPTI3ODtlLmxzbGFzaD0yMjI7ZS5vc2xhc2g9NjExO2Uub2U9OTQ0O2UuZ2VybWFuZGJscz02MTE7ZS5JZGllcmVzaXM9Mjc4O2UuZWFjdXRlPTU1NjtlLmFicmV2ZT01NTY7ZS51aHVuZ2FydW1sYXV0PTU1NjtlLmVjYXJvbj01NTY7ZS5ZZGllcmVzaXM9NjY3O2UuZGl2aWRlPTU4NDtlLllhY3V0ZT02Njc7ZS5BY2lyY3VtZmxleD02Njc7ZS5hYWN1dGU9NTU2O2UuVWNpcmN1bWZsZXg9NzIyO2UueWFjdXRlPTUwMDtlLnNjb21tYWFjY2VudD01MDA7ZS5lY2lyY3VtZmxleD01NTY7ZS5VcmluZz03MjI7ZS5VZGllcmVzaXM9NzIyO2UuYW9nb25laz01NTY7ZS5VYWN1dGU9NzIyO2UudW9nb25laz01NTY7ZS5FZGllcmVzaXM9NjY3O2UuRGNyb2F0PTcyMjtlLmNvbW1hYWNjZW50PTI1MDtlLmNvcHlyaWdodD03Mzc7ZS5FbWFjcm9uPTY2NztlLmNjYXJvbj01MDA7ZS5hcmluZz01NTY7ZS5OY29tbWFhY2NlbnQ9NzIyO2UubGFjdXRlPTIyMjtlLmFncmF2ZT01NTY7ZS5UY29tbWFhY2NlbnQ9NjExO2UuQ2FjdXRlPTcyMjtlLmF0aWxkZT01NTY7ZS5FZG90YWNjZW50PTY2NztlLnNjYXJvbj01MDA7ZS5zY2VkaWxsYT01MDA7ZS5pYWN1dGU9Mjc4O2UubG96ZW5nZT00NzE7ZS5SY2Fyb249NzIyO2UuR2NvbW1hYWNjZW50PTc3ODtlLnVjaXJjdW1mbGV4PTU1NjtlLmFjaXJjdW1mbGV4PTU1NjtlLkFtYWNyb249NjY3O2UucmNhcm9uPTMzMztlLmNjZWRpbGxhPTUwMDtlLlpkb3RhY2NlbnQ9NjExO2UuVGhvcm49NjY3O2UuT21hY3Jvbj03Nzg7ZS5SYWN1dGU9NzIyO2UuU2FjdXRlPTY2NztlLmRjYXJvbj02NDM7ZS5VbWFjcm9uPTcyMjtlLnVyaW5nPTU1NjtlLnRocmVlc3VwZXJpb3I9MzMzO2UuT2dyYXZlPTc3ODtlLkFncmF2ZT02Njc7ZS5BYnJldmU9NjY3O2UubXVsdGlwbHk9NTg0O2UudWFjdXRlPTU1NjtlLlRjYXJvbj02MTE7ZS5wYXJ0aWFsZGlmZj00NzY7ZS55ZGllcmVzaXM9NTAwO2UuTmFjdXRlPTcyMjtlLmljaXJjdW1mbGV4PTI3ODtlLkVjaXJjdW1mbGV4PTY2NztlLmFkaWVyZXNpcz01NTY7ZS5lZGllcmVzaXM9NTU2O2UuY2FjdXRlPTUwMDtlLm5hY3V0ZT01NTY7ZS51bWFjcm9uPTU1NjtlLk5jYXJvbj03MjI7ZS5JYWN1dGU9Mjc4O2UucGx1c21pbnVzPTU4NDtlLmJyb2tlbmJhcj0yNjA7ZS5yZWdpc3RlcmVkPTczNztlLkdicmV2ZT03Nzg7ZS5JZG90YWNjZW50PTI3ODtlLnN1bW1hdGlvbj02MDA7ZS5FZ3JhdmU9NjY3O2UucmFjdXRlPTMzMztlLm9tYWNyb249NTU2O2UuWmFjdXRlPTYxMTtlLlpjYXJvbj02MTE7ZS5ncmVhdGVyZXF1YWw9NTQ5O2UuRXRoPTcyMjtlLkNjZWRpbGxhPTcyMjtlLmxjb21tYWFjY2VudD0yMjI7ZS50Y2Fyb249MzE3O2UuZW9nb25laz01NTY7ZS5Vb2dvbmVrPTcyMjtlLkFhY3V0ZT02Njc7ZS5BZGllcmVzaXM9NjY3O2UuZWdyYXZlPTU1NjtlLnphY3V0ZT01MDA7ZS5pb2dvbmVrPTIyMjtlLk9hY3V0ZT03Nzg7ZS5vYWN1dGU9NTU2O2UuYW1hY3Jvbj01NTY7ZS5zYWN1dGU9NTAwO2UuaWRpZXJlc2lzPTI3ODtlLk9jaXJjdW1mbGV4PTc3ODtlLlVncmF2ZT03MjI7ZS5EZWx0YT02MTI7ZS50aG9ybj01NTY7ZS50d29zdXBlcmlvcj0zMzM7ZS5PZGllcmVzaXM9Nzc4O2UubXU9NTU2O2UuaWdyYXZlPTI3ODtlLm9odW5nYXJ1bWxhdXQ9NTU2O2UuRW9nb25laz02Njc7ZS5kY3JvYXQ9NTU2O2UudGhyZWVxdWFydGVycz04MzQ7ZS5TY2VkaWxsYT02Njc7ZS5sY2Fyb249Mjk5O2UuS2NvbW1hYWNjZW50PTY2NztlLkxhY3V0ZT01NTY7ZS50cmFkZW1hcms9MWUzO2UuZWRvdGFjY2VudD01NTY7ZS5JZ3JhdmU9Mjc4O2UuSW1hY3Jvbj0yNzg7ZS5MY2Fyb249NTU2O2Uub25laGFsZj04MzQ7ZS5sZXNzZXF1YWw9NTQ5O2Uub2NpcmN1bWZsZXg9NTU2O2UubnRpbGRlPTU1NjtlLlVodW5nYXJ1bWxhdXQ9NzIyO2UuRWFjdXRlPTY2NztlLmVtYWNyb249NTU2O2UuZ2JyZXZlPTU1NjtlLm9uZXF1YXJ0ZXI9ODM0O2UuU2Nhcm9uPTY2NztlLlNjb21tYWFjY2VudD02Njc7ZS5PaHVuZ2FydW1sYXV0PTc3ODtlLmRlZ3JlZT00MDA7ZS5vZ3JhdmU9NTU2O2UuQ2Nhcm9uPTcyMjtlLnVncmF2ZT01NTY7ZS5yYWRpY2FsPTQ1MztlLkRjYXJvbj03MjI7ZS5yY29tbWFhY2NlbnQ9MzMzO2UuTnRpbGRlPTcyMjtlLm90aWxkZT01NTY7ZS5SY29tbWFhY2NlbnQ9NzIyO2UuTGNvbW1hYWNjZW50PTU1NjtlLkF0aWxkZT02Njc7ZS5Bb2dvbmVrPTY2NztlLkFyaW5nPTY2NztlLk90aWxkZT03Nzg7ZS56ZG90YWNjZW50PTUwMDtlLkVjYXJvbj02Njc7ZS5Jb2dvbmVrPTI3ODtlLmtjb21tYWFjY2VudD01MDA7ZS5taW51cz01ODQ7ZS5JY2lyY3VtZmxleD0yNzg7ZS5uY2Fyb249NTU2O2UudGNvbW1hYWNjZW50PTI3ODtlLmxvZ2ljYWxub3Q9NTg0O2Uub2RpZXJlc2lzPTU1NjtlLnVkaWVyZXNpcz01NTY7ZS5ub3RlcXVhbD01NDk7ZS5nY29tbWFhY2NlbnQ9NTU2O2UuZXRoPTU1NjtlLnpjYXJvbj01MDA7ZS5uY29tbWFhY2NlbnQ9NTU2O2Uub25lc3VwZXJpb3I9MzMzO2UuaW1hY3Jvbj0yNzg7ZS5FdXJvPTU1Nn0pKTtlLlN5bWJvbD0oMCxyLmdldExvb2t1cFRhYmxlRmFjdG9yeSkoKGZ1bmN0aW9uKGUpe2Uuc3BhY2U9MjUwO2UuZXhjbGFtPTMzMztlLnVuaXZlcnNhbD03MTM7ZS5udW1iZXJzaWduPTUwMDtlLmV4aXN0ZW50aWFsPTU0OTtlLnBlcmNlbnQ9ODMzO2UuYW1wZXJzYW5kPTc3ODtlLnN1Y2h0aGF0PTQzOTtlLnBhcmVubGVmdD0zMzM7ZS5wYXJlbnJpZ2h0PTMzMztlLmFzdGVyaXNrbWF0aD01MDA7ZS5wbHVzPTU0OTtlLmNvbW1hPTI1MDtlLm1pbnVzPTU0OTtlLnBlcmlvZD0yNTA7ZS5zbGFzaD0yNzg7ZS56ZXJvPTUwMDtlLm9uZT01MDA7ZS50d289NTAwO2UudGhyZWU9NTAwO2UuZm91cj01MDA7ZS5maXZlPTUwMDtlLnNpeD01MDA7ZS5zZXZlbj01MDA7ZS5laWdodD01MDA7ZS5uaW5lPTUwMDtlLmNvbG9uPTI3ODtlLnNlbWljb2xvbj0yNzg7ZS5sZXNzPTU0OTtlLmVxdWFsPTU0OTtlLmdyZWF0ZXI9NTQ5O2UucXVlc3Rpb249NDQ0O2UuY29uZ3J1ZW50PTU0OTtlLkFscGhhPTcyMjtlLkJldGE9NjY3O2UuQ2hpPTcyMjtlLkRlbHRhPTYxMjtlLkVwc2lsb249NjExO2UuUGhpPTc2MztlLkdhbW1hPTYwMztlLkV0YT03MjI7ZS5Jb3RhPTMzMztlLnRoZXRhMT02MzE7ZS5LYXBwYT03MjI7ZS5MYW1iZGE9Njg2O2UuTXU9ODg5O2UuTnU9NzIyO2UuT21pY3Jvbj03MjI7ZS5QaT03Njg7ZS5UaGV0YT03NDE7ZS5SaG89NTU2O2UuU2lnbWE9NTkyO2UuVGF1PTYxMTtlLlVwc2lsb249NjkwO2Uuc2lnbWExPTQzOTtlLk9tZWdhPTc2ODtlLlhpPTY0NTtlLlBzaT03OTU7ZS5aZXRhPTYxMTtlLmJyYWNrZXRsZWZ0PTMzMztlLnRoZXJlZm9yZT04NjM7ZS5icmFja2V0cmlnaHQ9MzMzO2UucGVycGVuZGljdWxhcj02NTg7ZS51bmRlcnNjb3JlPTUwMDtlLnJhZGljYWxleD01MDA7ZS5hbHBoYT02MzE7ZS5iZXRhPTU0OTtlLmNoaT01NDk7ZS5kZWx0YT00OTQ7ZS5lcHNpbG9uPTQzOTtlLnBoaT01MjE7ZS5nYW1tYT00MTE7ZS5ldGE9NjAzO2UuaW90YT0zMjk7ZS5waGkxPTYwMztlLmthcHBhPTU0OTtlLmxhbWJkYT01NDk7ZS5tdT01NzY7ZS5udT01MjE7ZS5vbWljcm9uPTU0OTtlLnBpPTU0OTtlLnRoZXRhPTUyMTtlLnJobz01NDk7ZS5zaWdtYT02MDM7ZS50YXU9NDM5O2UudXBzaWxvbj01NzY7ZS5vbWVnYTE9NzEzO2Uub21lZ2E9Njg2O2UueGk9NDkzO2UucHNpPTY4NjtlLnpldGE9NDk0O2UuYnJhY2VsZWZ0PTQ4MDtlLmJhcj0yMDA7ZS5icmFjZXJpZ2h0PTQ4MDtlLnNpbWlsYXI9NTQ5O2UuRXVybz03NTA7ZS5VcHNpbG9uMT02MjA7ZS5taW51dGU9MjQ3O2UubGVzc2VxdWFsPTU0OTtlLmZyYWN0aW9uPTE2NztlLmluZmluaXR5PTcxMztlLmZsb3Jpbj01MDA7ZS5jbHViPTc1MztlLmRpYW1vbmQ9NzUzO2UuaGVhcnQ9NzUzO2Uuc3BhZGU9NzUzO2UuYXJyb3dib3RoPTEwNDI7ZS5hcnJvd2xlZnQ9OTg3O2UuYXJyb3d1cD02MDM7ZS5hcnJvd3JpZ2h0PTk4NztlLmFycm93ZG93bj02MDM7ZS5kZWdyZWU9NDAwO2UucGx1c21pbnVzPTU0OTtlLnNlY29uZD00MTE7ZS5ncmVhdGVyZXF1YWw9NTQ5O2UubXVsdGlwbHk9NTQ5O2UucHJvcG9ydGlvbmFsPTcxMztlLnBhcnRpYWxkaWZmPTQ5NDtlLmJ1bGxldD00NjA7ZS5kaXZpZGU9NTQ5O2Uubm90ZXF1YWw9NTQ5O2UuZXF1aXZhbGVuY2U9NTQ5O2UuYXBwcm94ZXF1YWw9NTQ5O2UuZWxsaXBzaXM9MWUzO2UuYXJyb3d2ZXJ0ZXg9NjAzO2UuYXJyb3dob3JpemV4PTFlMztlLmNhcnJpYWdlcmV0dXJuPTY1ODtlLmFsZXBoPTgyMztlLklmcmFrdHVyPTY4NjtlLlJmcmFrdHVyPTc5NTtlLndlaWVyc3RyYXNzPTk4NztlLmNpcmNsZW11bHRpcGx5PTc2ODtlLmNpcmNsZXBsdXM9NzY4O2UuZW1wdHlzZXQ9ODIzO2UuaW50ZXJzZWN0aW9uPTc2ODtlLnVuaW9uPTc2ODtlLnByb3BlcnN1cGVyc2V0PTcxMztlLnJlZmxleHN1cGVyc2V0PTcxMztlLm5vdHN1YnNldD03MTM7ZS5wcm9wZXJzdWJzZXQ9NzEzO2UucmVmbGV4c3Vic2V0PTcxMztlLmVsZW1lbnQ9NzEzO2Uubm90ZWxlbWVudD03MTM7ZS5hbmdsZT03Njg7ZS5ncmFkaWVudD03MTM7ZS5yZWdpc3RlcnNlcmlmPTc5MDtlLmNvcHlyaWdodHNlcmlmPTc5MDtlLnRyYWRlbWFya3NlcmlmPTg5MDtlLnByb2R1Y3Q9ODIzO2UucmFkaWNhbD01NDk7ZS5kb3RtYXRoPTI1MDtlLmxvZ2ljYWxub3Q9NzEzO2UubG9naWNhbGFuZD02MDM7ZS5sb2dpY2Fsb3I9NjAzO2UuYXJyb3dkYmxib3RoPTEwNDI7ZS5hcnJvd2RibGxlZnQ9OTg3O2UuYXJyb3dkYmx1cD02MDM7ZS5hcnJvd2RibHJpZ2h0PTk4NztlLmFycm93ZGJsZG93bj02MDM7ZS5sb3plbmdlPTQ5NDtlLmFuZ2xlbGVmdD0zMjk7ZS5yZWdpc3RlcnNhbnM9NzkwO2UuY29weXJpZ2h0c2Fucz03OTA7ZS50cmFkZW1hcmtzYW5zPTc4NjtlLnN1bW1hdGlvbj03MTM7ZS5wYXJlbmxlZnR0cD0zODQ7ZS5wYXJlbmxlZnRleD0zODQ7ZS5wYXJlbmxlZnRidD0zODQ7ZS5icmFja2V0bGVmdHRwPTM4NDtlLmJyYWNrZXRsZWZ0ZXg9Mzg0O2UuYnJhY2tldGxlZnRidD0zODQ7ZS5icmFjZWxlZnR0cD00OTQ7ZS5icmFjZWxlZnRtaWQ9NDk0O2UuYnJhY2VsZWZ0YnQ9NDk0O2UuYnJhY2VleD00OTQ7ZS5hbmdsZXJpZ2h0PTMyOTtlLmludGVncmFsPTI3NDtlLmludGVncmFsdHA9Njg2O2UuaW50ZWdyYWxleD02ODY7ZS5pbnRlZ3JhbGJ0PTY4NjtlLnBhcmVucmlnaHR0cD0zODQ7ZS5wYXJlbnJpZ2h0ZXg9Mzg0O2UucGFyZW5yaWdodGJ0PTM4NDtlLmJyYWNrZXRyaWdodHRwPTM4NDtlLmJyYWNrZXRyaWdodGV4PTM4NDtlLmJyYWNrZXRyaWdodGJ0PTM4NDtlLmJyYWNlcmlnaHR0cD00OTQ7ZS5icmFjZXJpZ2h0bWlkPTQ5NDtlLmJyYWNlcmlnaHRidD00OTQ7ZS5hcHBsZT03OTB9KSk7ZVsiVGltZXMtUm9tYW4iXT0oMCxyLmdldExvb2t1cFRhYmxlRmFjdG9yeSkoKGZ1bmN0aW9uKGUpe2Uuc3BhY2U9MjUwO2UuZXhjbGFtPTMzMztlLnF1b3RlZGJsPTQwODtlLm51bWJlcnNpZ249NTAwO2UuZG9sbGFyPTUwMDtlLnBlcmNlbnQ9ODMzO2UuYW1wZXJzYW5kPTc3ODtlLnF1b3RlcmlnaHQ9MzMzO2UucGFyZW5sZWZ0PTMzMztlLnBhcmVucmlnaHQ9MzMzO2UuYXN0ZXJpc2s9NTAwO2UucGx1cz01NjQ7ZS5jb21tYT0yNTA7ZS5oeXBoZW49MzMzO2UucGVyaW9kPTI1MDtlLnNsYXNoPTI3ODtlLnplcm89NTAwO2Uub25lPTUwMDtlLnR3bz01MDA7ZS50aHJlZT01MDA7ZS5mb3VyPTUwMDtlLmZpdmU9NTAwO2Uuc2l4PTUwMDtlLnNldmVuPTUwMDtlLmVpZ2h0PTUwMDtlLm5pbmU9NTAwO2UuY29sb249Mjc4O2Uuc2VtaWNvbG9uPTI3ODtlLmxlc3M9NTY0O2UuZXF1YWw9NTY0O2UuZ3JlYXRlcj01NjQ7ZS5xdWVzdGlvbj00NDQ7ZS5hdD05MjE7ZS5BPTcyMjtlLkI9NjY3O2UuQz02Njc7ZS5EPTcyMjtlLkU9NjExO2UuRj01NTY7ZS5HPTcyMjtlLkg9NzIyO2UuST0zMzM7ZS5KPTM4OTtlLks9NzIyO2UuTD02MTE7ZS5NPTg4OTtlLk49NzIyO2UuTz03MjI7ZS5QPTU1NjtlLlE9NzIyO2UuUj02Njc7ZS5TPTU1NjtlLlQ9NjExO2UuVT03MjI7ZS5WPTcyMjtlLlc9OTQ0O2UuWD03MjI7ZS5ZPTcyMjtlLlo9NjExO2UuYnJhY2tldGxlZnQ9MzMzO2UuYmFja3NsYXNoPTI3ODtlLmJyYWNrZXRyaWdodD0zMzM7ZS5hc2NpaWNpcmN1bT00Njk7ZS51bmRlcnNjb3JlPTUwMDtlLnF1b3RlbGVmdD0zMzM7ZS5hPTQ0NDtlLmI9NTAwO2UuYz00NDQ7ZS5kPTUwMDtlLmU9NDQ0O2UuZj0zMzM7ZS5nPTUwMDtlLmg9NTAwO2UuaT0yNzg7ZS5qPTI3ODtlLms9NTAwO2UubD0yNzg7ZS5tPTc3ODtlLm49NTAwO2Uubz01MDA7ZS5wPTUwMDtlLnE9NTAwO2Uucj0zMzM7ZS5zPTM4OTtlLnQ9Mjc4O2UudT01MDA7ZS52PTUwMDtlLnc9NzIyO2UueD01MDA7ZS55PTUwMDtlLno9NDQ0O2UuYnJhY2VsZWZ0PTQ4MDtlLmJhcj0yMDA7ZS5icmFjZXJpZ2h0PTQ4MDtlLmFzY2lpdGlsZGU9NTQxO2UuZXhjbGFtZG93bj0zMzM7ZS5jZW50PTUwMDtlLnN0ZXJsaW5nPTUwMDtlLmZyYWN0aW9uPTE2NztlLnllbj01MDA7ZS5mbG9yaW49NTAwO2Uuc2VjdGlvbj01MDA7ZS5jdXJyZW5jeT01MDA7ZS5xdW90ZXNpbmdsZT0xODA7ZS5xdW90ZWRibGxlZnQ9NDQ0O2UuZ3VpbGxlbW90bGVmdD01MDA7ZS5ndWlsc2luZ2xsZWZ0PTMzMztlLmd1aWxzaW5nbHJpZ2h0PTMzMztlLmZpPTU1NjtlLmZsPTU1NjtlLmVuZGFzaD01MDA7ZS5kYWdnZXI9NTAwO2UuZGFnZ2VyZGJsPTUwMDtlLnBlcmlvZGNlbnRlcmVkPTI1MDtlLnBhcmFncmFwaD00NTM7ZS5idWxsZXQ9MzUwO2UucXVvdGVzaW5nbGJhc2U9MzMzO2UucXVvdGVkYmxiYXNlPTQ0NDtlLnF1b3RlZGJscmlnaHQ9NDQ0O2UuZ3VpbGxlbW90cmlnaHQ9NTAwO2UuZWxsaXBzaXM9MWUzO2UucGVydGhvdXNhbmQ9MWUzO2UucXVlc3Rpb25kb3duPTQ0NDtlLmdyYXZlPTMzMztlLmFjdXRlPTMzMztlLmNpcmN1bWZsZXg9MzMzO2UudGlsZGU9MzMzO2UubWFjcm9uPTMzMztlLmJyZXZlPTMzMztlLmRvdGFjY2VudD0zMzM7ZS5kaWVyZXNpcz0zMzM7ZS5yaW5nPTMzMztlLmNlZGlsbGE9MzMzO2UuaHVuZ2FydW1sYXV0PTMzMztlLm9nb25laz0zMzM7ZS5jYXJvbj0zMzM7ZS5lbWRhc2g9MWUzO2UuQUU9ODg5O2Uub3JkZmVtaW5pbmU9Mjc2O2UuTHNsYXNoPTYxMTtlLk9zbGFzaD03MjI7ZS5PRT04ODk7ZS5vcmRtYXNjdWxpbmU9MzEwO2UuYWU9NjY3O2UuZG90bGVzc2k9Mjc4O2UubHNsYXNoPTI3ODtlLm9zbGFzaD01MDA7ZS5vZT03MjI7ZS5nZXJtYW5kYmxzPTUwMDtlLklkaWVyZXNpcz0zMzM7ZS5lYWN1dGU9NDQ0O2UuYWJyZXZlPTQ0NDtlLnVodW5nYXJ1bWxhdXQ9NTAwO2UuZWNhcm9uPTQ0NDtlLllkaWVyZXNpcz03MjI7ZS5kaXZpZGU9NTY0O2UuWWFjdXRlPTcyMjtlLkFjaXJjdW1mbGV4PTcyMjtlLmFhY3V0ZT00NDQ7ZS5VY2lyY3VtZmxleD03MjI7ZS55YWN1dGU9NTAwO2Uuc2NvbW1hYWNjZW50PTM4OTtlLmVjaXJjdW1mbGV4PTQ0NDtlLlVyaW5nPTcyMjtlLlVkaWVyZXNpcz03MjI7ZS5hb2dvbmVrPTQ0NDtlLlVhY3V0ZT03MjI7ZS51b2dvbmVrPTUwMDtlLkVkaWVyZXNpcz02MTE7ZS5EY3JvYXQ9NzIyO2UuY29tbWFhY2NlbnQ9MjUwO2UuY29weXJpZ2h0PTc2MDtlLkVtYWNyb249NjExO2UuY2Nhcm9uPTQ0NDtlLmFyaW5nPTQ0NDtlLk5jb21tYWFjY2VudD03MjI7ZS5sYWN1dGU9Mjc4O2UuYWdyYXZlPTQ0NDtlLlRjb21tYWFjY2VudD02MTE7ZS5DYWN1dGU9NjY3O2UuYXRpbGRlPTQ0NDtlLkVkb3RhY2NlbnQ9NjExO2Uuc2Nhcm9uPTM4OTtlLnNjZWRpbGxhPTM4OTtlLmlhY3V0ZT0yNzg7ZS5sb3plbmdlPTQ3MTtlLlJjYXJvbj02Njc7ZS5HY29tbWFhY2NlbnQ9NzIyO2UudWNpcmN1bWZsZXg9NTAwO2UuYWNpcmN1bWZsZXg9NDQ0O2UuQW1hY3Jvbj03MjI7ZS5yY2Fyb249MzMzO2UuY2NlZGlsbGE9NDQ0O2UuWmRvdGFjY2VudD02MTE7ZS5UaG9ybj01NTY7ZS5PbWFjcm9uPTcyMjtlLlJhY3V0ZT02Njc7ZS5TYWN1dGU9NTU2O2UuZGNhcm9uPTU4ODtlLlVtYWNyb249NzIyO2UudXJpbmc9NTAwO2UudGhyZWVzdXBlcmlvcj0zMDA7ZS5PZ3JhdmU9NzIyO2UuQWdyYXZlPTcyMjtlLkFicmV2ZT03MjI7ZS5tdWx0aXBseT01NjQ7ZS51YWN1dGU9NTAwO2UuVGNhcm9uPTYxMTtlLnBhcnRpYWxkaWZmPTQ3NjtlLnlkaWVyZXNpcz01MDA7ZS5OYWN1dGU9NzIyO2UuaWNpcmN1bWZsZXg9Mjc4O2UuRWNpcmN1bWZsZXg9NjExO2UuYWRpZXJlc2lzPTQ0NDtlLmVkaWVyZXNpcz00NDQ7ZS5jYWN1dGU9NDQ0O2UubmFjdXRlPTUwMDtlLnVtYWNyb249NTAwO2UuTmNhcm9uPTcyMjtlLklhY3V0ZT0zMzM7ZS5wbHVzbWludXM9NTY0O2UuYnJva2VuYmFyPTIwMDtlLnJlZ2lzdGVyZWQ9NzYwO2UuR2JyZXZlPTcyMjtlLklkb3RhY2NlbnQ9MzMzO2Uuc3VtbWF0aW9uPTYwMDtlLkVncmF2ZT02MTE7ZS5yYWN1dGU9MzMzO2Uub21hY3Jvbj01MDA7ZS5aYWN1dGU9NjExO2UuWmNhcm9uPTYxMTtlLmdyZWF0ZXJlcXVhbD01NDk7ZS5FdGg9NzIyO2UuQ2NlZGlsbGE9NjY3O2UubGNvbW1hYWNjZW50PTI3ODtlLnRjYXJvbj0zMjY7ZS5lb2dvbmVrPTQ0NDtlLlVvZ29uZWs9NzIyO2UuQWFjdXRlPTcyMjtlLkFkaWVyZXNpcz03MjI7ZS5lZ3JhdmU9NDQ0O2UuemFjdXRlPTQ0NDtlLmlvZ29uZWs9Mjc4O2UuT2FjdXRlPTcyMjtlLm9hY3V0ZT01MDA7ZS5hbWFjcm9uPTQ0NDtlLnNhY3V0ZT0zODk7ZS5pZGllcmVzaXM9Mjc4O2UuT2NpcmN1bWZsZXg9NzIyO2UuVWdyYXZlPTcyMjtlLkRlbHRhPTYxMjtlLnRob3JuPTUwMDtlLnR3b3N1cGVyaW9yPTMwMDtlLk9kaWVyZXNpcz03MjI7ZS5tdT01MDA7ZS5pZ3JhdmU9Mjc4O2Uub2h1bmdhcnVtbGF1dD01MDA7ZS5Fb2dvbmVrPTYxMTtlLmRjcm9hdD01MDA7ZS50aHJlZXF1YXJ0ZXJzPTc1MDtlLlNjZWRpbGxhPTU1NjtlLmxjYXJvbj0zNDQ7ZS5LY29tbWFhY2NlbnQ9NzIyO2UuTGFjdXRlPTYxMTtlLnRyYWRlbWFyaz05ODA7ZS5lZG90YWNjZW50PTQ0NDtlLklncmF2ZT0zMzM7ZS5JbWFjcm9uPTMzMztlLkxjYXJvbj02MTE7ZS5vbmVoYWxmPTc1MDtlLmxlc3NlcXVhbD01NDk7ZS5vY2lyY3VtZmxleD01MDA7ZS5udGlsZGU9NTAwO2UuVWh1bmdhcnVtbGF1dD03MjI7ZS5FYWN1dGU9NjExO2UuZW1hY3Jvbj00NDQ7ZS5nYnJldmU9NTAwO2Uub25lcXVhcnRlcj03NTA7ZS5TY2Fyb249NTU2O2UuU2NvbW1hYWNjZW50PTU1NjtlLk9odW5nYXJ1bWxhdXQ9NzIyO2UuZGVncmVlPTQwMDtlLm9ncmF2ZT01MDA7ZS5DY2Fyb249NjY3O2UudWdyYXZlPTUwMDtlLnJhZGljYWw9NDUzO2UuRGNhcm9uPTcyMjtlLnJjb21tYWFjY2VudD0zMzM7ZS5OdGlsZGU9NzIyO2Uub3RpbGRlPTUwMDtlLlJjb21tYWFjY2VudD02Njc7ZS5MY29tbWFhY2NlbnQ9NjExO2UuQXRpbGRlPTcyMjtlLkFvZ29uZWs9NzIyO2UuQXJpbmc9NzIyO2UuT3RpbGRlPTcyMjtlLnpkb3RhY2NlbnQ9NDQ0O2UuRWNhcm9uPTYxMTtlLklvZ29uZWs9MzMzO2Uua2NvbW1hYWNjZW50PTUwMDtlLm1pbnVzPTU2NDtlLkljaXJjdW1mbGV4PTMzMztlLm5jYXJvbj01MDA7ZS50Y29tbWFhY2NlbnQ9Mjc4O2UubG9naWNhbG5vdD01NjQ7ZS5vZGllcmVzaXM9NTAwO2UudWRpZXJlc2lzPTUwMDtlLm5vdGVxdWFsPTU0OTtlLmdjb21tYWFjY2VudD01MDA7ZS5ldGg9NTAwO2UuemNhcm9uPTQ0NDtlLm5jb21tYWFjY2VudD01MDA7ZS5vbmVzdXBlcmlvcj0zMDA7ZS5pbWFjcm9uPTI3ODtlLkV1cm89NTAwfSkpO2VbIlRpbWVzLUJvbGQiXT0oMCxyLmdldExvb2t1cFRhYmxlRmFjdG9yeSkoKGZ1bmN0aW9uKGUpe2Uuc3BhY2U9MjUwO2UuZXhjbGFtPTMzMztlLnF1b3RlZGJsPTU1NTtlLm51bWJlcnNpZ249NTAwO2UuZG9sbGFyPTUwMDtlLnBlcmNlbnQ9MWUzO2UuYW1wZXJzYW5kPTgzMztlLnF1b3RlcmlnaHQ9MzMzO2UucGFyZW5sZWZ0PTMzMztlLnBhcmVucmlnaHQ9MzMzO2UuYXN0ZXJpc2s9NTAwO2UucGx1cz01NzA7ZS5jb21tYT0yNTA7ZS5oeXBoZW49MzMzO2UucGVyaW9kPTI1MDtlLnNsYXNoPTI3ODtlLnplcm89NTAwO2Uub25lPTUwMDtlLnR3bz01MDA7ZS50aHJlZT01MDA7ZS5mb3VyPTUwMDtlLmZpdmU9NTAwO2Uuc2l4PTUwMDtlLnNldmVuPTUwMDtlLmVpZ2h0PTUwMDtlLm5pbmU9NTAwO2UuY29sb249MzMzO2Uuc2VtaWNvbG9uPTMzMztlLmxlc3M9NTcwO2UuZXF1YWw9NTcwO2UuZ3JlYXRlcj01NzA7ZS5xdWVzdGlvbj01MDA7ZS5hdD05MzA7ZS5BPTcyMjtlLkI9NjY3O2UuQz03MjI7ZS5EPTcyMjtlLkU9NjY3O2UuRj02MTE7ZS5HPTc3ODtlLkg9Nzc4O2UuST0zODk7ZS5KPTUwMDtlLks9Nzc4O2UuTD02Njc7ZS5NPTk0NDtlLk49NzIyO2UuTz03Nzg7ZS5QPTYxMTtlLlE9Nzc4O2UuUj03MjI7ZS5TPTU1NjtlLlQ9NjY3O2UuVT03MjI7ZS5WPTcyMjtlLlc9MWUzO2UuWD03MjI7ZS5ZPTcyMjtlLlo9NjY3O2UuYnJhY2tldGxlZnQ9MzMzO2UuYmFja3NsYXNoPTI3ODtlLmJyYWNrZXRyaWdodD0zMzM7ZS5hc2NpaWNpcmN1bT01ODE7ZS51bmRlcnNjb3JlPTUwMDtlLnF1b3RlbGVmdD0zMzM7ZS5hPTUwMDtlLmI9NTU2O2UuYz00NDQ7ZS5kPTU1NjtlLmU9NDQ0O2UuZj0zMzM7ZS5nPTUwMDtlLmg9NTU2O2UuaT0yNzg7ZS5qPTMzMztlLms9NTU2O2UubD0yNzg7ZS5tPTgzMztlLm49NTU2O2Uubz01MDA7ZS5wPTU1NjtlLnE9NTU2O2Uucj00NDQ7ZS5zPTM4OTtlLnQ9MzMzO2UudT01NTY7ZS52PTUwMDtlLnc9NzIyO2UueD01MDA7ZS55PTUwMDtlLno9NDQ0O2UuYnJhY2VsZWZ0PTM5NDtlLmJhcj0yMjA7ZS5icmFjZXJpZ2h0PTM5NDtlLmFzY2lpdGlsZGU9NTIwO2UuZXhjbGFtZG93bj0zMzM7ZS5jZW50PTUwMDtlLnN0ZXJsaW5nPTUwMDtlLmZyYWN0aW9uPTE2NztlLnllbj01MDA7ZS5mbG9yaW49NTAwO2Uuc2VjdGlvbj01MDA7ZS5jdXJyZW5jeT01MDA7ZS5xdW90ZXNpbmdsZT0yNzg7ZS5xdW90ZWRibGxlZnQ9NTAwO2UuZ3VpbGxlbW90bGVmdD01MDA7ZS5ndWlsc2luZ2xsZWZ0PTMzMztlLmd1aWxzaW5nbHJpZ2h0PTMzMztlLmZpPTU1NjtlLmZsPTU1NjtlLmVuZGFzaD01MDA7ZS5kYWdnZXI9NTAwO2UuZGFnZ2VyZGJsPTUwMDtlLnBlcmlvZGNlbnRlcmVkPTI1MDtlLnBhcmFncmFwaD01NDA7ZS5idWxsZXQ9MzUwO2UucXVvdGVzaW5nbGJhc2U9MzMzO2UucXVvdGVkYmxiYXNlPTUwMDtlLnF1b3RlZGJscmlnaHQ9NTAwO2UuZ3VpbGxlbW90cmlnaHQ9NTAwO2UuZWxsaXBzaXM9MWUzO2UucGVydGhvdXNhbmQ9MWUzO2UucXVlc3Rpb25kb3duPTUwMDtlLmdyYXZlPTMzMztlLmFjdXRlPTMzMztlLmNpcmN1bWZsZXg9MzMzO2UudGlsZGU9MzMzO2UubWFjcm9uPTMzMztlLmJyZXZlPTMzMztlLmRvdGFjY2VudD0zMzM7ZS5kaWVyZXNpcz0zMzM7ZS5yaW5nPTMzMztlLmNlZGlsbGE9MzMzO2UuaHVuZ2FydW1sYXV0PTMzMztlLm9nb25laz0zMzM7ZS5jYXJvbj0zMzM7ZS5lbWRhc2g9MWUzO2UuQUU9MWUzO2Uub3JkZmVtaW5pbmU9MzAwO2UuTHNsYXNoPTY2NztlLk9zbGFzaD03Nzg7ZS5PRT0xZTM7ZS5vcmRtYXNjdWxpbmU9MzMwO2UuYWU9NzIyO2UuZG90bGVzc2k9Mjc4O2UubHNsYXNoPTI3ODtlLm9zbGFzaD01MDA7ZS5vZT03MjI7ZS5nZXJtYW5kYmxzPTU1NjtlLklkaWVyZXNpcz0zODk7ZS5lYWN1dGU9NDQ0O2UuYWJyZXZlPTUwMDtlLnVodW5nYXJ1bWxhdXQ9NTU2O2UuZWNhcm9uPTQ0NDtlLllkaWVyZXNpcz03MjI7ZS5kaXZpZGU9NTcwO2UuWWFjdXRlPTcyMjtlLkFjaXJjdW1mbGV4PTcyMjtlLmFhY3V0ZT01MDA7ZS5VY2lyY3VtZmxleD03MjI7ZS55YWN1dGU9NTAwO2Uuc2NvbW1hYWNjZW50PTM4OTtlLmVjaXJjdW1mbGV4PTQ0NDtlLlVyaW5nPTcyMjtlLlVkaWVyZXNpcz03MjI7ZS5hb2dvbmVrPTUwMDtlLlVhY3V0ZT03MjI7ZS51b2dvbmVrPTU1NjtlLkVkaWVyZXNpcz02Njc7ZS5EY3JvYXQ9NzIyO2UuY29tbWFhY2NlbnQ9MjUwO2UuY29weXJpZ2h0PTc0NztlLkVtYWNyb249NjY3O2UuY2Nhcm9uPTQ0NDtlLmFyaW5nPTUwMDtlLk5jb21tYWFjY2VudD03MjI7ZS5sYWN1dGU9Mjc4O2UuYWdyYXZlPTUwMDtlLlRjb21tYWFjY2VudD02Njc7ZS5DYWN1dGU9NzIyO2UuYXRpbGRlPTUwMDtlLkVkb3RhY2NlbnQ9NjY3O2Uuc2Nhcm9uPTM4OTtlLnNjZWRpbGxhPTM4OTtlLmlhY3V0ZT0yNzg7ZS5sb3plbmdlPTQ5NDtlLlJjYXJvbj03MjI7ZS5HY29tbWFhY2NlbnQ9Nzc4O2UudWNpcmN1bWZsZXg9NTU2O2UuYWNpcmN1bWZsZXg9NTAwO2UuQW1hY3Jvbj03MjI7ZS5yY2Fyb249NDQ0O2UuY2NlZGlsbGE9NDQ0O2UuWmRvdGFjY2VudD02Njc7ZS5UaG9ybj02MTE7ZS5PbWFjcm9uPTc3ODtlLlJhY3V0ZT03MjI7ZS5TYWN1dGU9NTU2O2UuZGNhcm9uPTY3MjtlLlVtYWNyb249NzIyO2UudXJpbmc9NTU2O2UudGhyZWVzdXBlcmlvcj0zMDA7ZS5PZ3JhdmU9Nzc4O2UuQWdyYXZlPTcyMjtlLkFicmV2ZT03MjI7ZS5tdWx0aXBseT01NzA7ZS51YWN1dGU9NTU2O2UuVGNhcm9uPTY2NztlLnBhcnRpYWxkaWZmPTQ5NDtlLnlkaWVyZXNpcz01MDA7ZS5OYWN1dGU9NzIyO2UuaWNpcmN1bWZsZXg9Mjc4O2UuRWNpcmN1bWZsZXg9NjY3O2UuYWRpZXJlc2lzPTUwMDtlLmVkaWVyZXNpcz00NDQ7ZS5jYWN1dGU9NDQ0O2UubmFjdXRlPTU1NjtlLnVtYWNyb249NTU2O2UuTmNhcm9uPTcyMjtlLklhY3V0ZT0zODk7ZS5wbHVzbWludXM9NTcwO2UuYnJva2VuYmFyPTIyMDtlLnJlZ2lzdGVyZWQ9NzQ3O2UuR2JyZXZlPTc3ODtlLklkb3RhY2NlbnQ9Mzg5O2Uuc3VtbWF0aW9uPTYwMDtlLkVncmF2ZT02Njc7ZS5yYWN1dGU9NDQ0O2Uub21hY3Jvbj01MDA7ZS5aYWN1dGU9NjY3O2UuWmNhcm9uPTY2NztlLmdyZWF0ZXJlcXVhbD01NDk7ZS5FdGg9NzIyO2UuQ2NlZGlsbGE9NzIyO2UubGNvbW1hYWNjZW50PTI3ODtlLnRjYXJvbj00MTY7ZS5lb2dvbmVrPTQ0NDtlLlVvZ29uZWs9NzIyO2UuQWFjdXRlPTcyMjtlLkFkaWVyZXNpcz03MjI7ZS5lZ3JhdmU9NDQ0O2UuemFjdXRlPTQ0NDtlLmlvZ29uZWs9Mjc4O2UuT2FjdXRlPTc3ODtlLm9hY3V0ZT01MDA7ZS5hbWFjcm9uPTUwMDtlLnNhY3V0ZT0zODk7ZS5pZGllcmVzaXM9Mjc4O2UuT2NpcmN1bWZsZXg9Nzc4O2UuVWdyYXZlPTcyMjtlLkRlbHRhPTYxMjtlLnRob3JuPTU1NjtlLnR3b3N1cGVyaW9yPTMwMDtlLk9kaWVyZXNpcz03Nzg7ZS5tdT01NTY7ZS5pZ3JhdmU9Mjc4O2Uub2h1bmdhcnVtbGF1dD01MDA7ZS5Fb2dvbmVrPTY2NztlLmRjcm9hdD01NTY7ZS50aHJlZXF1YXJ0ZXJzPTc1MDtlLlNjZWRpbGxhPTU1NjtlLmxjYXJvbj0zOTQ7ZS5LY29tbWFhY2NlbnQ9Nzc4O2UuTGFjdXRlPTY2NztlLnRyYWRlbWFyaz0xZTM7ZS5lZG90YWNjZW50PTQ0NDtlLklncmF2ZT0zODk7ZS5JbWFjcm9uPTM4OTtlLkxjYXJvbj02Njc7ZS5vbmVoYWxmPTc1MDtlLmxlc3NlcXVhbD01NDk7ZS5vY2lyY3VtZmxleD01MDA7ZS5udGlsZGU9NTU2O2UuVWh1bmdhcnVtbGF1dD03MjI7ZS5FYWN1dGU9NjY3O2UuZW1hY3Jvbj00NDQ7ZS5nYnJldmU9NTAwO2Uub25lcXVhcnRlcj03NTA7ZS5TY2Fyb249NTU2O2UuU2NvbW1hYWNjZW50PTU1NjtlLk9odW5nYXJ1bWxhdXQ9Nzc4O2UuZGVncmVlPTQwMDtlLm9ncmF2ZT01MDA7ZS5DY2Fyb249NzIyO2UudWdyYXZlPTU1NjtlLnJhZGljYWw9NTQ5O2UuRGNhcm9uPTcyMjtlLnJjb21tYWFjY2VudD00NDQ7ZS5OdGlsZGU9NzIyO2Uub3RpbGRlPTUwMDtlLlJjb21tYWFjY2VudD03MjI7ZS5MY29tbWFhY2NlbnQ9NjY3O2UuQXRpbGRlPTcyMjtlLkFvZ29uZWs9NzIyO2UuQXJpbmc9NzIyO2UuT3RpbGRlPTc3ODtlLnpkb3RhY2NlbnQ9NDQ0O2UuRWNhcm9uPTY2NztlLklvZ29uZWs9Mzg5O2Uua2NvbW1hYWNjZW50PTU1NjtlLm1pbnVzPTU3MDtlLkljaXJjdW1mbGV4PTM4OTtlLm5jYXJvbj01NTY7ZS50Y29tbWFhY2NlbnQ9MzMzO2UubG9naWNhbG5vdD01NzA7ZS5vZGllcmVzaXM9NTAwO2UudWRpZXJlc2lzPTU1NjtlLm5vdGVxdWFsPTU0OTtlLmdjb21tYWFjY2VudD01MDA7ZS5ldGg9NTAwO2UuemNhcm9uPTQ0NDtlLm5jb21tYWFjY2VudD01NTY7ZS5vbmVzdXBlcmlvcj0zMDA7ZS5pbWFjcm9uPTI3ODtlLkV1cm89NTAwfSkpO2VbIlRpbWVzLUJvbGRJdGFsaWMiXT0oMCxyLmdldExvb2t1cFRhYmxlRmFjdG9yeSkoKGZ1bmN0aW9uKGUpe2Uuc3BhY2U9MjUwO2UuZXhjbGFtPTM4OTtlLnF1b3RlZGJsPTU1NTtlLm51bWJlcnNpZ249NTAwO2UuZG9sbGFyPTUwMDtlLnBlcmNlbnQ9ODMzO2UuYW1wZXJzYW5kPTc3ODtlLnF1b3RlcmlnaHQ9MzMzO2UucGFyZW5sZWZ0PTMzMztlLnBhcmVucmlnaHQ9MzMzO2UuYXN0ZXJpc2s9NTAwO2UucGx1cz01NzA7ZS5jb21tYT0yNTA7ZS5oeXBoZW49MzMzO2UucGVyaW9kPTI1MDtlLnNsYXNoPTI3ODtlLnplcm89NTAwO2Uub25lPTUwMDtlLnR3bz01MDA7ZS50aHJlZT01MDA7ZS5mb3VyPTUwMDtlLmZpdmU9NTAwO2Uuc2l4PTUwMDtlLnNldmVuPTUwMDtlLmVpZ2h0PTUwMDtlLm5pbmU9NTAwO2UuY29sb249MzMzO2Uuc2VtaWNvbG9uPTMzMztlLmxlc3M9NTcwO2UuZXF1YWw9NTcwO2UuZ3JlYXRlcj01NzA7ZS5xdWVzdGlvbj01MDA7ZS5hdD04MzI7ZS5BPTY2NztlLkI9NjY3O2UuQz02Njc7ZS5EPTcyMjtlLkU9NjY3O2UuRj02Njc7ZS5HPTcyMjtlLkg9Nzc4O2UuST0zODk7ZS5KPTUwMDtlLks9NjY3O2UuTD02MTE7ZS5NPTg4OTtlLk49NzIyO2UuTz03MjI7ZS5QPTYxMTtlLlE9NzIyO2UuUj02Njc7ZS5TPTU1NjtlLlQ9NjExO2UuVT03MjI7ZS5WPTY2NztlLlc9ODg5O2UuWD02Njc7ZS5ZPTYxMTtlLlo9NjExO2UuYnJhY2tldGxlZnQ9MzMzO2UuYmFja3NsYXNoPTI3ODtlLmJyYWNrZXRyaWdodD0zMzM7ZS5hc2NpaWNpcmN1bT01NzA7ZS51bmRlcnNjb3JlPTUwMDtlLnF1b3RlbGVmdD0zMzM7ZS5hPTUwMDtlLmI9NTAwO2UuYz00NDQ7ZS5kPTUwMDtlLmU9NDQ0O2UuZj0zMzM7ZS5nPTUwMDtlLmg9NTU2O2UuaT0yNzg7ZS5qPTI3ODtlLms9NTAwO2UubD0yNzg7ZS5tPTc3ODtlLm49NTU2O2Uubz01MDA7ZS5wPTUwMDtlLnE9NTAwO2Uucj0zODk7ZS5zPTM4OTtlLnQ9Mjc4O2UudT01NTY7ZS52PTQ0NDtlLnc9NjY3O2UueD01MDA7ZS55PTQ0NDtlLno9Mzg5O2UuYnJhY2VsZWZ0PTM0ODtlLmJhcj0yMjA7ZS5icmFjZXJpZ2h0PTM0ODtlLmFzY2lpdGlsZGU9NTcwO2UuZXhjbGFtZG93bj0zODk7ZS5jZW50PTUwMDtlLnN0ZXJsaW5nPTUwMDtlLmZyYWN0aW9uPTE2NztlLnllbj01MDA7ZS5mbG9yaW49NTAwO2Uuc2VjdGlvbj01MDA7ZS5jdXJyZW5jeT01MDA7ZS5xdW90ZXNpbmdsZT0yNzg7ZS5xdW90ZWRibGxlZnQ9NTAwO2UuZ3VpbGxlbW90bGVmdD01MDA7ZS5ndWlsc2luZ2xsZWZ0PTMzMztlLmd1aWxzaW5nbHJpZ2h0PTMzMztlLmZpPTU1NjtlLmZsPTU1NjtlLmVuZGFzaD01MDA7ZS5kYWdnZXI9NTAwO2UuZGFnZ2VyZGJsPTUwMDtlLnBlcmlvZGNlbnRlcmVkPTI1MDtlLnBhcmFncmFwaD01MDA7ZS5idWxsZXQ9MzUwO2UucXVvdGVzaW5nbGJhc2U9MzMzO2UucXVvdGVkYmxiYXNlPTUwMDtlLnF1b3RlZGJscmlnaHQ9NTAwO2UuZ3VpbGxlbW90cmlnaHQ9NTAwO2UuZWxsaXBzaXM9MWUzO2UucGVydGhvdXNhbmQ9MWUzO2UucXVlc3Rpb25kb3duPTUwMDtlLmdyYXZlPTMzMztlLmFjdXRlPTMzMztlLmNpcmN1bWZsZXg9MzMzO2UudGlsZGU9MzMzO2UubWFjcm9uPTMzMztlLmJyZXZlPTMzMztlLmRvdGFjY2VudD0zMzM7ZS5kaWVyZXNpcz0zMzM7ZS5yaW5nPTMzMztlLmNlZGlsbGE9MzMzO2UuaHVuZ2FydW1sYXV0PTMzMztlLm9nb25laz0zMzM7ZS5jYXJvbj0zMzM7ZS5lbWRhc2g9MWUzO2UuQUU9OTQ0O2Uub3JkZmVtaW5pbmU9MjY2O2UuTHNsYXNoPTYxMTtlLk9zbGFzaD03MjI7ZS5PRT05NDQ7ZS5vcmRtYXNjdWxpbmU9MzAwO2UuYWU9NzIyO2UuZG90bGVzc2k9Mjc4O2UubHNsYXNoPTI3ODtlLm9zbGFzaD01MDA7ZS5vZT03MjI7ZS5nZXJtYW5kYmxzPTUwMDtlLklkaWVyZXNpcz0zODk7ZS5lYWN1dGU9NDQ0O2UuYWJyZXZlPTUwMDtlLnVodW5nYXJ1bWxhdXQ9NTU2O2UuZWNhcm9uPTQ0NDtlLllkaWVyZXNpcz02MTE7ZS5kaXZpZGU9NTcwO2UuWWFjdXRlPTYxMTtlLkFjaXJjdW1mbGV4PTY2NztlLmFhY3V0ZT01MDA7ZS5VY2lyY3VtZmxleD03MjI7ZS55YWN1dGU9NDQ0O2Uuc2NvbW1hYWNjZW50PTM4OTtlLmVjaXJjdW1mbGV4PTQ0NDtlLlVyaW5nPTcyMjtlLlVkaWVyZXNpcz03MjI7ZS5hb2dvbmVrPTUwMDtlLlVhY3V0ZT03MjI7ZS51b2dvbmVrPTU1NjtlLkVkaWVyZXNpcz02Njc7ZS5EY3JvYXQ9NzIyO2UuY29tbWFhY2NlbnQ9MjUwO2UuY29weXJpZ2h0PTc0NztlLkVtYWNyb249NjY3O2UuY2Nhcm9uPTQ0NDtlLmFyaW5nPTUwMDtlLk5jb21tYWFjY2VudD03MjI7ZS5sYWN1dGU9Mjc4O2UuYWdyYXZlPTUwMDtlLlRjb21tYWFjY2VudD02MTE7ZS5DYWN1dGU9NjY3O2UuYXRpbGRlPTUwMDtlLkVkb3RhY2NlbnQ9NjY3O2Uuc2Nhcm9uPTM4OTtlLnNjZWRpbGxhPTM4OTtlLmlhY3V0ZT0yNzg7ZS5sb3plbmdlPTQ5NDtlLlJjYXJvbj02Njc7ZS5HY29tbWFhY2NlbnQ9NzIyO2UudWNpcmN1bWZsZXg9NTU2O2UuYWNpcmN1bWZsZXg9NTAwO2UuQW1hY3Jvbj02Njc7ZS5yY2Fyb249Mzg5O2UuY2NlZGlsbGE9NDQ0O2UuWmRvdGFjY2VudD02MTE7ZS5UaG9ybj02MTE7ZS5PbWFjcm9uPTcyMjtlLlJhY3V0ZT02Njc7ZS5TYWN1dGU9NTU2O2UuZGNhcm9uPTYwODtlLlVtYWNyb249NzIyO2UudXJpbmc9NTU2O2UudGhyZWVzdXBlcmlvcj0zMDA7ZS5PZ3JhdmU9NzIyO2UuQWdyYXZlPTY2NztlLkFicmV2ZT02Njc7ZS5tdWx0aXBseT01NzA7ZS51YWN1dGU9NTU2O2UuVGNhcm9uPTYxMTtlLnBhcnRpYWxkaWZmPTQ5NDtlLnlkaWVyZXNpcz00NDQ7ZS5OYWN1dGU9NzIyO2UuaWNpcmN1bWZsZXg9Mjc4O2UuRWNpcmN1bWZsZXg9NjY3O2UuYWRpZXJlc2lzPTUwMDtlLmVkaWVyZXNpcz00NDQ7ZS5jYWN1dGU9NDQ0O2UubmFjdXRlPTU1NjtlLnVtYWNyb249NTU2O2UuTmNhcm9uPTcyMjtlLklhY3V0ZT0zODk7ZS5wbHVzbWludXM9NTcwO2UuYnJva2VuYmFyPTIyMDtlLnJlZ2lzdGVyZWQ9NzQ3O2UuR2JyZXZlPTcyMjtlLklkb3RhY2NlbnQ9Mzg5O2Uuc3VtbWF0aW9uPTYwMDtlLkVncmF2ZT02Njc7ZS5yYWN1dGU9Mzg5O2Uub21hY3Jvbj01MDA7ZS5aYWN1dGU9NjExO2UuWmNhcm9uPTYxMTtlLmdyZWF0ZXJlcXVhbD01NDk7ZS5FdGg9NzIyO2UuQ2NlZGlsbGE9NjY3O2UubGNvbW1hYWNjZW50PTI3ODtlLnRjYXJvbj0zNjY7ZS5lb2dvbmVrPTQ0NDtlLlVvZ29uZWs9NzIyO2UuQWFjdXRlPTY2NztlLkFkaWVyZXNpcz02Njc7ZS5lZ3JhdmU9NDQ0O2UuemFjdXRlPTM4OTtlLmlvZ29uZWs9Mjc4O2UuT2FjdXRlPTcyMjtlLm9hY3V0ZT01MDA7ZS5hbWFjcm9uPTUwMDtlLnNhY3V0ZT0zODk7ZS5pZGllcmVzaXM9Mjc4O2UuT2NpcmN1bWZsZXg9NzIyO2UuVWdyYXZlPTcyMjtlLkRlbHRhPTYxMjtlLnRob3JuPTUwMDtlLnR3b3N1cGVyaW9yPTMwMDtlLk9kaWVyZXNpcz03MjI7ZS5tdT01NzY7ZS5pZ3JhdmU9Mjc4O2Uub2h1bmdhcnVtbGF1dD01MDA7ZS5Fb2dvbmVrPTY2NztlLmRjcm9hdD01MDA7ZS50aHJlZXF1YXJ0ZXJzPTc1MDtlLlNjZWRpbGxhPTU1NjtlLmxjYXJvbj0zODI7ZS5LY29tbWFhY2NlbnQ9NjY3O2UuTGFjdXRlPTYxMTtlLnRyYWRlbWFyaz0xZTM7ZS5lZG90YWNjZW50PTQ0NDtlLklncmF2ZT0zODk7ZS5JbWFjcm9uPTM4OTtlLkxjYXJvbj02MTE7ZS5vbmVoYWxmPTc1MDtlLmxlc3NlcXVhbD01NDk7ZS5vY2lyY3VtZmxleD01MDA7ZS5udGlsZGU9NTU2O2UuVWh1bmdhcnVtbGF1dD03MjI7ZS5FYWN1dGU9NjY3O2UuZW1hY3Jvbj00NDQ7ZS5nYnJldmU9NTAwO2Uub25lcXVhcnRlcj03NTA7ZS5TY2Fyb249NTU2O2UuU2NvbW1hYWNjZW50PTU1NjtlLk9odW5nYXJ1bWxhdXQ9NzIyO2UuZGVncmVlPTQwMDtlLm9ncmF2ZT01MDA7ZS5DY2Fyb249NjY3O2UudWdyYXZlPTU1NjtlLnJhZGljYWw9NTQ5O2UuRGNhcm9uPTcyMjtlLnJjb21tYWFjY2VudD0zODk7ZS5OdGlsZGU9NzIyO2Uub3RpbGRlPTUwMDtlLlJjb21tYWFjY2VudD02Njc7ZS5MY29tbWFhY2NlbnQ9NjExO2UuQXRpbGRlPTY2NztlLkFvZ29uZWs9NjY3O2UuQXJpbmc9NjY3O2UuT3RpbGRlPTcyMjtlLnpkb3RhY2NlbnQ9Mzg5O2UuRWNhcm9uPTY2NztlLklvZ29uZWs9Mzg5O2Uua2NvbW1hYWNjZW50PTUwMDtlLm1pbnVzPTYwNjtlLkljaXJjdW1mbGV4PTM4OTtlLm5jYXJvbj01NTY7ZS50Y29tbWFhY2NlbnQ9Mjc4O2UubG9naWNhbG5vdD02MDY7ZS5vZGllcmVzaXM9NTAwO2UudWRpZXJlc2lzPTU1NjtlLm5vdGVxdWFsPTU0OTtlLmdjb21tYWFjY2VudD01MDA7ZS5ldGg9NTAwO2UuemNhcm9uPTM4OTtlLm5jb21tYWFjY2VudD01NTY7ZS5vbmVzdXBlcmlvcj0zMDA7ZS5pbWFjcm9uPTI3ODtlLkV1cm89NTAwfSkpO2VbIlRpbWVzLUl0YWxpYyJdPSgwLHIuZ2V0TG9va3VwVGFibGVGYWN0b3J5KSgoZnVuY3Rpb24oZSl7ZS5zcGFjZT0yNTA7ZS5leGNsYW09MzMzO2UucXVvdGVkYmw9NDIwO2UubnVtYmVyc2lnbj01MDA7ZS5kb2xsYXI9NTAwO2UucGVyY2VudD04MzM7ZS5hbXBlcnNhbmQ9Nzc4O2UucXVvdGVyaWdodD0zMzM7ZS5wYXJlbmxlZnQ9MzMzO2UucGFyZW5yaWdodD0zMzM7ZS5hc3Rlcmlzaz01MDA7ZS5wbHVzPTY3NTtlLmNvbW1hPTI1MDtlLmh5cGhlbj0zMzM7ZS5wZXJpb2Q9MjUwO2Uuc2xhc2g9Mjc4O2UuemVybz01MDA7ZS5vbmU9NTAwO2UudHdvPTUwMDtlLnRocmVlPTUwMDtlLmZvdXI9NTAwO2UuZml2ZT01MDA7ZS5zaXg9NTAwO2Uuc2V2ZW49NTAwO2UuZWlnaHQ9NTAwO2UubmluZT01MDA7ZS5jb2xvbj0zMzM7ZS5zZW1pY29sb249MzMzO2UubGVzcz02NzU7ZS5lcXVhbD02NzU7ZS5ncmVhdGVyPTY3NTtlLnF1ZXN0aW9uPTUwMDtlLmF0PTkyMDtlLkE9NjExO2UuQj02MTE7ZS5DPTY2NztlLkQ9NzIyO2UuRT02MTE7ZS5GPTYxMTtlLkc9NzIyO2UuSD03MjI7ZS5JPTMzMztlLko9NDQ0O2UuSz02Njc7ZS5MPTU1NjtlLk09ODMzO2UuTj02Njc7ZS5PPTcyMjtlLlA9NjExO2UuUT03MjI7ZS5SPTYxMTtlLlM9NTAwO2UuVD01NTY7ZS5VPTcyMjtlLlY9NjExO2UuVz04MzM7ZS5YPTYxMTtlLlk9NTU2O2UuWj01NTY7ZS5icmFja2V0bGVmdD0zODk7ZS5iYWNrc2xhc2g9Mjc4O2UuYnJhY2tldHJpZ2h0PTM4OTtlLmFzY2lpY2lyY3VtPTQyMjtlLnVuZGVyc2NvcmU9NTAwO2UucXVvdGVsZWZ0PTMzMztlLmE9NTAwO2UuYj01MDA7ZS5jPTQ0NDtlLmQ9NTAwO2UuZT00NDQ7ZS5mPTI3ODtlLmc9NTAwO2UuaD01MDA7ZS5pPTI3ODtlLmo9Mjc4O2Uuaz00NDQ7ZS5sPTI3ODtlLm09NzIyO2Uubj01MDA7ZS5vPTUwMDtlLnA9NTAwO2UucT01MDA7ZS5yPTM4OTtlLnM9Mzg5O2UudD0yNzg7ZS51PTUwMDtlLnY9NDQ0O2Uudz02Njc7ZS54PTQ0NDtlLnk9NDQ0O2Uuej0zODk7ZS5icmFjZWxlZnQ9NDAwO2UuYmFyPTI3NTtlLmJyYWNlcmlnaHQ9NDAwO2UuYXNjaWl0aWxkZT01NDE7ZS5leGNsYW1kb3duPTM4OTtlLmNlbnQ9NTAwO2Uuc3Rlcmxpbmc9NTAwO2UuZnJhY3Rpb249MTY3O2UueWVuPTUwMDtlLmZsb3Jpbj01MDA7ZS5zZWN0aW9uPTUwMDtlLmN1cnJlbmN5PTUwMDtlLnF1b3Rlc2luZ2xlPTIxNDtlLnF1b3RlZGJsbGVmdD01NTY7ZS5ndWlsbGVtb3RsZWZ0PTUwMDtlLmd1aWxzaW5nbGxlZnQ9MzMzO2UuZ3VpbHNpbmdscmlnaHQ9MzMzO2UuZmk9NTAwO2UuZmw9NTAwO2UuZW5kYXNoPTUwMDtlLmRhZ2dlcj01MDA7ZS5kYWdnZXJkYmw9NTAwO2UucGVyaW9kY2VudGVyZWQ9MjUwO2UucGFyYWdyYXBoPTUyMztlLmJ1bGxldD0zNTA7ZS5xdW90ZXNpbmdsYmFzZT0zMzM7ZS5xdW90ZWRibGJhc2U9NTU2O2UucXVvdGVkYmxyaWdodD01NTY7ZS5ndWlsbGVtb3RyaWdodD01MDA7ZS5lbGxpcHNpcz04ODk7ZS5wZXJ0aG91c2FuZD0xZTM7ZS5xdWVzdGlvbmRvd249NTAwO2UuZ3JhdmU9MzMzO2UuYWN1dGU9MzMzO2UuY2lyY3VtZmxleD0zMzM7ZS50aWxkZT0zMzM7ZS5tYWNyb249MzMzO2UuYnJldmU9MzMzO2UuZG90YWNjZW50PTMzMztlLmRpZXJlc2lzPTMzMztlLnJpbmc9MzMzO2UuY2VkaWxsYT0zMzM7ZS5odW5nYXJ1bWxhdXQ9MzMzO2Uub2dvbmVrPTMzMztlLmNhcm9uPTMzMztlLmVtZGFzaD04ODk7ZS5BRT04ODk7ZS5vcmRmZW1pbmluZT0yNzY7ZS5Mc2xhc2g9NTU2O2UuT3NsYXNoPTcyMjtlLk9FPTk0NDtlLm9yZG1hc2N1bGluZT0zMTA7ZS5hZT02Njc7ZS5kb3RsZXNzaT0yNzg7ZS5sc2xhc2g9Mjc4O2Uub3NsYXNoPTUwMDtlLm9lPTY2NztlLmdlcm1hbmRibHM9NTAwO2UuSWRpZXJlc2lzPTMzMztlLmVhY3V0ZT00NDQ7ZS5hYnJldmU9NTAwO2UudWh1bmdhcnVtbGF1dD01MDA7ZS5lY2Fyb249NDQ0O2UuWWRpZXJlc2lzPTU1NjtlLmRpdmlkZT02NzU7ZS5ZYWN1dGU9NTU2O2UuQWNpcmN1bWZsZXg9NjExO2UuYWFjdXRlPTUwMDtlLlVjaXJjdW1mbGV4PTcyMjtlLnlhY3V0ZT00NDQ7ZS5zY29tbWFhY2NlbnQ9Mzg5O2UuZWNpcmN1bWZsZXg9NDQ0O2UuVXJpbmc9NzIyO2UuVWRpZXJlc2lzPTcyMjtlLmFvZ29uZWs9NTAwO2UuVWFjdXRlPTcyMjtlLnVvZ29uZWs9NTAwO2UuRWRpZXJlc2lzPTYxMTtlLkRjcm9hdD03MjI7ZS5jb21tYWFjY2VudD0yNTA7ZS5jb3B5cmlnaHQ9NzYwO2UuRW1hY3Jvbj02MTE7ZS5jY2Fyb249NDQ0O2UuYXJpbmc9NTAwO2UuTmNvbW1hYWNjZW50PTY2NztlLmxhY3V0ZT0yNzg7ZS5hZ3JhdmU9NTAwO2UuVGNvbW1hYWNjZW50PTU1NjtlLkNhY3V0ZT02Njc7ZS5hdGlsZGU9NTAwO2UuRWRvdGFjY2VudD02MTE7ZS5zY2Fyb249Mzg5O2Uuc2NlZGlsbGE9Mzg5O2UuaWFjdXRlPTI3ODtlLmxvemVuZ2U9NDcxO2UuUmNhcm9uPTYxMTtlLkdjb21tYWFjY2VudD03MjI7ZS51Y2lyY3VtZmxleD01MDA7ZS5hY2lyY3VtZmxleD01MDA7ZS5BbWFjcm9uPTYxMTtlLnJjYXJvbj0zODk7ZS5jY2VkaWxsYT00NDQ7ZS5aZG90YWNjZW50PTU1NjtlLlRob3JuPTYxMTtlLk9tYWNyb249NzIyO2UuUmFjdXRlPTYxMTtlLlNhY3V0ZT01MDA7ZS5kY2Fyb249NTQ0O2UuVW1hY3Jvbj03MjI7ZS51cmluZz01MDA7ZS50aHJlZXN1cGVyaW9yPTMwMDtlLk9ncmF2ZT03MjI7ZS5BZ3JhdmU9NjExO2UuQWJyZXZlPTYxMTtlLm11bHRpcGx5PTY3NTtlLnVhY3V0ZT01MDA7ZS5UY2Fyb249NTU2O2UucGFydGlhbGRpZmY9NDc2O2UueWRpZXJlc2lzPTQ0NDtlLk5hY3V0ZT02Njc7ZS5pY2lyY3VtZmxleD0yNzg7ZS5FY2lyY3VtZmxleD02MTE7ZS5hZGllcmVzaXM9NTAwO2UuZWRpZXJlc2lzPTQ0NDtlLmNhY3V0ZT00NDQ7ZS5uYWN1dGU9NTAwO2UudW1hY3Jvbj01MDA7ZS5OY2Fyb249NjY3O2UuSWFjdXRlPTMzMztlLnBsdXNtaW51cz02NzU7ZS5icm9rZW5iYXI9Mjc1O2UucmVnaXN0ZXJlZD03NjA7ZS5HYnJldmU9NzIyO2UuSWRvdGFjY2VudD0zMzM7ZS5zdW1tYXRpb249NjAwO2UuRWdyYXZlPTYxMTtlLnJhY3V0ZT0zODk7ZS5vbWFjcm9uPTUwMDtlLlphY3V0ZT01NTY7ZS5aY2Fyb249NTU2O2UuZ3JlYXRlcmVxdWFsPTU0OTtlLkV0aD03MjI7ZS5DY2VkaWxsYT02Njc7ZS5sY29tbWFhY2NlbnQ9Mjc4O2UudGNhcm9uPTMwMDtlLmVvZ29uZWs9NDQ0O2UuVW9nb25laz03MjI7ZS5BYWN1dGU9NjExO2UuQWRpZXJlc2lzPTYxMTtlLmVncmF2ZT00NDQ7ZS56YWN1dGU9Mzg5O2UuaW9nb25laz0yNzg7ZS5PYWN1dGU9NzIyO2Uub2FjdXRlPTUwMDtlLmFtYWNyb249NTAwO2Uuc2FjdXRlPTM4OTtlLmlkaWVyZXNpcz0yNzg7ZS5PY2lyY3VtZmxleD03MjI7ZS5VZ3JhdmU9NzIyO2UuRGVsdGE9NjEyO2UudGhvcm49NTAwO2UudHdvc3VwZXJpb3I9MzAwO2UuT2RpZXJlc2lzPTcyMjtlLm11PTUwMDtlLmlncmF2ZT0yNzg7ZS5vaHVuZ2FydW1sYXV0PTUwMDtlLkVvZ29uZWs9NjExO2UuZGNyb2F0PTUwMDtlLnRocmVlcXVhcnRlcnM9NzUwO2UuU2NlZGlsbGE9NTAwO2UubGNhcm9uPTMwMDtlLktjb21tYWFjY2VudD02Njc7ZS5MYWN1dGU9NTU2O2UudHJhZGVtYXJrPTk4MDtlLmVkb3RhY2NlbnQ9NDQ0O2UuSWdyYXZlPTMzMztlLkltYWNyb249MzMzO2UuTGNhcm9uPTYxMTtlLm9uZWhhbGY9NzUwO2UubGVzc2VxdWFsPTU0OTtlLm9jaXJjdW1mbGV4PTUwMDtlLm50aWxkZT01MDA7ZS5VaHVuZ2FydW1sYXV0PTcyMjtlLkVhY3V0ZT02MTE7ZS5lbWFjcm9uPTQ0NDtlLmdicmV2ZT01MDA7ZS5vbmVxdWFydGVyPTc1MDtlLlNjYXJvbj01MDA7ZS5TY29tbWFhY2NlbnQ9NTAwO2UuT2h1bmdhcnVtbGF1dD03MjI7ZS5kZWdyZWU9NDAwO2Uub2dyYXZlPTUwMDtlLkNjYXJvbj02Njc7ZS51Z3JhdmU9NTAwO2UucmFkaWNhbD00NTM7ZS5EY2Fyb249NzIyO2UucmNvbW1hYWNjZW50PTM4OTtlLk50aWxkZT02Njc7ZS5vdGlsZGU9NTAwO2UuUmNvbW1hYWNjZW50PTYxMTtlLkxjb21tYWFjY2VudD01NTY7ZS5BdGlsZGU9NjExO2UuQW9nb25laz02MTE7ZS5BcmluZz02MTE7ZS5PdGlsZGU9NzIyO2UuemRvdGFjY2VudD0zODk7ZS5FY2Fyb249NjExO2UuSW9nb25laz0zMzM7ZS5rY29tbWFhY2NlbnQ9NDQ0O2UubWludXM9Njc1O2UuSWNpcmN1bWZsZXg9MzMzO2UubmNhcm9uPTUwMDtlLnRjb21tYWFjY2VudD0yNzg7ZS5sb2dpY2Fsbm90PTY3NTtlLm9kaWVyZXNpcz01MDA7ZS51ZGllcmVzaXM9NTAwO2Uubm90ZXF1YWw9NTQ5O2UuZ2NvbW1hYWNjZW50PTUwMDtlLmV0aD01MDA7ZS56Y2Fyb249Mzg5O2UubmNvbW1hYWNjZW50PTUwMDtlLm9uZXN1cGVyaW9yPTMwMDtlLmltYWNyb249Mjc4O2UuRXVybz01MDB9KSk7ZS5aYXBmRGluZ2JhdHM9KDAsci5nZXRMb29rdXBUYWJsZUZhY3RvcnkpKChmdW5jdGlvbihlKXtlLnNwYWNlPTI3ODtlLmExPTk3NDtlLmEyPTk2MTtlLmEyMDI9OTc0O2UuYTM9OTgwO2UuYTQ9NzE5O2UuYTU9Nzg5O2UuYTExOT03OTA7ZS5hMTE4PTc5MTtlLmExMTc9NjkwO2UuYTExPTk2MDtlLmExMj05Mzk7ZS5hMTM9NTQ5O2UuYTE0PTg1NTtlLmExNT05MTE7ZS5hMTY9OTMzO2UuYTEwNT05MTE7ZS5hMTc9OTQ1O2UuYTE4PTk3NDtlLmExOT03NTU7ZS5hMjA9ODQ2O2UuYTIxPTc2MjtlLmEyMj03NjE7ZS5hMjM9NTcxO2UuYTI0PTY3NztlLmEyNT03NjM7ZS5hMjY9NzYwO2UuYTI3PTc1OTtlLmEyOD03NTQ7ZS5hNj00OTQ7ZS5hNz01NTI7ZS5hOD01Mzc7ZS5hOT01Nzc7ZS5hMTA9NjkyO2UuYTI5PTc4NjtlLmEzMD03ODg7ZS5hMzE9Nzg4O2UuYTMyPTc5MDtlLmEzMz03OTM7ZS5hMzQ9Nzk0O2UuYTM1PTgxNjtlLmEzNj04MjM7ZS5hMzc9Nzg5O2UuYTM4PTg0MTtlLmEzOT04MjM7ZS5hNDA9ODMzO2UuYTQxPTgxNjtlLmE0Mj04MzE7ZS5hNDM9OTIzO2UuYTQ0PTc0NDtlLmE0NT03MjM7ZS5hNDY9NzQ5O2UuYTQ3PTc5MDtlLmE0OD03OTI7ZS5hNDk9Njk1O2UuYTUwPTc3NjtlLmE1MT03Njg7ZS5hNTI9NzkyO2UuYTUzPTc1OTtlLmE1ND03MDc7ZS5hNTU9NzA4O2UuYTU2PTY4MjtlLmE1Nz03MDE7ZS5hNTg9ODI2O2UuYTU5PTgxNTtlLmE2MD03ODk7ZS5hNjE9Nzg5O2UuYTYyPTcwNztlLmE2Mz02ODc7ZS5hNjQ9Njk2O2UuYTY1PTY4OTtlLmE2Nj03ODY7ZS5hNjc9Nzg3O2UuYTY4PTcxMztlLmE2OT03OTE7ZS5hNzA9Nzg1O2UuYTcxPTc5MTtlLmE3Mj04NzM7ZS5hNzM9NzYxO2UuYTc0PTc2MjtlLmEyMDM9NzYyO2UuYTc1PTc1OTtlLmEyMDQ9NzU5O2UuYTc2PTg5MjtlLmE3Nz04OTI7ZS5hNzg9Nzg4O2UuYTc5PTc4NDtlLmE4MT00Mzg7ZS5hODI9MTM4O2UuYTgzPTI3NztlLmE4ND00MTU7ZS5hOTc9MzkyO2UuYTk4PTM5MjtlLmE5OT02Njg7ZS5hMTAwPTY2ODtlLmE4OT0zOTA7ZS5hOTA9MzkwO2UuYTkzPTMxNztlLmE5ND0zMTc7ZS5hOTE9Mjc2O2UuYTkyPTI3NjtlLmEyMDU9NTA5O2UuYTg1PTUwOTtlLmEyMDY9NDEwO2UuYTg2PTQxMDtlLmE4Nz0yMzQ7ZS5hODg9MjM0O2UuYTk1PTMzNDtlLmE5Nj0zMzQ7ZS5hMTAxPTczMjtlLmExMDI9NTQ0O2UuYTEwMz01NDQ7ZS5hMTA0PTkxMDtlLmExMDY9NjY3O2UuYTEwNz03NjA7ZS5hMTA4PTc2MDtlLmExMTI9Nzc2O2UuYTExMT01OTU7ZS5hMTEwPTY5NDtlLmExMDk9NjI2O2UuYTEyMD03ODg7ZS5hMTIxPTc4ODtlLmExMjI9Nzg4O2UuYTEyMz03ODg7ZS5hMTI0PTc4ODtlLmExMjU9Nzg4O2UuYTEyNj03ODg7ZS5hMTI3PTc4ODtlLmExMjg9Nzg4O2UuYTEyOT03ODg7ZS5hMTMwPTc4ODtlLmExMzE9Nzg4O2UuYTEzMj03ODg7ZS5hMTMzPTc4ODtlLmExMzQ9Nzg4O2UuYTEzNT03ODg7ZS5hMTM2PTc4ODtlLmExMzc9Nzg4O2UuYTEzOD03ODg7ZS5hMTM5PTc4ODtlLmExNDA9Nzg4O2UuYTE0MT03ODg7ZS5hMTQyPTc4ODtlLmExNDM9Nzg4O2UuYTE0ND03ODg7ZS5hMTQ1PTc4ODtlLmExNDY9Nzg4O2UuYTE0Nz03ODg7ZS5hMTQ4PTc4ODtlLmExNDk9Nzg4O2UuYTE1MD03ODg7ZS5hMTUxPTc4ODtlLmExNTI9Nzg4O2UuYTE1Mz03ODg7ZS5hMTU0PTc4ODtlLmExNTU9Nzg4O2UuYTE1Nj03ODg7ZS5hMTU3PTc4ODtlLmExNTg9Nzg4O2UuYTE1OT03ODg7ZS5hMTYwPTg5NDtlLmExNjE9ODM4O2UuYTE2Mz0xMDE2O2UuYTE2ND00NTg7ZS5hMTk2PTc0ODtlLmExNjU9OTI0O2UuYTE5Mj03NDg7ZS5hMTY2PTkxODtlLmExNjc9OTI3O2UuYTE2OD05Mjg7ZS5hMTY5PTkyODtlLmExNzA9ODM0O2UuYTE3MT04NzM7ZS5hMTcyPTgyODtlLmExNzM9OTI0O2UuYTE2Mj05MjQ7ZS5hMTc0PTkxNztlLmExNzU9OTMwO2UuYTE3Nj05MzE7ZS5hMTc3PTQ2MztlLmExNzg9ODgzO2UuYTE3OT04MzY7ZS5hMTkzPTgzNjtlLmExODA9ODY3O2UuYTE5OT04Njc7ZS5hMTgxPTY5NjtlLmEyMDA9Njk2O2UuYTE4Mj04NzQ7ZS5hMjAxPTg3NDtlLmExODM9NzYwO2UuYTE4ND05NDY7ZS5hMTk3PTc3MTtlLmExODU9ODY1O2UuYTE5ND03NzE7ZS5hMTk4PTg4ODtlLmExODY9OTY3O2UuYTE5NT04ODg7ZS5hMTg3PTgzMTtlLmExODg9ODczO2UuYTE4OT05Mjc7ZS5hMTkwPTk3MDtlLmExOTE9OTE4fSkpfSkpO3QuZ2V0TWV0cmljcz1uO2NvbnN0IGk9KDAsci5nZXRMb29rdXBUYWJsZUZhY3RvcnkpKChmdW5jdGlvbihlKXtlLkNvdXJpZXI9e2FzY2VudDo2MjksZGVzY2VudDotMTU3LGNhcEhlaWdodDo1NjIseEhlaWdodDotNDI2fTtlWyJDb3VyaWVyLUJvbGQiXT17YXNjZW50OjYyOSxkZXNjZW50Oi0xNTcsY2FwSGVpZ2h0OjU2Mix4SGVpZ2h0OjQzOX07ZVsiQ291cmllci1PYmxpcXVlIl09e2FzY2VudDo2MjksZGVzY2VudDotMTU3LGNhcEhlaWdodDo1NjIseEhlaWdodDo0MjZ9O2VbIkNvdXJpZXItQm9sZE9ibGlxdWUiXT17YXNjZW50OjYyOSxkZXNjZW50Oi0xNTcsY2FwSGVpZ2h0OjU2Mix4SGVpZ2h0OjQyNn07ZS5IZWx2ZXRpY2E9e2FzY2VudDo3MTgsZGVzY2VudDotMjA3LGNhcEhlaWdodDo3MTgseEhlaWdodDo1MjN9O2VbIkhlbHZldGljYS1Cb2xkIl09e2FzY2VudDo3MTgsZGVzY2VudDotMjA3LGNhcEhlaWdodDo3MTgseEhlaWdodDo1MzJ9O2VbIkhlbHZldGljYS1PYmxpcXVlIl09e2FzY2VudDo3MTgsZGVzY2VudDotMjA3LGNhcEhlaWdodDo3MTgseEhlaWdodDo1MjN9O2VbIkhlbHZldGljYS1Cb2xkT2JsaXF1ZSJdPXthc2NlbnQ6NzE4LGRlc2NlbnQ6LTIwNyxjYXBIZWlnaHQ6NzE4LHhIZWlnaHQ6NTMyfTtlWyJUaW1lcy1Sb21hbiJdPXthc2NlbnQ6NjgzLGRlc2NlbnQ6LTIxNyxjYXBIZWlnaHQ6NjYyLHhIZWlnaHQ6NDUwfTtlWyJUaW1lcy1Cb2xkIl09e2FzY2VudDo2ODMsZGVzY2VudDotMjE3LGNhcEhlaWdodDo2NzYseEhlaWdodDo0NjF9O2VbIlRpbWVzLUl0YWxpYyJdPXthc2NlbnQ6NjgzLGRlc2NlbnQ6LTIxNyxjYXBIZWlnaHQ6NjUzLHhIZWlnaHQ6NDQxfTtlWyJUaW1lcy1Cb2xkSXRhbGljIl09e2FzY2VudDo2ODMsZGVzY2VudDotMjE3LGNhcEhlaWdodDo2NjkseEhlaWdodDo0NjJ9O2UuU3ltYm9sPXthc2NlbnQ6TWF0aC5OYU4sZGVzY2VudDpNYXRoLk5hTixjYXBIZWlnaHQ6TWF0aC5OYU4seEhlaWdodDpNYXRoLk5hTn07ZS5aYXBmRGluZ2JhdHM9e2FzY2VudDpNYXRoLk5hTixkZXNjZW50Ok1hdGguTmFOLGNhcEhlaWdodDpNYXRoLk5hTix4SGVpZ2h0Ok1hdGguTmFOfX0pKTt0LmdldEZvbnRCYXNpY01ldHJpY3M9aX0sKGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5HbHlmVGFibGU9dm9pZCAwO3QuR2x5ZlRhYmxlPWNsYXNzIEdseWZUYWJsZXtjb25zdHJ1Y3Rvcih7Z2x5ZlRhYmxlOmUsaXNHbHlwaExvY2F0aW9uc0xvbmc6dCxsb2NhVGFibGU6YSxudW1HbHlwaHM6cn0pe3RoaXMuZ2x5cGhzPVtdO2NvbnN0IG49bmV3IERhdGFWaWV3KGEuYnVmZmVyLGEuYnl0ZU9mZnNldCxhLmJ5dGVMZW5ndGgpLGk9bmV3IERhdGFWaWV3KGUuYnVmZmVyLGUuYnl0ZU9mZnNldCxlLmJ5dGVMZW5ndGgpLHM9dD80OjI7bGV0IG89dD9uLmdldFVpbnQzMigwKToyKm4uZ2V0VWludDE2KDApLGM9MDtmb3IobGV0IGU9MDtlPHI7ZSsrKXtjKz1zO2NvbnN0IGU9dD9uLmdldFVpbnQzMihjKToyKm4uZ2V0VWludDE2KGMpO2lmKGU9PT1vKXt0aGlzLmdseXBocy5wdXNoKG5ldyBHbHlwaCh7fSkpO2NvbnRpbnVlfWNvbnN0IGE9R2x5cGgucGFyc2UobyxpKTt0aGlzLmdseXBocy5wdXNoKGEpO289ZX19Z2V0U2l6ZSgpe3JldHVybiB0aGlzLmdseXBocy5yZWR1Y2UoKChlLHQpPT5lKyh0LmdldFNpemUoKSszJi00KSksMCl9d3JpdGUoKXtjb25zdCBlPXRoaXMuZ2V0U2l6ZSgpLHQ9bmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcihlKSksYT1lPjEzMTA3MCxyPWE/NDoyLG49bmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigodGhpcy5nbHlwaHMubGVuZ3RoKzEpKnIpKTthP24uc2V0VWludDMyKDAsMCk6bi5zZXRVaW50MTYoMCwwKTtsZXQgaT0wLHM9MDtmb3IoY29uc3QgZSBvZiB0aGlzLmdseXBocyl7aSs9ZS53cml0ZShpLHQpO2k9aSszJi00O3MrPXI7YT9uLnNldFVpbnQzMihzLGkpOm4uc2V0VWludDE2KHMsaT4+MSl9cmV0dXJue2lzTG9jYXRpb25Mb25nOmEsbG9jYTpuZXcgVWludDhBcnJheShuLmJ1ZmZlciksZ2x5ZjpuZXcgVWludDhBcnJheSh0LmJ1ZmZlcil9fXNjYWxlKGUpe2ZvcihsZXQgdD0wLGE9dGhpcy5nbHlwaHMubGVuZ3RoO3Q8YTt0KyspdGhpcy5nbHlwaHNbdF0uc2NhbGUoZVt0XSl9fTtjbGFzcyBHbHlwaHtjb25zdHJ1Y3Rvcih7aGVhZGVyOmU9bnVsbCxzaW1wbGU6dD1udWxsLGNvbXBvc2l0ZXM6YT1udWxsfSl7dGhpcy5oZWFkZXI9ZTt0aGlzLnNpbXBsZT10O3RoaXMuY29tcG9zaXRlcz1hfXN0YXRpYyBwYXJzZShlLHQpe2NvbnN0W2Escl09R2x5cGhIZWFkZXIucGFyc2UoZSx0KTtlKz1hO2lmKHIubnVtYmVyT2ZDb250b3VyczwwKXtjb25zdCBhPVtdO2Zvcig7Oyl7Y29uc3RbcixuXT1Db21wb3NpdGVHbHlwaC5wYXJzZShlLHQpO2UrPXI7YS5wdXNoKG4pO2lmKCEoMzImbi5mbGFncykpYnJlYWt9cmV0dXJuIG5ldyBHbHlwaCh7aGVhZGVyOnIsY29tcG9zaXRlczphfSl9Y29uc3Qgbj1TaW1wbGVHbHlwaC5wYXJzZShlLHQsci5udW1iZXJPZkNvbnRvdXJzKTtyZXR1cm4gbmV3IEdseXBoKHtoZWFkZXI6cixzaW1wbGU6bn0pfWdldFNpemUoKXtpZighdGhpcy5oZWFkZXIpcmV0dXJuIDA7Y29uc3QgZT10aGlzLnNpbXBsZT90aGlzLnNpbXBsZS5nZXRTaXplKCk6dGhpcy5jb21wb3NpdGVzLnJlZHVjZSgoKGUsdCk9PmUrdC5nZXRTaXplKCkpLDApO3JldHVybiB0aGlzLmhlYWRlci5nZXRTaXplKCkrZX13cml0ZShlLHQpe2lmKCF0aGlzLmhlYWRlcilyZXR1cm4gMDtjb25zdCBhPWU7ZSs9dGhpcy5oZWFkZXIud3JpdGUoZSx0KTtpZih0aGlzLnNpbXBsZSllKz10aGlzLnNpbXBsZS53cml0ZShlLHQpO2Vsc2UgZm9yKGNvbnN0IGEgb2YgdGhpcy5jb21wb3NpdGVzKWUrPWEud3JpdGUoZSx0KTtyZXR1cm4gZS1hfXNjYWxlKGUpe2lmKCF0aGlzLmhlYWRlcilyZXR1cm47Y29uc3QgdD0odGhpcy5oZWFkZXIueE1pbit0aGlzLmhlYWRlci54TWF4KS8yO3RoaXMuaGVhZGVyLnNjYWxlKHQsZSk7aWYodGhpcy5zaW1wbGUpdGhpcy5zaW1wbGUuc2NhbGUodCxlKTtlbHNlIGZvcihjb25zdCBhIG9mIHRoaXMuY29tcG9zaXRlcylhLnNjYWxlKHQsZSl9fWNsYXNzIEdseXBoSGVhZGVye2NvbnN0cnVjdG9yKHtudW1iZXJPZkNvbnRvdXJzOmUseE1pbjp0LHlNaW46YSx4TWF4OnIseU1heDpufSl7dGhpcy5udW1iZXJPZkNvbnRvdXJzPWU7dGhpcy54TWluPXQ7dGhpcy55TWluPWE7dGhpcy54TWF4PXI7dGhpcy55TWF4PW59c3RhdGljIHBhcnNlKGUsdCl7cmV0dXJuWzEwLG5ldyBHbHlwaEhlYWRlcih7bnVtYmVyT2ZDb250b3Vyczp0LmdldEludDE2KGUpLHhNaW46dC5nZXRJbnQxNihlKzIpLHlNaW46dC5nZXRJbnQxNihlKzQpLHhNYXg6dC5nZXRJbnQxNihlKzYpLHlNYXg6dC5nZXRJbnQxNihlKzgpfSldfWdldFNpemUoKXtyZXR1cm4gMTB9d3JpdGUoZSx0KXt0LnNldEludDE2KGUsdGhpcy5udW1iZXJPZkNvbnRvdXJzKTt0LnNldEludDE2KGUrMix0aGlzLnhNaW4pO3Quc2V0SW50MTYoZSs0LHRoaXMueU1pbik7dC5zZXRJbnQxNihlKzYsdGhpcy54TWF4KTt0LnNldEludDE2KGUrOCx0aGlzLnlNYXgpO3JldHVybiAxMH1zY2FsZShlLHQpe3RoaXMueE1pbj1NYXRoLnJvdW5kKGUrKHRoaXMueE1pbi1lKSp0KTt0aGlzLnhNYXg9TWF0aC5yb3VuZChlKyh0aGlzLnhNYXgtZSkqdCl9fWNsYXNzIENvbnRvdXJ7Y29uc3RydWN0b3Ioe2ZsYWdzOmUseENvb3JkaW5hdGVzOnQseUNvb3JkaW5hdGVzOmF9KXt0aGlzLnhDb29yZGluYXRlcz10O3RoaXMueUNvb3JkaW5hdGVzPWE7dGhpcy5mbGFncz1lfX1jbGFzcyBTaW1wbGVHbHlwaHtjb25zdHJ1Y3Rvcih7Y29udG91cnM6ZSxpbnN0cnVjdGlvbnM6dH0pe3RoaXMuY29udG91cnM9ZTt0aGlzLmluc3RydWN0aW9ucz10fXN0YXRpYyBwYXJzZShlLHQsYSl7Y29uc3Qgcj1bXTtmb3IobGV0IG49MDtuPGE7bisrKXtjb25zdCBhPXQuZ2V0VWludDE2KGUpO2UrPTI7ci5wdXNoKGEpfWNvbnN0IG49clthLTFdKzEsaT10LmdldFVpbnQxNihlKTtlKz0yO2NvbnN0IHM9bmV3IFVpbnQ4QXJyYXkodCkuc2xpY2UoZSxlK2kpO2UrPWk7Y29uc3Qgbz1bXTtmb3IobGV0IGE9MDthPG47ZSsrLGErKyl7bGV0IHI9dC5nZXRVaW50OChlKTtvLnB1c2gocik7aWYoOCZyKXtjb25zdCBuPXQuZ2V0VWludDgoKytlKTtyXj04O2ZvcihsZXQgZT0wO2U8bjtlKyspby5wdXNoKHIpO2ErPW59fWNvbnN0IGM9W107bGV0IGw9W10saD1bXSx1PVtdO2NvbnN0IGQ9W107bGV0IGY9MCxnPTA7Zm9yKGxldCBhPTA7YTxuO2ErKyl7Y29uc3Qgbj1vW2FdO2lmKDImbil7Y29uc3QgYT10LmdldFVpbnQ4KGUrKyk7Zys9MTYmbj9hOi1hO2wucHVzaChnKX1lbHNlIGlmKDE2Jm4pbC5wdXNoKGcpO2Vsc2V7Zys9dC5nZXRJbnQxNihlKTtlKz0yO2wucHVzaChnKX1pZihyW2ZdPT09YSl7ZisrO2MucHVzaChsKTtsPVtdfX1nPTA7Zj0wO2ZvcihsZXQgYT0wO2E8bjthKyspe2NvbnN0IG49b1thXTtpZig0Jm4pe2NvbnN0IGE9dC5nZXRVaW50OChlKyspO2crPTMyJm4/YTotYTtoLnB1c2goZyl9ZWxzZSBpZigzMiZuKWgucHVzaChnKTtlbHNle2crPXQuZ2V0SW50MTYoZSk7ZSs9MjtoLnB1c2goZyl9dS5wdXNoKDEmbnw2NCZuKTtpZihyW2ZdPT09YSl7bD1jW2ZdO2YrKztkLnB1c2gobmV3IENvbnRvdXIoe2ZsYWdzOnUseENvb3JkaW5hdGVzOmwseUNvb3JkaW5hdGVzOmh9KSk7aD1bXTt1PVtdfX1yZXR1cm4gbmV3IFNpbXBsZUdseXBoKHtjb250b3VyczpkLGluc3RydWN0aW9uczpzfSl9Z2V0U2l6ZSgpe2xldCBlPTIqdGhpcy5jb250b3Vycy5sZW5ndGgrMit0aGlzLmluc3RydWN0aW9ucy5sZW5ndGgsdD0wLGE9MDtmb3IoY29uc3QgciBvZiB0aGlzLmNvbnRvdXJzKXtlKz1yLmZsYWdzLmxlbmd0aDtmb3IobGV0IG49MCxpPXIueENvb3JkaW5hdGVzLmxlbmd0aDtuPGk7bisrKXtjb25zdCBpPXIueENvb3JkaW5hdGVzW25dLHM9ci55Q29vcmRpbmF0ZXNbbl07bGV0IG89TWF0aC5hYnMoaS10KTtvPjI1NT9lKz0yOm8+MCYmKGUrPTEpO3Q9aTtvPU1hdGguYWJzKHMtYSk7bz4yNTU/ZSs9MjpvPjAmJihlKz0xKTthPXN9fXJldHVybiBlfXdyaXRlKGUsdCl7Y29uc3QgYT1lLHI9W10sbj1bXSxpPVtdO2xldCBzPTAsbz0wO2Zvcihjb25zdCBhIG9mIHRoaXMuY29udG91cnMpe2ZvcihsZXQgZT0wLHQ9YS54Q29vcmRpbmF0ZXMubGVuZ3RoO2U8dDtlKyspe2xldCB0PWEuZmxhZ3NbZV07Y29uc3QgYz1hLnhDb29yZGluYXRlc1tlXTtsZXQgbD1jLXM7aWYoMD09PWwpe3R8PTE2O3IucHVzaCgwKX1lbHNle2NvbnN0IGU9TWF0aC5hYnMobCk7aWYoZTw9MjU1KXt0fD1sPj0wPzE4OjI7ci5wdXNoKGUpfWVsc2Ugci5wdXNoKGwpfXM9Yztjb25zdCBoPWEueUNvb3JkaW5hdGVzW2VdO2w9aC1vO2lmKDA9PT1sKXt0fD0zMjtuLnB1c2goMCl9ZWxzZXtjb25zdCBlPU1hdGguYWJzKGwpO2lmKGU8PTI1NSl7dHw9bD49MD8zNjo0O24ucHVzaChlKX1lbHNlIG4ucHVzaChsKX1vPWg7aS5wdXNoKHQpfXQuc2V0VWludDE2KGUsci5sZW5ndGgtMSk7ZSs9Mn10LnNldFVpbnQxNihlLHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCk7ZSs9MjtpZih0aGlzLmluc3RydWN0aW9ucy5sZW5ndGgpe25ldyBVaW50OEFycmF5KHQuYnVmZmVyLDAsdC5idWZmZXIuYnl0ZUxlbmd0aCkuc2V0KHRoaXMuaW5zdHJ1Y3Rpb25zLGUpO2UrPXRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aH1mb3IoY29uc3QgYSBvZiBpKXQuc2V0VWludDgoZSsrLGEpO2ZvcihsZXQgYT0wLG49ci5sZW5ndGg7YTxuO2ErKyl7Y29uc3Qgbj1yW2FdLHM9aVthXTtpZigyJnMpdC5zZXRVaW50OChlKyssbik7ZWxzZSBpZighKDE2JnMpKXt0LnNldEludDE2KGUsbik7ZSs9Mn19Zm9yKGxldCBhPTAscj1uLmxlbmd0aDthPHI7YSsrKXtjb25zdCByPW5bYV0scz1pW2FdO2lmKDQmcyl0LnNldFVpbnQ4KGUrKyxyKTtlbHNlIGlmKCEoMzImcykpe3Quc2V0SW50MTYoZSxyKTtlKz0yfX1yZXR1cm4gZS1hfXNjYWxlKGUsdCl7Zm9yKGNvbnN0IGEgb2YgdGhpcy5jb250b3VycylpZigwIT09YS54Q29vcmRpbmF0ZXMubGVuZ3RoKWZvcihsZXQgcj0wLG49YS54Q29vcmRpbmF0ZXMubGVuZ3RoO3I8bjtyKyspYS54Q29vcmRpbmF0ZXNbcl09TWF0aC5yb3VuZChlKyhhLnhDb29yZGluYXRlc1tyXS1lKSp0KX19Y2xhc3MgQ29tcG9zaXRlR2x5cGh7Y29uc3RydWN0b3Ioe2ZsYWdzOmUsZ2x5cGhJbmRleDp0LGFyZ3VtZW50MTphLGFyZ3VtZW50MjpyLHRyYW5zZjpuLGluc3RydWN0aW9uczppfSl7dGhpcy5mbGFncz1lO3RoaXMuZ2x5cGhJbmRleD10O3RoaXMuYXJndW1lbnQxPWE7dGhpcy5hcmd1bWVudDI9cjt0aGlzLnRyYW5zZj1uO3RoaXMuaW5zdHJ1Y3Rpb25zPWl9c3RhdGljIHBhcnNlKGUsdCl7Y29uc3QgYT1lLHI9W107bGV0IG49dC5nZXRVaW50MTYoZSk7Y29uc3QgaT10LmdldFVpbnQxNihlKzIpO2UrPTQ7bGV0IHMsbztpZigxJm4pe2lmKDImbil7cz10LmdldEludDE2KGUpO289dC5nZXRJbnQxNihlKzIpfWVsc2V7cz10LmdldFVpbnQxNihlKTtvPXQuZ2V0VWludDE2KGUrMil9ZSs9NDtuXj0xfWVsc2V7aWYoMiZuKXtzPXQuZ2V0SW50OChlKTtvPXQuZ2V0SW50OChlKzEpfWVsc2V7cz10LmdldFVpbnQ4KGUpO289dC5nZXRVaW50OChlKzEpfWUrPTJ9aWYoOCZuKXtyLnB1c2godC5nZXRVaW50MTYoZSkpO2UrPTJ9ZWxzZSBpZig2NCZuKXtyLnB1c2godC5nZXRVaW50MTYoZSksdC5nZXRVaW50MTYoZSsyKSk7ZSs9NH1lbHNlIGlmKDEyOCZuKXtyLnB1c2godC5nZXRVaW50MTYoZSksdC5nZXRVaW50MTYoZSsyKSx0LmdldFVpbnQxNihlKzQpLHQuZ2V0VWludDE2KGUrNikpO2UrPTh9bGV0IGM9bnVsbDtpZigyNTYmbil7Y29uc3QgYT10LmdldFVpbnQxNihlKTtlKz0yO2M9bmV3IFVpbnQ4QXJyYXkodCkuc2xpY2UoZSxlK2EpO2UrPWF9cmV0dXJuW2UtYSxuZXcgQ29tcG9zaXRlR2x5cGgoe2ZsYWdzOm4sZ2x5cGhJbmRleDppLGFyZ3VtZW50MTpzLGFyZ3VtZW50MjpvLHRyYW5zZjpyLGluc3RydWN0aW9uczpjfSldfWdldFNpemUoKXtsZXQgZT00KzIqdGhpcy50cmFuc2YubGVuZ3RoOzI1NiZ0aGlzLmZsYWdzJiYoZSs9Mit0aGlzLmluc3RydWN0aW9ucy5sZW5ndGgpO2UrPTI7MiZ0aGlzLmZsYWdzP3RoaXMuYXJndW1lbnQxPj0tMTI4JiZ0aGlzLmFyZ3VtZW50MTw9MTI3JiZ0aGlzLmFyZ3VtZW50Mj49LTEyOCYmdGhpcy5hcmd1bWVudDI8PTEyN3x8KGUrPTIpOnRoaXMuYXJndW1lbnQxPj0wJiZ0aGlzLmFyZ3VtZW50MTw9MjU1JiZ0aGlzLmFyZ3VtZW50Mj49MCYmdGhpcy5hcmd1bWVudDI8PTI1NXx8KGUrPTIpO3JldHVybiBlfXdyaXRlKGUsdCl7Y29uc3QgYT1lOzImdGhpcy5mbGFncz90aGlzLmFyZ3VtZW50MT49LTEyOCYmdGhpcy5hcmd1bWVudDE8PTEyNyYmdGhpcy5hcmd1bWVudDI+PS0xMjgmJnRoaXMuYXJndW1lbnQyPD0xMjd8fCh0aGlzLmZsYWdzfD0xKTp0aGlzLmFyZ3VtZW50MT49MCYmdGhpcy5hcmd1bWVudDE8PTI1NSYmdGhpcy5hcmd1bWVudDI+PTAmJnRoaXMuYXJndW1lbnQyPD0yNTV8fCh0aGlzLmZsYWdzfD0xKTt0LnNldFVpbnQxNihlLHRoaXMuZmxhZ3MpO3Quc2V0VWludDE2KGUrMix0aGlzLmdseXBoSW5kZXgpO2UrPTQ7aWYoMSZ0aGlzLmZsYWdzKXtpZigyJnRoaXMuZmxhZ3Mpe3Quc2V0SW50MTYoZSx0aGlzLmFyZ3VtZW50MSk7dC5zZXRJbnQxNihlKzIsdGhpcy5hcmd1bWVudDIpfWVsc2V7dC5zZXRVaW50MTYoZSx0aGlzLmFyZ3VtZW50MSk7dC5zZXRVaW50MTYoZSsyLHRoaXMuYXJndW1lbnQyKX1lKz00fWVsc2V7dC5zZXRVaW50OChlLHRoaXMuYXJndW1lbnQxKTt0LnNldFVpbnQ4KGUrMSx0aGlzLmFyZ3VtZW50Mik7ZSs9Mn1pZigyNTYmdGhpcy5mbGFncyl7dC5zZXRVaW50MTYoZSx0aGlzLmluc3RydWN0aW9ucy5sZW5ndGgpO2UrPTI7aWYodGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoKXtuZXcgVWludDhBcnJheSh0LmJ1ZmZlciwwLHQuYnVmZmVyLmJ5dGVMZW5ndGgpLnNldCh0aGlzLmluc3RydWN0aW9ucyxlKTtlKz10aGlzLmluc3RydWN0aW9ucy5sZW5ndGh9fXJldHVybiBlLWF9c2NhbGUoZSx0KXt9fX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0Lk9wZW5UeXBlRmlsZUJ1aWxkZXI9dm9pZCAwO3ZhciByPWEoNiksbj1hKDIpO2Z1bmN0aW9uIHdyaXRlSW50MTYoZSx0LGEpe2VbdF09YT4+OCYyNTU7ZVt0KzFdPTI1NSZhfWZ1bmN0aW9uIHdyaXRlSW50MzIoZSx0LGEpe2VbdF09YT4+MjQmMjU1O2VbdCsxXT1hPj4xNiYyNTU7ZVt0KzJdPWE+PjgmMjU1O2VbdCszXT0yNTUmYX1mdW5jdGlvbiB3cml0ZURhdGEoZSx0LGEpe2lmKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KWUuc2V0KGEsdCk7ZWxzZSBpZigic3RyaW5nIj09dHlwZW9mIGEpZm9yKGxldCByPTAsbj1hLmxlbmd0aDtyPG47cisrKWVbdCsrXT0yNTUmYS5jaGFyQ29kZUF0KHIpO2Vsc2UgZm9yKGxldCByPTAsbj1hLmxlbmd0aDtyPG47cisrKWVbdCsrXT0yNTUmYVtyXX1jbGFzcyBPcGVuVHlwZUZpbGVCdWlsZGVye2NvbnN0cnVjdG9yKGUpe3RoaXMuc2ZudD1lO3RoaXMudGFibGVzPU9iamVjdC5jcmVhdGUobnVsbCl9c3RhdGljIGdldFNlYXJjaFBhcmFtcyhlLHQpe2xldCBhPTEscj0wO2Zvcig7KGFeZSk+YTspe2E8PD0xO3IrK31jb25zdCBuPWEqdDtyZXR1cm57cmFuZ2U6bixlbnRyeTpyLHJhbmdlU2hpZnQ6dCplLW59fXRvQXJyYXkoKXtsZXQgZT10aGlzLnNmbnQ7Y29uc3QgdD10aGlzLnRhYmxlcyxhPU9iamVjdC5rZXlzKHQpO2Euc29ydCgpO2NvbnN0IGk9YS5sZW5ndGg7bGV0IHMsbyxjLGwsaCx1PTEyKzE2Kmk7Y29uc3QgZD1bdV07Zm9yKHM9MDtzPGk7cysrKXtsPXRbYVtzXV07dSs9KGwubGVuZ3RoKzMmLTQpPj4+MDtkLnB1c2godSl9Y29uc3QgZj1uZXcgVWludDhBcnJheSh1KTtmb3Iocz0wO3M8aTtzKyspe2w9dFthW3NdXTt3cml0ZURhdGEoZixkW3NdLGwpfSJ0cnVlIj09PWUmJihlPSgwLG4uc3RyaW5nMzIpKDY1NTM2KSk7ZlswXT0yNTUmZS5jaGFyQ29kZUF0KDApO2ZbMV09MjU1JmUuY2hhckNvZGVBdCgxKTtmWzJdPTI1NSZlLmNoYXJDb2RlQXQoMik7ZlszXT0yNTUmZS5jaGFyQ29kZUF0KDMpO3dyaXRlSW50MTYoZiw0LGkpO2NvbnN0IGc9T3BlblR5cGVGaWxlQnVpbGRlci5nZXRTZWFyY2hQYXJhbXMoaSwxNik7d3JpdGVJbnQxNihmLDYsZy5yYW5nZSk7d3JpdGVJbnQxNihmLDgsZy5lbnRyeSk7d3JpdGVJbnQxNihmLDEwLGcucmFuZ2VTaGlmdCk7dT0xMjtmb3Iocz0wO3M8aTtzKyspe2g9YVtzXTtmW3VdPTI1NSZoLmNoYXJDb2RlQXQoMCk7Zlt1KzFdPTI1NSZoLmNoYXJDb2RlQXQoMSk7Zlt1KzJdPTI1NSZoLmNoYXJDb2RlQXQoMik7Zlt1KzNdPTI1NSZoLmNoYXJDb2RlQXQoMyk7bGV0IGU9MDtmb3Iobz1kW3NdLGM9ZFtzKzFdO288YztvKz00KXtlPWUrKDAsci5yZWFkVWludDMyKShmLG8pPj4+MH13cml0ZUludDMyKGYsdSs0LGUpO3dyaXRlSW50MzIoZix1KzgsZFtzXSk7d3JpdGVJbnQzMihmLHUrMTIsdFtoXS5sZW5ndGgpO3UrPTE2fXJldHVybiBmfWFkZFRhYmxlKGUsdCl7aWYoZSBpbiB0aGlzLnRhYmxlcyl0aHJvdyBuZXcgRXJyb3IoIlRhYmxlICIrZSsiIGFscmVhZHkgZXhpc3RzIik7dGhpcy50YWJsZXNbZV09dH19dC5PcGVuVHlwZUZpbGVCdWlsZGVyPU9wZW5UeXBlRmlsZUJ1aWxkZXJ9LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5UeXBlMUZvbnQ9dm9pZCAwO3ZhciByPWEoMzUpLG49YSgzOCksaT1hKDYpLHM9YSgxMCksbz1hKDQ5KSxjPWEoMik7ZnVuY3Rpb24gZmluZEJsb2NrKGUsdCxhKXtjb25zdCByPWUubGVuZ3RoLG49dC5sZW5ndGgscz1yLW47bGV0IG89YSxjPSExO2Zvcig7bzxzOyl7bGV0IGE9MDtmb3IoO2E8biYmZVtvK2FdPT09dFthXTspYSsrO2lmKGE+PW4pe28rPWE7Zm9yKDtvPHImJigwLGkuaXNXaGl0ZVNwYWNlKShlW29dKTspbysrO2M9ITA7YnJlYWt9bysrfXJldHVybntmb3VuZDpjLGxlbmd0aDpvfX10LlR5cGUxRm9udD1jbGFzcyBUeXBlMUZvbnR7Y29uc3RydWN0b3IoZSx0LGEpe2xldCByPWEubGVuZ3RoMSxpPWEubGVuZ3RoMixsPXQucGVla0J5dGVzKDYpO2NvbnN0IGg9MTI4PT09bFswXSYmMT09PWxbMV07aWYoaCl7dC5za2lwKDYpO3I9bFs1XTw8MjR8bFs0XTw8MTZ8bFszXTw8OHxsWzJdfWNvbnN0IHU9ZnVuY3Rpb24gZ2V0SGVhZGVyQmxvY2soZSx0KXtjb25zdCBhPVsxMDEsMTAxLDEyMCwxMDEsOTldLHI9ZS5wb3M7bGV0IG4saSxvLGw7dHJ5e249ZS5nZXRCeXRlcyh0KTtpPW4ubGVuZ3RofWNhdGNoKGUpe31pZihpPT09dCl7bz1maW5kQmxvY2sobixhLHQtMiphLmxlbmd0aCk7aWYoby5mb3VuZCYmby5sZW5ndGg9PT10KXJldHVybntzdHJlYW06bmV3IHMuU3RyZWFtKG4pLGxlbmd0aDp0fX0oMCxjLndhcm4pKCdJbnZhbGlkICJMZW5ndGgxIiBwcm9wZXJ0eSBpbiBUeXBlMSBmb250IC0tIHRyeWluZyB0byByZWNvdmVyLicpO2UucG9zPXI7Zm9yKDs7KXtvPWZpbmRCbG9jayhlLnBlZWtCeXRlcygyMDQ4KSxhLDApO2lmKDA9PT1vLmxlbmd0aClicmVhaztlLnBvcys9by5sZW5ndGg7aWYoby5mb3VuZCl7bD1lLnBvcy1yO2JyZWFrfX1lLnBvcz1yO2lmKGwpcmV0dXJue3N0cmVhbTpuZXcgcy5TdHJlYW0oZS5nZXRCeXRlcyhsKSksbGVuZ3RoOmx9OygwLGMud2FybikoJ1VuYWJsZSB0byByZWNvdmVyICJMZW5ndGgxIiBwcm9wZXJ0eSBpbiBUeXBlMSBmb250IC0tIHVzaW5nIGFzIGlzLicpO3JldHVybntzdHJlYW06bmV3IHMuU3RyZWFtKGUuZ2V0Qnl0ZXModCkpLGxlbmd0aDp0fX0odCxyKTtuZXcgby5UeXBlMVBhcnNlcih1LnN0cmVhbSwhMSxuLlNFQUNfQU5BTFlTSVNfRU5BQkxFRCkuZXh0cmFjdEZvbnRIZWFkZXIoYSk7aWYoaCl7bD10LmdldEJ5dGVzKDYpO2k9bFs1XTw8MjR8bFs0XTw8MTZ8bFszXTw8OHxsWzJdfWNvbnN0IGQ9ZnVuY3Rpb24gZ2V0RWV4ZWNCbG9jayhlLHQpe2NvbnN0IGE9ZS5nZXRCeXRlcygpO3JldHVybntzdHJlYW06bmV3IHMuU3RyZWFtKGEpLGxlbmd0aDphLmxlbmd0aH19KHQpLGY9bmV3IG8uVHlwZTFQYXJzZXIoZC5zdHJlYW0sITAsbi5TRUFDX0FOQUxZU0lTX0VOQUJMRUQpLmV4dHJhY3RGb250UHJvZ3JhbShhKTtmb3IoY29uc3QgZSBpbiBmLnByb3BlcnRpZXMpYVtlXT1mLnByb3BlcnRpZXNbZV07Y29uc3QgZz1mLmNoYXJzdHJpbmdzLHA9dGhpcy5nZXRUeXBlMkNoYXJzdHJpbmdzKGcpLG09dGhpcy5nZXRUeXBlMlN1YnJzKGYuc3VicnMpO3RoaXMuY2hhcnN0cmluZ3M9Zzt0aGlzLmRhdGE9dGhpcy53cmFwKGUscCx0aGlzLmNoYXJzdHJpbmdzLG0sYSk7dGhpcy5zZWFjcz10aGlzLmdldFNlYWNzKGYuY2hhcnN0cmluZ3MpfWdldCBudW1HbHlwaHMoKXtyZXR1cm4gdGhpcy5jaGFyc3RyaW5ncy5sZW5ndGgrMX1nZXRDaGFyc2V0KCl7Y29uc3QgZT1bIi5ub3RkZWYiXTtmb3IoY29uc3R7Z2x5cGhOYW1lOnR9b2YgdGhpcy5jaGFyc3RyaW5ncyllLnB1c2godCk7cmV0dXJuIGV9Z2V0R2x5cGhNYXBwaW5nKGUpe2NvbnN0IHQ9dGhpcy5jaGFyc3RyaW5ncztpZihlLmNvbXBvc2l0ZSl7Y29uc3QgYT1PYmplY3QuY3JlYXRlKG51bGwpO2ZvcihsZXQgcj0wLG49dC5sZW5ndGg7cjxuO3IrKyl7YVtlLmNNYXAuY2hhckNvZGVPZihyKV09cisxfXJldHVybiBhfWNvbnN0IGE9WyIubm90ZGVmIl07bGV0IHIsaTtmb3IoaT0wO2k8dC5sZW5ndGg7aSsrKWEucHVzaCh0W2ldLmdseXBoTmFtZSk7Y29uc3Qgcz1lLmJ1aWx0SW5FbmNvZGluZztpZihzKXtyPU9iamVjdC5jcmVhdGUobnVsbCk7Zm9yKGNvbnN0IGUgaW4gcyl7aT1hLmluZGV4T2Yoc1tlXSk7aT49MCYmKHJbZV09aSl9fXJldHVybigwLG4udHlwZTFGb250R2x5cGhNYXBwaW5nKShlLHIsYSl9aGFzR2x5cGhJZChlKXtpZihlPDB8fGU+PXRoaXMubnVtR2x5cGhzKXJldHVybiExO2lmKDA9PT1lKXJldHVybiEwO3JldHVybiB0aGlzLmNoYXJzdHJpbmdzW2UtMV0uY2hhcnN0cmluZy5sZW5ndGg+MH1nZXRTZWFjcyhlKXtjb25zdCB0PVtdO2ZvcihsZXQgYT0wLHI9ZS5sZW5ndGg7YTxyO2ErKyl7Y29uc3Qgcj1lW2FdO3Iuc2VhYyYmKHRbYSsxXT1yLnNlYWMpfXJldHVybiB0fWdldFR5cGUyQ2hhcnN0cmluZ3MoZSl7Y29uc3QgdD1bXTtmb3IobGV0IGE9MCxyPWUubGVuZ3RoO2E8cjthKyspdC5wdXNoKGVbYV0uY2hhcnN0cmluZyk7cmV0dXJuIHR9Z2V0VHlwZTJTdWJycyhlKXtsZXQgdD0wO2NvbnN0IGE9ZS5sZW5ndGg7dD1hPDExMzM/MTA3OmE8MzM3Njk/MTEzMTozMjc2ODtjb25zdCByPVtdO2xldCBuO2ZvcihuPTA7bjx0O24rKylyLnB1c2goWzExXSk7Zm9yKG49MDtuPGE7bisrKXIucHVzaChlW25dKTtyZXR1cm4gcn13cmFwKGUsdCxhLG4saSl7Y29uc3Qgcz1uZXcgci5DRkY7cy5oZWFkZXI9bmV3IHIuQ0ZGSGVhZGVyKDEsMCw0LDQpO3MubmFtZXM9W2VdO2NvbnN0IG89bmV3IHIuQ0ZGVG9wRGljdDtvLnNldEJ5TmFtZSgidmVyc2lvbiIsMzkxKTtvLnNldEJ5TmFtZSgiTm90aWNlIiwzOTIpO28uc2V0QnlOYW1lKCJGdWxsTmFtZSIsMzkzKTtvLnNldEJ5TmFtZSgiRmFtaWx5TmFtZSIsMzk0KTtvLnNldEJ5TmFtZSgiV2VpZ2h0IiwzOTUpO28uc2V0QnlOYW1lKCJFbmNvZGluZyIsbnVsbCk7by5zZXRCeU5hbWUoIkZvbnRNYXRyaXgiLGkuZm9udE1hdHJpeCk7by5zZXRCeU5hbWUoIkZvbnRCQm94IixpLmJib3gpO28uc2V0QnlOYW1lKCJjaGFyc2V0IixudWxsKTtvLnNldEJ5TmFtZSgiQ2hhclN0cmluZ3MiLG51bGwpO28uc2V0QnlOYW1lKCJQcml2YXRlIixudWxsKTtzLnRvcERpY3Q9bztjb25zdCBjPW5ldyByLkNGRlN0cmluZ3M7Yy5hZGQoIlZlcnNpb24gMC4xMSIpO2MuYWRkKCJTZWUgb3JpZ2luYWwgbm90aWNlIik7Yy5hZGQoZSk7Yy5hZGQoZSk7Yy5hZGQoIk1lZGl1bSIpO3Muc3RyaW5ncz1jO3MuZ2xvYmFsU3VickluZGV4PW5ldyByLkNGRkluZGV4O2NvbnN0IGw9dC5sZW5ndGgsaD1bIi5ub3RkZWYiXTtsZXQgdSxkO2Zvcih1PTA7dTxsO3UrKyl7Y29uc3QgZT1hW3VdLmdseXBoTmFtZTstMT09PXIuQ0ZGU3RhbmRhcmRTdHJpbmdzLmluZGV4T2YoZSkmJmMuYWRkKGUpO2gucHVzaChlKX1zLmNoYXJzZXQ9bmV3IHIuQ0ZGQ2hhcnNldCghMSwwLGgpO2NvbnN0IGY9bmV3IHIuQ0ZGSW5kZXg7Zi5hZGQoWzEzOSwxNF0pO2Zvcih1PTA7dTxsO3UrKylmLmFkZCh0W3VdKTtzLmNoYXJTdHJpbmdzPWY7Y29uc3QgZz1uZXcgci5DRkZQcml2YXRlRGljdDtnLnNldEJ5TmFtZSgiU3VicnMiLG51bGwpO2NvbnN0IHA9WyJCbHVlVmFsdWVzIiwiT3RoZXJCbHVlcyIsIkZhbWlseUJsdWVzIiwiRmFtaWx5T3RoZXJCbHVlcyIsIlN0ZW1TbmFwSCIsIlN0ZW1TbmFwViIsIkJsdWVTaGlmdCIsIkJsdWVGdXp6IiwiQmx1ZVNjYWxlIiwiTGFuZ3VhZ2VHcm91cCIsIkV4cGFuc2lvbkZhY3RvciIsIkZvcmNlQm9sZCIsIlN0ZEhXIiwiU3RkVlciXTtmb3IodT0wLGQ9cC5sZW5ndGg7dTxkO3UrKyl7Y29uc3QgZT1wW3VdO2lmKCEoZSBpbiBpLnByaXZhdGVEYXRhKSljb250aW51ZTtjb25zdCB0PWkucHJpdmF0ZURhdGFbZV07aWYoQXJyYXkuaXNBcnJheSh0KSlmb3IobGV0IGU9dC5sZW5ndGgtMTtlPjA7ZS0tKXRbZV0tPXRbZS0xXTtnLnNldEJ5TmFtZShlLHQpfXMudG9wRGljdC5wcml2YXRlRGljdD1nO2NvbnN0IG09bmV3IHIuQ0ZGSW5kZXg7Zm9yKHU9MCxkPW4ubGVuZ3RoO3U8ZDt1KyspbS5hZGQoblt1XSk7Zy5zdWJyc0luZGV4PW07cmV0dXJuIG5ldyByLkNGRkNvbXBpbGVyKHMpLmNvbXBpbGUoKX19fSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuVHlwZTFQYXJzZXI9dm9pZCAwO3ZhciByPWEoMzcpLG49YSg2KSxpPWEoMTApLHM9YSgyKTtjb25zdCBvPVs0XSxjPVs1XSxsPVs2XSxoPVs3XSx1PVs4XSxkPVsxMiwzNV0sZj1bMTRdLGc9WzIxXSxwPVsyMl0sbT1bMzBdLGI9WzMxXTtjbGFzcyBUeXBlMUNoYXJTdHJpbmd7Y29uc3RydWN0b3IoKXt0aGlzLndpZHRoPTA7dGhpcy5sc2I9MDt0aGlzLmZsZXhpbmc9ITE7dGhpcy5vdXRwdXQ9W107dGhpcy5zdGFjaz1bXX1jb252ZXJ0KGUsdCxhKXtjb25zdCByPWUubGVuZ3RoO2xldCBuLGkseSx3PSExO2ZvcihsZXQgUz0wO1M8cjtTKyspe2xldCByPWVbU107aWYocjwzMil7MTI9PT1yJiYocj0ocjw8OCkrZVsrK1NdKTtzd2l0Y2gocil7Y2FzZSAxOmNhc2UgMzpjYXNlIDk6Y2FzZSAzMDcyOmNhc2UgMzA3MzpjYXNlIDMwNzQ6Y2FzZSAzMTA1OnRoaXMuc3RhY2s9W107YnJlYWs7Y2FzZSA0OmlmKHRoaXMuZmxleGluZyl7aWYodGhpcy5zdGFjay5sZW5ndGg8MSl7dz0hMDticmVha31jb25zdCBlPXRoaXMuc3RhY2sucG9wKCk7dGhpcy5zdGFjay5wdXNoKDAsZSk7YnJlYWt9dz10aGlzLmV4ZWN1dGVDb21tYW5kKDEsbyk7YnJlYWs7Y2FzZSA1Onc9dGhpcy5leGVjdXRlQ29tbWFuZCgyLGMpO2JyZWFrO2Nhc2UgNjp3PXRoaXMuZXhlY3V0ZUNvbW1hbmQoMSxsKTticmVhaztjYXNlIDc6dz10aGlzLmV4ZWN1dGVDb21tYW5kKDEsaCk7YnJlYWs7Y2FzZSA4Onc9dGhpcy5leGVjdXRlQ29tbWFuZCg2LHUpO2JyZWFrO2Nhc2UgMTA6aWYodGhpcy5zdGFjay5sZW5ndGg8MSl7dz0hMDticmVha315PXRoaXMuc3RhY2sucG9wKCk7aWYoIXRbeV0pe3c9ITA7YnJlYWt9dz10aGlzLmNvbnZlcnQodFt5XSx0LGEpO2JyZWFrO2Nhc2UgMTE6cmV0dXJuIHc7Y2FzZSAxMzppZih0aGlzLnN0YWNrLmxlbmd0aDwyKXt3PSEwO2JyZWFrfW49dGhpcy5zdGFjay5wb3AoKTtpPXRoaXMuc3RhY2sucG9wKCk7dGhpcy5sc2I9aTt0aGlzLndpZHRoPW47dGhpcy5zdGFjay5wdXNoKG4saSk7dz10aGlzLmV4ZWN1dGVDb21tYW5kKDIscCk7YnJlYWs7Y2FzZSAxNDp0aGlzLm91dHB1dC5wdXNoKGZbMF0pO2JyZWFrO2Nhc2UgMjE6aWYodGhpcy5mbGV4aW5nKWJyZWFrO3c9dGhpcy5leGVjdXRlQ29tbWFuZCgyLGcpO2JyZWFrO2Nhc2UgMjI6aWYodGhpcy5mbGV4aW5nKXt0aGlzLnN0YWNrLnB1c2goMCk7YnJlYWt9dz10aGlzLmV4ZWN1dGVDb21tYW5kKDEscCk7YnJlYWs7Y2FzZSAzMDp3PXRoaXMuZXhlY3V0ZUNvbW1hbmQoNCxtKTticmVhaztjYXNlIDMxOnc9dGhpcy5leGVjdXRlQ29tbWFuZCg0LGIpO2JyZWFrO2Nhc2UgMzA3ODppZihhKXtjb25zdCBlPXRoaXMuc3RhY2suYXQoLTUpO3RoaXMuc2VhYz10aGlzLnN0YWNrLnNwbGljZSgtNCw0KTt0aGlzLnNlYWNbMF0rPXRoaXMubHNiLWU7dz10aGlzLmV4ZWN1dGVDb21tYW5kKDAsZil9ZWxzZSB3PXRoaXMuZXhlY3V0ZUNvbW1hbmQoNCxmKTticmVhaztjYXNlIDMwNzk6aWYodGhpcy5zdGFjay5sZW5ndGg8NCl7dz0hMDticmVha310aGlzLnN0YWNrLnBvcCgpO249dGhpcy5zdGFjay5wb3AoKTtjb25zdCBlPXRoaXMuc3RhY2sucG9wKCk7aT10aGlzLnN0YWNrLnBvcCgpO3RoaXMubHNiPWk7dGhpcy53aWR0aD1uO3RoaXMuc3RhY2sucHVzaChuLGksZSk7dz10aGlzLmV4ZWN1dGVDb21tYW5kKDMsZyk7YnJlYWs7Y2FzZSAzMDg0OmlmKHRoaXMuc3RhY2subGVuZ3RoPDIpe3c9ITA7YnJlYWt9Y29uc3QgUz10aGlzLnN0YWNrLnBvcCgpLHg9dGhpcy5zdGFjay5wb3AoKTt0aGlzLnN0YWNrLnB1c2goeC9TKTticmVhaztjYXNlIDMwODg6aWYodGhpcy5zdGFjay5sZW5ndGg8Mil7dz0hMDticmVha315PXRoaXMuc3RhY2sucG9wKCk7Y29uc3Qgaz10aGlzLnN0YWNrLnBvcCgpO2lmKDA9PT15JiYzPT09ayl7Y29uc3QgZT10aGlzLnN0YWNrLnNwbGljZSh0aGlzLnN0YWNrLmxlbmd0aC0xNywxNyk7dGhpcy5zdGFjay5wdXNoKGVbMl0rZVswXSxlWzNdK2VbMV0sZVs0XSxlWzVdLGVbNl0sZVs3XSxlWzhdLGVbOV0sZVsxMF0sZVsxMV0sZVsxMl0sZVsxM10sZVsxNF0pO3c9dGhpcy5leGVjdXRlQ29tbWFuZCgxMyxkLCEwKTt0aGlzLmZsZXhpbmc9ITE7dGhpcy5zdGFjay5wdXNoKGVbMTVdLGVbMTZdKX1lbHNlIDE9PT15JiYwPT09ayYmKHRoaXMuZmxleGluZz0hMCk7YnJlYWs7Y2FzZSAzMDg5OmJyZWFrO2RlZmF1bHQ6KDAscy53YXJuKSgnVW5rbm93biB0eXBlIDEgY2hhcnN0cmluZyBjb21tYW5kIG9mICInK3IrJyInKX1pZih3KWJyZWFrfWVsc2V7cjw9MjQ2P3ItPTEzOTpyPXI8PTI1MD8yNTYqKHItMjQ3KStlWysrU10rMTA4OnI8PTI1ND8tMjU2KihyLTI1MSktZVsrK1NdLTEwODooMjU1JmVbKytTXSk8PDI0fCgyNTUmZVsrK1NdKTw8MTZ8KDI1NSZlWysrU10pPDw4fCgyNTUmZVsrK1NdKTw8MDt0aGlzLnN0YWNrLnB1c2gocil9fXJldHVybiB3fWV4ZWN1dGVDb21tYW5kKGUsdCxhKXtjb25zdCByPXRoaXMuc3RhY2subGVuZ3RoO2lmKGU+cilyZXR1cm4hMDtjb25zdCBuPXItZTtmb3IobGV0IGU9bjtlPHI7ZSsrKXtsZXQgdD10aGlzLnN0YWNrW2VdO2lmKE51bWJlci5pc0ludGVnZXIodCkpdGhpcy5vdXRwdXQucHVzaCgyOCx0Pj44JjI1NSwyNTUmdCk7ZWxzZXt0PTY1NTM2KnR8MDt0aGlzLm91dHB1dC5wdXNoKDI1NSx0Pj4yNCYyNTUsdD4+MTYmMjU1LHQ+PjgmMjU1LDI1NSZ0KX19dGhpcy5vdXRwdXQucHVzaCguLi50KTthP3RoaXMuc3RhY2suc3BsaWNlKG4sZSk6dGhpcy5zdGFjay5sZW5ndGg9MDtyZXR1cm4hMX19ZnVuY3Rpb24gaXNIZXhEaWdpdChlKXtyZXR1cm4gZT49NDgmJmU8PTU3fHxlPj02NSYmZTw9NzB8fGU+PTk3JiZlPD0xMDJ9ZnVuY3Rpb24gZGVjcnlwdChlLHQsYSl7aWYoYT49ZS5sZW5ndGgpcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO2xldCByLG4saT0wfHQ7Zm9yKHI9MDtyPGE7cisrKWk9NTI4NDUqKGVbcl0raSkrMjI3MTkmNjU1MzU7Y29uc3Qgcz1lLmxlbmd0aC1hLG89bmV3IFVpbnQ4QXJyYXkocyk7Zm9yKHI9YSxuPTA7bjxzO3IrKyxuKyspe2NvbnN0IHQ9ZVtyXTtvW25dPXReaT4+ODtpPTUyODQ1Kih0K2kpKzIyNzE5JjY1NTM1fXJldHVybiBvfWZ1bmN0aW9uIGlzU3BlY2lhbChlKXtyZXR1cm4gNDc9PT1lfHw5MT09PWV8fDkzPT09ZXx8MTIzPT09ZXx8MTI1PT09ZXx8NDA9PT1lfHw0MT09PWV9dC5UeXBlMVBhcnNlcj1jbGFzcyBUeXBlMVBhcnNlcntjb25zdHJ1Y3RvcihlLHQsYSl7aWYodCl7Y29uc3QgdD1lLmdldEJ5dGVzKCksYT0hKChpc0hleERpZ2l0KHRbMF0pfHwoMCxuLmlzV2hpdGVTcGFjZSkodFswXSkpJiZpc0hleERpZ2l0KHRbMV0pJiZpc0hleERpZ2l0KHRbMl0pJiZpc0hleERpZ2l0KHRbM10pJiZpc0hleERpZ2l0KHRbNF0pJiZpc0hleERpZ2l0KHRbNV0pJiZpc0hleERpZ2l0KHRbNl0pJiZpc0hleERpZ2l0KHRbN10pKTtlPW5ldyBpLlN0cmVhbShhP2RlY3J5cHQodCw1NTY2NSw0KTpmdW5jdGlvbiBkZWNyeXB0QXNjaWkoZSx0LGEpe2xldCByPTB8dDtjb25zdCBuPWUubGVuZ3RoLGk9bmV3IFVpbnQ4QXJyYXkobj4+PjEpO2xldCBzLG87Zm9yKHM9MCxvPTA7czxuO3MrKyl7Y29uc3QgdD1lW3NdO2lmKCFpc0hleERpZ2l0KHQpKWNvbnRpbnVlO3MrKztsZXQgYTtmb3IoO3M8biYmIWlzSGV4RGlnaXQoYT1lW3NdKTspcysrO2lmKHM8bil7Y29uc3QgZT1wYXJzZUludChTdHJpbmcuZnJvbUNoYXJDb2RlKHQsYSksMTYpO2lbbysrXT1lXnI+Pjg7cj01Mjg0NSooZStyKSsyMjcxOSY2NTUzNX19cmV0dXJuIGkuc2xpY2UoYSxvKX0odCw1NTY2NSw0KSl9dGhpcy5zZWFjQW5hbHlzaXNFbmFibGVkPSEhYTt0aGlzLnN0cmVhbT1lO3RoaXMubmV4dENoYXIoKX1yZWFkTnVtYmVyQXJyYXkoKXt0aGlzLmdldFRva2VuKCk7Y29uc3QgZT1bXTtmb3IoOzspe2NvbnN0IHQ9dGhpcy5nZXRUb2tlbigpO2lmKG51bGw9PT10fHwiXSI9PT10fHwifSI9PT10KWJyZWFrO2UucHVzaChwYXJzZUZsb2F0KHR8fDApKX1yZXR1cm4gZX1yZWFkTnVtYmVyKCl7Y29uc3QgZT10aGlzLmdldFRva2VuKCk7cmV0dXJuIHBhcnNlRmxvYXQoZXx8MCl9cmVhZEludCgpe2NvbnN0IGU9dGhpcy5nZXRUb2tlbigpO3JldHVybiAwfHBhcnNlSW50KGV8fDAsMTApfXJlYWRCb29sZWFuKCl7cmV0dXJuInRydWUiPT09dGhpcy5nZXRUb2tlbigpPzE6MH1uZXh0Q2hhcigpe3JldHVybiB0aGlzLmN1cnJlbnRDaGFyPXRoaXMuc3RyZWFtLmdldEJ5dGUoKX1wcmV2Q2hhcigpe3RoaXMuc3RyZWFtLnNraXAoLTIpO3JldHVybiB0aGlzLmN1cnJlbnRDaGFyPXRoaXMuc3RyZWFtLmdldEJ5dGUoKX1nZXRUb2tlbigpe2xldCBlPSExLHQ9dGhpcy5jdXJyZW50Q2hhcjtmb3IoOzspe2lmKC0xPT09dClyZXR1cm4gbnVsbDtpZihlKTEwIT09dCYmMTMhPT10fHwoZT0hMSk7ZWxzZSBpZigzNz09PXQpZT0hMDtlbHNlIGlmKCEoMCxuLmlzV2hpdGVTcGFjZSkodCkpYnJlYWs7dD10aGlzLm5leHRDaGFyKCl9aWYoaXNTcGVjaWFsKHQpKXt0aGlzLm5leHRDaGFyKCk7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodCl9bGV0IGE9IiI7ZG97YSs9U3RyaW5nLmZyb21DaGFyQ29kZSh0KTt0PXRoaXMubmV4dENoYXIoKX13aGlsZSh0Pj0wJiYhKDAsbi5pc1doaXRlU3BhY2UpKHQpJiYhaXNTcGVjaWFsKHQpKTtyZXR1cm4gYX1yZWFkQ2hhclN0cmluZ3MoZSx0KXtyZXR1cm4tMT09PXQ/ZTpkZWNyeXB0KGUsNDMzMCx0KX1leHRyYWN0Rm9udFByb2dyYW0oZSl7Y29uc3QgdD10aGlzLnN0cmVhbSxhPVtdLHI9W10sbj1PYmplY3QuY3JlYXRlKG51bGwpO24ubGVuSVY9NDtjb25zdCBpPXtzdWJyczpbXSxjaGFyc3RyaW5nczpbXSxwcm9wZXJ0aWVzOntwcml2YXRlRGF0YTpufX07bGV0IHMsbyxjLGw7Zm9yKDtudWxsIT09KHM9dGhpcy5nZXRUb2tlbigpKTspaWYoIi8iPT09cyl7cz10aGlzLmdldFRva2VuKCk7c3dpdGNoKHMpe2Nhc2UiQ2hhclN0cmluZ3MiOnRoaXMuZ2V0VG9rZW4oKTt0aGlzLmdldFRva2VuKCk7dGhpcy5nZXRUb2tlbigpO3RoaXMuZ2V0VG9rZW4oKTtmb3IoOzspe3M9dGhpcy5nZXRUb2tlbigpO2lmKG51bGw9PT1zfHwiZW5kIj09PXMpYnJlYWs7aWYoIi8iIT09cyljb250aW51ZTtjb25zdCBlPXRoaXMuZ2V0VG9rZW4oKTtvPXRoaXMucmVhZEludCgpO3RoaXMuZ2V0VG9rZW4oKTtjPW8+MD90LmdldEJ5dGVzKG8pOm5ldyBVaW50OEFycmF5KDApO2w9aS5wcm9wZXJ0aWVzLnByaXZhdGVEYXRhLmxlbklWO2NvbnN0IGE9dGhpcy5yZWFkQ2hhclN0cmluZ3MoYyxsKTt0aGlzLm5leHRDaGFyKCk7cz10aGlzLmdldFRva2VuKCk7Im5vYWNjZXNzIj09PXM/dGhpcy5nZXRUb2tlbigpOiIvIj09PXMmJnRoaXMucHJldkNoYXIoKTtyLnB1c2goe2dseXBoOmUsZW5jb2RlZDphfSl9YnJlYWs7Y2FzZSJTdWJycyI6dGhpcy5yZWFkSW50KCk7dGhpcy5nZXRUb2tlbigpO2Zvcig7ImR1cCI9PT10aGlzLmdldFRva2VuKCk7KXtjb25zdCBlPXRoaXMucmVhZEludCgpO289dGhpcy5yZWFkSW50KCk7dGhpcy5nZXRUb2tlbigpO2M9bz4wP3QuZ2V0Qnl0ZXMobyk6bmV3IFVpbnQ4QXJyYXkoMCk7bD1pLnByb3BlcnRpZXMucHJpdmF0ZURhdGEubGVuSVY7Y29uc3Qgcj10aGlzLnJlYWRDaGFyU3RyaW5ncyhjLGwpO3RoaXMubmV4dENoYXIoKTtzPXRoaXMuZ2V0VG9rZW4oKTsibm9hY2Nlc3MiPT09cyYmdGhpcy5nZXRUb2tlbigpO2FbZV09cn1icmVhaztjYXNlIkJsdWVWYWx1ZXMiOmNhc2UiT3RoZXJCbHVlcyI6Y2FzZSJGYW1pbHlCbHVlcyI6Y2FzZSJGYW1pbHlPdGhlckJsdWVzIjpjb25zdCBlPXRoaXMucmVhZE51bWJlckFycmF5KCk7ZS5sZW5ndGg+MCYmZS5sZW5ndGgsMDticmVhaztjYXNlIlN0ZW1TbmFwSCI6Y2FzZSJTdGVtU25hcFYiOmkucHJvcGVydGllcy5wcml2YXRlRGF0YVtzXT10aGlzLnJlYWROdW1iZXJBcnJheSgpO2JyZWFrO2Nhc2UiU3RkSFciOmNhc2UiU3RkVlciOmkucHJvcGVydGllcy5wcml2YXRlRGF0YVtzXT10aGlzLnJlYWROdW1iZXJBcnJheSgpWzBdO2JyZWFrO2Nhc2UiQmx1ZVNoaWZ0IjpjYXNlImxlbklWIjpjYXNlIkJsdWVGdXp6IjpjYXNlIkJsdWVTY2FsZSI6Y2FzZSJMYW5ndWFnZUdyb3VwIjpjYXNlIkV4cGFuc2lvbkZhY3RvciI6aS5wcm9wZXJ0aWVzLnByaXZhdGVEYXRhW3NdPXRoaXMucmVhZE51bWJlcigpO2JyZWFrO2Nhc2UiRm9yY2VCb2xkIjppLnByb3BlcnRpZXMucHJpdmF0ZURhdGFbc109dGhpcy5yZWFkQm9vbGVhbigpfX1mb3IoY29uc3R7ZW5jb2RlZDp0LGdseXBoOm59b2Ygcil7Y29uc3Qgcj1uZXcgVHlwZTFDaGFyU3RyaW5nLHM9ci5jb252ZXJ0KHQsYSx0aGlzLnNlYWNBbmFseXNpc0VuYWJsZWQpO2xldCBvPXIub3V0cHV0O3MmJihvPVsxNF0pO2NvbnN0IGM9e2dseXBoTmFtZTpuLGNoYXJzdHJpbmc6byx3aWR0aDpyLndpZHRoLGxzYjpyLmxzYixzZWFjOnIuc2VhY307Ii5ub3RkZWYiPT09bj9pLmNoYXJzdHJpbmdzLnVuc2hpZnQoYyk6aS5jaGFyc3RyaW5ncy5wdXNoKGMpO2lmKGUuYnVpbHRJbkVuY29kaW5nKXtjb25zdCB0PWUuYnVpbHRJbkVuY29kaW5nLmluZGV4T2Yobik7dD4tMSYmdm9pZCAwPT09ZS53aWR0aHNbdF0mJnQ+PWUuZmlyc3RDaGFyJiZ0PD1lLmxhc3RDaGFyJiYoZS53aWR0aHNbdF09ci53aWR0aCl9fXJldHVybiBpfWV4dHJhY3RGb250SGVhZGVyKGUpe2xldCB0O2Zvcig7bnVsbCE9PSh0PXRoaXMuZ2V0VG9rZW4oKSk7KWlmKCIvIj09PXQpe3Q9dGhpcy5nZXRUb2tlbigpO3N3aXRjaCh0KXtjYXNlIkZvbnRNYXRyaXgiOmNvbnN0IGE9dGhpcy5yZWFkTnVtYmVyQXJyYXkoKTtlLmZvbnRNYXRyaXg9YTticmVhaztjYXNlIkVuY29kaW5nIjpjb25zdCBuPXRoaXMuZ2V0VG9rZW4oKTtsZXQgaTtpZigvXlxkKyQvLnRlc3Qobikpe2k9W107Y29uc3QgZT0wfHBhcnNlSW50KG4sMTApO3RoaXMuZ2V0VG9rZW4oKTtmb3IobGV0IGE9MDthPGU7YSsrKXt0PXRoaXMuZ2V0VG9rZW4oKTtmb3IoOyJkdXAiIT09dCYmImRlZiIhPT10Oyl7dD10aGlzLmdldFRva2VuKCk7aWYobnVsbD09PXQpcmV0dXJufWlmKCJkZWYiPT09dClicmVhaztjb25zdCBlPXRoaXMucmVhZEludCgpO3RoaXMuZ2V0VG9rZW4oKTtjb25zdCBhPXRoaXMuZ2V0VG9rZW4oKTtpW2VdPWE7dGhpcy5nZXRUb2tlbigpfX1lbHNlIGk9KDAsci5nZXRFbmNvZGluZykobik7ZS5idWlsdEluRW5jb2Rpbmc9aTticmVhaztjYXNlIkZvbnRCQm94Ijpjb25zdCBzPXRoaXMucmVhZE51bWJlckFycmF5KCk7ZS5hc2NlbnQ9TWF0aC5tYXgoc1szXSxzWzFdKTtlLmRlc2NlbnQ9TWF0aC5taW4oc1sxXSxzWzNdKTtlLmFzY2VudFNjYWxlZD0hMH19fX19LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5QYXR0ZXJuPXZvaWQgMDt0LmdldFRpbGluZ1BhdHRlcm5JUj1mdW5jdGlvbiBnZXRUaWxpbmdQYXR0ZXJuSVIoZSx0LGEpe2NvbnN0IG49dC5nZXRBcnJheSgiTWF0cml4IiksaT1yLlV0aWwubm9ybWFsaXplUmVjdCh0LmdldEFycmF5KCJCQm94IikpLHM9dC5nZXQoIlhTdGVwIiksbz10LmdldCgiWVN0ZXAiKSxjPXQuZ2V0KCJQYWludFR5cGUiKSxsPXQuZ2V0KCJUaWxpbmdUeXBlIik7aWYoaVsyXS1pWzBdPT0wfHxpWzNdLWlbMV09PTApdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoYEludmFsaWQgZ2V0VGlsaW5nUGF0dGVybklSIC9CQm94IGFycmF5OiBbJHtpfV0uYCk7cmV0dXJuWyJUaWxpbmdQYXR0ZXJuIixhLGUsbixpLHMsbyxjLGxdfTt2YXIgcj1hKDIpLG49YSg3KSxpPWEoMTQpLHM9YSg2KTtjb25zdCBvPTIsYz0zLGw9NCxoPTUsdT02LGQ9Nzt0LlBhdHRlcm49Y2xhc3MgUGF0dGVybntjb25zdHJ1Y3RvcigpeygwLHIudW5yZWFjaGFibGUpKCJDYW5ub3QgaW5pdGlhbGl6ZSBQYXR0ZXJuLiIpfXN0YXRpYyBwYXJzZVNoYWRpbmcoZSx0LGEsaSxmLGcpe2NvbnN0IHA9ZSBpbnN0YW5jZW9mIG4uQmFzZVN0cmVhbT9lLmRpY3Q6ZSxtPXAuZ2V0KCJTaGFkaW5nVHlwZSIpO3RyeXtzd2l0Y2gobSl7Y2FzZSBvOmNhc2UgYzpyZXR1cm4gbmV3IFJhZGlhbEF4aWFsU2hhZGluZyhwLHQsYSxmLGcpO2Nhc2UgbDpjYXNlIGg6Y2FzZSB1OmNhc2UgZDpyZXR1cm4gbmV3IE1lc2hTaGFkaW5nKGUsdCxhLGYsZyk7ZGVmYXVsdDp0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiVW5zdXBwb3J0ZWQgU2hhZGluZ1R5cGU6ICIrbSl9fWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBzLk1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7aS5zZW5kKCJVbnN1cHBvcnRlZEZlYXR1cmUiLHtmZWF0dXJlSWQ6ci5VTlNVUFBPUlRFRF9GRUFUVVJFUy5zaGFkaW5nUGF0dGVybn0pOygwLHIud2FybikoZSk7cmV0dXJuIG5ldyBEdW1teVNoYWRpbmd9fX07Y2xhc3MgQmFzZVNoYWRpbmd7c3RhdGljIGdldCBTTUFMTF9OVU1CRVIoKXtyZXR1cm4oMCxyLnNoYWRvdykodGhpcywiU01BTExfTlVNQkVSIiwxZS02KX1jb25zdHJ1Y3Rvcigpe3RoaXMuY29uc3RydWN0b3I9PT1CYXNlU2hhZGluZyYmKDAsci51bnJlYWNoYWJsZSkoIkNhbm5vdCBpbml0aWFsaXplIEJhc2VTaGFkaW5nLiIpfWdldElSKCl7KDAsci51bnJlYWNoYWJsZSkoIkFic3RyYWN0IG1ldGhvZCBgZ2V0SVJgIGNhbGxlZC4iKX19Y2xhc3MgUmFkaWFsQXhpYWxTaGFkaW5nIGV4dGVuZHMgQmFzZVNoYWRpbmd7Y29uc3RydWN0b3IoZSx0LGEsbixzKXtzdXBlcigpO3RoaXMuY29vcmRzQXJyPWUuZ2V0QXJyYXkoIkNvb3JkcyIpO3RoaXMuc2hhZGluZ1R5cGU9ZS5nZXQoIlNoYWRpbmdUeXBlIik7Y29uc3Qgbz1pLkNvbG9yU3BhY2UucGFyc2Uoe2NzOmUuZ2V0UmF3KCJDUyIpfHxlLmdldFJhdygiQ29sb3JTcGFjZSIpLHhyZWY6dCxyZXNvdXJjZXM6YSxwZGZGdW5jdGlvbkZhY3Rvcnk6bixsb2NhbENvbG9yU3BhY2VDYWNoZTpzfSksbD1lLmdldEFycmF5KCJCQm94Iik7QXJyYXkuaXNBcnJheShsKSYmND09PWwubGVuZ3RoP3RoaXMuYmJveD1yLlV0aWwubm9ybWFsaXplUmVjdChsKTp0aGlzLmJib3g9bnVsbDtsZXQgaD0wLHU9MTtpZihlLmhhcygiRG9tYWluIikpe2NvbnN0IHQ9ZS5nZXRBcnJheSgiRG9tYWluIik7aD10WzBdO3U9dFsxXX1sZXQgZD0hMSxmPSExO2lmKGUuaGFzKCJFeHRlbmQiKSl7Y29uc3QgdD1lLmdldEFycmF5KCJFeHRlbmQiKTtkPXRbMF07Zj10WzFdfWlmKCEodGhpcy5zaGFkaW5nVHlwZSE9PWN8fGQmJmYpKXtjb25zdFtlLHQsYSxuLGksc109dGhpcy5jb29yZHNBcnIsbz1NYXRoLmh5cG90KGUtbix0LWkpO2E8PXMrbyYmczw9YStvJiYoMCxyLndhcm4pKCJVbnN1cHBvcnRlZCByYWRpYWwgZ3JhZGllbnQuIil9dGhpcy5leHRlbmRTdGFydD1kO3RoaXMuZXh0ZW5kRW5kPWY7Y29uc3QgZz1lLmdldFJhdygiRnVuY3Rpb24iKSxwPW4uY3JlYXRlRnJvbUFycmF5KGcpLG09KHUtaCkvMTAsYj10aGlzLmNvbG9yU3RvcHM9W107aWYoaD49dXx8bTw9MCl7KDAsci5pbmZvKSgiQmFkIHNoYWRpbmcgZG9tYWluLiIpO3JldHVybn1jb25zdCB5PW5ldyBGbG9hdDMyQXJyYXkoby5udW1Db21wcyksdz1uZXcgRmxvYXQzMkFycmF5KDEpO2xldCBTO2ZvcihsZXQgZT0wO2U8PTEwO2UrKyl7d1swXT1oK2UqbTtwKHcsMCx5LDApO1M9by5nZXRSZ2IoeSwwKTtjb25zdCB0PXIuVXRpbC5tYWtlSGV4Q29sb3IoU1swXSxTWzFdLFNbMl0pO2IucHVzaChbZS8xMCx0XSl9bGV0IHg9InRyYW5zcGFyZW50IjtpZihlLmhhcygiQmFja2dyb3VuZCIpKXtTPW8uZ2V0UmdiKGUuZ2V0KCJCYWNrZ3JvdW5kIiksMCk7eD1yLlV0aWwubWFrZUhleENvbG9yKFNbMF0sU1sxXSxTWzJdKX1pZighZCl7Yi51bnNoaWZ0KFswLHhdKTtiWzFdWzBdKz1CYXNlU2hhZGluZy5TTUFMTF9OVU1CRVJ9aWYoIWYpe2IuYXQoLTEpWzBdLT1CYXNlU2hhZGluZy5TTUFMTF9OVU1CRVI7Yi5wdXNoKFsxLHhdKX10aGlzLmNvbG9yU3RvcHM9Yn1nZXRJUigpe2NvbnN0IGU9dGhpcy5jb29yZHNBcnIsdD10aGlzLnNoYWRpbmdUeXBlO2xldCBhLG4saSxzLGw7aWYodD09PW8pe249W2VbMF0sZVsxXV07aT1bZVsyXSxlWzNdXTtzPW51bGw7bD1udWxsO2E9ImF4aWFsIn1lbHNlIGlmKHQ9PT1jKXtuPVtlWzBdLGVbMV1dO2k9W2VbM10sZVs0XV07cz1lWzJdO2w9ZVs1XTthPSJyYWRpYWwifWVsc2UoMCxyLnVucmVhY2hhYmxlKShgZ2V0UGF0dGVybiB0eXBlIHVua25vd246ICR7dH1gKTtyZXR1cm5bIlJhZGlhbEF4aWFsIixhLHRoaXMuYmJveCx0aGlzLmNvbG9yU3RvcHMsbixpLHMsbF19fWNsYXNzIE1lc2hTdHJlYW1SZWFkZXJ7Y29uc3RydWN0b3IoZSx0KXt0aGlzLnN0cmVhbT1lO3RoaXMuY29udGV4dD10O3RoaXMuYnVmZmVyPTA7dGhpcy5idWZmZXJMZW5ndGg9MDtjb25zdCBhPXQubnVtQ29tcHM7dGhpcy50bXBDb21wc0J1Zj1uZXcgRmxvYXQzMkFycmF5KGEpO2NvbnN0IHI9dC5jb2xvclNwYWNlLm51bUNvbXBzO3RoaXMudG1wQ3NDb21wc0J1Zj10LmNvbG9yRm4/bmV3IEZsb2F0MzJBcnJheShyKTp0aGlzLnRtcENvbXBzQnVmfWdldCBoYXNEYXRhKCl7aWYodGhpcy5zdHJlYW0uZW5kKXJldHVybiB0aGlzLnN0cmVhbS5wb3M8dGhpcy5zdHJlYW0uZW5kO2lmKHRoaXMuYnVmZmVyTGVuZ3RoPjApcmV0dXJuITA7Y29uc3QgZT10aGlzLnN0cmVhbS5nZXRCeXRlKCk7aWYoZTwwKXJldHVybiExO3RoaXMuYnVmZmVyPWU7dGhpcy5idWZmZXJMZW5ndGg9ODtyZXR1cm4hMH1yZWFkQml0cyhlKXtsZXQgdD10aGlzLmJ1ZmZlcixhPXRoaXMuYnVmZmVyTGVuZ3RoO2lmKDMyPT09ZSl7aWYoMD09PWEpcmV0dXJuKHRoaXMuc3RyZWFtLmdldEJ5dGUoKTw8MjR8dGhpcy5zdHJlYW0uZ2V0Qnl0ZSgpPDwxNnx0aGlzLnN0cmVhbS5nZXRCeXRlKCk8PDh8dGhpcy5zdHJlYW0uZ2V0Qnl0ZSgpKT4+PjA7dD10PDwyNHx0aGlzLnN0cmVhbS5nZXRCeXRlKCk8PDE2fHRoaXMuc3RyZWFtLmdldEJ5dGUoKTw8OHx0aGlzLnN0cmVhbS5nZXRCeXRlKCk7Y29uc3QgZT10aGlzLnN0cmVhbS5nZXRCeXRlKCk7dGhpcy5idWZmZXI9ZSYoMTw8YSktMTtyZXR1cm4odDw8OC1hfCgyNTUmZSk+PmEpPj4+MH1pZig4PT09ZSYmMD09PWEpcmV0dXJuIHRoaXMuc3RyZWFtLmdldEJ5dGUoKTtmb3IoO2E8ZTspe3Q9dDw8OHx0aGlzLnN0cmVhbS5nZXRCeXRlKCk7YSs9OH1hLT1lO3RoaXMuYnVmZmVyTGVuZ3RoPWE7dGhpcy5idWZmZXI9dCYoMTw8YSktMTtyZXR1cm4gdD4+YX1hbGlnbigpe3RoaXMuYnVmZmVyPTA7dGhpcy5idWZmZXJMZW5ndGg9MH1yZWFkRmxhZygpe3JldHVybiB0aGlzLnJlYWRCaXRzKHRoaXMuY29udGV4dC5iaXRzUGVyRmxhZyl9cmVhZENvb3JkaW5hdGUoKXtjb25zdCBlPXRoaXMuY29udGV4dC5iaXRzUGVyQ29vcmRpbmF0ZSx0PXRoaXMucmVhZEJpdHMoZSksYT10aGlzLnJlYWRCaXRzKGUpLHI9dGhpcy5jb250ZXh0LmRlY29kZSxuPWU8MzI/MS8oKDE8PGUpLTEpOjIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7cmV0dXJuW3QqbiooclsxXS1yWzBdKStyWzBdLGEqbiooclszXS1yWzJdKStyWzJdXX1yZWFkQ29tcG9uZW50cygpe2NvbnN0IGU9dGhpcy5jb250ZXh0Lm51bUNvbXBzLHQ9dGhpcy5jb250ZXh0LmJpdHNQZXJDb21wb25lbnQsYT10PDMyPzEvKCgxPDx0KS0xKToyLjMyODMwNjQzNjUzODY5NjNlLTEwLHI9dGhpcy5jb250ZXh0LmRlY29kZSxuPXRoaXMudG1wQ29tcHNCdWY7Zm9yKGxldCBpPTAscz00O2k8ZTtpKysscys9Mil7Y29uc3QgZT10aGlzLnJlYWRCaXRzKHQpO25baV09ZSphKihyW3MrMV0tcltzXSkrcltzXX1jb25zdCBpPXRoaXMudG1wQ3NDb21wc0J1Zjt0aGlzLmNvbnRleHQuY29sb3JGbiYmdGhpcy5jb250ZXh0LmNvbG9yRm4obiwwLGksMCk7cmV0dXJuIHRoaXMuY29udGV4dC5jb2xvclNwYWNlLmdldFJnYihpLDApfX1jb25zdCBmPWZ1bmN0aW9uIGdldEJDbG9zdXJlKCl7Y29uc3QgZT1bXTtyZXR1cm4gZnVuY3Rpb24odCl7ZVt0XXx8KGVbdF09ZnVuY3Rpb24gYnVpbGRCKGUpe2NvbnN0IHQ9W107Zm9yKGxldCBhPTA7YTw9ZTthKyspe2NvbnN0IHI9YS9lLG49MS1yO3QucHVzaChuZXcgRmxvYXQzMkFycmF5KFtuKm4qbiwzKnIqbipuLDMqcipyKm4scipyKnJdKSl9cmV0dXJuIHR9KHQpKTtyZXR1cm4gZVt0XX19KCk7Y2xhc3MgTWVzaFNoYWRpbmcgZXh0ZW5kcyBCYXNlU2hhZGluZ3tzdGF0aWMgZ2V0IE1JTl9TUExJVF9QQVRDSF9DSFVOS1NfQU1PVU5UKCl7cmV0dXJuKDAsci5zaGFkb3cpKHRoaXMsIk1JTl9TUExJVF9QQVRDSF9DSFVOS1NfQU1PVU5UIiwzKX1zdGF0aWMgZ2V0IE1BWF9TUExJVF9QQVRDSF9DSFVOS1NfQU1PVU5UKCl7cmV0dXJuKDAsci5zaGFkb3cpKHRoaXMsIk1BWF9TUExJVF9QQVRDSF9DSFVOS1NfQU1PVU5UIiwyMCl9c3RhdGljIGdldCBUUklBTkdMRV9ERU5TSVRZKCl7cmV0dXJuKDAsci5zaGFkb3cpKHRoaXMsIlRSSUFOR0xFX0RFTlNJVFkiLDIwKX1jb25zdHJ1Y3RvcihlLHQsYSxzLG8pe3N1cGVyKCk7aWYoIShlIGluc3RhbmNlb2Ygbi5CYXNlU3RyZWFtKSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiTWVzaCBkYXRhIGlzIG5vdCBhIHN0cmVhbSIpO2NvbnN0IGM9ZS5kaWN0O3RoaXMuc2hhZGluZ1R5cGU9Yy5nZXQoIlNoYWRpbmdUeXBlIik7Y29uc3QgZj1jLmdldEFycmF5KCJCQm94Iik7QXJyYXkuaXNBcnJheShmKSYmND09PWYubGVuZ3RoP3RoaXMuYmJveD1yLlV0aWwubm9ybWFsaXplUmVjdChmKTp0aGlzLmJib3g9bnVsbDtjb25zdCBnPWkuQ29sb3JTcGFjZS5wYXJzZSh7Y3M6Yy5nZXRSYXcoIkNTIil8fGMuZ2V0UmF3KCJDb2xvclNwYWNlIikseHJlZjp0LHJlc291cmNlczphLHBkZkZ1bmN0aW9uRmFjdG9yeTpzLGxvY2FsQ29sb3JTcGFjZUNhY2hlOm99KTt0aGlzLmJhY2tncm91bmQ9Yy5oYXMoIkJhY2tncm91bmQiKT9nLmdldFJnYihjLmdldCgiQmFja2dyb3VuZCIpLDApOm51bGw7Y29uc3QgcD1jLmdldFJhdygiRnVuY3Rpb24iKSxtPXA/cy5jcmVhdGVGcm9tQXJyYXkocCk6bnVsbDt0aGlzLmNvb3Jkcz1bXTt0aGlzLmNvbG9ycz1bXTt0aGlzLmZpZ3VyZXM9W107Y29uc3QgYj17Yml0c1BlckNvb3JkaW5hdGU6Yy5nZXQoIkJpdHNQZXJDb29yZGluYXRlIiksYml0c1BlckNvbXBvbmVudDpjLmdldCgiQml0c1BlckNvbXBvbmVudCIpLGJpdHNQZXJGbGFnOmMuZ2V0KCJCaXRzUGVyRmxhZyIpLGRlY29kZTpjLmdldEFycmF5KCJEZWNvZGUiKSxjb2xvckZuOm0sY29sb3JTcGFjZTpnLG51bUNvbXBzOm0/MTpnLm51bUNvbXBzfSx5PW5ldyBNZXNoU3RyZWFtUmVhZGVyKGUsYik7bGV0IHc9ITE7c3dpdGNoKHRoaXMuc2hhZGluZ1R5cGUpe2Nhc2UgbDp0aGlzLl9kZWNvZGVUeXBlNFNoYWRpbmcoeSk7YnJlYWs7Y2FzZSBoOmNvbnN0IGU9MHxjLmdldCgiVmVydGljZXNQZXJSb3ciKTtpZihlPDIpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoIkludmFsaWQgVmVydGljZXNQZXJSb3ciKTt0aGlzLl9kZWNvZGVUeXBlNVNoYWRpbmcoeSxlKTticmVhaztjYXNlIHU6dGhpcy5fZGVjb2RlVHlwZTZTaGFkaW5nKHkpO3c9ITA7YnJlYWs7Y2FzZSBkOnRoaXMuX2RlY29kZVR5cGU3U2hhZGluZyh5KTt3PSEwO2JyZWFrO2RlZmF1bHQ6KDAsci51bnJlYWNoYWJsZSkoIlVuc3VwcG9ydGVkIG1lc2ggdHlwZS4iKX1pZih3KXt0aGlzLl91cGRhdGVCb3VuZHMoKTtmb3IobGV0IGU9MCx0PXRoaXMuZmlndXJlcy5sZW5ndGg7ZTx0O2UrKyl0aGlzLl9idWlsZEZpZ3VyZUZyb21QYXRjaChlKX10aGlzLl91cGRhdGVCb3VuZHMoKTt0aGlzLl9wYWNrRGF0YSgpfV9kZWNvZGVUeXBlNFNoYWRpbmcoZSl7Y29uc3QgdD10aGlzLmNvb3JkcyxhPXRoaXMuY29sb3JzLG49W10saT1bXTtsZXQgcz0wO2Zvcig7ZS5oYXNEYXRhOyl7Y29uc3Qgbz1lLnJlYWRGbGFnKCksYz1lLnJlYWRDb29yZGluYXRlKCksbD1lLnJlYWRDb21wb25lbnRzKCk7aWYoMD09PXMpe2lmKCEoMDw9byYmbzw9MikpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoIlVua25vd24gdHlwZTQgZmxhZyIpO3N3aXRjaChvKXtjYXNlIDA6cz0zO2JyZWFrO2Nhc2UgMTppLnB1c2goaS5hdCgtMiksaS5hdCgtMSkpO3M9MTticmVhaztjYXNlIDI6aS5wdXNoKGkuYXQoLTMpLGkuYXQoLTEpKTtzPTF9bi5wdXNoKG8pfWkucHVzaCh0Lmxlbmd0aCk7dC5wdXNoKGMpO2EucHVzaChsKTtzLS07ZS5hbGlnbigpfXRoaXMuZmlndXJlcy5wdXNoKHt0eXBlOiJ0cmlhbmdsZXMiLGNvb3JkczpuZXcgSW50MzJBcnJheShpKSxjb2xvcnM6bmV3IEludDMyQXJyYXkoaSl9KX1fZGVjb2RlVHlwZTVTaGFkaW5nKGUsdCl7Y29uc3QgYT10aGlzLmNvb3JkcyxyPXRoaXMuY29sb3JzLG49W107Zm9yKDtlLmhhc0RhdGE7KXtjb25zdCB0PWUucmVhZENvb3JkaW5hdGUoKSxpPWUucmVhZENvbXBvbmVudHMoKTtuLnB1c2goYS5sZW5ndGgpO2EucHVzaCh0KTtyLnB1c2goaSl9dGhpcy5maWd1cmVzLnB1c2goe3R5cGU6ImxhdHRpY2UiLGNvb3JkczpuZXcgSW50MzJBcnJheShuKSxjb2xvcnM6bmV3IEludDMyQXJyYXkobiksdmVydGljZXNQZXJSb3c6dH0pfV9kZWNvZGVUeXBlNlNoYWRpbmcoZSl7Y29uc3QgdD10aGlzLmNvb3JkcyxhPXRoaXMuY29sb3JzLG49bmV3IEludDMyQXJyYXkoMTYpLGk9bmV3IEludDMyQXJyYXkoNCk7Zm9yKDtlLmhhc0RhdGE7KXtjb25zdCBzPWUucmVhZEZsYWcoKTtpZighKDA8PXMmJnM8PTMpKXRocm93IG5ldyByLkZvcm1hdEVycm9yKCJVbmtub3duIHR5cGU2IGZsYWciKTtjb25zdCBvPXQubGVuZ3RoO2ZvcihsZXQgYT0wLHI9MCE9PXM/ODoxMjthPHI7YSsrKXQucHVzaChlLnJlYWRDb29yZGluYXRlKCkpO2NvbnN0IGM9YS5sZW5ndGg7Zm9yKGxldCB0PTAscj0wIT09cz8yOjQ7dDxyO3QrKylhLnB1c2goZS5yZWFkQ29tcG9uZW50cygpKTtsZXQgbCxoLHUsZDtzd2l0Y2gocyl7Y2FzZSAwOm5bMTJdPW8rMztuWzEzXT1vKzQ7blsxNF09bys1O25bMTVdPW8rNjtuWzhdPW8rMjtuWzExXT1vKzc7bls0XT1vKzE7bls3XT1vKzg7blswXT1vO25bMV09bysxMTtuWzJdPW8rMTA7blszXT1vKzk7aVsyXT1jKzE7aVszXT1jKzI7aVswXT1jO2lbMV09YyszO2JyZWFrO2Nhc2UgMTpsPW5bMTJdO2g9blsxM107dT1uWzE0XTtkPW5bMTVdO25bMTJdPWQ7blsxM109byswO25bMTRdPW8rMTtuWzE1XT1vKzI7bls4XT11O25bMTFdPW8rMztuWzRdPWg7bls3XT1vKzQ7blswXT1sO25bMV09bys3O25bMl09bys2O25bM109bys1O2w9aVsyXTtoPWlbM107aVsyXT1oO2lbM109YztpWzBdPWw7aVsxXT1jKzE7YnJlYWs7Y2FzZSAyOmw9blsxNV07aD1uWzExXTtuWzEyXT1uWzNdO25bMTNdPW8rMDtuWzE0XT1vKzE7blsxNV09bysyO25bOF09bls3XTtuWzExXT1vKzM7bls0XT1oO25bN109bys0O25bMF09bDtuWzFdPW8rNztuWzJdPW8rNjtuWzNdPW8rNTtsPWlbM107aVsyXT1pWzFdO2lbM109YztpWzBdPWw7aVsxXT1jKzE7YnJlYWs7Y2FzZSAzOm5bMTJdPW5bMF07blsxM109byswO25bMTRdPW8rMTtuWzE1XT1vKzI7bls4XT1uWzFdO25bMTFdPW8rMztuWzRdPW5bMl07bls3XT1vKzQ7blswXT1uWzNdO25bMV09bys3O25bMl09bys2O25bM109bys1O2lbMl09aVswXTtpWzNdPWM7aVswXT1pWzFdO2lbMV09YysxfW5bNV09dC5sZW5ndGg7dC5wdXNoKFsoLTQqdFtuWzBdXVswXS10W25bMTVdXVswXSs2Kih0W25bNF1dWzBdK3RbblsxXV1bMF0pLTIqKHRbblsxMl1dWzBdK3RbblszXV1bMF0pKzMqKHRbblsxM11dWzBdK3Rbbls3XV1bMF0pKS85LCgtNCp0W25bMF1dWzFdLXRbblsxNV1dWzFdKzYqKHRbbls0XV1bMV0rdFtuWzFdXVsxXSktMioodFtuWzEyXV1bMV0rdFtuWzNdXVsxXSkrMyoodFtuWzEzXV1bMV0rdFtuWzddXVsxXSkpLzldKTtuWzZdPXQubGVuZ3RoO3QucHVzaChbKC00KnRbblszXV1bMF0tdFtuWzEyXV1bMF0rNioodFtuWzJdXVswXSt0W25bN11dWzBdKS0yKih0W25bMF1dWzBdK3RbblsxNV1dWzBdKSszKih0W25bNF1dWzBdK3RbblsxNF1dWzBdKSkvOSwoLTQqdFtuWzNdXVsxXS10W25bMTJdXVsxXSs2Kih0W25bMl1dWzFdK3Rbbls3XV1bMV0pLTIqKHRbblswXV1bMV0rdFtuWzE1XV1bMV0pKzMqKHRbbls0XV1bMV0rdFtuWzE0XV1bMV0pKS85XSk7bls5XT10Lmxlbmd0aDt0LnB1c2goWygtNCp0W25bMTJdXVswXS10W25bM11dWzBdKzYqKHRbbls4XV1bMF0rdFtuWzEzXV1bMF0pLTIqKHRbblswXV1bMF0rdFtuWzE1XV1bMF0pKzMqKHRbblsxMV1dWzBdK3RbblsxXV1bMF0pKS85LCgtNCp0W25bMTJdXVsxXS10W25bM11dWzFdKzYqKHRbbls4XV1bMV0rdFtuWzEzXV1bMV0pLTIqKHRbblswXV1bMV0rdFtuWzE1XV1bMV0pKzMqKHRbblsxMV1dWzFdK3RbblsxXV1bMV0pKS85XSk7blsxMF09dC5sZW5ndGg7dC5wdXNoKFsoLTQqdFtuWzE1XV1bMF0tdFtuWzBdXVswXSs2Kih0W25bMTFdXVswXSt0W25bMTRdXVswXSktMioodFtuWzEyXV1bMF0rdFtuWzNdXVswXSkrMyoodFtuWzJdXVswXSt0W25bOF1dWzBdKSkvOSwoLTQqdFtuWzE1XV1bMV0tdFtuWzBdXVsxXSs2Kih0W25bMTFdXVsxXSt0W25bMTRdXVsxXSktMioodFtuWzEyXV1bMV0rdFtuWzNdXVsxXSkrMyoodFtuWzJdXVsxXSt0W25bOF1dWzFdKSkvOV0pO3RoaXMuZmlndXJlcy5wdXNoKHt0eXBlOiJwYXRjaCIsY29vcmRzOm5ldyBJbnQzMkFycmF5KG4pLGNvbG9yczpuZXcgSW50MzJBcnJheShpKX0pfX1fZGVjb2RlVHlwZTdTaGFkaW5nKGUpe2NvbnN0IHQ9dGhpcy5jb29yZHMsYT10aGlzLmNvbG9ycyxuPW5ldyBJbnQzMkFycmF5KDE2KSxpPW5ldyBJbnQzMkFycmF5KDQpO2Zvcig7ZS5oYXNEYXRhOyl7Y29uc3Qgcz1lLnJlYWRGbGFnKCk7aWYoISgwPD1zJiZzPD0zKSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiVW5rbm93biB0eXBlNyBmbGFnIik7Y29uc3Qgbz10Lmxlbmd0aDtmb3IobGV0IGE9MCxyPTAhPT1zPzEyOjE2O2E8cjthKyspdC5wdXNoKGUucmVhZENvb3JkaW5hdGUoKSk7Y29uc3QgYz1hLmxlbmd0aDtmb3IobGV0IHQ9MCxyPTAhPT1zPzI6NDt0PHI7dCsrKWEucHVzaChlLnJlYWRDb21wb25lbnRzKCkpO2xldCBsLGgsdSxkO3N3aXRjaChzKXtjYXNlIDA6blsxMl09byszO25bMTNdPW8rNDtuWzE0XT1vKzU7blsxNV09bys2O25bOF09bysyO25bOV09bysxMztuWzEwXT1vKzE0O25bMTFdPW8rNztuWzRdPW8rMTtuWzVdPW8rMTI7bls2XT1vKzE1O25bN109bys4O25bMF09bztuWzFdPW8rMTE7blsyXT1vKzEwO25bM109bys5O2lbMl09YysxO2lbM109YysyO2lbMF09YztpWzFdPWMrMzticmVhaztjYXNlIDE6bD1uWzEyXTtoPW5bMTNdO3U9blsxNF07ZD1uWzE1XTtuWzEyXT1kO25bMTNdPW8rMDtuWzE0XT1vKzE7blsxNV09bysyO25bOF09dTtuWzldPW8rOTtuWzEwXT1vKzEwO25bMTFdPW8rMztuWzRdPWg7bls1XT1vKzg7bls2XT1vKzExO25bN109bys0O25bMF09bDtuWzFdPW8rNztuWzJdPW8rNjtuWzNdPW8rNTtsPWlbMl07aD1pWzNdO2lbMl09aDtpWzNdPWM7aVswXT1sO2lbMV09YysxO2JyZWFrO2Nhc2UgMjpsPW5bMTVdO2g9blsxMV07blsxMl09blszXTtuWzEzXT1vKzA7blsxNF09bysxO25bMTVdPW8rMjtuWzhdPW5bN107bls5XT1vKzk7blsxMF09bysxMDtuWzExXT1vKzM7bls0XT1oO25bNV09bys4O25bNl09bysxMTtuWzddPW8rNDtuWzBdPWw7blsxXT1vKzc7blsyXT1vKzY7blszXT1vKzU7bD1pWzNdO2lbMl09aVsxXTtpWzNdPWM7aVswXT1sO2lbMV09YysxO2JyZWFrO2Nhc2UgMzpuWzEyXT1uWzBdO25bMTNdPW8rMDtuWzE0XT1vKzE7blsxNV09bysyO25bOF09blsxXTtuWzldPW8rOTtuWzEwXT1vKzEwO25bMTFdPW8rMztuWzRdPW5bMl07bls1XT1vKzg7bls2XT1vKzExO25bN109bys0O25bMF09blszXTtuWzFdPW8rNztuWzJdPW8rNjtuWzNdPW8rNTtpWzJdPWlbMF07aVszXT1jO2lbMF09aVsxXTtpWzFdPWMrMX10aGlzLmZpZ3VyZXMucHVzaCh7dHlwZToicGF0Y2giLGNvb3JkczpuZXcgSW50MzJBcnJheShuKSxjb2xvcnM6bmV3IEludDMyQXJyYXkoaSl9KX19X2J1aWxkRmlndXJlRnJvbVBhdGNoKGUpe2NvbnN0IHQ9dGhpcy5maWd1cmVzW2VdOygwLHIuYXNzZXJ0KSgicGF0Y2giPT09dC50eXBlLCJVbmV4cGVjdGVkIHBhdGNoIG1lc2ggZmlndXJlIik7Y29uc3QgYT10aGlzLmNvb3JkcyxuPXRoaXMuY29sb3JzLGk9dC5jb29yZHMscz10LmNvbG9ycyxvPU1hdGgubWluKGFbaVswXV1bMF0sYVtpWzNdXVswXSxhW2lbMTJdXVswXSxhW2lbMTVdXVswXSksYz1NYXRoLm1pbihhW2lbMF1dWzFdLGFbaVszXV1bMV0sYVtpWzEyXV1bMV0sYVtpWzE1XV1bMV0pLGw9TWF0aC5tYXgoYVtpWzBdXVswXSxhW2lbM11dWzBdLGFbaVsxMl1dWzBdLGFbaVsxNV1dWzBdKSxoPU1hdGgubWF4KGFbaVswXV1bMV0sYVtpWzNdXVsxXSxhW2lbMTJdXVsxXSxhW2lbMTVdXVsxXSk7bGV0IHU9TWF0aC5jZWlsKChsLW8pKk1lc2hTaGFkaW5nLlRSSUFOR0xFX0RFTlNJVFkvKHRoaXMuYm91bmRzWzJdLXRoaXMuYm91bmRzWzBdKSk7dT1NYXRoLm1heChNZXNoU2hhZGluZy5NSU5fU1BMSVRfUEFUQ0hfQ0hVTktTX0FNT1VOVCxNYXRoLm1pbihNZXNoU2hhZGluZy5NQVhfU1BMSVRfUEFUQ0hfQ0hVTktTX0FNT1VOVCx1KSk7bGV0IGQ9TWF0aC5jZWlsKChoLWMpKk1lc2hTaGFkaW5nLlRSSUFOR0xFX0RFTlNJVFkvKHRoaXMuYm91bmRzWzNdLXRoaXMuYm91bmRzWzFdKSk7ZD1NYXRoLm1heChNZXNoU2hhZGluZy5NSU5fU1BMSVRfUEFUQ0hfQ0hVTktTX0FNT1VOVCxNYXRoLm1pbihNZXNoU2hhZGluZy5NQVhfU1BMSVRfUEFUQ0hfQ0hVTktTX0FNT1VOVCxkKSk7Y29uc3QgZz11KzEscD1uZXcgSW50MzJBcnJheSgoZCsxKSpnKSxtPW5ldyBJbnQzMkFycmF5KChkKzEpKmcpO2xldCBiPTA7Y29uc3QgeT1uZXcgVWludDhBcnJheSgzKSx3PW5ldyBVaW50OEFycmF5KDMpLFM9bltzWzBdXSx4PW5bc1sxXV0saz1uW3NbMl1dLEM9bltzWzNdXSx2PWYoZCksRj1mKHUpO2ZvcihsZXQgZT0wO2U8PWQ7ZSsrKXt5WzBdPShTWzBdKihkLWUpK2tbMF0qZSkvZHwwO3lbMV09KFNbMV0qKGQtZSkra1sxXSplKS9kfDA7eVsyXT0oU1syXSooZC1lKStrWzJdKmUpL2R8MDt3WzBdPSh4WzBdKihkLWUpK0NbMF0qZSkvZHwwO3dbMV09KHhbMV0qKGQtZSkrQ1sxXSplKS9kfDA7d1syXT0oeFsyXSooZC1lKStDWzJdKmUpL2R8MDtmb3IobGV0IHQ9MDt0PD11O3QrKyxiKyspe2lmKCEoMCE9PWUmJmUhPT1kfHwwIT09dCYmdCE9PXUpKWNvbnRpbnVlO2xldCByPTAscz0wLG89MDtmb3IobGV0IG49MDtuPD0zO24rKylmb3IobGV0IGM9MDtjPD0zO2MrKyxvKyspe2NvbnN0IGw9dltlXVtuXSpGW3RdW2NdO3IrPWFbaVtvXV1bMF0qbDtzKz1hW2lbb11dWzFdKmx9cFtiXT1hLmxlbmd0aDthLnB1c2goW3Isc10pO21bYl09bi5sZW5ndGg7Y29uc3QgYz1uZXcgVWludDhBcnJheSgzKTtjWzBdPSh5WzBdKih1LXQpK3dbMF0qdCkvdXwwO2NbMV09KHlbMV0qKHUtdCkrd1sxXSp0KS91fDA7Y1syXT0oeVsyXSoodS10KSt3WzJdKnQpL3V8MDtuLnB1c2goYyl9fXBbMF09aVswXTttWzBdPXNbMF07cFt1XT1pWzNdO21bdV09c1sxXTtwW2cqZF09aVsxMl07bVtnKmRdPXNbMl07cFtnKmQrdV09aVsxNV07bVtnKmQrdV09c1szXTt0aGlzLmZpZ3VyZXNbZV09e3R5cGU6ImxhdHRpY2UiLGNvb3JkczpwLGNvbG9yczptLHZlcnRpY2VzUGVyUm93Omd9fV91cGRhdGVCb3VuZHMoKXtsZXQgZT10aGlzLmNvb3Jkc1swXVswXSx0PXRoaXMuY29vcmRzWzBdWzFdLGE9ZSxyPXQ7Zm9yKGxldCBuPTEsaT10aGlzLmNvb3Jkcy5sZW5ndGg7bjxpO24rKyl7Y29uc3QgaT10aGlzLmNvb3Jkc1tuXVswXSxzPXRoaXMuY29vcmRzW25dWzFdO2U9ZT5pP2k6ZTt0PXQ+cz9zOnQ7YT1hPGk/aTphO3I9cjxzP3M6cn10aGlzLmJvdW5kcz1bZSx0LGEscl19X3BhY2tEYXRhKCl7bGV0IGUsdCxhLHI7Y29uc3Qgbj10aGlzLmNvb3JkcyxpPW5ldyBGbG9hdDMyQXJyYXkoMipuLmxlbmd0aCk7Zm9yKGU9MCxhPTAsdD1uLmxlbmd0aDtlPHQ7ZSsrKXtjb25zdCB0PW5bZV07aVthKytdPXRbMF07aVthKytdPXRbMV19dGhpcy5jb29yZHM9aTtjb25zdCBzPXRoaXMuY29sb3JzLG89bmV3IFVpbnQ4QXJyYXkoMypzLmxlbmd0aCk7Zm9yKGU9MCxhPTAsdD1zLmxlbmd0aDtlPHQ7ZSsrKXtjb25zdCB0PXNbZV07b1thKytdPXRbMF07b1thKytdPXRbMV07b1thKytdPXRbMl19dGhpcy5jb2xvcnM9bztjb25zdCBjPXRoaXMuZmlndXJlcztmb3IoZT0wLHQ9Yy5sZW5ndGg7ZTx0O2UrKyl7Y29uc3QgdD1jW2VdLG49dC5jb29yZHMsaT10LmNvbG9ycztmb3IoYT0wLHI9bi5sZW5ndGg7YTxyO2ErKyl7blthXSo9MjtpW2FdKj0zfX19Z2V0SVIoKXtyZXR1cm5bIk1lc2giLHRoaXMuc2hhZGluZ1R5cGUsdGhpcy5jb29yZHMsdGhpcy5jb2xvcnMsdGhpcy5maWd1cmVzLHRoaXMuYm91bmRzLHRoaXMuYmJveCx0aGlzLmJhY2tncm91bmRdfX1jbGFzcyBEdW1teVNoYWRpbmcgZXh0ZW5kcyBCYXNlU2hhZGluZ3tnZXRJUigpe3JldHVyblsiRHVtbXkiXX19fSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuZ2V0WGZhRm9udERpY3Q9ZnVuY3Rpb24gZ2V0WGZhRm9udERpY3QoZSl7Y29uc3QgdD1mdW5jdGlvbiBnZXRYZmFGb250V2lkdGhzKGUpe2NvbnN0IHQ9Z2V0WGZhRm9udE5hbWUoZSk7aWYoIXQpcmV0dXJuIG51bGw7Y29uc3R7YmFzZVdpZHRoczphLGJhc2VNYXBwaW5nOnIsZmFjdG9yczpufT10O2xldCBpO2k9bj9hLm1hcCgoKGUsdCk9PmUqblt0XSkpOmE7bGV0IHMsbz0tMjtjb25zdCBjPVtdO2Zvcihjb25zdFtlLHRdb2Ygci5tYXAoKChlLHQpPT5bZSx0XSkpLnNvcnQoKChbZV0sW3RdKT0+ZS10KSkpaWYoLTEhPT1lKWlmKGU9PT1vKzEpe3MucHVzaChpW3RdKTtvKz0xfWVsc2V7bz1lO3M9W2lbdF1dO2MucHVzaChlLHMpfXJldHVybiBjfShlKSxhPW5ldyBuLkRpY3QobnVsbCk7YS5zZXQoIkJhc2VGb250IixuLk5hbWUuZ2V0KGUpKTthLnNldCgiVHlwZSIsbi5OYW1lLmdldCgiRm9udCIpKTthLnNldCgiU3VidHlwZSIsbi5OYW1lLmdldCgiQ0lERm9udFR5cGUyIikpO2Euc2V0KCJFbmNvZGluZyIsbi5OYW1lLmdldCgiSWRlbnRpdHktSCIpKTthLnNldCgiQ0lEVG9HSURNYXAiLG4uTmFtZS5nZXQoIklkZW50aXR5IikpO2Euc2V0KCJXIix0KTthLnNldCgiRmlyc3RDaGFyIix0WzBdKTthLnNldCgiTGFzdENoYXIiLHQuYXQoLTIpK3QuYXQoLTEpLmxlbmd0aC0xKTtjb25zdCByPW5ldyBuLkRpY3QobnVsbCk7YS5zZXQoIkZvbnREZXNjcmlwdG9yIixyKTtjb25zdCBpPW5ldyBuLkRpY3QobnVsbCk7aS5zZXQoIk9yZGVyaW5nIiwiSWRlbnRpdHkiKTtpLnNldCgiUmVnaXN0cnkiLCJBZG9iZSIpO2kuc2V0KCJTdXBwbGVtZW50IiwwKTthLnNldCgiQ0lEU3lzdGVtSW5mbyIsaSk7cmV0dXJuIGF9O3QuZ2V0WGZhRm9udE5hbWU9Z2V0WGZhRm9udE5hbWU7dmFyIHI9YSg1Miksbj1hKDUpLGk9YSg1Mykscz1hKDU0KSxvPWEoNTUpLGM9YSg1NiksbD1hKDYpLGg9YSgzOCk7Y29uc3QgdT0oMCxsLmdldExvb2t1cFRhYmxlRmFjdG9yeSkoKGZ1bmN0aW9uKGUpe2VbIk15cmlhZFByby1SZWd1bGFyIl09ZVsiUGRmSlMtRmFsbGJhY2stUmVndWxhciJdPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1SZWd1bGFyIixmYWN0b3JzOm8uTXlyaWFkUHJvUmVndWxhckZhY3RvcnMsYmFzZVdpZHRoczpzLkxpYmVyYXRpb25TYW5zUmVndWxhcldpZHRocyxiYXNlTWFwcGluZzpzLkxpYmVyYXRpb25TYW5zUmVndWxhck1hcHBpbmcsbWV0cmljczpvLk15cmlhZFByb1JlZ3VsYXJNZXRyaWNzfTtlWyJNeXJpYWRQcm8tQm9sZCJdPWVbIlBkZkpTLUZhbGxiYWNrLUJvbGQiXT17bmFtZToiTGliZXJhdGlvblNhbnMtQm9sZCIsZmFjdG9yczpvLk15cmlhZFByb0JvbGRGYWN0b3JzLGJhc2VXaWR0aHM6cy5MaWJlcmF0aW9uU2Fuc0JvbGRXaWR0aHMsYmFzZU1hcHBpbmc6cy5MaWJlcmF0aW9uU2Fuc0JvbGRNYXBwaW5nLG1ldHJpY3M6by5NeXJpYWRQcm9Cb2xkTWV0cmljc307ZVsiTXlyaWFkUHJvLUl0Il09ZVsiTXlyaWFkUHJvLUl0YWxpYyJdPWVbIlBkZkpTLUZhbGxiYWNrLUl0YWxpYyJdPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1JdGFsaWMiLGZhY3RvcnM6by5NeXJpYWRQcm9JdGFsaWNGYWN0b3JzLGJhc2VXaWR0aHM6cy5MaWJlcmF0aW9uU2Fuc0l0YWxpY1dpZHRocyxiYXNlTWFwcGluZzpzLkxpYmVyYXRpb25TYW5zSXRhbGljTWFwcGluZyxtZXRyaWNzOm8uTXlyaWFkUHJvSXRhbGljTWV0cmljc307ZVsiTXlyaWFkUHJvLUJvbGRJdCJdPWVbIk15cmlhZFByby1Cb2xkSXRhbGljIl09ZVsiUGRmSlMtRmFsbGJhY2stQm9sZEl0YWxpYyJdPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1Cb2xkSXRhbGljIixmYWN0b3JzOm8uTXlyaWFkUHJvQm9sZEl0YWxpY0ZhY3RvcnMsYmFzZVdpZHRoczpzLkxpYmVyYXRpb25TYW5zQm9sZEl0YWxpY1dpZHRocyxiYXNlTWFwcGluZzpzLkxpYmVyYXRpb25TYW5zQm9sZEl0YWxpY01hcHBpbmcsbWV0cmljczpvLk15cmlhZFByb0JvbGRJdGFsaWNNZXRyaWNzfTtlLkFyaWFsTVQ9ZS5BcmlhbD1lWyJBcmlhbC1SZWd1bGFyIl09e25hbWU6IkxpYmVyYXRpb25TYW5zLVJlZ3VsYXIiLGJhc2VXaWR0aHM6cy5MaWJlcmF0aW9uU2Fuc1JlZ3VsYXJXaWR0aHMsYmFzZU1hcHBpbmc6cy5MaWJlcmF0aW9uU2Fuc1JlZ3VsYXJNYXBwaW5nfTtlWyJBcmlhbC1Cb2xkTVQiXT1lWyJBcmlhbC1Cb2xkIl09e25hbWU6IkxpYmVyYXRpb25TYW5zLUJvbGQiLGJhc2VXaWR0aHM6cy5MaWJlcmF0aW9uU2Fuc0JvbGRXaWR0aHMsYmFzZU1hcHBpbmc6cy5MaWJlcmF0aW9uU2Fuc0JvbGRNYXBwaW5nfTtlWyJBcmlhbC1JdGFsaWNNVCJdPWVbIkFyaWFsLUl0YWxpYyJdPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1JdGFsaWMiLGJhc2VXaWR0aHM6cy5MaWJlcmF0aW9uU2Fuc0l0YWxpY1dpZHRocyxiYXNlTWFwcGluZzpzLkxpYmVyYXRpb25TYW5zSXRhbGljTWFwcGluZ307ZVsiQXJpYWwtQm9sZEl0YWxpY01UIl09ZVsiQXJpYWwtQm9sZEl0YWxpYyJdPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1Cb2xkSXRhbGljIixiYXNlV2lkdGhzOnMuTGliZXJhdGlvblNhbnNCb2xkSXRhbGljV2lkdGhzLGJhc2VNYXBwaW5nOnMuTGliZXJhdGlvblNhbnNCb2xkSXRhbGljTWFwcGluZ307ZVsiQ2FsaWJyaS1SZWd1bGFyIl09e25hbWU6IkxpYmVyYXRpb25TYW5zLVJlZ3VsYXIiLGZhY3RvcnM6ci5DYWxpYnJpUmVndWxhckZhY3RvcnMsYmFzZVdpZHRoczpzLkxpYmVyYXRpb25TYW5zUmVndWxhcldpZHRocyxiYXNlTWFwcGluZzpzLkxpYmVyYXRpb25TYW5zUmVndWxhck1hcHBpbmcsbWV0cmljczpyLkNhbGlicmlSZWd1bGFyTWV0cmljc307ZVsiQ2FsaWJyaS1Cb2xkIl09e25hbWU6IkxpYmVyYXRpb25TYW5zLUJvbGQiLGZhY3RvcnM6ci5DYWxpYnJpQm9sZEZhY3RvcnMsYmFzZVdpZHRoczpzLkxpYmVyYXRpb25TYW5zQm9sZFdpZHRocyxiYXNlTWFwcGluZzpzLkxpYmVyYXRpb25TYW5zQm9sZE1hcHBpbmcsbWV0cmljczpyLkNhbGlicmlCb2xkTWV0cmljc307ZVsiQ2FsaWJyaS1JdGFsaWMiXT17bmFtZToiTGliZXJhdGlvblNhbnMtSXRhbGljIixmYWN0b3JzOnIuQ2FsaWJyaUl0YWxpY0ZhY3RvcnMsYmFzZVdpZHRoczpzLkxpYmVyYXRpb25TYW5zSXRhbGljV2lkdGhzLGJhc2VNYXBwaW5nOnMuTGliZXJhdGlvblNhbnNJdGFsaWNNYXBwaW5nLG1ldHJpY3M6ci5DYWxpYnJpSXRhbGljTWV0cmljc307ZVsiQ2FsaWJyaS1Cb2xkSXRhbGljIl09e25hbWU6IkxpYmVyYXRpb25TYW5zLUJvbGRJdGFsaWMiLGZhY3RvcnM6ci5DYWxpYnJpQm9sZEl0YWxpY0ZhY3RvcnMsYmFzZVdpZHRoczpzLkxpYmVyYXRpb25TYW5zQm9sZEl0YWxpY1dpZHRocyxiYXNlTWFwcGluZzpzLkxpYmVyYXRpb25TYW5zQm9sZEl0YWxpY01hcHBpbmcsbWV0cmljczpyLkNhbGlicmlCb2xkSXRhbGljTWV0cmljc307ZVsiU2Vnb2V1aS1SZWd1bGFyIl09e25hbWU6IkxpYmVyYXRpb25TYW5zLVJlZ3VsYXIiLGZhY3RvcnM6Yy5TZWdvZXVpUmVndWxhckZhY3RvcnMsYmFzZVdpZHRoczpzLkxpYmVyYXRpb25TYW5zUmVndWxhcldpZHRocyxiYXNlTWFwcGluZzpzLkxpYmVyYXRpb25TYW5zUmVndWxhck1hcHBpbmcsbWV0cmljczpjLlNlZ29ldWlSZWd1bGFyTWV0cmljc307ZVsiU2Vnb2V1aS1Cb2xkIl09e25hbWU6IkxpYmVyYXRpb25TYW5zLUJvbGQiLGZhY3RvcnM6Yy5TZWdvZXVpQm9sZEZhY3RvcnMsYmFzZVdpZHRoczpzLkxpYmVyYXRpb25TYW5zQm9sZFdpZHRocyxiYXNlTWFwcGluZzpzLkxpYmVyYXRpb25TYW5zQm9sZE1hcHBpbmcsbWV0cmljczpjLlNlZ29ldWlCb2xkTWV0cmljc307ZVsiU2Vnb2V1aS1JdGFsaWMiXT17bmFtZToiTGliZXJhdGlvblNhbnMtSXRhbGljIixmYWN0b3JzOmMuU2Vnb2V1aUl0YWxpY0ZhY3RvcnMsYmFzZVdpZHRoczpzLkxpYmVyYXRpb25TYW5zSXRhbGljV2lkdGhzLGJhc2VNYXBwaW5nOnMuTGliZXJhdGlvblNhbnNJdGFsaWNNYXBwaW5nLG1ldHJpY3M6Yy5TZWdvZXVpSXRhbGljTWV0cmljc307ZVsiU2Vnb2V1aS1Cb2xkSXRhbGljIl09e25hbWU6IkxpYmVyYXRpb25TYW5zLUJvbGRJdGFsaWMiLGZhY3RvcnM6Yy5TZWdvZXVpQm9sZEl0YWxpY0ZhY3RvcnMsYmFzZVdpZHRoczpzLkxpYmVyYXRpb25TYW5zQm9sZEl0YWxpY1dpZHRocyxiYXNlTWFwcGluZzpzLkxpYmVyYXRpb25TYW5zQm9sZEl0YWxpY01hcHBpbmcsbWV0cmljczpjLlNlZ29ldWlCb2xkSXRhbGljTWV0cmljc307ZVsiSGVsdmV0aWNhLVJlZ3VsYXIiXT1lLkhlbHZldGljYT17bmFtZToiTGliZXJhdGlvblNhbnMtUmVndWxhciIsZmFjdG9yczppLkhlbHZldGljYVJlZ3VsYXJGYWN0b3JzLGJhc2VXaWR0aHM6cy5MaWJlcmF0aW9uU2Fuc1JlZ3VsYXJXaWR0aHMsYmFzZU1hcHBpbmc6cy5MaWJlcmF0aW9uU2Fuc1JlZ3VsYXJNYXBwaW5nLG1ldHJpY3M6aS5IZWx2ZXRpY2FSZWd1bGFyTWV0cmljc307ZVsiSGVsdmV0aWNhLUJvbGQiXT17bmFtZToiTGliZXJhdGlvblNhbnMtQm9sZCIsZmFjdG9yczppLkhlbHZldGljYUJvbGRGYWN0b3JzLGJhc2VXaWR0aHM6cy5MaWJlcmF0aW9uU2Fuc0JvbGRXaWR0aHMsYmFzZU1hcHBpbmc6cy5MaWJlcmF0aW9uU2Fuc0JvbGRNYXBwaW5nLG1ldHJpY3M6aS5IZWx2ZXRpY2FCb2xkTWV0cmljc307ZVsiSGVsdmV0aWNhLUl0YWxpYyJdPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1JdGFsaWMiLGZhY3RvcnM6aS5IZWx2ZXRpY2FJdGFsaWNGYWN0b3JzLGJhc2VXaWR0aHM6cy5MaWJlcmF0aW9uU2Fuc0l0YWxpY1dpZHRocyxiYXNlTWFwcGluZzpzLkxpYmVyYXRpb25TYW5zSXRhbGljTWFwcGluZyxtZXRyaWNzOmkuSGVsdmV0aWNhSXRhbGljTWV0cmljc307ZVsiSGVsdmV0aWNhLUJvbGRJdGFsaWMiXT17bmFtZToiTGliZXJhdGlvblNhbnMtQm9sZEl0YWxpYyIsZmFjdG9yczppLkhlbHZldGljYUJvbGRJdGFsaWNGYWN0b3JzLGJhc2VXaWR0aHM6cy5MaWJlcmF0aW9uU2Fuc0JvbGRJdGFsaWNXaWR0aHMsYmFzZU1hcHBpbmc6cy5MaWJlcmF0aW9uU2Fuc0JvbGRJdGFsaWNNYXBwaW5nLG1ldHJpY3M6aS5IZWx2ZXRpY2FCb2xkSXRhbGljTWV0cmljc319KSk7ZnVuY3Rpb24gZ2V0WGZhRm9udE5hbWUoZSl7Y29uc3QgdD0oMCxoLm5vcm1hbGl6ZUZvbnROYW1lKShlKTtyZXR1cm4gdSgpW3RdfX0sKGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5DYWxpYnJpUmVndWxhck1ldHJpY3M9dC5DYWxpYnJpUmVndWxhckZhY3RvcnM9dC5DYWxpYnJpSXRhbGljTWV0cmljcz10LkNhbGlicmlJdGFsaWNGYWN0b3JzPXQuQ2FsaWJyaUJvbGRNZXRyaWNzPXQuQ2FsaWJyaUJvbGRJdGFsaWNNZXRyaWNzPXQuQ2FsaWJyaUJvbGRJdGFsaWNGYWN0b3JzPXQuQ2FsaWJyaUJvbGRGYWN0b3JzPXZvaWQgMDt0LkNhbGlicmlCb2xkRmFjdG9ycz1bMS4zODc3LDEsMSwxLC45NzgwMSwuOTI0ODIsLjg5NTUyLC45MTEzMywuODE5ODgsLjk3NTY2LC45ODE1MiwuOTM1NDgsLjkzNTQ4LDEuMjc5OCwuODUyODQsLjkyNzk0LDEsLjk2MTM0LDEuNTQ2NTcsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC44Mjg0NSwuODI4NDUsLjg1Mjg0LC44NTI4NCwuODUyODQsLjc1ODU5LC45MjEzOCwuODM5MDgsLjc3NjIsLjczMjkzLC44NzI4OSwuNzMxMzMsLjc1MTQsLjgxOTIxLC44NzM1NiwuOTU5NTgsLjU5NTI2LC43NTcyNywuNjkyMjUsMS4wNDkyNCwuOTEyMSwuODY5NDMsLjc5Nzk1LC44ODE5OCwuNzc5NTgsLjcwODY0LC44MTA1NSwuOTAzOTksLjg4NjUzLC45NjAxNywuODI1NzcsLjc3ODkyLC43ODI1NywuOTc1MDcsMS41NDY1NywuOTc1MDcsLjg1Mjg0LC44OTU1MiwuOTAxNzYsLjg4NzYyLC44Nzg1LC43NTI0MSwuODc4NSwuOTA1MTgsLjk1MDE1LC43NzYxOCwuODc4NSwuODg0MDEsLjkxOTE2LC44NjMwNCwuODg0MDEsLjkxNDg4LC44Nzg1LC44ODAxLC44Nzg1LC44Nzg1LC45MTM0MywuNzE3MywxLjA0MTA2LC44Nzg1LC44NTA3NSwuOTU3OTQsLjgyNjE2LC44NTE2MiwuNzk0OTIsLjg4MzMxLDEuNjk4MDgsLjg4MzMxLC44NTI4NCwuOTc4MDEsLjg5NTUyLC45MTEzMywuODk1NTIsLjkxMTMzLDEuNzgwMSwuODk1NTIsMS4yNDQ4NywxLjEzMjU0LDEuMTI0MDEsLjk2ODM5LC44NTI4NCwuNjg3ODcsLjcwNjQ1LC44NTU5MiwuOTA3NDcsMS4wMTQ2NiwxLjAwODgsLjkwMzIzLDEsMS4wNzQ2MywxLC45MTA1NiwuNzU4MDYsMS4xOTExOCwuOTY4MzksLjc4ODY0LC44Mjg0NSwuODQxMzMsLjc1ODU5LC44MzkwOCwuODM5MDgsLjgzOTA4LC44MzkwOCwuODM5MDgsLjgzOTA4LC43NzUzOSwuNzMyOTMsLjczMTMzLC43MzEzMywuNzMxMzMsLjczMTMzLC45NTk1OCwuOTU5NTgsLjk1OTU4LC45NTk1OCwuODg1MDYsLjkxMjEsLjg2OTQzLC44Njk0MywuODY5NDMsLjg2OTQzLC44Njk0MywuODUyODQsLjg3NTA4LC45MDM5OSwuOTAzOTksLjkwMzk5LC45MDM5OSwuNzc4OTIsLjc5Nzk1LC45MDgwNywuODg3NjIsLjg4NzYyLC44ODc2MiwuODg3NjIsLjg4NzYyLC44ODc2MiwuODcxNSwuNzUyNDEsLjkwNTE4LC45MDUxOCwuOTA1MTgsLjkwNTE4LC44ODQwMSwuODg0MDEsLjg4NDAxLC44ODQwMSwuODc4NSwuODc4NSwuODgwMSwuODgwMSwuODgwMSwuODgwMSwuODgwMSwuOTA3NDcsLjg5MDQ5LC44Nzg1LC44Nzg1LC44Nzg1LC44Nzg1LC44NTE2MiwuODc4NSwuODUxNjIsLjgzOTA4LC44ODc2MiwuODM5MDgsLjg4NzYyLC44MzkwOCwuODg3NjIsLjczMjkzLC43NTI0MSwuNzMyOTMsLjc1MjQxLC43MzI5MywuNzUyNDEsLjczMjkzLC43NTI0MSwuODcyODksLjgzMDE2LC44ODUwNiwuOTMxMjUsLjczMTMzLC45MDUxOCwuNzMxMzMsLjkwNTE4LC43MzEzMywuOTA1MTgsLjczMTMzLC45MDUxOCwuNzMxMzMsLjkwNTE4LC44MTkyMSwuNzc2MTgsLjgxOTIxLC43NzYxOCwuODE5MjEsLjc3NjE4LDEsMSwuODczNTYsLjg3ODUsLjkxMDc1LC44OTYwOCwuOTU5NTgsLjg4NDAxLC45NTk1OCwuODg0MDEsLjk1OTU4LC44ODQwMSwuOTU5NTgsLjg4NDAxLC45NTk1OCwuODg0MDEsLjc2MjI5LC45MDE2NywuNTk1MjYsLjkxOTE2LDEsMSwuODYzMDQsLjY5MjI1LC44ODQwMSwxLDEsLjcwNDI0LC43OTQ2OCwuOTE5MjYsLjg4MTc1LC43MDgyMywuOTQ5MDMsLjkxMjEsLjg3ODUsMSwxLC45MTIxLC44Nzg1LC44NzgwMiwuODg2NTYsLjg3ODUsLjg2OTQzLC44ODAxLC44Njk0MywuODgwMSwuODY5NDMsLjg4MDEsLjg3NDAyLC44OTI5MSwuNzc5NTgsLjkxMzQzLDEsMSwuNzc5NTgsLjkxMzQzLC43MDg2NCwuNzE3MywuNzA4NjQsLjcxNzMsLjcwODY0LC43MTczLC43MDg2NCwuNzE3MywxLDEsLjgxMDU1LC43NTg0MSwuODEwNTUsMS4wNjQ1MiwuOTAzOTksLjg3ODUsLjkwMzk5LC44Nzg1LC45MDM5OSwuODc4NSwuOTAzOTksLjg3ODUsLjkwMzk5LC44Nzg1LC45MDM5OSwuODc4NSwuOTYwMTcsLjk1Nzk0LC43Nzg5MiwuODUxNjIsLjc3ODkyLC43ODI1NywuNzk0OTIsLjc4MjU3LC43OTQ5MiwuNzgyNTcsLjc5NDkyLC45Mjk3LC41Njg5MiwuODM5MDgsLjg4NzYyLC43NzUzOSwuODcxNSwuODc1MDgsLjg5MDQ5LDEsMSwuODEwNTUsMS4wNDEwNiwxLjIwNTI4LDEuMjA1MjgsMSwxLjE1NTQzLC43MDY3NCwuOTgzODcsLjk0NzIxLDEuMzM0MzEsMS40NTg5NCwuOTUxNjEsMS4wNjMwMywuODM5MDgsLjgwMzUyLC41NzE4NCwuNjk2NSwuNTYyODksLjgyMDAxLC41NjAyOSwuODEyMzUsMS4wMjk4OCwuODM5MDgsLjc3NjIsLjY4MTU2LC44MDM2NywuNzMxMzMsLjc4MjU3LC44NzM1NiwuODY5NDMsLjk1OTU4LC43NTcyNywuODkwMTksMS4wNDkyNCwuOTEyMSwuNzY0OCwuODY5NDMsLjg3MzU2LC43OTc5NSwuNzgyNzUsLjgxMDU1LC43Nzg5MiwuOTc2MiwuODI1NzcsLjk5ODE5LC44NDg5NiwuOTU5NTgsLjc3ODkyLC45NjEwOCwxLjAxNDA3LC44OTA0OSwxLjAyOTg4LC45NDIxMSwuOTYxMDgsLjg5MzYsLjg0MDIxLC44Nzg0MiwuOTYzOTksLjc5MTA5LC44OTA0OSwxLjAwODEzLDEuMDI5ODgsLjg2MDc3LC44NzQ0NSwuOTIwOTksLjg0NzIzLC44NjUxMywuODgwMSwuNzU2MzgsLjg1NzE0LC43ODIxNiwuNzk1ODYsLjg3OTY1LC45NDIxMSwuOTc3NDcsLjc4Mjg3LC45NzkyNiwuODQ5NzEsMS4wMjk4OCwuOTQyMTEsLjg4MDEsLjk0MjExLC44NDk3MSwuNzMxMzMsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjkwMjY0LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC45MDUxOCwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTA1NDgsMSwxLDEsMSwxLDEsLjk2MDE3LC45NTc5NCwuOTYwMTcsLjk1Nzk0LC45NjAxNywuOTU3OTQsLjc3ODkyLC44NTE2MiwxLDEsLjg5NTUyLC45MDUyNywxLC45MDM2MywuOTI3OTQsLjkyNzk0LC45Mjc5NCwuOTI3OTQsLjg3MDEyLC44NzAxMiwuODcwMTIsLjg5NTUyLC44OTU1MiwxLjQyMjU5LC43MTE0MywxLjA2MTUyLDEsMSwxLjAzMzcyLDEuMDMzNzIsLjk3MTcxLDEuNDk1NiwyLjI4MDcsLjkzODM1LC44MzQwNiwuOTExMzMsLjg0MTA3LC45MTEzMywxLDEsMSwuNzIwMjEsMSwxLjIzMTA4LC44MzQ4OSwuODg1MjUsLjg4NTI1LC44MTQ5OSwuOTA1MjcsMS44MTA1NSwuOTA1MjcsMS44MTA1NSwxLjMxMDA2LDEuNTM3MTEsLjk0NDM0LDEuMDg2OTYsMSwuOTUwMTgsLjc3MTkyLC44NTI4NCwuOTA3NDcsMS4xNzUzNCwuNjk4MjUsLjk3MTYsMS4zNzA3NywuOTA3NDcsLjkwNzQ3LC44NTM1NiwuOTA3NDcsLjkwNzQ3LDEuNDQ5NDcsLjg1Mjg0LC44OTQxLC44OTQxLC43MDU3MiwuOCwuNzA1NzIsLjcwNTcyLC43MDU3MiwuNzA1NzIsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC45OTg2MiwuOTk4NjIsMSwxLDEsMSwxLDEuMDgwMDQsLjkxMDI3LDEsMSwxLC45OTg2MiwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTA3MjcsLjkwNzI3LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxXTt0LkNhbGlicmlCb2xkTWV0cmljcz17bGluZUhlaWdodDoxLjIyMDcsbGluZUdhcDouMjIwN307dC5DYWxpYnJpQm9sZEl0YWxpY0ZhY3RvcnM9WzEuMzg3NywxLDEsMSwuOTc4MDEsLjkyNDgyLC44OTU1MiwuOTExMzMsLjgxOTg4LC45NzU2NiwuOTgxNTIsLjkzNTQ4LC45MzU0OCwxLjI3OTgsLjg1Mjg0LC45Mjc5NCwxLC45NjEzNCwxLjU2MjM5LC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuODI4NDUsLjgyODQ1LC44NTI4NCwuODUyODQsLjg1Mjg0LC43NTg1OSwuOTIxMzgsLjgzOTA4LC43NzYyLC43MTgwNSwuODcyODksLjczMTMzLC43NTE0LC44MTkyMSwuODczNTYsLjk1OTU4LC41OTUyNiwuNzU3MjcsLjY5MjI1LDEuMDQ5MjQsLjkwODcyLC44NTkzOCwuNzk3OTUsLjg3MDY4LC43Nzk1OCwuNjk3NjYsLjgxMDU1LC45MDM5OSwuODg2NTMsLjk2MDY4LC44MjU3NywuNzc4OTIsLjc4MjU3LC45NzUwNywxLjUyOSwuOTc1MDcsLjg1Mjg0LC44OTU1MiwuOTAxNzYsLjk0OTA4LC44NjQxMSwuNzQwMTIsLjg2NDExLC44ODMyMywuOTUwMTUsLjg2NDExLC44NjMzMSwuODg0MDEsLjkxOTE2LC44NjMwNCwuODg0MDEsLjkwMzksLjg2MzMxLC44NjMzMSwuODY0MTEsLjg2NDExLC45MDQ2NCwuNzA4NTIsMS4wNDEwNiwuODYzMzEsLjg0MzcyLC45NTc5NCwuODI2MTYsLjg0NTQ4LC43OTQ5MiwuODgzMzEsMS42OTgwOCwuODgzMzEsLjg1Mjg0LC45NzgwMSwuODk1NTIsLjkxMTMzLC44OTU1MiwuOTExMzMsMS43ODAxLC44OTU1MiwxLjI0NDg3LDEuMTMyNTQsMS4xOTEyOSwuOTY4MzksLjg1Mjg0LC42ODc4NywuNzA2NDUsLjg1NTkyLC45MDc0NywxLjAxNDY2LDEuMDA4OCwuOTAzMjMsMSwxLjA3NDYzLDEsLjkxMDU2LC43NTgwNiwxLjE5MTE4LC45NjgzOSwuNzg4NjQsLjgyODQ1LC44NDEzMywuNzU4NTksLjgzOTA4LC44MzkwOCwuODM5MDgsLjgzOTA4LC44MzkwOCwuODM5MDgsLjc3NTM5LC43MTgwNSwuNzMxMzMsLjczMTMzLC43MzEzMywuNzMxMzMsLjk1OTU4LC45NTk1OCwuOTU5NTgsLjk1OTU4LC44ODUwNiwuOTA4NzIsLjg1OTM4LC44NTkzOCwuODU5MzgsLjg1OTM4LC44NTkzOCwuODUyODQsLjg3MDY4LC45MDM5OSwuOTAzOTksLjkwMzk5LC45MDM5OSwuNzc4OTIsLjc5Nzk1LC45MDgwNywuOTQ5MDgsLjk0OTA4LC45NDkwOCwuOTQ5MDgsLjk0OTA4LC45NDkwOCwuODU4ODcsLjc0MDEyLC44ODMyMywuODgzMjMsLjg4MzIzLC44ODMyMywuODg0MDEsLjg4NDAxLC44ODQwMSwuODg0MDEsLjg3ODUsLjg2MzMxLC44NjMzMSwuODYzMzEsLjg2MzMxLC44NjMzMSwuODYzMzEsLjkwNzQ3LC44OTA0OSwuODYzMzEsLjg2MzMxLC44NjMzMSwuODYzMzEsLjg0NTQ4LC44NjQxMSwuODQ1NDgsLjgzOTA4LC45NDkwOCwuODM5MDgsLjk0OTA4LC44MzkwOCwuOTQ5MDgsLjcxODA1LC43NDAxMiwuNzE4MDUsLjc0MDEyLC43MTgwNSwuNzQwMTIsLjcxODA1LC43NDAxMiwuODcyODksLjc5NTM4LC44ODUwNiwuOTI3MjYsLjczMTMzLC44ODMyMywuNzMxMzMsLjg4MzIzLC43MzEzMywuODgzMjMsLjczMTMzLC44ODMyMywuNzMxMzMsLjg4MzIzLC44MTkyMSwuODY0MTEsLjgxOTIxLC44NjQxMSwuODE5MjEsLjg2NDExLDEsMSwuODczNTYsLjg2MzMxLC45MTA3NSwuODc3NywuOTU5NTgsLjg4NDAxLC45NTk1OCwuODg0MDEsLjk1OTU4LC44ODQwMSwuOTU5NTgsLjg4NDAxLC45NTk1OCwuODg0MDEsLjc2NDY3LC45MDE2NywuNTk1MjYsLjkxOTE2LDEsMSwuODYzMDQsLjY5MjI1LC44ODQwMSwxLDEsLjcwNDI0LC43NzMxMiwuOTE5MjYsLjg4MTc1LC43MDgyMywuOTQ5MDMsLjkwODcyLC44NjMzMSwxLDEsLjkwODcyLC44NjMzMSwuODY5MDYsLjg4MTE2LC44NjMzMSwuODU5MzgsLjg2MzMxLC44NTkzOCwuODYzMzEsLjg1OTM4LC44NjMzMSwuODc0MDIsLjg2NTQ5LC43Nzk1OCwuOTA0NjQsMSwxLC43Nzk1OCwuOTA0NjQsLjY5NzY2LC43MDg1MiwuNjk3NjYsLjcwODUyLC42OTc2NiwuNzA4NTIsLjY5NzY2LC43MDg1MiwxLDEsLjgxMDU1LC43NTg0MSwuODEwNTUsMS4wNjQ1MiwuOTAzOTksLjg2MzMxLC45MDM5OSwuODYzMzEsLjkwMzk5LC44NjMzMSwuOTAzOTksLjg2MzMxLC45MDM5OSwuODYzMzEsLjkwMzk5LC44NjMzMSwuOTYwNjgsLjk1Nzk0LC43Nzg5MiwuODQ1NDgsLjc3ODkyLC43ODI1NywuNzk0OTIsLjc4MjU3LC43OTQ5MiwuNzgyNTcsLjc5NDkyLC45Mjk3LC41Njg5MiwuODM5MDgsLjk0OTA4LC43NzUzOSwuODU4ODcsLjg3MDY4LC44OTA0OSwxLDEsLjgxMDU1LDEuMDQxMDYsMS4yMDUyOCwxLjIwNTI4LDEsMS4xNTU0MywuNzAwODgsLjk4Mzg3LC45NDcyMSwxLjMzNDMxLDEuNDU4OTQsLjk1MTYxLDEuNDgzODcsLjgzOTA4LC44MDM1MiwuNTcxMTgsLjY5NjUsLjU2MzQ3LC43OTE3OSwuNTU4NTMsLjgwMzQ2LDEuMDI5ODgsLjgzOTA4LC43NzYyLC42NzE3NCwuODYwMzYsLjczMTMzLC43ODI1NywuODczNTYsLjg2NDQxLC45NTk1OCwuNzU3MjcsLjg5MDE5LDEuMDQ5MjQsLjkwODcyLC43NDg4OSwuODU5MzgsLjg3ODkxLC43OTc5NSwuNzk1NywuODEwNTUsLjc3ODkyLC45NzQ0NywuODI1NzcsLjk3NDY2LC44NzE3OSwuOTU5NTgsLjc3ODkyLC45NDI1MiwuOTU2MTIsLjg3NTMsMS4wMjk4OCwuOTI3MzMsLjk0MjUyLC44NzQxMSwuODQwMjEsLjg3MjgsLjk1NjEyLC43NDA4MSwuODc1MywxLjAyMTg5LDEuMDI5ODgsLjg0ODE0LC44NzQ0NSwuOTE4MjIsLjg0NzIzLC44NTY2OCwuODYzMzEsLjgxMzQ0LC44NzU4MSwuNzY0MjIsLjgyMDQ2LC45NjA1NywuOTI3MzMsLjk5Mzc1LC43ODAyMiwuOTU0NTIsLjg2MDE1LDEuMDI5ODgsLjkyNzMzLC44NjMzMSwuOTI3MzMsLjg2MDE1LC43MzEzMywxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTA2MzEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjg4MzIzLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC44NTE3NCwxLDEsMSwxLDEsMSwuOTYwNjgsLjk1Nzk0LC45NjA2OCwuOTU3OTQsLjk2MDY4LC45NTc5NCwuNzc4OTIsLjg0NTQ4LDEsMSwuODk1NTIsLjkwNTI3LDEsLjkwMzYzLC45Mjc5NCwuOTI3OTQsLjkyNzk0LC44OTgwNywuODcwMTIsLjg3MDEyLC44NzAxMiwuODk1NTIsLjg5NTUyLDEuNDIyNTksLjcxMDk0LDEuMDYxNTIsMSwxLDEuMDMzNzIsMS4wMzM3MiwuOTcxNzEsMS40OTU2LDIuMjgwNywuOTI5NzIsLjgzNDA2LC45MTEzMywuODMzMjYsLjkxMTMzLDEsMSwxLC43MjAyMSwxLDEuMjMxMDgsLjgzNDg5LC44ODUyNSwuODg1MjUsLjgxNDk5LC45MDYxNiwxLjgxMDU1LC45MDUyNywxLjgxMDU1LDEuMzEwNywxLjUzNzExLC45NDQzNCwxLjA4Njk2LDEsLjk1MDE4LC43NzE5MiwuODUyODQsLjkwNzQ3LDEuMTc1MzQsLjY5ODI1LC45NzE2LDEuMzcwNzcsLjkwNzQ3LC45MDc0NywuODUzNTYsLjkwNzQ3LC45MDc0NywxLjQ0OTQ3LC44NTI4NCwuODk0MSwuODk0MSwuNzA1NzIsLjgsLjcwNTcyLC43MDU3MiwuNzA1NzIsLjcwNTcyLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTk4NjIsLjk5ODYyLDEsMSwxLDEsMSwxLjA4MDA0LC45MTAyNywxLDEsMSwuOTk4NjIsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjkwNzI3LC45MDcyNywxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMV07dC5DYWxpYnJpQm9sZEl0YWxpY01ldHJpY3M9e2xpbmVIZWlnaHQ6MS4yMjA3LGxpbmVHYXA6LjIyMDd9O3QuQ2FsaWJyaUl0YWxpY0ZhY3RvcnM9WzEuMzg3NywxLDEsMSwxLjE3MjIzLDEuMTI5MywuODk1NTIsLjkxMTMzLC44MDM5NSwxLjAyMjY5LDEuMTU2MDEsLjkxMDU2LC45MTA1NiwxLjI3OTgsLjg1Mjg0LC44OTgwNywxLC45MDg2MSwxLjM5NTQzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTYzMDksLjk2MzA5LC44NTI4NCwuODUyODQsLjg1Mjg0LC44MzMxOSwuODgwNzEsLjg2NzUsLjgxNTUyLC43MjM0NiwuODUxOTMsLjczMjA2LC43NTIyLC44MTEwNSwuODYyNzUsLjkwNjg1LC42Mzc3LC43Nzg5MiwuNzU1OTMsMS4wMjYzOCwuODkyNDksLjg0MTE4LC43NzQ1MiwuODUzNzQsLjc1MTg2LC42Nzc4OSwuNzk3NzYsLjg4ODQ0LC44NTA2NiwuOTQzMDksLjc3ODE4LC43MzA2LC43NjY1OSwxLjEwMzY5LDEuMzgzMTMsMS4xMDM2OSwxLjA2MTM5LC44OTU1MiwuODczOSwuOTI0NSwuOTI0NSwuODMyMDMsLjkyNDUsLjg1ODY1LDEuMDk4NDIsLjkyNDUsLjkyNDUsMS4wMzI5NywxLjA3NjkyLC45MDkxOCwxLjAzMjk3LC45NDk1OSwuOTI0NSwuOTIyNzQsLjkyNDUsLjkyNDUsMS4wMjkzMywuNzc4MzIsMS4yMDU2MiwuOTI0NSwuODkxNiwuOTg5ODYsLjg2NjIxLC44OTQ1MywuNzkwMDQsLjk0MTUyLDEuNzcyNTYsLjk0MTUyLC44NTI4NCwuOTc4MDEsLjg5NTUyLC45MTEzMywuODk1NTIsLjkxMTMzLDEuOTE3MjksLjg5NTUyLDEuMTc4ODksMS4xMzI1NCwxLjE2MzU5LC45MjA5OCwuODUyODQsLjY4Nzg3LC43MTM1MywuODQ3MzcsLjkwNzQ3LDEuMDA4OCwxLjAwNDQsLjg3NjgzLDEsMS4wOTA5MSwxLC45MjIyOSwuNzM5LDEuMTU2NDIsLjkyMDk4LC43NjI4OCwuODA1MDQsLjgwOTcyLC43NTg1OSwuODY3NSwuODY3NSwuODY3NSwuODY3NSwuODY3NSwuODY3NSwuNzYzMTgsLjcyMzQ2LC43MzIwNiwuNzMyMDYsLjczMjA2LC43MzIwNiwuOTA2ODUsLjkwNjg1LC45MDY4NSwuOTA2ODUsLjg2NDc3LC44OTI0OSwuODQxMTgsLjg0MTE4LC44NDExOCwuODQxMTgsLjg0MTE4LC44NTI4NCwuODQ1NTcsLjg4ODQ0LC44ODg0NCwuODg4NDQsLjg4ODQ0LC43MzA2LC43NzQ1MiwuODYzMzEsLjkyNDUsLjkyNDUsLjkyNDUsLjkyNDUsLjkyNDUsLjkyNDUsLjg0ODQzLC44MzIwMywuODU4NjUsLjg1ODY1LC44NTg2NSwuODU4NjUsLjgyNjAxLC44MjYwMSwuODI2MDEsLjgyNjAxLC45NDQ2OSwuOTI0NSwuOTIyNzQsLjkyMjc0LC45MjI3NCwuOTIyNzQsLjkyMjc0LC45MDc0NywuODY2NTEsLjkyNDUsLjkyNDUsLjkyNDUsLjkyNDUsLjg5NDUzLC45MjQ1LC44OTQ1MywuODY3NSwuOTI0NSwuODY3NSwuOTI0NSwuODY3NSwuOTI0NSwuNzIzNDYsLjgzMjAzLC43MjM0NiwuODMyMDMsLjcyMzQ2LC44MzIwMywuNzIzNDYsLjgzMjAzLC44NTE5MywuODg3NSwuODY0NzcsLjk5MDM0LC43MzIwNiwuODU4NjUsLjczMjA2LC44NTg2NSwuNzMyMDYsLjg1ODY1LC43MzIwNiwuODU4NjUsLjczMjA2LC44NTg2NSwuODExMDUsLjkyNDUsLjgxMTA1LC45MjQ1LC44MTEwNSwuOTI0NSwxLDEsLjg2Mjc1LC45MjQ1LC45MDg3MiwuOTM1OTEsLjkwNjg1LC44MjYwMSwuOTA2ODUsLjgyNjAxLC45MDY4NSwuODI2MDEsLjkwNjg1LDEuMDMyOTcsLjkwNjg1LC44MjYwMSwuNzc4OTYsMS4wNTYxMSwuNjM3NywxLjA3NjkyLDEsMSwuOTA5MTgsLjc1NTkzLDEuMDMyOTcsMSwxLC43NjAzMiwuOTM3NSwuOTgxNTYsLjkzNDA3LC43NzI2MSwxLjExNDI5LC44OTI0OSwuOTI0NSwxLDEsLjg5MjQ5LC45MjQ1LC45MjUzNCwuODY2OTgsLjkyNDUsLjg0MTE4LC45MjI3NCwuODQxMTgsLjkyMjc0LC44NDExOCwuOTIyNzQsLjg2NjcsLjg2MjkxLC43NTE4NiwxLjAyOTMzLDEsMSwuNzUxODYsMS4wMjkzMywuNjc3ODksLjc3ODMyLC42Nzc4OSwuNzc4MzIsLjY3Nzg5LC43NzgzMiwuNjc3ODksLjc3ODMyLDEsMSwuNzk3NzYsLjk3NjU1LC43OTc3NiwxLjIzMDIzLC44ODg0NCwuOTI0NSwuODg4NDQsLjkyNDUsLjg4ODQ0LC45MjQ1LC44ODg0NCwuOTI0NSwuODg4NDQsLjkyNDUsLjg4ODQ0LC45MjQ1LC45NDMwOSwuOTg5ODYsLjczMDYsLjg5NDUzLC43MzA2LC43NjY1OSwuNzkwMDQsLjc2NjU5LC43OTAwNCwuNzY2NTksLjc5MDA0LDEuMDkyMzEsLjU0ODczLC44Njc1LC45MjQ1LC43NjMxOCwuODQ4NDMsLjg0NTU3LC44NjY1MSwxLDEsLjc5Nzc2LDEuMjA1NjIsMS4xODYyMiwxLjE4NjIyLDEsMS4xNDM3LC42NzAwOSwuOTYzMzQsLjkzNjk1LDEuMzUxOTEsMS40MDkwOSwuOTUxNjEsMS40ODM4NywuODY3NSwuOTA4NjEsLjYxOTIsLjczNjMsLjY0ODI0LC44MjQxMSwuNTYzMjEsLjg1Njk2LDEuMjM1MTYsLjg2NzUsLjgxNTUyLC43Mjg2LC44NDEzNCwuNzMyMDYsLjc2NjU5LC44NjI3NSwuODQzNjksLjkwNjg1LC43Nzg5MiwuODU4NzEsMS4wMjYzOCwuODkyNDksLjc1ODI4LC44NDExOCwuODU5ODQsLjc3NDUyLC43NjQ2NiwuNzk3NzYsLjczMDYsLjkwNzgyLC43NzgxOCwuOTAzLC44NzI5MSwuOTA2ODUsLjczMDYsLjk5MDU4LDEuMDM2NjcsLjk0NjM1LDEuMjM1MTYsLjk4NDksLjk5MDU4LC45MjM5MywuODkxNiwuOTQyLDEuMDM2NjcsLjc1MDI2LC45NDYzNSwxLjAyOTcsMS4yMzUxNiwuOTA5MTgsLjk0MDQ4LC45ODIxNywuODk3NDYsLjg0MTUzLC45MjI3NCwuODI1MDcsLjg4ODMyLC44NDQzOCwuODgxNzgsMS4wMzUyNSwuOTg0OSwxLjAwMjI1LC43ODA4NiwuOTcyNDgsLjg5NDA0LDEuMjM1MTYsLjk4NDksLjkyMjc0LC45ODQ5LC44OTQwNCwuNzMyMDYsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjg5NjkzLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC44NTg2NSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTA5MzMsMSwxLDEsMSwxLDEsLjk0MzA5LC45ODk4NiwuOTQzMDksLjk4OTg2LC45NDMwOSwuOTg5ODYsLjczMDYsLjg5NDUzLDEsMSwuODk1NTIsLjkwNTI3LDEsLjkwMTg2LDEuMTIzMDgsMS4xMjMwOCwxLjEyMzA4LDEuMTIzMDgsMS4yNTY2LDEuMjU2NiwxLjI1NjYsLjg5NTUyLC44OTU1MiwxLjQyMjU5LC42ODk5NCwxLjAzODA5LDEsMSwxLjAxNzYsMS4wMTc2LDEuMTE1MjMsMS40OTU2LDIuMDE0NjIsLjk3ODU4LC44MjYxNiwuOTExMzMsLjgzNDM3LC45MTEzMywxLDEsMSwuNzA1MDgsMSwxLjIzMTA4LC43OTgwMSwuODQ0MjYsLjg0NDI2LC43NzQsLjkwNTcyLDEuODEwNTUsLjkwNzQ5LDEuODEwNTUsMS4yODgwOSwxLjU1NDY5LC45NDQzNCwxLjA3ODA2LDEsLjk3MDk0LC43NTg5LC44NTI4NCwuOTA3NDcsMS4xOTY1OCwuNjk4MjUsLjk3NjIyLDEuMzM1MTIsLjkwNzQ3LC45MDc0NywuODUyODQsLjkwNzQ3LC45MDc0NywxLjQ0OTQ3LC44NTI4NCwuODk0MSwuODk0MSwuNzA1NzIsLjgsLjcwNTcyLC43MDU3MiwuNzA1NzIsLjcwNTcyLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTk4NjIsLjk5ODYyLDEsMSwxLDEsMSwxLjAzMzYsLjkxMDI3LDEsMSwxLC45OTg2MiwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLjA1ODU5LDEuMDU4NTksMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDFdO3QuQ2FsaWJyaUl0YWxpY01ldHJpY3M9e2xpbmVIZWlnaHQ6MS4yMjA3LGxpbmVHYXA6LjIyMDd9O3QuQ2FsaWJyaVJlZ3VsYXJGYWN0b3JzPVsxLjM4NzcsMSwxLDEsMS4xNzIyMywxLjEyOTMsLjg5NTUyLC45MTEzMywuODAzOTUsMS4wMjI2OSwxLjE1NjAxLC45MTA1NiwuOTEwNTYsMS4yNzk4LC44NTI4NCwuODk4MDcsMSwuOTA4NjEsMS4zOTAxNiwuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjk2MzA5LC45NjMwOSwuODUyODQsLjg1Mjg0LC44NTI4NCwuODMzMTksLjg4MDcxLC44Njc1LC44MTU1MiwuNzM4MzQsLjg1MTkzLC43MzIwNiwuNzUyMiwuODExMDUsLjg2Mjc1LC45MDY4NSwuNjM3NywuNzc4OTIsLjc1NTkzLDEuMDI2MzgsLjg5Mzg1LC44NTEyMiwuNzc0NTIsLjg2NTAzLC43NTE4NiwuNjg4ODcsLjc5Nzc2LC44ODg0NCwuODUwNjYsLjk0MjU4LC43NzgxOCwuNzMwNiwuNzY2NTksMS4xMDM2OSwxLjM5MDE2LDEuMTAzNjksMS4wNjEzOSwuODk1NTIsLjg3MzksLjg2MTI4LC45NDQ2OSwuODQ1NywuOTQ0NjksLjg5NDY0LDEuMDk4NDIsLjg0NjM2LC45NDQ2OSwxLjAzMjk3LDEuMDc2OTIsLjkwOTE4LDEuMDMyOTcsLjk1ODk3LC45NDQ2OSwuOTQ4MiwuOTQ0NjksLjk0NDY5LDEuMDQ2OTIsLjc4MjIzLDEuMjA1NjIsLjk0NDY5LC45MDMzMiwuOTg5ODYsLjg2NjIxLC45MDUyNywuNzkwMDQsLjk0MTUyLDEuNzcyNTYsLjk0MTUyLC44NTI4NCwuOTc4MDEsLjg5NTUyLC45MTEzMywuODk1NTIsLjkxMTMzLDEuOTE3MjksLjg5NTUyLDEuMTc4ODksMS4xMzI1NCwxLjA4NzA3LC45MjA5OCwuODUyODQsLjY4Nzg3LC43MTM1MywuODQ3MzcsLjkwNzQ3LDEuMDA4OCwxLjAwNDQsLjg3NjgzLDEsMS4wOTA5MSwxLC45MjIyOSwuNzM5LDEuMTU2NDIsLjkyMDk4LC43NjI4OCwuODA1MDQsLjgwOTcyLC43NTg1OSwuODY3NSwuODY3NSwuODY3NSwuODY3NSwuODY3NSwuODY3NSwuNzYzMTgsLjczODM0LC43MzIwNiwuNzMyMDYsLjczMjA2LC43MzIwNiwuOTA2ODUsLjkwNjg1LC45MDY4NSwuOTA2ODUsLjg2NDc3LC44OTM4NSwuODUxMjIsLjg1MTIyLC44NTEyMiwuODUxMjIsLjg1MTIyLC44NTI4NCwuODUzMTEsLjg4ODQ0LC44ODg0NCwuODg4NDQsLjg4ODQ0LC43MzA2LC43NzQ1MiwuODYzMzEsLjg2MTI4LC44NjEyOCwuODYxMjgsLjg2MTI4LC44NjEyOCwuODYxMjgsLjg2OTMsLjg0NTcsLjg5NDY0LC44OTQ2NCwuODk0NjQsLjg5NDY0LC44MjYwMSwuODI2MDEsLjgyNjAxLC44MjYwMSwuOTQ0NjksLjk0NDY5LC45NDgyLC45NDgyLC45NDgyLC45NDgyLC45NDgyLC45MDc0NywuODY2NTEsLjk0NDY5LC45NDQ2OSwuOTQ0NjksLjk0NDY5LC45MDUyNywuOTQ0NjksLjkwNTI3LC44Njc1LC44NjEyOCwuODY3NSwuODYxMjgsLjg2NzUsLjg2MTI4LC43MzgzNCwuODQ1NywuNzM4MzQsLjg0NTcsLjczODM0LC44NDU3LC43MzgzNCwuODQ1NywuODUxOTMsLjkyNDU0LC44NjQ3NywuOTkyMSwuNzMyMDYsLjg5NDY0LC43MzIwNiwuODk0NjQsLjczMjA2LC44OTQ2NCwuNzMyMDYsLjg5NDY0LC43MzIwNiwuODk0NjQsLjgxMTA1LC44NDYzNiwuODExMDUsLjg0NjM2LC44MTEwNSwuODQ2MzYsMSwxLC44NjI3NSwuOTQ0NjksLjkwODcyLC45NTc4NiwuOTA2ODUsLjgyNjAxLC45MDY4NSwuODI2MDEsLjkwNjg1LC44MjYwMSwuOTA2ODUsMS4wMzI5NywuOTA2ODUsLjgyNjAxLC43Nzc0MSwxLjA1NjExLC42Mzc3LDEuMDc2OTIsMSwxLC45MDkxOCwuNzU1OTMsMS4wMzI5NywxLDEsLjc2MDMyLC45MDQ1MiwuOTgxNTYsMS4xMTg0MiwuNzcyNjEsMS4xMTQyOSwuODkzODUsLjk0NDY5LDEsMSwuODkzODUsLjk0NDY5LC45NTg3NywuODY5MDEsLjk0NDY5LC44NTEyMiwuOTQ4MiwuODUxMjIsLjk0ODIsLjg1MTIyLC45NDgyLC44NjY3LC45MDAxNiwuNzUxODYsMS4wNDY5MiwxLDEsLjc1MTg2LDEuMDQ2OTIsLjY4ODg3LC43ODIyMywuNjg4ODcsLjc4MjIzLC42ODg4NywuNzgyMjMsLjY4ODg3LC43ODIyMywxLDEsLjc5Nzc2LC45MjE4OCwuNzk3NzYsMS4yMzAyMywuODg4NDQsLjk0NDY5LC44ODg0NCwuOTQ0NjksLjg4ODQ0LC45NDQ2OSwuODg4NDQsLjk0NDY5LC44ODg0NCwuOTQ0NjksLjg4ODQ0LC45NDQ2OSwuOTQyNTgsLjk4OTg2LC43MzA2LC45MDUyNywuNzMwNiwuNzY2NTksLjc5MDA0LC43NjY1OSwuNzkwMDQsLjc2NjU5LC43OTAwNCwxLjA5MjMxLC41NDg3MywuODY3NSwuODYxMjgsLjc2MzE4LC44NjkzLC44NTMxMSwuODY2NTEsMSwxLC43OTc3NiwxLjIwNTYyLDEuMTg2MjIsMS4xODYyMiwxLDEuMTQzNywuNjc3NDIsLjk2MzM0LC45MzY5NSwxLjM1MTkxLDEuNDA5MDksLjk1MTYxLDEuNDgzODcsLjg2Njg2LC45MDg2MSwuNjIyNjcsLjc0MzU5LC42NTY0OSwuODU0OTgsLjU2OTYzLC44ODI1NCwxLjIzNTE2LC44Njc1LC44MTU1MiwuNzU0NDMsLjg0NTAzLC43MzIwNiwuNzY2NTksLjg2Mjc1LC44NTEyMiwuOTA2ODUsLjc3ODkyLC44NTc0NiwxLjAyNjM4LC44OTM4NSwuNzU2NTcsLjg1MTIyLC44NjI3NSwuNzc0NTIsLjc0MTcxLC43OTc3NiwuNzMwNiwuOTUxNjUsLjc3ODE4LC44OTc3MiwuODg4MzEsLjkwNjg1LC43MzA2LC45ODE0MiwxLjAyMTkxLC45NjU3NiwxLjIzNTE2LC45OTAxOCwuOTgxNDIsLjkyMzYsLjg5MjU4LC45NDAzNSwxLjAyMTkxLC43ODg0OCwuOTY1NzYsLjk1NjEsMS4yMzUxNiwuOTA5MTgsLjkyNTc4LC45NTQyNCwuODk3NDYsLjgzOTY5LC45NDgyLC44MDExMywuODk0NDIsLjg1MjA4LC44NjE1NSwuOTgwMjIsLjk5MDE4LDEuMDA0NTIsLjgxMjA5LC45OTI0NywuODkxODEsMS4yMzUxNiwuOTkwMTgsLjk0ODIsLjk5MDE4LC44OTE4MSwuNzMyMDYsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjg4ODQ0LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC44OTQ2NCwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTY3NjYsMSwxLDEsMSwxLDEsLjk0MjU4LC45ODk4NiwuOTQyNTgsLjk4OTg2LC45NDI1OCwuOTg5ODYsLjczMDYsLjkwNTI3LDEsMSwuODk1NTIsLjkwNTI3LDEsLjkwMTg2LDEuMTIzMDgsMS4xMjMwOCwxLjEyMzA4LDEuMTIzMDgsMS4yNTY2LDEuMjU2NiwxLjI1NjYsLjg5NTUyLC44OTU1MiwxLjQyMjU5LC42OTA0MywxLjAzODA5LDEsMSwxLjAxNzYsMS4wMTc2LDEuMTE1MjMsMS40OTU2LDIuMDE0NjIsLjk5MzMxLC44MjYxNiwuOTExMzMsLjg0Mjg2LC45MTEzMywxLDEsMSwuNzA1MDgsMSwxLjIzMTA4LC43OTgwMSwuODQ0MjYsLjg0NDI2LC43NzQsLjkwNTI3LDEuODEwNTUsLjkwNTI3LDEuODEwNTUsMS4yODgwOSwxLjU1NDY5LC45NDQzNCwxLjA3ODA2LDEsLjk3MDk0LC43NTg5LC44NTI4NCwuOTA3NDcsMS4xOTY1OCwuNjk4MjUsLjk3NjIyLDEuMzM1MTIsLjkwNzQ3LC45MDc0NywuODUzNTYsLjkwNzQ3LC45MDc0NywxLjQ0OTQ3LC44NTI4NCwuODk0MSwuODk0MSwuNzA1NzIsLjgsLjcwNTcyLC43MDU3MiwuNzA1NzIsLjcwNTcyLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTk4NjIsLjk5ODYyLDEsMSwxLDEsMSwxLjAzMzYsLjkxMDI3LDEsMSwxLC45OTg2MiwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLjA1ODU5LDEuMDU4NTksMSwxLDEsMS4wNzE4NSwuOTk0MTMsLjk2MzM0LDEuMDgwNjUsMSwxLDEsMSwxLDEsMSwxLDEsMSwxXTt0LkNhbGlicmlSZWd1bGFyTWV0cmljcz17bGluZUhlaWdodDoxLjIyMDcsbGluZUdhcDouMjIwN319LChlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuSGVsdmV0aWNhUmVndWxhck1ldHJpY3M9dC5IZWx2ZXRpY2FSZWd1bGFyRmFjdG9ycz10LkhlbHZldGljYUl0YWxpY01ldHJpY3M9dC5IZWx2ZXRpY2FJdGFsaWNGYWN0b3JzPXQuSGVsdmV0aWNhQm9sZE1ldHJpY3M9dC5IZWx2ZXRpY2FCb2xkSXRhbGljTWV0cmljcz10LkhlbHZldGljYUJvbGRJdGFsaWNGYWN0b3JzPXQuSGVsdmV0aWNhQm9sZEZhY3RvcnM9dm9pZCAwO3QuSGVsdmV0aWNhQm9sZEZhY3RvcnM9Wy43NjExNiwxLDEsMS4wMDA2LC45OTk5OCwuOTk5NzQsLjk5OTczLC45OTk3MywuOTk5ODIsLjk5OTc3LDEuMDAwODcsLjk5OTk4LC45OTk5OCwuOTk5NTksMS4wMDAwMywxLjAwMDYsLjk5OTk4LDEuMDAwNiwxLjAwMDYsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk5OCwxLDEuMDAwMDMsMS4wMDAwMywxLjAwMDAzLDEuMDAwMjYsLjk5OTksLjk5OTc3LC45OTk3NywuOTk5NzcsLjk5OTc3LDEuMDAwMDEsMS4wMDAyNiwxLjAwMDIyLC45OTk3NywxLjAwMDYsLjk5OTczLC45OTk3NywxLjAwMDI2LC45OTk5OSwuOTk5NzcsMS4wMDAyMiwxLjAwMDAxLDEuMDAwMjIsLjk5OTc3LDEuMDAwMDEsMS4wMDAyNiwuOTk5NzcsMS4wMDAwMSwxLjAwMDE2LDEuMDAwMDEsMS4wMDAwMSwxLjAwMDI2LC45OTk5OCwxLjAwMDYsLjk5OTk4LDEuMDAwMDMsLjk5OTczLC45OTk5OCwuOTk5NzMsMS4wMDAyNiwuOTk5NzMsMS4wMDAyNiwuOTk5NzMsLjk5OTk4LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDYsMS4wMDA2LC45OTk3MywxLjAwMDYsLjk5OTgyLDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsLjk5OTU5LC45OTk3MywuOTk5OTgsMS4wMDAyNiwuOTk5NzMsMS4wMDAyMiwuOTk5NzMsLjk5OTczLDEsLjk5OTU5LDEuMDAwNzcsLjk5OTU5LDEuMDAwMDMsLjk5OTk4LC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywxLjAwMDc3LC45OTk3MywuOTk5OTgsMS4wMDAyNSwuOTk5NjgsLjk5OTczLDEuMDAwMDMsMS4wMDAyNSwuNjAyOTksMS4wMDAyNCwxLjA2NDA5LDEsMSwuOTk5OTgsMSwuOTk5NzMsMS4wMDA2LC45OTk5OCwxLC45OTkzNiwuOTk5NzMsMS4wMDAwMiwxLjAwMDAyLDEuMDAwMDIsMS4wMDAyNiwuOTk5NzcsLjk5OTc3LC45OTk3NywuOTk5NzcsLjk5OTc3LC45OTk3NywxLC45OTk3NywxLjAwMDAxLDEuMDAwMDEsMS4wMDAwMSwxLjAwMDAxLDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwuOTk5NzcsLjk5OTc3LDEuMDAwMjIsMS4wMDAyMiwxLjAwMDIyLDEuMDAwMjIsMS4wMDAyMiwxLjAwMDAzLDEuMDAwMjIsLjk5OTc3LC45OTk3NywuOTk5NzcsLjk5OTc3LDEuMDAwMDEsMS4wMDAwMSwxLjAwMDI2LC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk4MiwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDY0MDksMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LC45OTk3MywxLjAwMDI2LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywxLjAzMzc0LC45OTk3NywxLjAwMDI2LDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMjIsMS4wMDAyNiwxLjAwMDIyLDEuMDAwMjYsMS4wMDAyMiwxLjAwMDI2LDEuMDAwMjIsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA0MiwuOTk5NzMsLjk5OTczLDEuMDAwNiwuOTk5NzcsLjk5OTczLC45OTk3MywxLjAwMDI2LDEuMDAwNiwxLjAwMDI2LDEuMDAwNiwxLjAwMDI2LDEuMDM4MjgsMS4wMDAyNiwuOTk5OTksMS4wMDAyNiwxLjAwMDYsLjk5OTc3LDEuMDAwMjYsLjk5OTc3LDEuMDAwMjYsLjk5OTc3LDEuMDAwMjYsLjk5OTMsLjk5OTgsMS4wMDAyNiwxLjAwMDIyLDEuMDAwMjYsMS4wMDAyMiwxLjAwMDI2LDEuMDAwMjIsMS4wMDAyNiwxLDEuMDAwMTYsLjk5OTc3LC45OTk1OSwuOTk5NzcsLjk5OTU5LC45OTk3NywuOTk5NTksMS4wMDAwMSwuOTk5NzMsMS4wMDAwMSwuOTk5NzMsMS4wMDAwMSwuOTk5NzMsMS4wMDAwMSwuOTk5NzMsMS4wMDAyNiwuOTk5OTgsMS4wMDAyNiwuODEyMSwxLjAwMDI2LC45OTk5OCwuOTk5NzcsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwxLjAwMDE2LDEuMDAwMjIsMS4wMDAwMSwuOTk5NzMsMS4wMDAwMSwxLjAwMDI2LDEsMS4wMDAyNiwxLDEuMDAwMjYsMSwxLjAwMDYsLjk5OTczLC45OTk3NywuOTk5NzMsMSwuOTk5ODIsMS4wMDAyMiwxLjAwMDI2LDEuMDAwMDEsLjk5OTczLDEuMDAwMjYsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwxLjAwMDM0LC45OTk3NywxLC45OTk5NywxLjAwMDI2LDEuMDAwNzgsMS4wMDAzNiwuOTk5NzMsMS4wMDAxMywxLjAwMDYsLjk5OTc3LC45OTk3NywuOTk5ODgsLjg1MTQ4LDEuMDAwMDEsMS4wMDAyNiwuOTk5NzcsMS4wMDAyMiwxLjAwMDYsLjk5OTc3LDEuMDAwMDEsLjk5OTk5LC45OTk3NywxLjAwMDY5LDEuMDAwMjIsLjk5OTc3LDEuMDAwMDEsLjk5OTg0LDEuMDAwMjYsMS4wMDAwMSwxLjAwMDI0LDEuMDAwMDEsLjk5OTksMSwxLjAwMDYsMS4wMDAwMSwxLjAwMDQxLC45OTk2MiwxLjAwMDI2LDEuMDAwNiwuOTk5OTUsMS4wMDA0MSwuOTk5NDIsLjk5OTczLC45OTkyNywxLjAwMDgyLC45OTkwMiwxLjAwMDI2LDEuMDAwODcsMS4wMDA2LDEuMDAwNjksLjk5OTczLC45OTg2NywuOTk5NzMsLjk5OTMsMS4wMDAyNiwxLjAwMDQ5LDEuMDAwNTYsMSwuOTk5ODgsLjk5OTM1LC45OTk5NSwuOTk5NTQsMS4wMDA1NSwuOTk5NDUsMS4wMDAzMiwxLjAwMDYsLjk5OTk1LDEuMDAwMjYsLjk5OTk1LDEuMDAwMzIsMS4wMDAwMSwxLjAwMDA4LC45OTk3MSwxLjAwMDE5LC45OTk0LDEuMDAwMDEsMS4wMDA2LDEuMDAwNDQsLjk5OTczLDEuMDAwMjMsMS4wMDA0NywxLC45OTk0MiwuOTk1NjEsLjk5OTg5LDEuMDAwMzUsLjk5OTc3LDEuMDAwMzUsLjk5OTc3LDEuMDAwMTksLjk5OTQ0LDEuMDAwMDEsMS4wMDAyMSwuOTk5MjYsMS4wMDAzNSwxLjAwMDM1LC45OTk0MiwxLjAwMDQ4LC45OTk5OSwuOTk5NzcsMS4wMDAyMiwxLjAwMDM1LDEuMDAwMDEsLjk5OTc3LDEuMDAwMjYsLjk5OTg5LDEuMDAwNTcsMS4wMDAwMSwuOTk5MzYsMS4wMDA1MiwxLjAwMDEyLC45OTk5NiwxLjAwMDQzLDEsMS4wMDAzNSwuOTk5NCwuOTk5NzYsMS4wMDAzNSwuOTk5NzMsMS4wMDA1MiwxLjAwMDQxLDEuMDAxMTksMS4wMDAzNywuOTk5NzMsMS4wMDAwMiwuOTk5ODYsMS4wMDA0MSwxLjAwMDQxLC45OTkwMiwuOTk5NiwxLjAwMDM0LC45OTk5OSwxLjAwMDI2LC45OTk5OSwxLjAwMDI2LC45OTk3MywxLjAwMDUyLC45OTk3MywxLC45OTk3MywxLjAwMDQxLDEuMDAwNzUsLjk5OTQsMS4wMDAzLC45OTk5OSwxLDEuMDAwNDEsLjk5OTU1LDEsLjk5OTE1LC45OTk3MywuOTk5NzMsMS4wMDAyNiwxLjAwMTE5LC45OTk1NSwuOTk5NzMsMS4wMDA2LC45OTkxMSwxLjAwMDYsMS4wMDAyNiwuOTk5NzIsMS4wMDAyNiwuOTk5MDIsMS4wMDA0MSwuOTk5NzMsLjk5OTk5LDEsMSwxLjAwMDM4LDEuMDAwNSwxLjAwMDE2LDEuMDAwMjIsMS4wMDAxNiwxLjAwMDIyLDEuMDAwMTYsMS4wMDAyMiwxLjAwMDAxLC45OTk3MywxLDEsLjk5OTczLDEsMSwuOTk5NTUsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEsMSwxLC45OTk3MywuOTk5NzMsLjk5OTcyLDEsMSwxLjAwMTA2LC45OTk5OSwuOTk5OTgsLjk5OTk4LC45OTk5OSwuOTk5OTgsMS42NjQ3NSwxLC45OTk3MywuOTk5NzMsMS4wMDAyMywuOTk5NzMsLjk5OTcxLDEuMDAwNDcsMS4wMDAyMywxLC45OTk5MSwuOTk5ODQsMS4wMDAwMiwxLjAwMDAyLDEuMDAwMDIsMS4wMDAwMiwxLDEsMSwxLDEsMSwxLC45OTk3MiwxLDEuMjA5ODUsMS4zOTcxMywxLjAwMDAzLDEuMDAwMzEsMS4wMDAxNSwxLC45OTU2MSwxLjAwMDI3LDEuMDAwMzEsMS4wMDAzMSwuOTk5MTUsMS4wMDAzMSwxLjAwMDMxLC45OTk5OSwxLjAwMDAzLC45OTk5OSwuOTk5OTksMS40MTE0NCwxLjYsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQwNTc5LDEuNDA1NzksMS4zNjYyNSwuOTk5OTksMSwuOTk4NjEsLjk5ODYxLDEsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwuOTk5NzIsLjk5OTk5LC45OTk5OSwuOTk5OTksLjk5OTk5LDEuNDA0ODMsMSwuOTk5NzcsMS4wMDA1NCwxLDEsLjk5OTUzLC45OTk2MiwxLjAwMDQyLC45OTk1LDEsMSwxLDEsMSwxLDEsMSwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsMSwxLDEsMSwxLDEsMSwxLDEsMSwxXTt0LkhlbHZldGljYUJvbGRNZXRyaWNzPXtsaW5lSGVpZ2h0OjEuMixsaW5lR2FwOi4yfTt0LkhlbHZldGljYUJvbGRJdGFsaWNGYWN0b3JzPVsuNzYxMTYsMSwxLDEuMDAwNiwuOTk5OTgsLjk5OTc0LC45OTk3MywuOTk5NzMsLjk5OTgyLC45OTk3NywxLjAwMDg3LC45OTk5OCwuOTk5OTgsLjk5OTU5LDEuMDAwMDMsMS4wMDA2LC45OTk5OCwxLjAwMDYsMS4wMDA2LC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5OTgsMSwxLjAwMDAzLDEuMDAwMDMsMS4wMDAwMywxLjAwMDI2LC45OTk5LC45OTk3NywuOTk5NzcsLjk5OTc3LC45OTk3NywxLjAwMDAxLDEuMDAwMjYsMS4wMDAyMiwuOTk5NzcsMS4wMDA2LC45OTk3MywuOTk5NzcsMS4wMDAyNiwuOTk5OTksLjk5OTc3LDEuMDAwMjIsMS4wMDAwMSwxLjAwMDIyLC45OTk3NywxLjAwMDAxLDEuMDAwMjYsLjk5OTc3LDEuMDAwMDEsMS4wMDAxNiwxLjAwMDAxLDEuMDAwMDEsMS4wMDAyNiwuOTk5OTgsMS4wMDA2LC45OTk5OCwxLjAwMDAzLC45OTk3MywuOTk5OTgsLjk5OTczLDEuMDAwMjYsLjk5OTczLDEuMDAwMjYsLjk5OTczLC45OTk5OCwxLjAwMDI2LDEuMDAwMjYsMS4wMDA2LDEuMDAwNiwuOTk5NzMsMS4wMDA2LC45OTk4MiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LC45OTk1OSwuOTk5NzMsLjk5OTk4LDEuMDAwMjYsLjk5OTczLDEuMDAwMjIsLjk5OTczLC45OTk3MywxLC45OTk1OSwxLjAwMDc3LC45OTk1OSwxLjAwMDAzLC45OTk5OCwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsMS4wMDA3NywuOTk5NzMsLjk5OTk4LDEuMDAwMjUsLjk5OTY4LC45OTk3MywxLjAwMDAzLDEuMDAwMjUsLjYwMjk5LDEuMDAwMjQsMS4wNjQwOSwxLDEsLjk5OTk4LDEsLjk5OTczLDEuMDAwNiwuOTk5OTgsMSwuOTk5MzYsLjk5OTczLDEuMDAwMDIsMS4wMDAwMiwxLjAwMDAyLDEuMDAwMjYsLjk5OTc3LC45OTk3NywuOTk5NzcsLjk5OTc3LC45OTk3NywuOTk5NzcsMSwuOTk5NzcsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMDEsMS4wMDAwMSwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsLjk5OTc3LC45OTk3NywxLjAwMDIyLDEuMDAwMjIsMS4wMDAyMiwxLjAwMDIyLDEuMDAwMjIsMS4wMDAwMywxLjAwMDIyLC45OTk3NywuOTk5NzcsLjk5OTc3LC45OTk3NywxLjAwMDAxLDEuMDAwMDEsMS4wMDAyNiwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5ODIsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwxLjA2NDA5LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwuOTk5NzMsMS4wMDAyNiwuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsMS4wMDQ0LC45OTk3NywxLjAwMDI2LDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMjIsMS4wMDAyNiwxLjAwMDIyLDEuMDAwMjYsMS4wMDAyMiwxLjAwMDI2LDEuMDAwMjIsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsLjk5OTcxLC45OTk3MywuOTk5NzMsMS4wMDA2LC45OTk3NywuOTk5NzMsLjk5OTczLDEuMDAwMjYsMS4wMDA2LDEuMDAwMjYsMS4wMDA2LDEuMDAwMjYsMS4wMTAxMSwxLjAwMDI2LC45OTk5OSwxLjAwMDI2LDEuMDAwNiwuOTk5NzcsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwuOTk5MywuOTk5OCwxLjAwMDI2LDEuMDAwMjIsMS4wMDAyNiwxLjAwMDIyLDEuMDAwMjYsMS4wMDAyMiwxLjAwMDI2LDEsMS4wMDAxNiwuOTk5NzcsLjk5OTU5LC45OTk3NywuOTk5NTksLjk5OTc3LC45OTk1OSwxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDI2LC45OTk5OCwxLjAwMDI2LC44MTIxLDEuMDAwMjYsLjk5OTk4LC45OTk3NywxLjAwMDI2LC45OTk3NywxLjAwMDI2LC45OTk3NywxLjAwMDI2LC45OTk3NywxLjAwMDI2LC45OTk3NywxLjAwMDI2LC45OTk3NywxLjAwMDI2LDEuMDAwMTYsMS4wMDAyMiwxLjAwMDAxLC45OTk3MywxLjAwMDAxLDEuMDAwMjYsMSwxLjAwMDI2LDEsMS4wMDAyNiwxLDEuMDAwNiwuOTk5NzMsLjk5OTc3LC45OTk3MywxLC45OTk4MiwxLjAwMDIyLDEuMDAwMjYsMS4wMDAwMSwuOTk5NzMsMS4wMDAyNiwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5NzcsMSwxLDEuMDAwMjYsLjk5OTY5LC45OTk3MiwuOTk5ODEsLjk5OTgsMS4wMDA2LC45OTk3NywuOTk5NzcsMS4wMDAyMiwuOTExNTUsMS4wMDAwMSwxLjAwMDI2LC45OTk3NywxLjAwMDIyLDEuMDAwNiwuOTk5NzcsMS4wMDAwMSwuOTk5OTksLjk5OTc3LC45OTk2NiwxLjAwMDIyLDEuMDAwMzIsMS4wMDAwMSwuOTk5NDQsMS4wMDAyNiwxLjAwMDAxLC45OTk2OCwxLjAwMDAxLDEuMDAwNDcsMSwxLjAwMDYsMS4wMDAwMSwuOTk5ODEsMS4wMDEwMSwxLjAwMDI2LDEuMDAwNiwuOTk5NDgsLjk5OTgxLDEuMDAwNjQsLjk5OTczLC45OTk0MiwxLjAwMTAxLDEuMDAwNjEsMS4wMDAyNiwxLjAwMDY5LDEuMDAwNiwxLjAwMDE0LC45OTk3MywxLjAxMzIyLC45OTk3MywxLjAwMDY1LDEuMDAwMjYsMS4wMDAxMiwuOTk5MjMsMSwxLjAwMDY0LDEuMDAwNzYsLjk5OTQ4LDEuMDAwNTUsMS4wMDA2MywxLjAwMDA3LC45OTk0MywxLjAwMDYsLjk5OTQ4LDEuMDAwMjYsLjk5OTQ4LC45OTk0MywxLjAwMDAxLDEuMDAwMDEsMS4wMDAyOSwxLjAwMDM4LDEuMDAwMzUsMS4wMDAwMSwxLjAwMDYsMS4wMDA2LC45OTk3MywuOTk5NzgsMS4wMDAwMSwxLjAwMDU3LC45OTk4OSwuOTk5NjcsLjk5OTY0LC45OTk2NywuOTk5NzcsLjk5OTk5LC45OTk3NywxLjAwMDM4LC45OTk3NywxLjAwMDAxLC45OTk3MywxLjAwMDY2LC45OTk2NywuOTk5NjcsMS4wMDA0MSwuOTk5OTgsLjk5OTk5LC45OTk3NywxLjAwMDIyLC45OTk2NywxLjAwMDAxLC45OTk3NywxLjAwMDI2LC45OTk2NCwxLjAwMDMxLDEuMDAwMDEsLjk5OTk5LC45OTk5OSwxLDEuMDAwMjMsMSwxLC45OTk5OSwxLjAwMDM1LDEuMDAwMDEsLjk5OTk5LC45OTk3MywuOTk5NzcsLjk5OTk5LDEuMDAwNTgsLjk5OTczLC45OTk3MywuOTk5NTUsLjk5OTUsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMzIsLjk5OTg5LDEuMDAwMzQsLjk5OTk5LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LC45OTk3MywuNDU5OTgsLjk5OTczLDEuMDAwMjYsLjk5OTczLDEuMDAwMDEsLjk5OTk5LC45OTk4MiwuOTk5OTQsLjk5OTk2LDEsMS4wMDA0MiwxLjAwMDQ0LDEuMDAwMjksMS4wMDAyMywuOTk5NzMsLjk5OTczLDEuMDAwMjYsLjk5OTQ5LDEuMDAwMDIsLjk5OTczLDEuMDAwNiwxLjAwMDYsMS4wMDA2LC45OTk3NSwxLjAwMDI2LDEuMDAwMjYsMS4wMDAzMiwuOTg2ODUsLjk5OTczLDEuMDAwMjYsMSwxLC45OTk2NiwxLjAwMDQ0LDEuMDAwMTYsMS4wMDAyMiwxLjAwMDE2LDEuMDAwMjIsMS4wMDAxNiwxLjAwMDIyLDEuMDAwMDEsLjk5OTczLDEsMSwuOTk5NzMsMSwxLC45OTk1NSwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMSwxLDEsLjk5OTczLC45OTk3MywuOTk5NzIsMSwxLDEuMDAxMDYsLjk5OTk5LC45OTk5OCwuOTk5OTgsLjk5OTk5LC45OTk5OCwxLjY2NDc1LDEsLjk5OTczLC45OTk3MywxLC45OTk3MywuOTk5NzEsLjk5OTc4LDEsMSwuOTk5OTEsLjk5OTg0LDEuMDAwMDIsMS4wMDAwMiwxLjAwMDAyLDEuMDAwMDIsMS4wMDA5OCwxLDEsMSwxLjAwMDQ5LDEsMSwuOTk5NzIsMSwxLjIwOTg1LDEuMzk3MTMsMS4wMDAwMywxLjAwMDMxLDEuMDAwMTUsMSwuOTk1NjEsMS4wMDAyNywxLjAwMDMxLDEuMDAwMzEsLjk5OTE1LDEuMDAwMzEsMS4wMDAzMSwuOTk5OTksMS4wMDAwMywuOTk5OTksLjk5OTk5LDEuNDExNDQsMS42LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MDU3OSwxLjQwNTc5LDEuMzY2MjUsLjk5OTk5LDEsLjk5ODYxLC45OTg2MSwxLDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsLjk5OTcyLC45OTk5OSwuOTk5OTksLjk5OTk5LC45OTk5OSwxLjQwNDgzLDEsLjk5OTc3LDEuMDAwNTQsMSwxLC45OTk1MywuOTk5NjIsMS4wMDA0MiwuOTk5NSwxLDEsMSwxLDEsMSwxLDEsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LDEsMSwxLDEsMSwxLDEsMSwxLDEsMV07dC5IZWx2ZXRpY2FCb2xkSXRhbGljTWV0cmljcz17bGluZUhlaWdodDoxLjM1LGxpbmVHYXA6LjJ9O3QuSGVsdmV0aWNhSXRhbGljRmFjdG9ycz1bLjc2MTE2LDEsMSwxLjAwMDYsMS4wMDA2LDEuMDAwMDYsLjk5OTczLC45OTk3MywuOTk5ODIsMS4wMDAwMSwxLjAwMDQzLC45OTk5OCwuOTk5OTgsLjk5OTU5LDEuMDAwMDMsMS4wMDA2LC45OTk5OCwxLjAwMDYsMS4wMDA2LC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywxLjAwMDYsMSwxLjAwMDAzLDEuMDAwMDMsMS4wMDAwMywuOTk5NzMsLjk5OTg3LDEuMDAwMDEsMS4wMDAwMSwuOTk5NzcsLjk5OTc3LDEuMDAwMDEsMS4wMDAyNiwxLjAwMDIyLC45OTk3NywxLjAwMDYsMSwxLjAwMDAxLC45OTk3MywuOTk5OTksLjk5OTc3LDEuMDAwMjIsMS4wMDAwMSwxLjAwMDIyLC45OTk3NywxLjAwMDAxLDEuMDAwMjYsLjk5OTc3LDEuMDAwMDEsMS4wMDAxNiwxLjAwMDAxLDEuMDAwMDEsMS4wMDAyNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwuOTk5NDksLjk5OTczLC45OTk5OCwuOTk5NzMsLjk5OTczLDEsLjk5OTczLC45OTk3MywxLjAwMDYsLjk5OTczLC45OTk3MywuOTk5MjQsLjk5OTI0LDEsLjk5OTI0LC45OTk5OSwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTk4LDEsMS4wMDA2LC45OTk3MywxLC45OTk3NywxLDEsMSwxLjAwMDA1LDEuMDAwOSwxLjAwMDA1LDEuMDAwMDMsLjk5OTk4LC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywxLjAwMDksLjk5OTczLC45OTk5OCwxLjAwMDI1LC45OTk2OCwuOTk5NzMsMS4wMDAwMywxLjAwMDI1LC42MDI5OSwxLjAwMDI0LDEuMDY0MDksMSwxLC45OTk5OCwxLC45OTk4LDEuMDAwNiwuOTk5OTgsMSwuOTk5MzYsLjk5OTczLDEuMDAwMDIsMS4wMDAwMiwxLjAwMDAyLDEuMDAwMjYsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMDEsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMDEsMSwuOTk5NzcsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMDEsMS4wMDAwMSwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsLjk5OTc3LC45OTk3NywxLjAwMDIyLDEuMDAwMjIsMS4wMDAyMiwxLjAwMDIyLDEuMDAwMjIsMS4wMDAwMywxLjAwMDIyLC45OTk3NywuOTk5NzcsLjk5OTc3LC45OTk3NywxLjAwMDAxLDEuMDAwMDEsMS4wMDAyNiwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5ODIsMSwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywxLjA2NDA5LDEuMDAwMjYsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLDEsLjk5OTczLDEsMS4wMDAwMSwuOTk5NzMsMS4wMDAwMSwuOTk5NzMsMS4wMDAwMSwuOTk5NzMsLjk5OTc3LDEsLjk5OTc3LDEsLjk5OTc3LDEsLjk5OTc3LDEsLjk5OTc3LDEuMDI4OCwuOTk5NzcsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMjIsLjk5OTczLDEuMDAwMjIsLjk5OTczLDEuMDAwMjIsLjk5OTczLDEuMDAwMjIsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsLjk5OTI0LDEuMDAwNiwxLjAwMDYsLjk5OTQ2LDEuMDAwMzQsMSwuOTk5MjQsMS4wMDAwMSwxLDEsLjk5OTczLC45OTkyNCwuOTk5NzMsLjk5OTI0LC45OTk3MywxLjA2MzExLC45OTk3MywxLjAwMDI0LC45OTk3MywuOTk5MjQsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsMS4wMDA0MSwuOTk5OCwuOTk5NzMsMS4wMDAyMiwuOTk5NzMsMS4wMDAyMiwuOTk5NzMsMS4wMDAyMiwuOTk5NzMsMSwxLjAwMDE2LC45OTk3NywuOTk5OTgsLjk5OTc3LC45OTk5OCwuOTk5NzcsLjk5OTk4LDEuMDAwMDEsMSwxLjAwMDAxLDEsMS4wMDAwMSwxLDEuMDAwMDEsMSwxLjAwMDI2LDEuMDAwNiwxLjAwMDI2LC44OTU0NywxLjAwMDI2LDEuMDAwNiwuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywxLjAwMDE2LC45OTk3NywxLjAwMDAxLDEsMS4wMDAwMSwxLjAwMDI2LDEsMS4wMDAyNiwxLDEuMDAwMjYsMSwuOTk5MjQsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEsLjk5OTgyLDEuMDAwMjIsMS4wMDAyNiwxLjAwMDAxLDEsMS4wMDAyNiwxLjAwMDYsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwxLjAwMDAxLDEsMS4wMDA1NCwuOTk5NzcsMS4wMDA4NCwxLjAwMDA3LC45OTk3MywxLjAwMDEzLC45OTkyNCwxLjAwMDAxLDEuMDAwMDEsLjk5OTQ1LC45MTIyMSwxLjAwMDAxLDEuMDAwMjYsLjk5OTc3LDEuMDAwMjIsMS4wMDA2LDEuMDAwMDEsMS4wMDAwMSwuOTk5OTksLjk5OTc3LC45OTkzMywxLjAwMDIyLDEuMDAwNTQsMS4wMDAwMSwxLjAwMDY1LDEuMDAwMjYsMS4wMDAwMSwxLjAwMDEsMS4wMDAwMSwxLjAwMDUyLDEsMS4wMDA2LDEuMDAwMDEsLjk5OTQ1LC45OTg5NywuOTk5NjgsLjk5OTI0LDEuMDAwMzYsLjk5OTQ1LC45OTk0OSwxLDEuMDAwNiwuOTk4OTcsLjk5OTE4LC45OTk2OCwuOTk5MTEsLjk5OTI0LDEsLjk5OTYyLDEuMDE0ODcsMSwxLjAwMDUsLjk5OTczLDEuMDAwMTIsMS4wMDA0MywxLC45OTk5NSwuOTk5OTQsMS4wMDAzNiwuOTk5NDcsMS4wMDAxOSwxLjAwMDYzLDEuMDAwMjUsLjk5OTI0LDEuMDAwMzYsLjk5OTczLDEuMDAwMzYsMS4wMDAyNSwxLjAwMDAxLDEuMDAwMDEsMS4wMDAyNywxLjAwMDEsMS4wMDA2OCwxLjAwMDAxLDEuMDAwNiwxLjAwMDYsMSwxLjAwMDA4LC45OTk1NywuOTk5NzIsLjk5OTQsLjk5OTU0LC45OTk3NSwxLjAwMDUxLDEuMDAwMDEsMS4wMDAxOSwxLjAwMDAxLDEuMDAwMSwuOTk5ODYsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMzgsLjk5OTU0LC45OTk1NCwuOTk5NCwxLjAwMDY2LC45OTk5OSwuOTk5NzcsMS4wMDAyMiwxLjAwMDU0LDEuMDAwMDEsLjk5OTc3LDEuMDAwMjYsLjk5OTc1LDEuMDAwMSwxLjAwMDAxLC45OTk5MywuOTk5NSwuOTk5NTUsMS4wMDAxNiwuOTk5NzgsLjk5OTc0LDEuMDAwMTksMS4wMDAyMiwuOTk5NTUsMS4wMDA1MywuOTk5NzMsMS4wMDA4OSwxLjAwMDA1LC45OTk2NywxLjAwMDQ4LC45OTk3MywxLjAwMDAyLDEuMDAwMzQsLjk5OTczLC45OTk3MywuOTk5NjQsMS4wMDAwNiwxLjAwMDY2LC45OTk0NywuOTk5NzMsLjk4ODk0LC45OTk3MywxLC40NDg5OCwxLC45OTk0NiwxLDEuMDAwMzksMS4wMDA4MiwuOTk5OTEsLjk5OTkxLC45OTk4NSwxLjAwMDIyLDEuMDAwMjMsMS4wMDA2MSwxLjAwMDA2LC45OTk2NiwuOTk5NzMsLjk5OTczLC45OTk3MywxLjAwMDE5LDEuMDAwOCwxLC45OTkyNCwuOTk5MjQsLjk5OTI0LC45OTk4MywxLjAwMDQ0LC45OTk3MywuOTk5NjQsLjk4MzMyLDEsLjk5OTczLDEsMSwuOTk5NjIsLjk5ODk1LDEuMDAwMTYsLjk5OTc3LDEuMDAwMTYsLjk5OTc3LDEuMDAwMTYsLjk5OTc3LDEuMDAwMDEsMSwxLDEsLjk5OTczLDEsMSwuOTk5NTUsLjk5OTI0LC45OTkyNCwuOTk5MjQsLjk5OTI0LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk3MywuOTk5NzMsLjk5OTcyLDEsMSwxLjAwMjY3LC45OTk5OSwuOTk5OTgsLjk5OTk4LDEsLjk5OTk4LDEuNjY0NzUsMSwuOTk5NzMsLjk5OTczLDEuMDAwMjMsLjk5OTczLDEuMDA0MjMsLjk5OTI1LC45OTk5OSwxLC45OTk5MSwuOTk5ODQsMS4wMDAwMiwxLjAwMDAyLDEuMDAwMDIsMS4wMDAwMiwxLjAwMDQ5LDEsMS4wMDI0NSwxLDEsMSwxLC45NjMyOSwxLDEuMjA5ODUsMS4zOTcxMywxLjAwMDAzLC44MjU0LDEuMDAwMTUsMSwxLjAwMDM1LDEuMDAwMjcsMS4wMDAzMSwxLjAwMDMxLDEuMDAwMDMsMS4wMDAzMSwxLjAwMDMxLC45OTk5OSwxLjAwMDAzLC45OTk5OSwuOTk5OTksMS40MTE0NCwxLjYsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQwNTc5LDEuNDA1NzksMS4zNjYyNSwuOTk5OTksMSwuOTk4NjEsLjk5ODYxLDEsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwuOTUzMTcsLjk5OTk5LC45OTk5OSwuOTk5OTksLjk5OTk5LDEuNDA0ODMsMSwuOTk5NzcsMS4wMDA1NCwxLDEsLjk5OTUzLC45OTk2MiwxLjAwMDQyLC45OTk1LDEsMSwxLDEsMSwxLDEsMSwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsMSwxLDEsMSwxLDEsMSwxLDEsMSwxXTt0LkhlbHZldGljYUl0YWxpY01ldHJpY3M9e2xpbmVIZWlnaHQ6MS4zNSxsaW5lR2FwOi4yfTt0LkhlbHZldGljYVJlZ3VsYXJGYWN0b3JzPVsuNzYxMTYsMSwxLDEuMDAwNiwxLjAwMDYsMS4wMDAwNiwuOTk5NzMsLjk5OTczLC45OTk4MiwxLjAwMDAxLDEuMDAwNDMsLjk5OTk4LC45OTk5OCwuOTk5NTksMS4wMDAwMywxLjAwMDYsLjk5OTk4LDEuMDAwNiwxLjAwMDYsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLDEuMDAwNiwxLDEuMDAwMDMsMS4wMDAwMywxLjAwMDAzLC45OTk3MywuOTk5ODcsMS4wMDAwMSwxLjAwMDAxLC45OTk3NywuOTk5NzcsMS4wMDAwMSwxLjAwMDI2LDEuMDAwMjIsLjk5OTc3LDEuMDAwNiwxLDEuMDAwMDEsLjk5OTczLC45OTk5OSwuOTk5NzcsMS4wMDAyMiwxLjAwMDAxLDEuMDAwMjIsLjk5OTc3LDEuMDAwMDEsMS4wMDAyNiwuOTk5NzcsMS4wMDAwMSwxLjAwMDE2LDEuMDAwMDEsMS4wMDAwMSwxLjAwMDI2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LC45OTk0OSwuOTk5NzMsLjk5OTk4LC45OTk3MywuOTk5NzMsMSwuOTk5NzMsLjk5OTczLDEuMDAwNiwuOTk5NzMsLjk5OTczLC45OTkyNCwuOTk5MjQsMSwuOTk5MjQsLjk5OTk5LC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5OTgsMSwxLjAwMDYsLjk5OTczLDEsLjk5OTc3LDEsMSwxLDEuMDAwMDUsMS4wMDA5LDEuMDAwMDUsMS4wMDAwMywuOTk5OTgsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLDEuMDAwOSwuOTk5NzMsLjk5OTk4LDEuMDAwMjUsLjk5OTY4LC45OTk3MywxLjAwMDAzLDEuMDAwMjUsLjYwMjk5LDEuMDAwMjQsMS4wNjQwOSwxLDEsLjk5OTk4LDEsLjk5OTgsMS4wMDA2LC45OTk5OCwxLC45OTkzNiwuOTk5NzMsMS4wMDAwMiwxLjAwMDAyLDEuMDAwMDIsMS4wMDAyNiwxLjAwMDAxLDEuMDAwMDEsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMDEsMS4wMDAwMSwxLC45OTk3NywxLjAwMDAxLDEuMDAwMDEsMS4wMDAwMSwxLjAwMDAxLDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwuOTk5NzcsLjk5OTc3LDEuMDAwMjIsMS4wMDAyMiwxLjAwMDIyLDEuMDAwMjIsMS4wMDAyMiwxLjAwMDAzLDEuMDAwMjIsLjk5OTc3LC45OTk3NywuOTk5NzcsLjk5OTc3LDEuMDAwMDEsMS4wMDAwMSwxLjAwMDI2LC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk4MiwxLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLDEuMDY0MDksMS4wMDAyNiwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsMSwuOTk5NzMsMSwxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywuOTk5NzcsMSwuOTk5NzcsMSwuOTk5NzcsMSwuOTk5NzcsMSwuOTk5NzcsMS4wNDU5NiwuOTk5NzcsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMjIsLjk5OTczLDEuMDAwMjIsLjk5OTczLDEuMDAwMjIsLjk5OTczLDEuMDAwMjIsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsLjk5OTI0LDEuMDAwNiwxLjAwMDYsMS4wMDAxOSwxLjAwMDM0LDEsLjk5OTI0LDEuMDAwMDEsMSwxLC45OTk3MywuOTk5MjQsLjk5OTczLC45OTkyNCwuOTk5NzMsMS4wMjU3MiwuOTk5NzMsMS4wMDAwNSwuOTk5NzMsLjk5OTI0LC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk5OSwuOTk5OCwuOTk5NzMsMS4wMDAyMiwuOTk5NzMsMS4wMDAyMiwuOTk5NzMsMS4wMDAyMiwuOTk5NzMsMSwxLjAwMDE2LC45OTk3NywuOTk5OTgsLjk5OTc3LC45OTk5OCwuOTk5NzcsLjk5OTk4LDEuMDAwMDEsMSwxLjAwMDAxLDEsMS4wMDAwMSwxLDEuMDAwMDEsMSwxLjAwMDI2LDEuMDAwNiwxLjAwMDI2LC44NDUzMywxLjAwMDI2LDEuMDAwNiwuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywxLjAwMDE2LC45OTk3NywxLjAwMDAxLDEsMS4wMDAwMSwxLjAwMDI2LDEsMS4wMDAyNiwxLDEuMDAwMjYsMSwuOTk5MjQsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEsLjk5OTgyLDEuMDAwMjIsMS4wMDAyNiwxLjAwMDAxLDEsMS4wMDAyNiwxLjAwMDYsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5MjgsMSwuOTk5NzcsMS4wMDAxMywxLjAwMDU1LC45OTk0NywuOTk5NDUsLjk5OTQxLC45OTkyNCwxLjAwMDAxLDEuMDAwMDEsMS4wMDA0LC45MTYyMSwxLjAwMDAxLDEuMDAwMjYsLjk5OTc3LDEuMDAwMjIsMS4wMDA2LDEuMDAwMDEsMS4wMDAwNSwuOTk5OTksLjk5OTc3LDEuMDAwMTUsMS4wMDAyMiwuOTk5NzcsMS4wMDAwMSwuOTk5NzMsMS4wMDAyNiwxLjAwMDAxLDEuMDAwMTksMS4wMDAwMSwuOTk5NDYsMSwxLjAwMDYsMS4wMDAwMSwuOTk5NzgsMS4wMDA0NSwuOTk5NzMsLjk5OTI0LDEuMDAwMjMsLjk5OTc4LC45OTk2NiwxLDEuMDAwNjUsMS4wMDA0NSwxLjAwMDE5LC45OTk3MywuOTk5NzMsLjk5OTI0LDEsMSwuOTY0OTksMSwxLjAwMDU1LC45OTk3MywxLjAwMDA4LDEuMDAwMjcsMSwuOTk5NywuOTk5OTUsMS4wMDAyMywuOTk5MzMsMS4wMDAxOSwxLjAwMDE1LDEuMDAwMzEsLjk5OTI0LDEuMDAwMjMsLjk5OTczLDEuMDAwMjMsMS4wMDAzMSwxLjAwMDAxLC45OTkyOCwxLjAwMDI5LDEuMDAwOTIsMS4wMDAzNSwxLjAwMDAxLDEuMDAwNiwxLjAwMDYsMSwuOTk5ODgsLjk5OTc1LDEsMS4wMDA4MiwuOTk1NjEsLjk5OTYsMS4wMDAzNSwxLjAwMDAxLC45OTk2MiwxLjAwMDAxLDEuMDAwOTIsLjk5OTY0LDEuMDAwMDEsLjk5OTYzLC45OTk5OSwxLjAwMDM1LDEuMDAwMzUsMS4wMDA4MiwuOTk5NjIsLjk5OTk5LC45OTk3NywxLjAwMDIyLDEuMDAwMzUsMS4wMDAwMSwuOTk5NzcsMS4wMDAyNiwuOTk5NiwuOTk5NjcsMS4wMDAwMSwxLjAwMDM0LDEuMDAwNzQsMS4wMDA1NCwxLjAwMDUzLDEuMDAwNjMsLjk5OTcxLC45OTk2MiwxLjAwMDM1LC45OTk3NSwuOTk5NzcsLjk5OTczLDEuMDAwNDMsLjk5OTUzLDEuMDAwNywuOTk5MTUsLjk5OTczLDEuMDAwMDgsLjk5ODkyLDEuMDAwNzMsMS4wMDA3MywxLjAwMTE0LC45OTkxNSwxLjAwMDczLC45OTk1NSwuOTk5NzMsMS4wMDA5MiwuOTk5NzMsMSwuOTk5OTgsMSwxLjAwMDMsMSwxLjAwMDQzLDEuMDAwMDEsLjk5OTY5LDEuMDAwMywxLDEuMDAwMzUsMS4wMDAwMSwuOTk5NSwxLDEuMDAwOTIsLjk5OTczLC45OTk3MywuOTk5NzMsMS4wMDA3LC45OTk1LDEsLjk5OTI0LDEuMDAwNiwuOTk5MjQsLjk5OTcyLDEuMDAwNjIsLjk5OTczLDEuMDAxMTQsMS4wMDA3MywxLC45OTk1NSwxLDEsMS4wMDA0NywuOTk5NjgsMS4wMDAxNiwuOTk5NzcsMS4wMDAxNiwuOTk5NzcsMS4wMDAxNiwuOTk5NzcsMS4wMDAwMSwxLDEsMSwuOTk5NzMsMSwxLC45OTk1NSwuOTk5MjQsLjk5OTI0LC45OTkyNCwuOTk5MjQsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTczLC45OTk3MywuOTk5NzIsMSwxLDEuMDAyNjcsLjk5OTk5LC45OTk5OCwuOTk5OTgsMSwuOTk5OTgsMS42NjQ3NSwxLC45OTk3MywuOTk5NzMsMS4wMDAyMywuOTk5NzMsLjk5OTcxLC45OTkyNSwxLjAwMDIzLDEsLjk5OTkxLC45OTk4NCwxLjAwMDAyLDEuMDAwMDIsMS4wMDAwMiwxLjAwMDAyLDEsMSwxLDEsMSwxLDEsLjk2MzI5LDEsMS4yMDk4NSwxLjM5NzEzLDEuMDAwMDMsLjgyNTQsMS4wMDAxNSwxLDEuMDAwMzUsMS4wMDAyNywxLjAwMDMxLDEuMDAwMzEsLjk5OTE1LDEuMDAwMzEsMS4wMDAzMSwuOTk5OTksMS4wMDAwMywuOTk5OTksLjk5OTk5LDEuNDExNDQsMS42LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MDU3OSwxLjQwNTc5LDEuMzY2MjUsLjk5OTk5LDEsLjk5ODYxLC45OTg2MSwxLDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsLjk1MzE3LC45OTk5OSwuOTk5OTksLjk5OTk5LC45OTk5OSwxLjQwNDgzLDEsLjk5OTc3LDEuMDAwNTQsMSwxLC45OTk1MywuOTk5NjIsMS4wMDA0MiwuOTk5NSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDFdO3QuSGVsdmV0aWNhUmVndWxhck1ldHJpY3M9e2xpbmVIZWlnaHQ6MS4yLGxpbmVHYXA6LjJ9fSwoZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LkxpYmVyYXRpb25TYW5zUmVndWxhcldpZHRocz10LkxpYmVyYXRpb25TYW5zUmVndWxhck1hcHBpbmc9dC5MaWJlcmF0aW9uU2Fuc0l0YWxpY1dpZHRocz10LkxpYmVyYXRpb25TYW5zSXRhbGljTWFwcGluZz10LkxpYmVyYXRpb25TYW5zQm9sZFdpZHRocz10LkxpYmVyYXRpb25TYW5zQm9sZE1hcHBpbmc9dC5MaWJlcmF0aW9uU2Fuc0JvbGRJdGFsaWNXaWR0aHM9dC5MaWJlcmF0aW9uU2Fuc0JvbGRJdGFsaWNNYXBwaW5nPXZvaWQgMDt0LkxpYmVyYXRpb25TYW5zQm9sZFdpZHRocz1bMzY1LDAsMzMzLDI3OCwzMzMsNDc0LDU1Niw1NTYsODg5LDcyMiwyMzgsMzMzLDMzMywzODksNTg0LDI3OCwzMzMsMjc4LDI3OCw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsMzMzLDMzMyw1ODQsNTg0LDU4NCw2MTEsOTc1LDcyMiw3MjIsNzIyLDcyMiw2NjcsNjExLDc3OCw3MjIsMjc4LDU1Niw3MjIsNjExLDgzMyw3MjIsNzc4LDY2Nyw3NzgsNzIyLDY2Nyw2MTEsNzIyLDY2Nyw5NDQsNjY3LDY2Nyw2MTEsMzMzLDI3OCwzMzMsNTg0LDU1NiwzMzMsNTU2LDYxMSw1NTYsNjExLDU1NiwzMzMsNjExLDYxMSwyNzgsMjc4LDU1NiwyNzgsODg5LDYxMSw2MTEsNjExLDYxMSwzODksNTU2LDMzMyw2MTEsNTU2LDc3OCw1NTYsNTU2LDUwMCwzODksMjgwLDM4OSw1ODQsMzMzLDU1Niw1NTYsNTU2LDU1NiwyODAsNTU2LDMzMyw3MzcsMzcwLDU1Niw1ODQsNzM3LDU1Miw0MDAsNTQ5LDMzMywzMzMsMzMzLDU3Niw1NTYsMjc4LDMzMywzMzMsMzY1LDU1Niw4MzQsODM0LDgzNCw2MTEsNzIyLDcyMiw3MjIsNzIyLDcyMiw3MjIsMWUzLDcyMiw2NjcsNjY3LDY2Nyw2NjcsMjc4LDI3OCwyNzgsMjc4LDcyMiw3MjIsNzc4LDc3OCw3NzgsNzc4LDc3OCw1ODQsNzc4LDcyMiw3MjIsNzIyLDcyMiw2NjcsNjY3LDYxMSw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw4ODksNTU2LDU1Niw1NTYsNTU2LDU1NiwyNzgsMjc4LDI3OCwyNzgsNjExLDYxMSw2MTEsNjExLDYxMSw2MTEsNjExLDU0OSw2MTEsNjExLDYxMSw2MTEsNjExLDU1Niw2MTEsNTU2LDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDcyMiw1NTYsNzIyLDcxOSw3MjIsNjExLDY2Nyw1NTYsNjY3LDU1Niw2NjcsNTU2LDY2Nyw1NTYsNjY3LDU1Niw3NzgsNjExLDc3OCw2MTEsNzc4LDYxMSw3NzgsNjExLDcyMiw2MTEsNzIyLDYxMSwyNzgsMjc4LDI3OCwyNzgsMjc4LDI3OCwyNzgsMjc4LDI3OCwyNzgsNzg1LDU1Niw1NTYsMjc4LDcyMiw1NTYsNTU2LDYxMSwyNzgsNjExLDI3OCw2MTEsMzg1LDYxMSw0NzksNjExLDI3OCw3MjIsNjExLDcyMiw2MTEsNzIyLDYxMSw3MDgsNzIzLDYxMSw3NzgsNjExLDc3OCw2MTEsNzc4LDYxMSwxZTMsOTQ0LDcyMiwzODksNzIyLDM4OSw3MjIsMzg5LDY2Nyw1NTYsNjY3LDU1Niw2NjcsNTU2LDY2Nyw1NTYsNjExLDMzMyw2MTEsNDc5LDYxMSwzMzMsNzIyLDYxMSw3MjIsNjExLDcyMiw2MTEsNzIyLDYxMSw3MjIsNjExLDcyMiw2MTEsOTQ0LDc3OCw2NjcsNTU2LDY2Nyw2MTEsNTAwLDYxMSw1MDAsNjExLDUwMCwyNzgsNTU2LDcyMiw1NTYsMWUzLDg4OSw3NzgsNjExLDY2Nyw1NTYsNjExLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsNDY1LDcyMiwzMzMsODUzLDkwNiw0NzQsODI1LDkyNyw4MzgsMjc4LDcyMiw3MjIsNjAxLDcxOSw2NjcsNjExLDcyMiw3NzgsMjc4LDcyMiw2NjcsODMzLDcyMiw2NDQsNzc4LDcyMiw2NjcsNjAwLDYxMSw2NjcsODIxLDY2Nyw4MDksODAyLDI3OCw2NjcsNjE1LDQ1MSw2MTEsMjc4LDU4Miw2MTUsNjEwLDU1Niw2MDYsNDc1LDQ2MCw2MTEsNTQxLDI3OCw1NTgsNTU2LDYxMiw1NTYsNDQ1LDYxMSw3NjYsNjE5LDUyMCw2ODQsNDQ2LDU4Miw3MTUsNTc2LDc1Myw4NDUsMjc4LDU4Miw2MTEsNTgyLDg0NSw2NjcsNjY5LDg4NSw1NjcsNzExLDY2NywyNzgsMjc2LDU1NiwxMDk0LDEwNjIsODc1LDYxMCw3MjIsNjIyLDcxOSw3MjIsNzE5LDcyMiw1NjcsNzEyLDY2Nyw5MDQsNjI2LDcxOSw3MTksNjEwLDcwMiw4MzMsNzIyLDc3OCw3MTksNjY3LDcyMiw2MTEsNjIyLDg1NCw2NjcsNzMwLDcwMywxMDA1LDEwMTksODcwLDk3OSw3MTksNzExLDEwMzEsNzE5LDU1Niw2MTgsNjE1LDQxNyw2MzUsNTU2LDcwOSw0OTcsNjE1LDYxNSw1MDAsNjM1LDc0MCw2MDQsNjExLDYwNCw2MTEsNTU2LDQ5MCw1NTYsODc1LDU1Niw2MTUsNTgxLDgzMyw4NDQsNzI5LDg1NCw2MTUsNTUyLDg1NCw1ODMsNTU2LDU1Niw2MTEsNDE3LDU1Miw1NTYsMjc4LDI4MSwyNzgsOTY5LDkwNiw2MTEsNTAwLDYxNSw1NTYsNjA0LDc3OCw2MTEsNDg3LDQ0Nyw5NDQsNzc4LDk0NCw3NzgsOTQ0LDc3OCw2NjcsNTU2LDMzMywzMzMsNTU2LDFlMywxZTMsNTUyLDI3OCwyNzgsMjc4LDI3OCw1MDAsNTAwLDUwMCw1NTYsNTU2LDM1MCwxZTMsMWUzLDI0MCw0NzksMzMzLDMzMyw2MDQsMzMzLDE2NywzOTYsNTU2LDU1NiwxMDk0LDU1Niw4ODUsNDg5LDExMTUsMWUzLDc2OCw2MDAsODM0LDgzNCw4MzQsODM0LDFlMyw1MDAsMWUzLDUwMCwxZTMsNTAwLDUwMCw0OTQsNjEyLDgyMyw3MTMsNTg0LDU0OSw3MTMsOTc5LDcyMiwyNzQsNTQ5LDU0OSw1ODMsNTQ5LDU0OSw2MDQsNTg0LDYwNCw2MDQsNzA4LDYyNSw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MjksNjA0LDYwNCwzNTQsMzU0LDFlMyw5OTAsOTkwLDk5MCw5OTAsNDk0LDYwNCw2MDQsNjA0LDYwNCwzNTQsMTAyMSwxMDUyLDkxNyw3NTAsNzUwLDUzMSw2NTYsNTk0LDUxMCw1MDAsNzUwLDc1MCw2MTEsNjExLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMjIyLDIyMiwzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzXTt0LkxpYmVyYXRpb25TYW5zQm9sZE1hcHBpbmc9Wy0xLC0xLC0xLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDU5LDYwLDYxLDYyLDYzLDY0LDY1LDY2LDY3LDY4LDY5LDcwLDcxLDcyLDczLDc0LDc1LDc2LDc3LDc4LDc5LDgwLDgxLDgyLDgzLDg0LDg1LDg2LDg3LDg4LDg5LDkwLDkxLDkyLDkzLDk0LDk1LDk2LDk3LDk4LDk5LDEwMCwxMDEsMTAyLDEwMywxMDQsMTA1LDEwNiwxMDcsMTA4LDEwOSwxMTAsMTExLDExMiwxMTMsMTE0LDExNSwxMTYsMTE3LDExOCwxMTksMTIwLDEyMSwxMjIsMTIzLDEyNCwxMjUsMTI2LDE2MSwxNjIsMTYzLDE2NCwxNjUsMTY2LDE2NywxNjgsMTY5LDE3MCwxNzEsMTcyLDE3NCwxNzUsMTc2LDE3NywxNzgsMTc5LDE4MCwxODEsMTgyLDE4MywxODQsMTg1LDE4NiwxODcsMTg4LDE4OSwxOTAsMTkxLDE5MiwxOTMsMTk0LDE5NSwxOTYsMTk3LDE5OCwxOTksMjAwLDIwMSwyMDIsMjAzLDIwNCwyMDUsMjA2LDIwNywyMDgsMjA5LDIxMCwyMTEsMjEyLDIxMywyMTQsMjE1LDIxNiwyMTcsMjE4LDIxOSwyMjAsMjIxLDIyMiwyMjMsMjI0LDIyNSwyMjYsMjI3LDIyOCwyMjksMjMwLDIzMSwyMzIsMjMzLDIzNCwyMzUsMjM2LDIzNywyMzgsMjM5LDI0MCwyNDEsMjQyLDI0MywyNDQsMjQ1LDI0NiwyNDcsMjQ4LDI0OSwyNTAsMjUxLDI1MiwyNTMsMjU0LDI1NSwyNTYsMjU3LDI1OCwyNTksMjYwLDI2MSwyNjIsMjYzLDI2NCwyNjUsMjY2LDI2NywyNjgsMjY5LDI3MCwyNzEsMjcyLDI3MywyNzQsMjc1LDI3NiwyNzcsMjc4LDI3OSwyODAsMjgxLDI4MiwyODMsMjg0LDI4NSwyODYsMjg3LDI4OCwyODksMjkwLDI5MSwyOTIsMjkzLDI5NCwyOTUsMjk2LDI5NywyOTgsMjk5LDMwMCwzMDEsMzAyLDMwMywzMDQsMzA1LDMwNiwzMDcsMzA4LDMwOSwzMTAsMzExLDMxMiwzMTMsMzE0LDMxNSwzMTYsMzE3LDMxOCwzMTksMzIwLDMyMSwzMjIsMzIzLDMyNCwzMjUsMzI2LDMyNywzMjgsMzI5LDMzMCwzMzEsMzMyLDMzMywzMzQsMzM1LDMzNiwzMzcsMzM4LDMzOSwzNDAsMzQxLDM0MiwzNDMsMzQ0LDM0NSwzNDYsMzQ3LDM0OCwzNDksMzUwLDM1MSwzNTIsMzUzLDM1NCwzNTUsMzU2LDM1NywzNTgsMzU5LDM2MCwzNjEsMzYyLDM2MywzNjQsMzY1LDM2NiwzNjcsMzY4LDM2OSwzNzAsMzcxLDM3MiwzNzMsMzc0LDM3NSwzNzYsMzc3LDM3OCwzNzksMzgwLDM4MSwzODIsMzgzLDQwMiw1MDYsNTA3LDUwOCw1MDksNTEwLDUxMSw1MzYsNTM3LDUzOCw1MzksNzEwLDcxMSw3MTMsNzI4LDcyOSw3MzAsNzMxLDczMiw3MzMsOTAwLDkwMSw5MDIsOTAzLDkwNCw5MDUsOTA2LDkwOCw5MTAsOTExLDkxMiw5MTMsOTE0LDkxNSw5MTYsOTE3LDkxOCw5MTksOTIwLDkyMSw5MjIsOTIzLDkyNCw5MjUsOTI2LDkyNyw5MjgsOTI5LDkzMSw5MzIsOTMzLDkzNCw5MzUsOTM2LDkzNyw5MzgsOTM5LDk0MCw5NDEsOTQyLDk0Myw5NDQsOTQ1LDk0Niw5NDcsOTQ4LDk0OSw5NTAsOTUxLDk1Miw5NTMsOTU0LDk1NSw5NTYsOTU3LDk1OCw5NTksOTYwLDk2MSw5NjIsOTYzLDk2NCw5NjUsOTY2LDk2Nyw5NjgsOTY5LDk3MCw5NzEsOTcyLDk3Myw5NzQsMTAyNCwxMDI1LDEwMjYsMTAyNywxMDI4LDEwMjksMTAzMCwxMDMxLDEwMzIsMTAzMywxMDM0LDEwMzUsMTAzNiwxMDM3LDEwMzgsMTAzOSwxMDQwLDEwNDEsMTA0MiwxMDQzLDEwNDQsMTA0NSwxMDQ2LDEwNDcsMTA0OCwxMDQ5LDEwNTAsMTA1MSwxMDUyLDEwNTMsMTA1NCwxMDU1LDEwNTYsMTA1NywxMDU4LDEwNTksMTA2MCwxMDYxLDEwNjIsMTA2MywxMDY0LDEwNjUsMTA2NiwxMDY3LDEwNjgsMTA2OSwxMDcwLDEwNzEsMTA3MiwxMDczLDEwNzQsMTA3NSwxMDc2LDEwNzcsMTA3OCwxMDc5LDEwODAsMTA4MSwxMDgyLDEwODMsMTA4NCwxMDg1LDEwODYsMTA4NywxMDg4LDEwODksMTA5MCwxMDkxLDEwOTIsMTA5MywxMDk0LDEwOTUsMTA5NiwxMDk3LDEwOTgsMTA5OSwxMTAwLDExMDEsMTEwMiwxMTAzLDExMDQsMTEwNSwxMTA2LDExMDcsMTEwOCwxMTA5LDExMTAsMTExMSwxMTEyLDExMTMsMTExNCwxMTE1LDExMTYsMTExNywxMTE4LDExMTksMTEzOCwxMTM5LDExNjgsMTE2OSw3ODA4LDc4MDksNzgxMCw3ODExLDc4MTIsNzgxMyw3OTIyLDc5MjMsODIwOCw4MjA5LDgyMTEsODIxMiw4MjEzLDgyMTUsODIxNiw4MjE3LDgyMTgsODIxOSw4MjIwLDgyMjEsODIyMiw4MjI0LDgyMjUsODIyNiw4MjMwLDgyNDAsODI0Miw4MjQzLDgyNDksODI1MCw4MjUyLDgyNTQsODI2MCw4MzE5LDgzNTUsODM1Niw4MzU5LDgzNjQsODQ1Myw4NDY3LDg0NzAsODQ4Miw4NDg2LDg0OTQsODUzOSw4NTQwLDg1NDEsODU0Miw4NTkyLDg1OTMsODU5NCw4NTk1LDg1OTYsODU5Nyw4NjE2LDg3MDYsODcxMCw4NzE5LDg3MjEsODcyMiw4NzMwLDg3MzQsODczNSw4NzQ1LDg3NDcsODc3Niw4ODAwLDg4MDEsODgwNCw4ODA1LDg5NjIsODk3Niw4OTkyLDg5OTMsOTQ3Miw5NDc0LDk0ODQsOTQ4OCw5NDkyLDk0OTYsOTUwMCw5NTA4LDk1MTYsOTUyNCw5NTMyLDk1NTIsOTU1Myw5NTU0LDk1NTUsOTU1Niw5NTU3LDk1NTgsOTU1OSw5NTYwLDk1NjEsOTU2Miw5NTYzLDk1NjQsOTU2NSw5NTY2LDk1NjcsOTU2OCw5NTY5LDk1NzAsOTU3MSw5NTcyLDk1NzMsOTU3NCw5NTc1LDk1NzYsOTU3Nyw5NTc4LDk1NzksOTU4MCw5NjAwLDk2MDQsOTYwOCw5NjEyLDk2MTYsOTYxNyw5NjE4LDk2MTksOTYzMiw5NjMzLDk2NDIsOTY0Myw5NjQ0LDk2NTAsOTY1OCw5NjYwLDk2NjgsOTY3NCw5Njc1LDk2NzksOTY4OCw5Njg5LDk3MDIsOTc4Niw5Nzg3LDk3ODgsOTc5Miw5Nzk0LDk4MjQsOTgyNyw5ODI5LDk4MzAsOTgzNCw5ODM1LDk4MzYsNjE0NDEsNjE0NDIsNjE0NDUsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTFdO3QuTGliZXJhdGlvblNhbnNCb2xkSXRhbGljV2lkdGhzPVszNjUsMCwzMzMsMjc4LDMzMyw0NzQsNTU2LDU1Niw4ODksNzIyLDIzOCwzMzMsMzMzLDM4OSw1ODQsMjc4LDMzMywyNzgsMjc4LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1NiwzMzMsMzMzLDU4NCw1ODQsNTg0LDYxMSw5NzUsNzIyLDcyMiw3MjIsNzIyLDY2Nyw2MTEsNzc4LDcyMiwyNzgsNTU2LDcyMiw2MTEsODMzLDcyMiw3NzgsNjY3LDc3OCw3MjIsNjY3LDYxMSw3MjIsNjY3LDk0NCw2NjcsNjY3LDYxMSwzMzMsMjc4LDMzMyw1ODQsNTU2LDMzMyw1NTYsNjExLDU1Niw2MTEsNTU2LDMzMyw2MTEsNjExLDI3OCwyNzgsNTU2LDI3OCw4ODksNjExLDYxMSw2MTEsNjExLDM4OSw1NTYsMzMzLDYxMSw1NTYsNzc4LDU1Niw1NTYsNTAwLDM4OSwyODAsMzg5LDU4NCwzMzMsNTU2LDU1Niw1NTYsNTU2LDI4MCw1NTYsMzMzLDczNywzNzAsNTU2LDU4NCw3MzcsNTUyLDQwMCw1NDksMzMzLDMzMywzMzMsNTc2LDU1NiwyNzgsMzMzLDMzMywzNjUsNTU2LDgzNCw4MzQsODM0LDYxMSw3MjIsNzIyLDcyMiw3MjIsNzIyLDcyMiwxZTMsNzIyLDY2Nyw2NjcsNjY3LDY2NywyNzgsMjc4LDI3OCwyNzgsNzIyLDcyMiw3NzgsNzc4LDc3OCw3NzgsNzc4LDU4NCw3NzgsNzIyLDcyMiw3MjIsNzIyLDY2Nyw2NjcsNjExLDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDg4OSw1NTYsNTU2LDU1Niw1NTYsNTU2LDI3OCwyNzgsMjc4LDI3OCw2MTEsNjExLDYxMSw2MTEsNjExLDYxMSw2MTEsNTQ5LDYxMSw2MTEsNjExLDYxMSw2MTEsNTU2LDYxMSw1NTYsNzIyLDU1Niw3MjIsNTU2LDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDcyMiw1NTYsNzIyLDU1Niw3MjIsNzQwLDcyMiw2MTEsNjY3LDU1Niw2NjcsNTU2LDY2Nyw1NTYsNjY3LDU1Niw2NjcsNTU2LDc3OCw2MTEsNzc4LDYxMSw3NzgsNjExLDc3OCw2MTEsNzIyLDYxMSw3MjIsNjExLDI3OCwyNzgsMjc4LDI3OCwyNzgsMjc4LDI3OCwyNzgsMjc4LDI3OCw3ODIsNTU2LDU1NiwyNzgsNzIyLDU1Niw1NTYsNjExLDI3OCw2MTEsMjc4LDYxMSwzOTYsNjExLDQ3OSw2MTEsMjc4LDcyMiw2MTEsNzIyLDYxMSw3MjIsNjExLDcwOCw3MjMsNjExLDc3OCw2MTEsNzc4LDYxMSw3NzgsNjExLDFlMyw5NDQsNzIyLDM4OSw3MjIsMzg5LDcyMiwzODksNjY3LDU1Niw2NjcsNTU2LDY2Nyw1NTYsNjY3LDU1Niw2MTEsMzMzLDYxMSw0NzksNjExLDMzMyw3MjIsNjExLDcyMiw2MTEsNzIyLDYxMSw3MjIsNjExLDcyMiw2MTEsNzIyLDYxMSw5NDQsNzc4LDY2Nyw1NTYsNjY3LDYxMSw1MDAsNjExLDUwMCw2MTEsNTAwLDI3OCw1NTYsNzIyLDU1NiwxZTMsODg5LDc3OCw2MTEsNjY3LDU1Niw2MTEsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsNzIyLDMzMyw4NTQsOTA2LDQ3Myw4NDQsOTMwLDg0NywyNzgsNzIyLDcyMiw2MTAsNjcxLDY2Nyw2MTEsNzIyLDc3OCwyNzgsNzIyLDY2Nyw4MzMsNzIyLDY1Nyw3NzgsNzE4LDY2Nyw1OTAsNjExLDY2Nyw4MjIsNjY3LDgyOSw3ODEsMjc4LDY2Nyw2MjAsNDc5LDYxMSwyNzgsNTkxLDYyMCw2MjEsNTU2LDYxMCw0NzksNDkyLDYxMSw1NTgsMjc4LDU2Niw1NTYsNjAzLDU1Niw0NTAsNjExLDcxMiw2MDUsNTMyLDY2NCw0MDksNTkxLDcwNCw1NzgsNzczLDgzNCwyNzgsNTkxLDYxMSw1OTEsODM0LDY2Nyw2NjcsODg2LDYxNCw3MTksNjY3LDI3OCwyNzgsNTU2LDEwOTQsMTA0Miw4NTQsNjIyLDcxOSw2NzcsNzE5LDcyMiw3MDgsNzIyLDYxNCw3MjIsNjY3LDkyNyw2NDMsNzE5LDcxOSw2MTUsNjg3LDgzMyw3MjIsNzc4LDcxOSw2NjcsNzIyLDYxMSw2NzcsNzgxLDY2Nyw3MjksNzA4LDk3OSw5ODksODU0LDFlMyw3MDgsNzE5LDEwNDIsNzI5LDU1Niw2MTksNjA0LDUzNCw2MTgsNTU2LDczNiw1MTAsNjExLDYxMSw1MDcsNjIyLDc0MCw2MDQsNjExLDYxMSw2MTEsNTU2LDg4OSw1NTYsODg1LDU1Niw2NDYsNTgzLDg4OSw5MzUsNzA3LDg1NCw1OTQsNTUyLDg2NSw1ODksNTU2LDU1Niw2MTEsNDY5LDU2Myw1NTYsMjc4LDI3OCwyNzgsOTY5LDkwNiw2MTEsNTA3LDYxOSw1NTYsNjExLDc3OCw2MTEsNTc1LDQ2Nyw5NDQsNzc4LDk0NCw3NzgsOTQ0LDc3OCw2NjcsNTU2LDMzMywzMzMsNTU2LDFlMywxZTMsNTUyLDI3OCwyNzgsMjc4LDI3OCw1MDAsNTAwLDUwMCw1NTYsNTU2LDM1MCwxZTMsMWUzLDI0MCw0NzksMzMzLDMzMyw2MDQsMzMzLDE2NywzOTYsNTU2LDU1NiwxMTA0LDU1Niw4ODUsNTE2LDExNDYsMWUzLDc2OCw2MDAsODM0LDgzNCw4MzQsODM0LDk5OSw1MDAsMWUzLDUwMCwxZTMsNTAwLDUwMCw0OTQsNjEyLDgyMyw3MTMsNTg0LDU0OSw3MTMsOTc5LDcyMiwyNzQsNTQ5LDU0OSw1ODMsNTQ5LDU0OSw2MDQsNTg0LDYwNCw2MDQsNzA4LDYyNSw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MjksNjA0LDYwNCwzNTQsMzU0LDFlMyw5OTAsOTkwLDk5MCw5OTAsNDk0LDYwNCw2MDQsNjA0LDYwNCwzNTQsMTAyMSwxMDUyLDkxNyw3NTAsNzUwLDUzMSw2NTYsNTk0LDUxMCw1MDAsNzUwLDc1MCw2MTEsNjExLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMjIyLDIyMiwzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzXTt0LkxpYmVyYXRpb25TYW5zQm9sZEl0YWxpY01hcHBpbmc9Wy0xLC0xLC0xLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDU5LDYwLDYxLDYyLDYzLDY0LDY1LDY2LDY3LDY4LDY5LDcwLDcxLDcyLDczLDc0LDc1LDc2LDc3LDc4LDc5LDgwLDgxLDgyLDgzLDg0LDg1LDg2LDg3LDg4LDg5LDkwLDkxLDkyLDkzLDk0LDk1LDk2LDk3LDk4LDk5LDEwMCwxMDEsMTAyLDEwMywxMDQsMTA1LDEwNiwxMDcsMTA4LDEwOSwxMTAsMTExLDExMiwxMTMsMTE0LDExNSwxMTYsMTE3LDExOCwxMTksMTIwLDEyMSwxMjIsMTIzLDEyNCwxMjUsMTI2LDE2MSwxNjIsMTYzLDE2NCwxNjUsMTY2LDE2NywxNjgsMTY5LDE3MCwxNzEsMTcyLDE3NCwxNzUsMTc2LDE3NywxNzgsMTc5LDE4MCwxODEsMTgyLDE4MywxODQsMTg1LDE4NiwxODcsMTg4LDE4OSwxOTAsMTkxLDE5MiwxOTMsMTk0LDE5NSwxOTYsMTk3LDE5OCwxOTksMjAwLDIwMSwyMDIsMjAzLDIwNCwyMDUsMjA2LDIwNywyMDgsMjA5LDIxMCwyMTEsMjEyLDIxMywyMTQsMjE1LDIxNiwyMTcsMjE4LDIxOSwyMjAsMjIxLDIyMiwyMjMsMjI0LDIyNSwyMjYsMjI3LDIyOCwyMjksMjMwLDIzMSwyMzIsMjMzLDIzNCwyMzUsMjM2LDIzNywyMzgsMjM5LDI0MCwyNDEsMjQyLDI0MywyNDQsMjQ1LDI0NiwyNDcsMjQ4LDI0OSwyNTAsMjUxLDI1MiwyNTMsMjU0LDI1NSwyNTYsMjU3LDI1OCwyNTksMjYwLDI2MSwyNjIsMjYzLDI2NCwyNjUsMjY2LDI2NywyNjgsMjY5LDI3MCwyNzEsMjcyLDI3MywyNzQsMjc1LDI3NiwyNzcsMjc4LDI3OSwyODAsMjgxLDI4MiwyODMsMjg0LDI4NSwyODYsMjg3LDI4OCwyODksMjkwLDI5MSwyOTIsMjkzLDI5NCwyOTUsMjk2LDI5NywyOTgsMjk5LDMwMCwzMDEsMzAyLDMwMywzMDQsMzA1LDMwNiwzMDcsMzA4LDMwOSwzMTAsMzExLDMxMiwzMTMsMzE0LDMxNSwzMTYsMzE3LDMxOCwzMTksMzIwLDMyMSwzMjIsMzIzLDMyNCwzMjUsMzI2LDMyNywzMjgsMzI5LDMzMCwzMzEsMzMyLDMzMywzMzQsMzM1LDMzNiwzMzcsMzM4LDMzOSwzNDAsMzQxLDM0MiwzNDMsMzQ0LDM0NSwzNDYsMzQ3LDM0OCwzNDksMzUwLDM1MSwzNTIsMzUzLDM1NCwzNTUsMzU2LDM1NywzNTgsMzU5LDM2MCwzNjEsMzYyLDM2MywzNjQsMzY1LDM2NiwzNjcsMzY4LDM2OSwzNzAsMzcxLDM3MiwzNzMsMzc0LDM3NSwzNzYsMzc3LDM3OCwzNzksMzgwLDM4MSwzODIsMzgzLDQwMiw1MDYsNTA3LDUwOCw1MDksNTEwLDUxMSw1MzYsNTM3LDUzOCw1MzksNzEwLDcxMSw3MTMsNzI4LDcyOSw3MzAsNzMxLDczMiw3MzMsOTAwLDkwMSw5MDIsOTAzLDkwNCw5MDUsOTA2LDkwOCw5MTAsOTExLDkxMiw5MTMsOTE0LDkxNSw5MTYsOTE3LDkxOCw5MTksOTIwLDkyMSw5MjIsOTIzLDkyNCw5MjUsOTI2LDkyNyw5MjgsOTI5LDkzMSw5MzIsOTMzLDkzNCw5MzUsOTM2LDkzNyw5MzgsOTM5LDk0MCw5NDEsOTQyLDk0Myw5NDQsOTQ1LDk0Niw5NDcsOTQ4LDk0OSw5NTAsOTUxLDk1Miw5NTMsOTU0LDk1NSw5NTYsOTU3LDk1OCw5NTksOTYwLDk2MSw5NjIsOTYzLDk2NCw5NjUsOTY2LDk2Nyw5NjgsOTY5LDk3MCw5NzEsOTcyLDk3Myw5NzQsMTAyNCwxMDI1LDEwMjYsMTAyNywxMDI4LDEwMjksMTAzMCwxMDMxLDEwMzIsMTAzMywxMDM0LDEwMzUsMTAzNiwxMDM3LDEwMzgsMTAzOSwxMDQwLDEwNDEsMTA0MiwxMDQzLDEwNDQsMTA0NSwxMDQ2LDEwNDcsMTA0OCwxMDQ5LDEwNTAsMTA1MSwxMDUyLDEwNTMsMTA1NCwxMDU1LDEwNTYsMTA1NywxMDU4LDEwNTksMTA2MCwxMDYxLDEwNjIsMTA2MywxMDY0LDEwNjUsMTA2NiwxMDY3LDEwNjgsMTA2OSwxMDcwLDEwNzEsMTA3MiwxMDczLDEwNzQsMTA3NSwxMDc2LDEwNzcsMTA3OCwxMDc5LDEwODAsMTA4MSwxMDgyLDEwODMsMTA4NCwxMDg1LDEwODYsMTA4NywxMDg4LDEwODksMTA5MCwxMDkxLDEwOTIsMTA5MywxMDk0LDEwOTUsMTA5NiwxMDk3LDEwOTgsMTA5OSwxMTAwLDExMDEsMTEwMiwxMTAzLDExMDQsMTEwNSwxMTA2LDExMDcsMTEwOCwxMTA5LDExMTAsMTExMSwxMTEyLDExMTMsMTExNCwxMTE1LDExMTYsMTExNywxMTE4LDExMTksMTEzOCwxMTM5LDExNjgsMTE2OSw3ODA4LDc4MDksNzgxMCw3ODExLDc4MTIsNzgxMyw3OTIyLDc5MjMsODIwOCw4MjA5LDgyMTEsODIxMiw4MjEzLDgyMTUsODIxNiw4MjE3LDgyMTgsODIxOSw4MjIwLDgyMjEsODIyMiw4MjI0LDgyMjUsODIyNiw4MjMwLDgyNDAsODI0Miw4MjQzLDgyNDksODI1MCw4MjUyLDgyNTQsODI2MCw4MzE5LDgzNTUsODM1Niw4MzU5LDgzNjQsODQ1Myw4NDY3LDg0NzAsODQ4Miw4NDg2LDg0OTQsODUzOSw4NTQwLDg1NDEsODU0Miw4NTkyLDg1OTMsODU5NCw4NTk1LDg1OTYsODU5Nyw4NjE2LDg3MDYsODcxMCw4NzE5LDg3MjEsODcyMiw4NzMwLDg3MzQsODczNSw4NzQ1LDg3NDcsODc3Niw4ODAwLDg4MDEsODgwNCw4ODA1LDg5NjIsODk3Niw4OTkyLDg5OTMsOTQ3Miw5NDc0LDk0ODQsOTQ4OCw5NDkyLDk0OTYsOTUwMCw5NTA4LDk1MTYsOTUyNCw5NTMyLDk1NTIsOTU1Myw5NTU0LDk1NTUsOTU1Niw5NTU3LDk1NTgsOTU1OSw5NTYwLDk1NjEsOTU2Miw5NTYzLDk1NjQsOTU2NSw5NTY2LDk1NjcsOTU2OCw5NTY5LDk1NzAsOTU3MSw5NTcyLDk1NzMsOTU3NCw5NTc1LDk1NzYsOTU3Nyw5NTc4LDk1NzksOTU4MCw5NjAwLDk2MDQsOTYwOCw5NjEyLDk2MTYsOTYxNyw5NjE4LDk2MTksOTYzMiw5NjMzLDk2NDIsOTY0Myw5NjQ0LDk2NTAsOTY1OCw5NjYwLDk2NjgsOTY3NCw5Njc1LDk2NzksOTY4OCw5Njg5LDk3MDIsOTc4Niw5Nzg3LDk3ODgsOTc5Miw5Nzk0LDk4MjQsOTgyNyw5ODI5LDk4MzAsOTgzNCw5ODM1LDk4MzYsNjE0NDEsNjE0NDIsNjE0NDUsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTFdO3QuTGliZXJhdGlvblNhbnNJdGFsaWNXaWR0aHM9WzM2NSwwLDMzMywyNzgsMjc4LDM1NSw1NTYsNTU2LDg4OSw2NjcsMTkxLDMzMywzMzMsMzg5LDU4NCwyNzgsMzMzLDI3OCwyNzgsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDI3OCwyNzgsNTg0LDU4NCw1ODQsNTU2LDEwMTUsNjY3LDY2Nyw3MjIsNzIyLDY2Nyw2MTEsNzc4LDcyMiwyNzgsNTAwLDY2Nyw1NTYsODMzLDcyMiw3NzgsNjY3LDc3OCw3MjIsNjY3LDYxMSw3MjIsNjY3LDk0NCw2NjcsNjY3LDYxMSwyNzgsMjc4LDI3OCw0NjksNTU2LDMzMyw1NTYsNTU2LDUwMCw1NTYsNTU2LDI3OCw1NTYsNTU2LDIyMiwyMjIsNTAwLDIyMiw4MzMsNTU2LDU1Niw1NTYsNTU2LDMzMyw1MDAsMjc4LDU1Niw1MDAsNzIyLDUwMCw1MDAsNTAwLDMzNCwyNjAsMzM0LDU4NCwzMzMsNTU2LDU1Niw1NTYsNTU2LDI2MCw1NTYsMzMzLDczNywzNzAsNTU2LDU4NCw3MzcsNTUyLDQwMCw1NDksMzMzLDMzMywzMzMsNTc2LDUzNywyNzgsMzMzLDMzMywzNjUsNTU2LDgzNCw4MzQsODM0LDYxMSw2NjcsNjY3LDY2Nyw2NjcsNjY3LDY2NywxZTMsNzIyLDY2Nyw2NjcsNjY3LDY2NywyNzgsMjc4LDI3OCwyNzgsNzIyLDcyMiw3NzgsNzc4LDc3OCw3NzgsNzc4LDU4NCw3NzgsNzIyLDcyMiw3MjIsNzIyLDY2Nyw2NjcsNjExLDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDg4OSw1MDAsNTU2LDU1Niw1NTYsNTU2LDI3OCwyNzgsMjc4LDI3OCw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTQ5LDYxMSw1NTYsNTU2LDU1Niw1NTYsNTAwLDU1Niw1MDAsNjY3LDU1Niw2NjcsNTU2LDY2Nyw1NTYsNzIyLDUwMCw3MjIsNTAwLDcyMiw1MDAsNzIyLDUwMCw3MjIsNjI1LDcyMiw1NTYsNjY3LDU1Niw2NjcsNTU2LDY2Nyw1NTYsNjY3LDU1Niw2NjcsNTU2LDc3OCw1NTYsNzc4LDU1Niw3NzgsNTU2LDc3OCw1NTYsNzIyLDU1Niw3MjIsNTU2LDI3OCwyNzgsMjc4LDI3OCwyNzgsMjc4LDI3OCwyMjIsMjc4LDI3OCw3MzMsNDQ0LDUwMCwyMjIsNjY3LDUwMCw1MDAsNTU2LDIyMiw1NTYsMjIyLDU1NiwyODEsNTU2LDQwMCw1NTYsMjIyLDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDYxNSw3MjMsNTU2LDc3OCw1NTYsNzc4LDU1Niw3NzgsNTU2LDFlMyw5NDQsNzIyLDMzMyw3MjIsMzMzLDcyMiwzMzMsNjY3LDUwMCw2NjcsNTAwLDY2Nyw1MDAsNjY3LDUwMCw2MTEsMjc4LDYxMSwzNTQsNjExLDI3OCw3MjIsNTU2LDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDcyMiw1NTYsNzIyLDU1Niw5NDQsNzIyLDY2Nyw1MDAsNjY3LDYxMSw1MDAsNjExLDUwMCw2MTEsNTAwLDIyMiw1NTYsNjY3LDU1NiwxZTMsODg5LDc3OCw2MTEsNjY3LDUwMCw2MTEsMjc4LDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsNjY3LDI3OCw3ODksODQ2LDM4OSw3OTQsODY1LDc3NSwyMjIsNjY3LDY2Nyw1NzAsNjcxLDY2Nyw2MTEsNzIyLDc3OCwyNzgsNjY3LDY2Nyw4MzMsNzIyLDY0OCw3NzgsNzI1LDY2Nyw2MDAsNjExLDY2Nyw4MzcsNjY3LDgzMSw3NjEsMjc4LDY2Nyw1NzAsNDM5LDU1NSwyMjIsNTUwLDU3MCw1NzEsNTAwLDU1Niw0MzksNDYzLDU1NSw1NDIsMjIyLDUwMCw0OTIsNTQ4LDUwMCw0NDcsNTU2LDY3MCw1NzMsNDg2LDYwMywzNzQsNTUwLDY1Miw1NDYsNzI4LDc3OSwyMjIsNTUwLDU1Niw1NTAsNzc5LDY2Nyw2NjcsODQzLDU0NCw3MDgsNjY3LDI3OCwyNzgsNTAwLDEwNjYsOTgyLDg0NCw1ODksNzE1LDYzOSw3MjQsNjY3LDY1MSw2NjcsNTQ0LDcwNCw2NjcsOTE3LDYxNCw3MTUsNzE1LDU4OSw2ODYsODMzLDcyMiw3NzgsNzI1LDY2Nyw3MjIsNjExLDYzOSw3OTUsNjY3LDcyNyw2NzMsOTIwLDkyMyw4MDUsODg2LDY1MSw2OTQsMTAyMiw2ODIsNTU2LDU2Miw1MjIsNDkzLDU1Myw1NTYsNjg4LDQ2NSw1NTYsNTU2LDQ3Miw1NjQsNjg2LDU1MCw1NTYsNTU2LDU1Niw1MDAsODMzLDUwMCw4MzUsNTAwLDU3Miw1MTgsODMwLDg1MSw2MjEsNzM2LDUyNiw0OTIsNzUyLDUzNCw1NTYsNTU2LDU1NiwzNzgsNDk2LDUwMCwyMjIsMjIyLDIyMiw5MTAsODI4LDU1Niw0NzIsNTY1LDUwMCw1NTYsNzc4LDU1Niw0OTIsMzM5LDk0NCw3MjIsOTQ0LDcyMiw5NDQsNzIyLDY2Nyw1MDAsMzMzLDMzMyw1NTYsMWUzLDFlMyw1NTIsMjIyLDIyMiwyMjIsMjIyLDMzMywzMzMsMzMzLDU1Niw1NTYsMzUwLDFlMywxZTMsMTg4LDM1NCwzMzMsMzMzLDUwMCwzMzMsMTY3LDM2NSw1NTYsNTU2LDEwOTQsNTU2LDg4NSwzMjMsMTA4MywxZTMsNzY4LDYwMCw4MzQsODM0LDgzNCw4MzQsMWUzLDUwMCw5OTgsNTAwLDFlMyw1MDAsNTAwLDQ5NCw2MTIsODIzLDcxMyw1ODQsNTQ5LDcxMyw5NzksNzE5LDI3NCw1NDksNTQ5LDU4NCw1NDksNTQ5LDYwNCw1ODQsNjA0LDYwNCw3MDgsNjI1LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcyOSw2MDQsNjA0LDM1NCwzNTQsMWUzLDk5MCw5OTAsOTkwLDk5MCw0OTQsNjA0LDYwNCw2MDQsNjA0LDM1NCwxMDIxLDEwNTIsOTE3LDc1MCw3NTAsNTMxLDY1Niw1OTQsNTEwLDUwMCw3NTAsNzUwLDUwMCw1MDAsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywyMjIsMjIyLDI5NCwyOTQsMzI0LDMyNCwzMTYsMzI4LDM5OCwyODVdO3QuTGliZXJhdGlvblNhbnNJdGFsaWNNYXBwaW5nPVstMSwtMSwtMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1Nyw1OCw1OSw2MCw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw3NSw3Niw3Nyw3OCw3OSw4MCw4MSw4Miw4Myw4NCw4NSw4Niw4Nyw4OCw4OSw5MCw5MSw5Miw5Myw5NCw5NSw5Niw5Nyw5OCw5OSwxMDAsMTAxLDEwMiwxMDMsMTA0LDEwNSwxMDYsMTA3LDEwOCwxMDksMTEwLDExMSwxMTIsMTEzLDExNCwxMTUsMTE2LDExNywxMTgsMTE5LDEyMCwxMjEsMTIyLDEyMywxMjQsMTI1LDEyNiwxNjEsMTYyLDE2MywxNjQsMTY1LDE2NiwxNjcsMTY4LDE2OSwxNzAsMTcxLDE3MiwxNzQsMTc1LDE3NiwxNzcsMTc4LDE3OSwxODAsMTgxLDE4MiwxODMsMTg0LDE4NSwxODYsMTg3LDE4OCwxODksMTkwLDE5MSwxOTIsMTkzLDE5NCwxOTUsMTk2LDE5NywxOTgsMTk5LDIwMCwyMDEsMjAyLDIwMywyMDQsMjA1LDIwNiwyMDcsMjA4LDIwOSwyMTAsMjExLDIxMiwyMTMsMjE0LDIxNSwyMTYsMjE3LDIxOCwyMTksMjIwLDIyMSwyMjIsMjIzLDIyNCwyMjUsMjI2LDIyNywyMjgsMjI5LDIzMCwyMzEsMjMyLDIzMywyMzQsMjM1LDIzNiwyMzcsMjM4LDIzOSwyNDAsMjQxLDI0MiwyNDMsMjQ0LDI0NSwyNDYsMjQ3LDI0OCwyNDksMjUwLDI1MSwyNTIsMjUzLDI1NCwyNTUsMjU2LDI1NywyNTgsMjU5LDI2MCwyNjEsMjYyLDI2MywyNjQsMjY1LDI2NiwyNjcsMjY4LDI2OSwyNzAsMjcxLDI3MiwyNzMsMjc0LDI3NSwyNzYsMjc3LDI3OCwyNzksMjgwLDI4MSwyODIsMjgzLDI4NCwyODUsMjg2LDI4NywyODgsMjg5LDI5MCwyOTEsMjkyLDI5MywyOTQsMjk1LDI5NiwyOTcsMjk4LDI5OSwzMDAsMzAxLDMwMiwzMDMsMzA0LDMwNSwzMDYsMzA3LDMwOCwzMDksMzEwLDMxMSwzMTIsMzEzLDMxNCwzMTUsMzE2LDMxNywzMTgsMzE5LDMyMCwzMjEsMzIyLDMyMywzMjQsMzI1LDMyNiwzMjcsMzI4LDMyOSwzMzAsMzMxLDMzMiwzMzMsMzM0LDMzNSwzMzYsMzM3LDMzOCwzMzksMzQwLDM0MSwzNDIsMzQzLDM0NCwzNDUsMzQ2LDM0NywzNDgsMzQ5LDM1MCwzNTEsMzUyLDM1MywzNTQsMzU1LDM1NiwzNTcsMzU4LDM1OSwzNjAsMzYxLDM2MiwzNjMsMzY0LDM2NSwzNjYsMzY3LDM2OCwzNjksMzcwLDM3MSwzNzIsMzczLDM3NCwzNzUsMzc2LDM3NywzNzgsMzc5LDM4MCwzODEsMzgyLDM4Myw0MDIsNTA2LDUwNyw1MDgsNTA5LDUxMCw1MTEsNTM2LDUzNyw1MzgsNTM5LDcxMCw3MTEsNzEzLDcyOCw3MjksNzMwLDczMSw3MzIsNzMzLDkwMCw5MDEsOTAyLDkwMyw5MDQsOTA1LDkwNiw5MDgsOTEwLDkxMSw5MTIsOTEzLDkxNCw5MTUsOTE2LDkxNyw5MTgsOTE5LDkyMCw5MjEsOTIyLDkyMyw5MjQsOTI1LDkyNiw5MjcsOTI4LDkyOSw5MzEsOTMyLDkzMyw5MzQsOTM1LDkzNiw5MzcsOTM4LDkzOSw5NDAsOTQxLDk0Miw5NDMsOTQ0LDk0NSw5NDYsOTQ3LDk0OCw5NDksOTUwLDk1MSw5NTIsOTUzLDk1NCw5NTUsOTU2LDk1Nyw5NTgsOTU5LDk2MCw5NjEsOTYyLDk2Myw5NjQsOTY1LDk2Niw5NjcsOTY4LDk2OSw5NzAsOTcxLDk3Miw5NzMsOTc0LDEwMjQsMTAyNSwxMDI2LDEwMjcsMTAyOCwxMDI5LDEwMzAsMTAzMSwxMDMyLDEwMzMsMTAzNCwxMDM1LDEwMzYsMTAzNywxMDM4LDEwMzksMTA0MCwxMDQxLDEwNDIsMTA0MywxMDQ0LDEwNDUsMTA0NiwxMDQ3LDEwNDgsMTA0OSwxMDUwLDEwNTEsMTA1MiwxMDUzLDEwNTQsMTA1NSwxMDU2LDEwNTcsMTA1OCwxMDU5LDEwNjAsMTA2MSwxMDYyLDEwNjMsMTA2NCwxMDY1LDEwNjYsMTA2NywxMDY4LDEwNjksMTA3MCwxMDcxLDEwNzIsMTA3MywxMDc0LDEwNzUsMTA3NiwxMDc3LDEwNzgsMTA3OSwxMDgwLDEwODEsMTA4MiwxMDgzLDEwODQsMTA4NSwxMDg2LDEwODcsMTA4OCwxMDg5LDEwOTAsMTA5MSwxMDkyLDEwOTMsMTA5NCwxMDk1LDEwOTYsMTA5NywxMDk4LDEwOTksMTEwMCwxMTAxLDExMDIsMTEwMywxMTA0LDExMDUsMTEwNiwxMTA3LDExMDgsMTEwOSwxMTEwLDExMTEsMTExMiwxMTEzLDExMTQsMTExNSwxMTE2LDExMTcsMTExOCwxMTE5LDExMzgsMTEzOSwxMTY4LDExNjksNzgwOCw3ODA5LDc4MTAsNzgxMSw3ODEyLDc4MTMsNzkyMiw3OTIzLDgyMDgsODIwOSw4MjExLDgyMTIsODIxMyw4MjE1LDgyMTYsODIxNyw4MjE4LDgyMTksODIyMCw4MjIxLDgyMjIsODIyNCw4MjI1LDgyMjYsODIzMCw4MjQwLDgyNDIsODI0Myw4MjQ5LDgyNTAsODI1Miw4MjU0LDgyNjAsODMxOSw4MzU1LDgzNTYsODM1OSw4MzY0LDg0NTMsODQ2Nyw4NDcwLDg0ODIsODQ4Niw4NDk0LDg1MzksODU0MCw4NTQxLDg1NDIsODU5Miw4NTkzLDg1OTQsODU5NSw4NTk2LDg1OTcsODYxNiw4NzA2LDg3MTAsODcxOSw4NzIxLDg3MjIsODczMCw4NzM0LDg3MzUsODc0NSw4NzQ3LDg3NzYsODgwMCw4ODAxLDg4MDQsODgwNSw4OTYyLDg5NzYsODk5Miw4OTkzLDk0NzIsOTQ3NCw5NDg0LDk0ODgsOTQ5Miw5NDk2LDk1MDAsOTUwOCw5NTE2LDk1MjQsOTUzMiw5NTUyLDk1NTMsOTU1NCw5NTU1LDk1NTYsOTU1Nyw5NTU4LDk1NTksOTU2MCw5NTYxLDk1NjIsOTU2Myw5NTY0LDk1NjUsOTU2Niw5NTY3LDk1NjgsOTU2OSw5NTcwLDk1NzEsOTU3Miw5NTczLDk1NzQsOTU3NSw5NTc2LDk1NzcsOTU3OCw5NTc5LDk1ODAsOTYwMCw5NjA0LDk2MDgsOTYxMiw5NjE2LDk2MTcsOTYxOCw5NjE5LDk2MzIsOTYzMyw5NjQyLDk2NDMsOTY0NCw5NjUwLDk2NTgsOTY2MCw5NjY4LDk2NzQsOTY3NSw5Njc5LDk2ODgsOTY4OSw5NzAyLDk3ODYsOTc4Nyw5Nzg4LDk3OTIsOTc5NCw5ODI0LDk4MjcsOTgyOSw5ODMwLDk4MzQsOTgzNSw5ODM2LDYxNDQxLDYxNDQyLDYxNDQ1LC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xXTt0LkxpYmVyYXRpb25TYW5zUmVndWxhcldpZHRocz1bMzY1LDAsMzMzLDI3OCwyNzgsMzU1LDU1Niw1NTYsODg5LDY2NywxOTEsMzMzLDMzMywzODksNTg0LDI3OCwzMzMsMjc4LDI3OCw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsMjc4LDI3OCw1ODQsNTg0LDU4NCw1NTYsMTAxNSw2NjcsNjY3LDcyMiw3MjIsNjY3LDYxMSw3NzgsNzIyLDI3OCw1MDAsNjY3LDU1Niw4MzMsNzIyLDc3OCw2NjcsNzc4LDcyMiw2NjcsNjExLDcyMiw2NjcsOTQ0LDY2Nyw2NjcsNjExLDI3OCwyNzgsMjc4LDQ2OSw1NTYsMzMzLDU1Niw1NTYsNTAwLDU1Niw1NTYsMjc4LDU1Niw1NTYsMjIyLDIyMiw1MDAsMjIyLDgzMyw1NTYsNTU2LDU1Niw1NTYsMzMzLDUwMCwyNzgsNTU2LDUwMCw3MjIsNTAwLDUwMCw1MDAsMzM0LDI2MCwzMzQsNTg0LDMzMyw1NTYsNTU2LDU1Niw1NTYsMjYwLDU1NiwzMzMsNzM3LDM3MCw1NTYsNTg0LDczNyw1NTIsNDAwLDU0OSwzMzMsMzMzLDMzMyw1NzYsNTM3LDI3OCwzMzMsMzMzLDM2NSw1NTYsODM0LDgzNCw4MzQsNjExLDY2Nyw2NjcsNjY3LDY2Nyw2NjcsNjY3LDFlMyw3MjIsNjY3LDY2Nyw2NjcsNjY3LDI3OCwyNzgsMjc4LDI3OCw3MjIsNzIyLDc3OCw3NzgsNzc4LDc3OCw3NzgsNTg0LDc3OCw3MjIsNzIyLDcyMiw3MjIsNjY3LDY2Nyw2MTEsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsODg5LDUwMCw1NTYsNTU2LDU1Niw1NTYsMjc4LDI3OCwyNzgsMjc4LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NDksNjExLDU1Niw1NTYsNTU2LDU1Niw1MDAsNTU2LDUwMCw2NjcsNTU2LDY2Nyw1NTYsNjY3LDU1Niw3MjIsNTAwLDcyMiw1MDAsNzIyLDUwMCw3MjIsNTAwLDcyMiw2MTUsNzIyLDU1Niw2NjcsNTU2LDY2Nyw1NTYsNjY3LDU1Niw2NjcsNTU2LDY2Nyw1NTYsNzc4LDU1Niw3NzgsNTU2LDc3OCw1NTYsNzc4LDU1Niw3MjIsNTU2LDcyMiw1NTYsMjc4LDI3OCwyNzgsMjc4LDI3OCwyNzgsMjc4LDIyMiwyNzgsMjc4LDczNSw0NDQsNTAwLDIyMiw2NjcsNTAwLDUwMCw1NTYsMjIyLDU1NiwyMjIsNTU2LDI5Miw1NTYsMzM0LDU1NiwyMjIsNzIyLDU1Niw3MjIsNTU2LDcyMiw1NTYsNjA0LDcyMyw1NTYsNzc4LDU1Niw3NzgsNTU2LDc3OCw1NTYsMWUzLDk0NCw3MjIsMzMzLDcyMiwzMzMsNzIyLDMzMyw2NjcsNTAwLDY2Nyw1MDAsNjY3LDUwMCw2NjcsNTAwLDYxMSwyNzgsNjExLDM3NSw2MTEsMjc4LDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDk0NCw3MjIsNjY3LDUwMCw2NjcsNjExLDUwMCw2MTEsNTAwLDYxMSw1MDAsMjIyLDU1Niw2NjcsNTU2LDFlMyw4ODksNzc4LDYxMSw2NjcsNTAwLDYxMSwyNzgsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMyw2NjcsMjc4LDc4NCw4MzgsMzg0LDc3NCw4NTUsNzUyLDIyMiw2NjcsNjY3LDU1MSw2NjgsNjY3LDYxMSw3MjIsNzc4LDI3OCw2NjcsNjY4LDgzMyw3MjIsNjUwLDc3OCw3MjIsNjY3LDYxOCw2MTEsNjY3LDc5OCw2NjcsODM1LDc0OCwyNzgsNjY3LDU3OCw0NDYsNTU2LDIyMiw1NDcsNTc4LDU3NSw1MDAsNTU3LDQ0Niw0NDEsNTU2LDU1NiwyMjIsNTAwLDUwMCw1NzYsNTAwLDQ0OCw1NTYsNjkwLDU2OSw0ODIsNjE3LDM5NSw1NDcsNjQ4LDUyNSw3MTMsNzgxLDIyMiw1NDcsNTU2LDU0Nyw3ODEsNjY3LDY2Nyw4NjUsNTQyLDcxOSw2NjcsMjc4LDI3OCw1MDAsMTA1NywxMDEwLDg1NCw1ODMsNzIyLDYzNSw3MTksNjY3LDY1Niw2NjcsNTQyLDY3Nyw2NjcsOTIzLDYwNCw3MTksNzE5LDU4Myw2NTYsODMzLDcyMiw3NzgsNzE5LDY2Nyw3MjIsNjExLDYzNSw3NjAsNjY3LDc0MCw2NjcsOTE3LDkzOCw3OTIsODg1LDY1Niw3MTksMTAxMCw3MjIsNTU2LDU3Myw1MzEsMzY1LDU4Myw1NTYsNjY5LDQ1OCw1NTksNTU5LDQzOCw1ODMsNjg4LDU1Miw1NTYsNTQyLDU1Niw1MDAsNDU4LDUwMCw4MjMsNTAwLDU3Myw1MjEsODAyLDgyMyw2MjUsNzE5LDUyMSw1MTAsNzUwLDU0Miw1NTYsNTU2LDU1NiwzNjUsNTEwLDUwMCwyMjIsMjc4LDIyMiw5MDYsODEyLDU1Niw0MzgsNTU5LDUwMCw1NTIsNzc4LDU1Niw0ODksNDExLDk0NCw3MjIsOTQ0LDcyMiw5NDQsNzIyLDY2Nyw1MDAsMzMzLDMzMyw1NTYsMWUzLDFlMyw1NTIsMjIyLDIyMiwyMjIsMjIyLDMzMywzMzMsMzMzLDU1Niw1NTYsMzUwLDFlMywxZTMsMTg4LDM1NCwzMzMsMzMzLDUwMCwzMzMsMTY3LDM2NSw1NTYsNTU2LDEwOTQsNTU2LDg4NSwzMjMsMTA3MywxZTMsNzY4LDYwMCw4MzQsODM0LDgzNCw4MzQsMWUzLDUwMCwxZTMsNTAwLDFlMyw1MDAsNTAwLDQ5NCw2MTIsODIzLDcxMyw1ODQsNTQ5LDcxMyw5NzksNzE5LDI3NCw1NDksNTQ5LDU4Myw1NDksNTQ5LDYwNCw1ODQsNjA0LDYwNCw3MDgsNjI1LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcyOSw2MDQsNjA0LDM1NCwzNTQsMWUzLDk5MCw5OTAsOTkwLDk5MCw0OTQsNjA0LDYwNCw2MDQsNjA0LDM1NCwxMDIxLDEwNTIsOTE3LDc1MCw3NTAsNTMxLDY1Niw1OTQsNTEwLDUwMCw3NTAsNzUwLDUwMCw1MDAsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywyMjIsMjIyLDI5NCwyOTQsMzI0LDMyNCwzMTYsMzI4LDM5OCwyODVdO3QuTGliZXJhdGlvblNhbnNSZWd1bGFyTWFwcGluZz1bLTEsLTEsLTEsMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzksNDAsNDEsNDIsNDMsNDQsNDUsNDYsNDcsNDgsNDksNTAsNTEsNTIsNTMsNTQsNTUsNTYsNTcsNTgsNTksNjAsNjEsNjIsNjMsNjQsNjUsNjYsNjcsNjgsNjksNzAsNzEsNzIsNzMsNzQsNzUsNzYsNzcsNzgsNzksODAsODEsODIsODMsODQsODUsODYsODcsODgsODksOTAsOTEsOTIsOTMsOTQsOTUsOTYsOTcsOTgsOTksMTAwLDEwMSwxMDIsMTAzLDEwNCwxMDUsMTA2LDEwNywxMDgsMTA5LDExMCwxMTEsMTEyLDExMywxMTQsMTE1LDExNiwxMTcsMTE4LDExOSwxMjAsMTIxLDEyMiwxMjMsMTI0LDEyNSwxMjYsMTYxLDE2MiwxNjMsMTY0LDE2NSwxNjYsMTY3LDE2OCwxNjksMTcwLDE3MSwxNzIsMTc0LDE3NSwxNzYsMTc3LDE3OCwxNzksMTgwLDE4MSwxODIsMTgzLDE4NCwxODUsMTg2LDE4NywxODgsMTg5LDE5MCwxOTEsMTkyLDE5MywxOTQsMTk1LDE5NiwxOTcsMTk4LDE5OSwyMDAsMjAxLDIwMiwyMDMsMjA0LDIwNSwyMDYsMjA3LDIwOCwyMDksMjEwLDIxMSwyMTIsMjEzLDIxNCwyMTUsMjE2LDIxNywyMTgsMjE5LDIyMCwyMjEsMjIyLDIyMywyMjQsMjI1LDIyNiwyMjcsMjI4LDIyOSwyMzAsMjMxLDIzMiwyMzMsMjM0LDIzNSwyMzYsMjM3LDIzOCwyMzksMjQwLDI0MSwyNDIsMjQzLDI0NCwyNDUsMjQ2LDI0NywyNDgsMjQ5LDI1MCwyNTEsMjUyLDI1MywyNTQsMjU1LDI1NiwyNTcsMjU4LDI1OSwyNjAsMjYxLDI2MiwyNjMsMjY0LDI2NSwyNjYsMjY3LDI2OCwyNjksMjcwLDI3MSwyNzIsMjczLDI3NCwyNzUsMjc2LDI3NywyNzgsMjc5LDI4MCwyODEsMjgyLDI4MywyODQsMjg1LDI4NiwyODcsMjg4LDI4OSwyOTAsMjkxLDI5MiwyOTMsMjk0LDI5NSwyOTYsMjk3LDI5OCwyOTksMzAwLDMwMSwzMDIsMzAzLDMwNCwzMDUsMzA2LDMwNywzMDgsMzA5LDMxMCwzMTEsMzEyLDMxMywzMTQsMzE1LDMxNiwzMTcsMzE4LDMxOSwzMjAsMzIxLDMyMiwzMjMsMzI0LDMyNSwzMjYsMzI3LDMyOCwzMjksMzMwLDMzMSwzMzIsMzMzLDMzNCwzMzUsMzM2LDMzNywzMzgsMzM5LDM0MCwzNDEsMzQyLDM0MywzNDQsMzQ1LDM0NiwzNDcsMzQ4LDM0OSwzNTAsMzUxLDM1MiwzNTMsMzU0LDM1NSwzNTYsMzU3LDM1OCwzNTksMzYwLDM2MSwzNjIsMzYzLDM2NCwzNjUsMzY2LDM2NywzNjgsMzY5LDM3MCwzNzEsMzcyLDM3MywzNzQsMzc1LDM3NiwzNzcsMzc4LDM3OSwzODAsMzgxLDM4MiwzODMsNDAyLDUwNiw1MDcsNTA4LDUwOSw1MTAsNTExLDUzNiw1MzcsNTM4LDUzOSw3MTAsNzExLDcxMyw3MjgsNzI5LDczMCw3MzEsNzMyLDczMyw5MDAsOTAxLDkwMiw5MDMsOTA0LDkwNSw5MDYsOTA4LDkxMCw5MTEsOTEyLDkxMyw5MTQsOTE1LDkxNiw5MTcsOTE4LDkxOSw5MjAsOTIxLDkyMiw5MjMsOTI0LDkyNSw5MjYsOTI3LDkyOCw5MjksOTMxLDkzMiw5MzMsOTM0LDkzNSw5MzYsOTM3LDkzOCw5MzksOTQwLDk0MSw5NDIsOTQzLDk0NCw5NDUsOTQ2LDk0Nyw5NDgsOTQ5LDk1MCw5NTEsOTUyLDk1Myw5NTQsOTU1LDk1Niw5NTcsOTU4LDk1OSw5NjAsOTYxLDk2Miw5NjMsOTY0LDk2NSw5NjYsOTY3LDk2OCw5NjksOTcwLDk3MSw5NzIsOTczLDk3NCwxMDI0LDEwMjUsMTAyNiwxMDI3LDEwMjgsMTAyOSwxMDMwLDEwMzEsMTAzMiwxMDMzLDEwMzQsMTAzNSwxMDM2LDEwMzcsMTAzOCwxMDM5LDEwNDAsMTA0MSwxMDQyLDEwNDMsMTA0NCwxMDQ1LDEwNDYsMTA0NywxMDQ4LDEwNDksMTA1MCwxMDUxLDEwNTIsMTA1MywxMDU0LDEwNTUsMTA1NiwxMDU3LDEwNTgsMTA1OSwxMDYwLDEwNjEsMTA2MiwxMDYzLDEwNjQsMTA2NSwxMDY2LDEwNjcsMTA2OCwxMDY5LDEwNzAsMTA3MSwxMDcyLDEwNzMsMTA3NCwxMDc1LDEwNzYsMTA3NywxMDc4LDEwNzksMTA4MCwxMDgxLDEwODIsMTA4MywxMDg0LDEwODUsMTA4NiwxMDg3LDEwODgsMTA4OSwxMDkwLDEwOTEsMTA5MiwxMDkzLDEwOTQsMTA5NSwxMDk2LDEwOTcsMTA5OCwxMDk5LDExMDAsMTEwMSwxMTAyLDExMDMsMTEwNCwxMTA1LDExMDYsMTEwNywxMTA4LDExMDksMTExMCwxMTExLDExMTIsMTExMywxMTE0LDExMTUsMTExNiwxMTE3LDExMTgsMTExOSwxMTM4LDExMzksMTE2OCwxMTY5LDc4MDgsNzgwOSw3ODEwLDc4MTEsNzgxMiw3ODEzLDc5MjIsNzkyMyw4MjA4LDgyMDksODIxMSw4MjEyLDgyMTMsODIxNSw4MjE2LDgyMTcsODIxOCw4MjE5LDgyMjAsODIyMSw4MjIyLDgyMjQsODIyNSw4MjI2LDgyMzAsODI0MCw4MjQyLDgyNDMsODI0OSw4MjUwLDgyNTIsODI1NCw4MjYwLDgzMTksODM1NSw4MzU2LDgzNTksODM2NCw4NDUzLDg0NjcsODQ3MCw4NDgyLDg0ODYsODQ5NCw4NTM5LDg1NDAsODU0MSw4NTQyLDg1OTIsODU5Myw4NTk0LDg1OTUsODU5Niw4NTk3LDg2MTYsODcwNiw4NzEwLDg3MTksODcyMSw4NzIyLDg3MzAsODczNCw4NzM1LDg3NDUsODc0Nyw4Nzc2LDg4MDAsODgwMSw4ODA0LDg4MDUsODk2Miw4OTc2LDg5OTIsODk5Myw5NDcyLDk0NzQsOTQ4NCw5NDg4LDk0OTIsOTQ5Niw5NTAwLDk1MDgsOTUxNiw5NTI0LDk1MzIsOTU1Miw5NTUzLDk1NTQsOTU1NSw5NTU2LDk1NTcsOTU1OCw5NTU5LDk1NjAsOTU2MSw5NTYyLDk1NjMsOTU2NCw5NTY1LDk1NjYsOTU2Nyw5NTY4LDk1NjksOTU3MCw5NTcxLDk1NzIsOTU3Myw5NTc0LDk1NzUsOTU3Niw5NTc3LDk1NzgsOTU3OSw5NTgwLDk2MDAsOTYwNCw5NjA4LDk2MTIsOTYxNiw5NjE3LDk2MTgsOTYxOSw5NjMyLDk2MzMsOTY0Miw5NjQzLDk2NDQsOTY1MCw5NjU4LDk2NjAsOTY2OCw5Njc0LDk2NzUsOTY3OSw5Njg4LDk2ODksOTcwMiw5Nzg2LDk3ODcsOTc4OCw5NzkyLDk3OTQsOTgyNCw5ODI3LDk4MjksOTgzMCw5ODM0LDk4MzUsOTgzNiw2MTQ0MSw2MTQ0Miw2MTQ0NSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMV19LChlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuTXlyaWFkUHJvUmVndWxhck1ldHJpY3M9dC5NeXJpYWRQcm9SZWd1bGFyRmFjdG9ycz10Lk15cmlhZFByb0l0YWxpY01ldHJpY3M9dC5NeXJpYWRQcm9JdGFsaWNGYWN0b3JzPXQuTXlyaWFkUHJvQm9sZE1ldHJpY3M9dC5NeXJpYWRQcm9Cb2xkSXRhbGljTWV0cmljcz10Lk15cmlhZFByb0JvbGRJdGFsaWNGYWN0b3JzPXQuTXlyaWFkUHJvQm9sZEZhY3RvcnM9dm9pZCAwO3QuTXlyaWFkUHJvQm9sZEZhY3RvcnM9WzEuMzY4OTgsMSwxLC43MjcwNiwuODA0NzksLjgzNzM0LC45ODg5NCwuOTk3OTMsLjk4OTcsLjkzODg0LC44NjIwOSwuOTQyOTIsLjk0MjkyLDEuMTY2NjEsMS4wMjA1OCwuOTM1ODIsLjk2Njk0LC45MzU4MiwxLjE5MTM3LC45OTc5MywuOTk3OTMsLjk5NzkzLC45OTc5MywuOTk3OTMsLjk5NzkzLC45OTc5MywuOTk3OTMsLjk5NzkzLC45OTc5MywuNzgwNzYsLjc4MDc2LDEuMDIwNTgsMS4wMjA1OCwxLjAyMDU4LC43Mjg1MSwuNzg5NjYsLjkwODM4LC44MzYzNywuODIzOTEsLjk2Mzc2LC44MDA2MSwuODYyNzUsLjg3NjgsLjk1NDA3LDEuMDI1OCwuNzM5MDEsLjg1MDIyLC44MzY1NSwxLjAxNTYsLjk1NTQ2LC45MjE3OSwuODcxMDcsLjkyMTc5LC44MjExNCwuODA5NiwuODk3MTMsLjk0NDM4LC45NTM1MywuOTQwODMsLjkxOTA1LC45MDQwNiwuOTQ0NiwuOTQyOTIsMS4xODc3NywuOTQyOTIsMS4wMjA1OCwuODk5MDMsLjkwMDg4LC45NDkzOCwuOTc4OTgsLjgxMDkzLC45NzU3MSwuOTQ5MzgsMS4wMjQsLjk1NzcsLjk1OTMzLC45ODYyMSwxLjA0NzQsLjk3NDU1LC45ODk4MSwuOTY3MiwuOTU5MzMsLjk0NDYsLjk3ODk4LC45NzQwNywuOTc2NDYsLjc4MDM2LDEuMTAyMDgsLjk1NDQyLC45NTI5OCwuOTc1NzksLjkzMzIsLjk0MDM5LC45MzgsLjgwNjg3LDEuMDExNDksLjgwNjg3LDEuMDIwNTgsLjgwNDc5LC45OTc5MywuOTk3OTMsLjk5NzkzLC45OTc5MywxLjAxMTQ5LDEuMDA4NzIsLjkwMDg4LC45MTg4MiwxLjAyMTMsLjgzNjEsMS4wMjA1OCwuNjIyOTUsLjU0MzI0LC44OTAyMiwxLjA4NTk1LDEsMSwuOTAwODgsMSwuOTc0NTUsLjkzNTgyLC45MDA4OCwxLDEuMDU2ODYsLjgzNjEsLjk5NjQyLC45OTY0MiwuOTk2NDIsLjcyODUxLC45MDgzOCwuOTA4MzgsLjkwODM4LC45MDgzOCwuOTA4MzgsLjkwODM4LC44NjgsLjgyMzkxLC44MDA2MSwuODAwNjEsLjgwMDYxLC44MDA2MSwxLjAyNTgsMS4wMjU4LDEuMDI1OCwxLjAyNTgsLjk3NDg0LC45NTU0NiwuOTIxNzksLjkyMTc5LC45MjE3OSwuOTIxNzksLjkyMTc5LDEuMDIwNTgsLjkyMTc5LC45NDQzOCwuOTQ0MzgsLjk0NDM4LC45NDQzOCwuOTA0MDYsLjg2OTU4LC45ODIyNSwuOTQ5MzgsLjk0OTM4LC45NDkzOCwuOTQ5MzgsLjk0OTM4LC45NDkzOCwuOTAzMSwuODEwOTMsLjk0OTM4LC45NDkzOCwuOTQ5MzgsLjk0OTM4LC45ODYyMSwuOTg2MjEsLjk4NjIxLC45ODYyMSwuOTM5NjksLjk1OTMzLC45NDQ2LC45NDQ2LC45NDQ2LC45NDQ2LC45NDQ2LDEuMDg1OTUsLjk0NDYsLjk1NDQyLC45NTQ0MiwuOTU0NDIsLjk1NDQyLC45NDAzOSwuOTc4OTgsLjk0MDM5LC45MDgzOCwuOTQ5MzgsLjkwODM4LC45NDkzOCwuOTA4MzgsLjk0OTM4LC44MjM5MSwuODEwOTMsLjgyMzkxLC44MTA5MywuODIzOTEsLjgxMDkzLC44MjM5MSwuODEwOTMsLjk2Mzc2LC44NDMxMywuOTc0ODQsLjk3NTcxLC44MDA2MSwuOTQ5MzgsLjgwMDYxLC45NDkzOCwuODAwNjEsLjk0OTM4LC44MDA2MSwuOTQ5MzgsLjgwMDYxLC45NDkzOCwuODc2OCwuOTU3NywuODc2OCwuOTU3NywuODc2OCwuOTU3NywxLDEsLjk1NDA3LC45NTkzMywuOTcwNjksLjk1OTMzLDEuMDI1OCwuOTg2MjEsMS4wMjU4LC45ODYyMSwxLjAyNTgsLjk4NjIxLDEuMDI1OCwuOTg2MjEsMS4wMjU4LC45ODYyMSwuODg3LDEuMDE1OTEsLjczOTAxLDEuMDQ3NCwxLDEsLjk3NDU1LC44MzY1NSwuOTg5ODEsMSwxLC44MzY1NSwuNzM5NzcsLjgzNjU1LC43MzkwMywuODQ2MzgsMS4wMzMsLjk1NTQ2LC45NTkzMywxLDEsLjk1NTQ2LC45NTkzMywuODI3MSwuOTU0MTcsLjk1OTMzLC45MjE3OSwuOTQ0NiwuOTIxNzksLjk0NDYsLjkyMTc5LC45NDQ2LC45MzYsLjkxOTY0LC44MjExNCwuOTc2NDYsMSwxLC44MjExNCwuOTc2NDYsLjgwOTYsLjc4MDM2LC44MDk2LC43ODAzNiwxLDEsLjgwOTYsLjc4MDM2LDEsMSwuODk3MTMsLjc3NDUyLC44OTcxMywxLjEwMjA4LC45NDQzOCwuOTU0NDIsLjk0NDM4LC45NTQ0MiwuOTQ0MzgsLjk1NDQyLC45NDQzOCwuOTU0NDIsLjk0NDM4LC45NTQ0MiwuOTQ0MzgsLjk1NDQyLC45NDA4MywuOTc1NzksLjkwNDA2LC45NDAzOSwuOTA0MDYsLjk0NDYsLjkzOCwuOTQ0NiwuOTM4LC45NDQ2LC45MzgsMSwuOTk3OTMsLjkwODM4LC45NDkzOCwuODY4LC45MDMxLC45MjE3OSwuOTQ0NiwxLDEsLjg5NzEzLDEuMTAyMDgsLjkwMDg4LC45MDA4OCwuOTAwODgsLjkwMDg4LC45MDA4OCwuOTAwODgsLjkwMDg4LC45MDA4OCwuOTAwODgsLjkwOTg5LC45MzU4LC45MTk0NSwuODMxODEsLjc1MjYxLC44Nzk5MiwuODI5NzYsLjk2MDM0LC44MzY4OSwuOTcyNjgsMS4wMDc4LC45MDgzOCwuODM2MzcsLjgwMTksLjkwMTU3LC44MDA2MSwuOTQ0NiwuOTU0MDcsLjkyNDM2LDEuMDI1OCwuODUwMjIsLjk3MTUzLDEuMDE1NiwuOTU1NDYsLjg5MTkyLC45MjE3OSwuOTIzNjEsLjg3MTA3LC45NjMxOCwuODk3MTMsLjkzNzA0LC45NTYzOCwuOTE5MDUsLjkxNzA5LC45Mjc5NiwxLjAyNTgsLjkzNzA0LC45NDgzNiwxLjAzNzMsLjk1OTMzLDEuMDA3OCwuOTU4NzEsLjk0ODM2LC45NjE3NCwuOTI2MDEsLjk0OTgsLjk4NjA3LC45NTc3NiwuOTU5MzMsMS4wNTQ1MywxLjAwNzgsLjk4Mjc1LC45MzE0LC45NTYxNywuOTE3MDEsMS4wNTk5MywuOTQ0NiwuNzgzNjcsLjk1NTMsMSwuODY4MzIsMS4wMTI4LC45NTg3MSwuOTkzOTQsLjg3NTQ4LC45NjM2MSwuODY3NzQsMS4wMDc4LC45NTg3MSwuOTQ0NiwuOTU4NzEsLjg2Nzc0LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjk0MDgzLC45NzU3OSwuOTQwODMsLjk3NTc5LC45NDA4MywuOTc1NzksLjkwNDA2LC45NDAzOSwuOTY2OTQsMSwuODk5MDMsMSwxLDEsLjkzNTgyLC45MzU4MiwuOTM1ODIsMSwuOTA4LC45MDgsLjkxOCwuOTQyMTksLjk0MjE5LC45NjU0NCwxLDEuMjg1LDEsMSwuODEwNzksLjgxMDc5LDEsMSwuNzQ4NTQsMSwxLDEsMSwuOTk3OTMsMSwxLDEsLjY1LDEsMS4zNjE0NSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMS4xNzE3MywxLC44MDUzNSwuNzYxNjksMS4wMjA1OCwxLjA3MzIsMS4wNTQ4NiwxLDEsMS4zMDY5MiwxLjA4NTk1LDEuMDg1OTUsMSwxLjA4NTk1LDEuMDg1OTUsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLjE2MTYxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDFdO3QuTXlyaWFkUHJvQm9sZE1ldHJpY3M9e2xpbmVIZWlnaHQ6MS4yLGxpbmVHYXA6LjJ9O3QuTXlyaWFkUHJvQm9sZEl0YWxpY0ZhY3RvcnM9WzEuMzY4OTgsMSwxLC42NjIyNywuODA3NzksLjgxNjI1LC45NzI3NiwuOTcyNzYsLjk3NzMzLC45MjIyMiwuODMyNjYsLjk0MjkyLC45NDI5MiwxLjE2MTQ4LDEuMDIwNTgsLjkzNTgyLC45NjY5NCwuOTM1ODIsMS4xNzMzNywuOTcyNzYsLjk3Mjc2LC45NzI3NiwuOTcyNzYsLjk3Mjc2LC45NzI3NiwuOTcyNzYsLjk3Mjc2LC45NzI3NiwuOTcyNzYsLjc4MDc2LC43ODA3NiwxLjAyMDU4LDEuMDIwNTgsMS4wMjA1OCwuNzE1NDEsLjc2ODEzLC44NTU3NiwuODA1OTEsLjgwNzI5LC45NDI5OSwuNzc1MTIsLjgzNjU1LC44NjUyMywuOTIyMjIsLjk4NjIxLC43MTc0MywuODE2OTgsLjc5NzI2LC45ODU1OCwuOTIyMjIsLjkwNjM3LC44MzgwOSwuOTA2MzcsLjgwNzI5LC43NjQ2MywuODYyNzUsLjkwNjk5LC45MTYwNSwuOTE1NCwuODUzMDgsLjg1NDU4LC45MDUzMSwuOTQyOTIsMS4yMTI5NiwuOTQyOTIsMS4wMjA1OCwuODk5MDMsMS4xODYxNiwuOTk2MTMsLjkxNjc3LC43ODIxNiwuOTE2NzcsLjkwMDgzLC45ODc5NiwuOTEzNSwuOTIxNjgsLjk1MzgxLC45ODk4MSwuOTUyOTgsLjk1MzgxLC45MzQ1OSwuOTIxNjgsLjkxNTEzLC45MjAwNCwuOTE2NzcsLjk1MDc3LC43NDgsMS4wNDUwMiwuOTE2NzcsLjkyMDYxLC45NDIzNiwuODk1NDQsLjg5MzY0LC45LC44MDY4NywuODU3OCwuODA2ODcsMS4wMjA1OCwuODA3NzksLjk3Mjc2LC45NzI3NiwuOTcyNzYsLjk3Mjc2LC44NTc4LC45OTk3MywxLjE4NjE2LC45MTMzOSwxLjA4MDc0LC44Mjg5MSwxLjAyMDU4LC41NTUwOSwuNzE1MjYsLjg5MDIyLDEuMDg1OTUsMSwxLDEuMTg2MTYsMSwuOTY3MzYsLjkzNTgyLDEuMTg2MTYsMSwxLjA0ODY0LC44MjcxMSwuOTkwNDMsLjk5MDQzLC45OTA0MywuNzE1NDEsLjg1NTc2LC44NTU3NiwuODU1NzYsLjg1NTc2LC44NTU3NiwuODU1NzYsLjg0NSwuODA3MjksLjc3NTEyLC43NzUxMiwuNzc1MTIsLjc3NTEyLC45ODYyMSwuOTg2MjEsLjk4NjIxLC45ODYyMSwuOTU5NjEsLjkyMjIyLC45MDYzNywuOTA2MzcsLjkwNjM3LC45MDYzNywuOTA2MzcsMS4wMjA1OCwuOTAyNTEsLjkwNjk5LC45MDY5OSwuOTA2OTksLjkwNjk5LC44NTQ1OCwuODM2NTksLjk0OTUxLC45OTYxMywuOTk2MTMsLjk5NjEzLC45OTYxMywuOTk2MTMsLjk5NjEzLC44NTgxMSwuNzgyMTYsLjkwMDgzLC45MDA4MywuOTAwODMsLjkwMDgzLC45NTM4MSwuOTUzODEsLjk1MzgxLC45NTM4MSwuOTEzNSwuOTIxNjgsLjkxNTEzLC45MTUxMywuOTE1MTMsLjkxNTEzLC45MTUxMywxLjA4NTk1LC45MTY3NywuOTE2NzcsLjkxNjc3LC45MTY3NywuOTE2NzcsLjg5MzY0LC45MjMzMiwuODkzNjQsLjg1NTc2LC45OTYxMywuODU1NzYsLjk5NjEzLC44NTU3NiwuOTk2MTMsLjgwNzI5LC43ODIxNiwuODA3MjksLjc4MjE2LC44MDcyOSwuNzgyMTYsLjgwNzI5LC43ODIxNiwuOTQyOTksLjc2NzgzLC45NTk2MSwuOTE2NzcsLjc3NTEyLC45MDA4MywuNzc1MTIsLjkwMDgzLC43NzUxMiwuOTAwODMsLjc3NTEyLC45MDA4MywuNzc1MTIsLjkwMDgzLC44NjUyMywuOTEzNSwuODY1MjMsLjkxMzUsLjg2NTIzLC45MTM1LDEsMSwuOTIyMjIsLjkyMTY4LC45MjIyMiwuOTIxNjgsLjk4NjIxLC45NTM4MSwuOTg2MjEsLjk1MzgxLC45ODYyMSwuOTUzODEsLjk4NjIxLC45NTM4MSwuOTg2MjEsLjk1MzgxLC44NjAzNiwuOTcwOTYsLjcxNzQzLC45ODk4MSwxLDEsLjk1Mjk4LC43OTcyNiwuOTUzODEsMSwxLC43OTcyNiwuNjg5NCwuNzk3MjYsLjc0MzIxLC44MTY5MSwxLjAwMDYsLjkyMjIyLC45MjE2OCwxLDEsLjkyMjIyLC45MjE2OCwuNzk0NjQsLjkyMDk4LC45MjE2OCwuOTA2MzcsLjkxNTEzLC45MDYzNywuOTE1MTMsLjkwNjM3LC45MTUxMywuOTA5LC44NzUxNCwuODA3MjksLjk1MDc3LDEsMSwuODA3MjksLjk1MDc3LC43NjQ2MywuNzQ4LC43NjQ2MywuNzQ4LDEsMSwuNzY0NjMsLjc0OCwxLDEsLjg2Mjc1LC43MjY1MSwuODYyNzUsMS4wNDUwMiwuOTA2OTksLjkxNjc3LC45MDY5OSwuOTE2NzcsLjkwNjk5LC45MTY3NywuOTA2OTksLjkxNjc3LC45MDY5OSwuOTE2NzcsLjkwNjk5LC45MTY3NywuOTE1NCwuOTQyMzYsLjg1NDU4LC44OTM2NCwuODU0NTgsLjkwNTMxLC45LC45MDUzMSwuOSwuOTA1MzEsLjksMSwuOTcyNzYsLjg1NTc2LC45OTYxMywuODQ1LC44NTgxMSwuOTAyNTEsLjkxNjc3LDEsMSwuODYyNzUsMS4wNDUwMiwxLjE4NjE2LDEuMTg2MTYsMS4xODYxNiwxLjE4NjE2LDEuMTg2MTYsMS4xODYxNiwxLjE4NjE2LDEuMTg2MTYsMS4xODYxNiwxLjAwODk5LDEuMzA2MjgsLjg1NTc2LC44MDE3OCwuNjY4NjIsLjc5MjcsLjY5MzIzLC44ODEyNywuNzI0NTksLjg5NzExLC45NTM4MSwuODU1NzYsLjgwNTkxLC43ODA1LC45NDcyOSwuNzc1MTIsLjkwNTMxLC45MjIyMiwuOTA2MzcsLjk4NjIxLC44MTY5OCwuOTI2NTUsLjk4NTU4LC45MjIyMiwuODUzNTksLjkwNjM3LC45MDk3NiwuODM4MDksLjk0NTIzLC44NjI3NSwuODM1MDksLjkzMTU3LC44NTMwOCwuODMzOTIsLjkyMzQ2LC45ODYyMSwuODM1MDksLjkyODg2LC45MTMyNCwuOTIxNjgsLjk1MzgxLC45MDY0NiwuOTI4ODYsLjkwNTU3LC44Njg0NywuOTAyNzYsLjkxMzI0LC44Njg0MiwuOTIxNjgsLjk5NTMxLC45NTM4MSwuOTIyNCwuODU0MDgsLjkyNjk5LC44Njg0NywxLjAwNTEsLjkxNTEzLC44MDQ4NywuOTM0ODEsMSwuODgxNTksMS4wNTIxNCwuOTA2NDYsLjk3MzU1LC44MTUzOSwuODkzOTgsLjg1OTIzLC45NTM4MSwuOTA2NDYsLjkxNTEzLC45MDY0NiwuODU5MjMsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTE1NCwuOTQyMzYsLjkxNTQsLjk0MjM2LC45MTU0LC45NDIzNiwuODU0NTgsLjg5MzY0LC45NjY5NCwxLC44OTkwMywxLDEsMSwuOTE3ODIsLjkxNzgyLC45MTc4MiwxLC44OTYsLjg5NiwuODk2LC45MzMyLC45MzMyLC45NTk3MywxLDEuMjYsMSwxLC44MDQ3OSwuODAxNzgsMSwxLC44NTYzMywxLDEsMSwxLC45NzI3NiwxLDEsMSwuNjk4LDEsMS4zNjE0NSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMS4xNDU0MiwxLC43OTE5OSwuNzg2OTQsMS4wMjA1OCwxLjAzNDkzLDEuMDU0ODYsMSwxLDEuMjMwMjYsMS4wODU5NSwxLjA4NTk1LDEsMS4wODU5NSwxLjA4NTk1LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMS4yMDAwNiwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxXTt0Lk15cmlhZFByb0JvbGRJdGFsaWNNZXRyaWNzPXtsaW5lSGVpZ2h0OjEuMixsaW5lR2FwOi4yfTt0Lk15cmlhZFByb0l0YWxpY0ZhY3RvcnM9WzEuMzY4OTgsMSwxLC42NTUwNywuODQ5NDMsLjg1NjM5LC44ODQ2NSwuODg0NjUsLjg2OTM2LC44ODMwNywuODY5NDgsLjg1MjgzLC44NTI4MywxLjA2MzgzLDEuMDIwNTgsLjc1OTQ1LC45MjE5LC43NTk0NSwxLjE3MzM3LC44ODQ2NSwuODg0NjUsLjg4NDY1LC44ODQ2NSwuODg0NjUsLjg4NDY1LC44ODQ2NSwuODg0NjUsLjg4NDY1LC44ODQ2NSwuNzU5NDUsLjc1OTQ1LDEuMDIwNTgsMS4wMjA1OCwxLjAyMDU4LC42OTA0NiwuNzA5MjYsLjg1MTU4LC43NzgxMiwuNzY4NTIsLjg5NTkxLC43MDQ2NiwuNzYxMjUsLjgwMDk0LC44NjgyMiwuODM4NjQsLjcyOCwuNzcyMTIsLjc5NDc1LC45MzYzNywuODc1MTQsLjg1ODgsLjc2MDEzLC44NTg4LC43MjQyMSwuNjk4NjYsLjc3NTk4LC44NTk5MSwuODA4MTEsLjg3ODMyLC43ODExMiwuNzc1MTIsLjg1NjIsMS4wMjIyLDEuMTg0MTcsMS4wMjIyLDEuMjcwMTQsLjg5OTAzLDEuMTUwMTIsLjkzODU5LC45NDM5OSwuODQ2LC45NDM5OSwuODE0NTMsMS4wMTg2LC45NDIxOSwuOTYwMTcsMS4wMzA3NSwxLjAyMTc1LC45MTIsMS4wMzA3NSwuOTY5OTgsLjk2MDE3LC45Mzg1OSwuOTQzOTksLjk0Mzk5LC45NTQ5MywuNzQ2LDEuMTI2NTgsLjk0NTc4LC45MSwuOTc5LC44ODIsLjg4MiwuODMsLjg1MDM0LC44MzUzNywuODUwMzQsMS4wMjA1OCwuNzA4NjksLjg4NDY1LC44ODQ2NSwuODg0NjUsLjg4NDY1LC44MzUzNywuOTAwODMsMS4xNTAxMiwuOTE2MSwuOTQ1NjUsLjczNTQxLDEuMDIwNTgsLjUzNjA5LC42OTM1MywuNzk1MTksMS4wODU5NSwxLDEsMS4xNTAxMiwxLC45MTk3NCwuNzU5NDUsMS4xNTAxMiwxLC45NDQ2LC43MzM2MSwuOTAwNSwuOTAwNSwuOTAwNSwuNjI4NjQsLjg1MTU4LC44NTE1OCwuODUxNTgsLjg1MTU4LC44NTE1OCwuODUxNTgsLjc3MywuNzY4NTIsLjcwNDY2LC43MDQ2NiwuNzA0NjYsLjcwNDY2LC44Mzg2NCwuODM4NjQsLjgzODY0LC44Mzg2NCwuOTA1NjEsLjg3NTE0LC44NTg4LC44NTg4LC44NTg4LC44NTg4LC44NTg4LDEuMDIwNTgsLjg1NzUxLC44NTk5MSwuODU5OTEsLjg1OTkxLC44NTk5MSwuNzc1MTIsLjc2MDEzLC44ODA3NSwuOTM4NTksLjkzODU5LC45Mzg1OSwuOTM4NTksLjkzODU5LC45Mzg1OSwuODA3NSwuODQ2LC44MTQ1MywuODE0NTMsLjgxNDUzLC44MTQ1MywuODI0MjQsLjgyNDI0LC44MjQyNCwuODI0MjQsLjkyNzgsLjk2MDE3LC45Mzg1OSwuOTM4NTksLjkzODU5LC45Mzg1OSwuOTM4NTksMS4wODU5NSwuODU2MiwuOTQ1NzgsLjk0NTc4LC45NDU3OCwuOTQ1NzgsLjg4MiwuOTQ1NzgsLjg4MiwuODUxNTgsLjkzODU5LC44NTE1OCwuOTM4NTksLjg1MTU4LC45Mzg1OSwuNzY4NTIsLjg0NiwuNzY4NTIsLjg0NiwuNzY4NTIsLjg0NiwuNzY4NTIsLjg0NiwuODk1OTEsLjg1NDQsLjkwNTYxLC45NDM5OSwuNzA0NjYsLjgxNDUzLC43MDQ2NiwuODE0NTMsLjcwNDY2LC44MTQ1MywuNzA0NjYsLjgxNDUzLC43MDQ2NiwuODE0NTMsLjgwMDk0LC45NDIxOSwuODAwOTQsLjk0MjE5LC44MDA5NCwuOTQyMTksMSwxLC44NjgyMiwuOTYwMTcsLjg2ODIyLC45NjAxNywuODM4NjQsLjgyNDI0LC44Mzg2NCwuODI0MjQsLjgzODY0LC44MjQyNCwuODM4NjQsMS4wMzA3NSwuODM4NjQsLjgyNDI0LC44MTQwMiwxLjAyNzM4LC43MjgsMS4wMjE3NSwxLDEsLjkxMiwuNzk0NzUsMS4wMzA3NSwxLDEsLjc5NDc1LC44MzkxMSwuNzk0NzUsLjY2MjY2LC44MDU1MywxLjA2Njc2LC44NzUxNCwuOTYwMTcsMSwxLC44NzUxNCwuOTYwMTcsLjg2ODY1LC44NzM5NiwuOTYwMTcsLjg1ODgsLjkzODU5LC44NTg4LC45Mzg1OSwuODU4OCwuOTM4NTksLjg2NywuODQ3NTksLjcyNDIxLC45NTQ5MywxLDEsLjcyNDIxLC45NTQ5MywuNjk4NjYsLjc0NiwuNjk4NjYsLjc0NiwxLDEsLjY5ODY2LC43NDYsMSwxLC43NzU5OCwuODg0MTcsLjc3NTk4LDEuMTI2NTgsLjg1OTkxLC45NDU3OCwuODU5OTEsLjk0NTc4LC44NTk5MSwuOTQ1NzgsLjg1OTkxLC45NDU3OCwuODU5OTEsLjk0NTc4LC44NTk5MSwuOTQ1NzgsLjg3ODMyLC45NzksLjc3NTEyLC44ODIsLjc3NTEyLC44NTYyLC44MywuODU2MiwuODMsLjg1NjIsLjgzLDEsLjg4NDY1LC44NTE1OCwuOTM4NTksLjc3MywuODA3NSwuODU3NTEsLjg1NjIsMSwxLC43NzU5OCwxLjEyNjU4LDEuMTUwMTIsMS4xNTAxMiwxLjE1MDEyLDEuMTUwMTIsMS4xNTAxMiwxLjE1MzEzLDEuMTUwMTIsMS4xNTAxMiwxLjE1MDEyLDEuMDgxMDYsMS4wMzkwMSwuODUxNTgsLjc3MDI1LC42MjI2NCwuNzY0NiwuNjUzNTEsLjg2MDI2LC42OTQ2MSwuODk5NDcsMS4wMzA3NSwuODUxNTgsLjc3ODEyLC43NjQ0OSwuODg4MzYsLjcwNDY2LC44NTYyLC44NjgyMiwuODU4OCwuODM4NjQsLjc3MjEyLC44NTMwOCwuOTM2MzcsLjg3NTE0LC44MjM1MiwuODU4OCwuODU3MDEsLjc2MDEzLC44OTA1OCwuNzc1OTgsLjgxNTYsLjgyNTY1LC43ODExMiwuNzc4OTksLjg5Mzg2LC44Mzg2NCwuODE1NiwuOTQ4NiwuOTIzODgsLjk2MTg2LDEuMDMwNzUsLjkxMTIzLC45NDg2LC45MzI5OCwuODc4LC45Mzk0MiwuOTIzODgsLjg0NTk2LC45NjE4NiwuOTUxMTksMS4wMzA3NSwuOTIyLC44ODc4NywuOTU4MjksLjg4LC45MzU1OSwuOTM4NTksLjc4ODE1LC45Mzc1OCwxLC44OTIxNywxLjAzNzM3LC45MTEyMywuOTM5NjksLjc3NDg3LC44NTc2OSwuODY3OTksMS4wMzA3NSwuOTExMjMsLjkzODU5LC45MTEyMywuODY3OTksMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuODc4MzIsLjk3OSwuODc4MzIsLjk3OSwuODc4MzIsLjk3OSwuNzc1MTIsLjg4MiwuOTIxOSwxLC44OTkwMywxLDEsMSwuODczMjEsLjg3MzIxLC44NzMyMSwxLDEuMDI3LDEuMDI3LDEuMDI3LC44Njg0NywuODY4NDcsLjc5MTIxLDEsMS4xMjQsMSwxLC43MzU3MiwuNzM1NzIsMSwxLC44NTAzNCwxLDEsMSwxLC44ODQ2NSwxLDEsMSwuNjY5LDEsMS4zNjE0NSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMS4wNDgyOCwxLC43NDk0OCwuNzUxODcsMS4wMjA1OCwuOTgzOTEsMS4wMjExOSwxLDEsMS4wNjIzMywxLjA4NTk1LDEuMDg1OTUsMSwxLjA4NTk1LDEuMDg1OTUsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLjA1MjMzLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDFdO3QuTXlyaWFkUHJvSXRhbGljTWV0cmljcz17bGluZUhlaWdodDoxLjIsbGluZUdhcDouMn07dC5NeXJpYWRQcm9SZWd1bGFyRmFjdG9ycz1bMS4zNjg5OCwxLDEsLjc2MzA1LC44Mjc4NCwuOTQ5MzUsLjg5MzY0LC45MjI0MSwuODkwNzMsLjkwNzA2LC45ODQ3MiwuODUyODMsLjg1MjgzLDEuMDY2NCwxLjAyMDU4LC43NDUwNSwuOTIxOSwuNzQ1MDUsMS4yMzQ1NiwuOTIyNDEsLjkyMjQxLC45MjI0MSwuOTIyNDEsLjkyMjQxLC45MjI0MSwuOTIyNDEsLjkyMjQxLC45MjI0MSwuOTIyNDEsLjc0NTA1LC43NDUwNSwxLjAyMDU4LDEuMDIwNTgsMS4wMjA1OCwuNzMwMDIsLjcyNjAxLC45MTc1NSwuODEyNiwuODAzMTQsLjkyMjIyLC43Mzc2NCwuNzk3MjYsLjgzMDUxLC45MDI4NCwuODYwMjMsLjc0LC44MTI2LC44NDg2OSwuOTY1MTgsLjkxMTE1LC44ODU4LC43OTc2MSwuODg1OCwuNzQ0OTgsLjczOTE0LC44MTM2MywuODk1OTEsLjgzNjU5LC44OTYzMywuODU2MDgsLjgxMTEsLjkwNTMxLDEuMDIyMiwxLjIyNzM2LDEuMDIyMiwxLjI3MDE0LC44OTkwMywuOTAwODgsLjg2NjY3LDEuMDIzMSwuODk2LDEuMDE0MTEsLjkwMDgzLDEuMDUwOTksMS4wMDUxMiwuOTk3OTMsMS4wNTMyNiwxLjA5Mzc3LC45MzgsMS4wNjIyNiwxLjAwMTE5LC45OTc5MywuOTg3MTQsMS4wMjMxLDEuMDEyMzEsLjk4MTk2LC43OTIsMS4xOTEzNywuOTkwNzQsLjk2MiwxLjAxOTE1LC45MjYsLjk0MiwuODU2LC44NTAzNCwuOTIwMDYsLjg1MDM0LDEuMDIwNTgsLjY5MDY3LC45MjI0MSwuOTIyNDEsLjkyMjQxLC45MjI0MSwuOTIwMDYsLjkzMzIsLjkwMDg4LC45MTg4MiwuOTM0ODQsLjc1MzM5LDEuMDIwNTgsLjU2ODY2LC41NDMyNCwuNzk1MTksMS4wODU5NSwxLDEsLjkwMDg4LDEsLjk1MzI1LC43NDUwNSwuOTAwODgsMSwuOTcxOTgsLjc1MzM5LC45MTAwOSwuOTEwMDksLjkxMDA5LC42NjQ2NiwuOTE3NTUsLjkxNzU1LC45MTc1NSwuOTE3NTUsLjkxNzU1LC45MTc1NSwuNzg4LC44MDMxNCwuNzM3NjQsLjczNzY0LC43Mzc2NCwuNzM3NjQsLjg2MDIzLC44NjAyMywuODYwMjMsLjg2MDIzLC45MjkxNSwuOTExMTUsLjg4NTgsLjg4NTgsLjg4NTgsLjg4NTgsLjg4NTgsMS4wMjA1OCwuODg1OCwuODk1OTEsLjg5NTkxLC44OTU5MSwuODk1OTEsLjgxMTEsLjc5NjExLC44OTcxMywuODY2NjcsLjg2NjY3LC44NjY2NywuODY2NjcsLjg2NjY3LC44NjY2NywuODY5MzYsLjg5NiwuOTAwODMsLjkwMDgzLC45MDA4MywuOTAwODMsLjg0MjI0LC44NDIyNCwuODQyMjQsLjg0MjI0LC45NzI3NiwuOTk3OTMsLjk4NzE0LC45ODcxNCwuOTg3MTQsLjk4NzE0LC45ODcxNCwxLjA4NTk1LC44OTg3NiwuOTkwNzQsLjk5MDc0LC45OTA3NCwuOTkwNzQsLjk0MiwxLjAyMzEsLjk0MiwuOTE3NTUsLjg2NjY3LC45MTc1NSwuODY2NjcsLjkxNzU1LC44NjY2NywuODAzMTQsLjg5NiwuODAzMTQsLjg5NiwuODAzMTQsLjg5NiwuODAzMTQsLjg5NiwuOTIyMjIsLjkzMzcyLC45MjkxNSwxLjAxNDExLC43Mzc2NCwuOTAwODMsLjczNzY0LC45MDA4MywuNzM3NjQsLjkwMDgzLC43Mzc2NCwuOTAwODMsLjczNzY0LC45MDA4MywuODMwNTEsMS4wMDUxMiwuODMwNTEsMS4wMDUxMiwuODMwNTEsMS4wMDUxMiwxLDEsLjkwMjg0LC45OTc5MywuOTA5NzYsLjk5NzkzLC44NjAyMywuODQyMjQsLjg2MDIzLC44NDIyNCwuODYwMjMsLjg0MjI0LC44NjAyMywxLjA1MzI2LC44NjAyMywuODQyMjQsLjgyODczLDEuMDc0NjksLjc0LDEuMDkzNzcsMSwxLC45MzgsLjg0ODY5LDEuMDYyMjYsMSwxLC44NDg2OSwuODM3MDQsLjg0ODY5LC44MTQ0MSwuODU1ODgsMS4wODkyNywuOTExMTUsLjk5NzkzLDEsMSwuOTExMTUsLjk5NzkzLC45MTg4NywuOTA5OTEsLjk5NzkzLC44ODU4LC45ODcxNCwuODg1OCwuOTg3MTQsLjg4NTgsLjk4NzE0LC44OTQsLjkxNDM0LC43NDQ5OCwuOTgxOTYsMSwxLC43NDQ5OCwuOTgxOTYsLjczOTE0LC43OTIsLjczOTE0LC43OTIsMSwxLC43MzkxNCwuNzkyLDEsMSwuODEzNjMsLjkwNCwuODEzNjMsMS4xOTEzNywuODk1OTEsLjk5MDc0LC44OTU5MSwuOTkwNzQsLjg5NTkxLC45OTA3NCwuODk1OTEsLjk5MDc0LC44OTU5MSwuOTkwNzQsLjg5NTkxLC45OTA3NCwuODk2MzMsMS4wMTkxNSwuODExMSwuOTQyLC44MTExLC45MDUzMSwuODU2LC45MDUzMSwuODU2LC45MDUzMSwuODU2LDEsLjkyMjQxLC45MTc1NSwuODY2NjcsLjc4OCwuODY5MzYsLjg4NTgsLjg5ODc2LDEsMSwuODEzNjMsMS4xOTEzNywuOTAwODgsLjkwMDg4LC45MDA4OCwuOTAwODgsLjkwMDg4LC45MDA4OCwuOTAwODgsLjkwMDg4LC45MDA4OCwuOTAzODgsMS4wMzkwMSwuOTIxMzgsLjc4MTA1LC43MTU0LC44NjE2OSwuODA1MTMsLjk0MDA3LC44MjUyOCwuOTg2MTIsMS4wNjIyNiwuOTE3NTUsLjgxMjYsLjgxODg0LC45MjgxOSwuNzM3NjQsLjkwNTMxLC45MDI4NCwuODg1OCwuODYwMjMsLjgxMjYsLjkxMTcyLC45NjUxOCwuOTExMTUsLjgzMDg5LC44ODU4LC44Nzc5MSwuNzk3NjEsLjg5Mjk3LC44MTM2MywuODgxNTcsLjg5OTkyLC44NTYwOCwuODE5OTIsLjk0MzA3LC44NjAyMywuODgxNTcsLjk1MzA4LC45ODY5OSwuOTk3OTMsMS4wNjIyNiwuOTU4MTcsLjk1MzA4LC45NzM1OCwuOTI4LC45ODA4OCwuOTg2OTksLjkyNzYxLC45OTc5MywuOTYwMTcsMS4wNjIyNiwuOTg2LC45NDQsLjk1OTc4LC45MzgsLjk2NzA1LC45ODcxNCwuODA0NDIsLjk4OTcyLDEsLjg5NzYyLDEuMDQ1NTIsLjk1ODE3LC45OTAwNywuODcwNjQsLjkxODc5LC44ODg4OCwxLjA2MjI2LC45NTgxNywuOTg3MTQsLjk1ODE3LC44ODg4OCwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC44OTYzMywxLjAxOTE1LC44OTYzMywxLjAxOTE1LC44OTYzMywxLjAxOTE1LC44MTExLC45NDIsLjkyMTksMSwuODk5MDMsMSwxLDEsLjkzMTczLC45MzE3MywuOTMxNzMsMSwxLjA2MzA0LDEuMDYzMDQsMS4wNjkwNCwuODk5MDMsLjg5OTAzLC44MDU0OSwxLDEuMTU2LDEsMSwuNzY1NzUsLjc2NTc1LDEsMSwuNzI0NTgsMSwxLDEsMSwuOTIyNDEsMSwxLDEsLjYxOSwxLDEuMzYxNDUsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuMDcyNTcsMSwuNzQ3MDUsLjcxMTE5LDEuMDIwNTgsMS4wMjQsMS4wMjExOSwxLDEsMS4xNTM2LDEuMDg1OTUsMS4wODU5NSwxLDEuMDg1OTUsMS4wODU5NSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuMDU2MzgsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMV07dC5NeXJpYWRQcm9SZWd1bGFyTWV0cmljcz17bGluZUhlaWdodDoxLjIsbGluZUdhcDouMn19LChlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuU2Vnb2V1aVJlZ3VsYXJNZXRyaWNzPXQuU2Vnb2V1aVJlZ3VsYXJGYWN0b3JzPXQuU2Vnb2V1aUl0YWxpY01ldHJpY3M9dC5TZWdvZXVpSXRhbGljRmFjdG9ycz10LlNlZ29ldWlCb2xkTWV0cmljcz10LlNlZ29ldWlCb2xkSXRhbGljTWV0cmljcz10LlNlZ29ldWlCb2xkSXRhbGljRmFjdG9ycz10LlNlZ29ldWlCb2xkRmFjdG9ycz12b2lkIDA7dC5TZWdvZXVpQm9sZEZhY3RvcnM9WzEuNzY3MzgsMSwxLC45OTI5NywuOTgyNCwxLjA0MDE2LDEuMDY0OTcsMS4wMzQyNCwuOTc1MjksMS4xNzY0NywxLjIzMjAzLDEuMTA4NSwxLjEwODUsMS4xNjkzOSwxLjIxMDcsLjk3NTQsMS4yMTQwOCwuOTc1NCwxLjU5NTc4LDEuMDM0MjQsMS4wMzQyNCwxLjAzNDI0LDEuMDM0MjQsMS4wMzQyNCwxLjAzNDI0LDEuMDM0MjQsMS4wMzQyNCwxLjAzNDI0LDEuMDM0MjQsLjgxMzc4LC44MTM3OCwxLjIxMDcsMS4yMTA3LDEuMjEwNywuNzE3MDMsLjk3ODQ3LC45NzM2MywuODg3NzYsLjg2NDEsMS4wMjA5NiwuNzk3OTUsLjg1MTMyLC45MTQsMS4wNjA4NSwxLjE0MDYsLjgwMDcsLjg5ODU4LC44MzY5MywxLjE0ODg5LDEuMDkzOTgsLjk3NDg5LC45MjA5NCwuOTc0ODksLjkwMzk5LC44NDA0MSwuOTU5MjMsMS4wMDEzNSwxLDEuMDY0NjcsLjk4MjQzLC45MDk5NiwuOTkzNjEsMS4xMDg1LDEuNTY5NDIsMS4xMDg1LDEuMjEwNywuNzQ2MjcsLjk0MjgyLC45Njc1MiwxLjAxNTE5LC44NjMwNCwxLjAxMzU5LC45NzI3OCwxLjE1MTAzLDEuMDEzNTksLjk4NTYxLDEuMDIyODUsMS4wMjI4NSwxLjAwNTI3LDEuMDIyODUsMS4wMzAyLC45OTA0MSwxLjAwMDgsMS4wMTUxOSwxLjAxMzU5LDEuMDIyNTgsLjc5MTA0LDEuMTY4NjIsLjk5MDQxLC45NzQ1NCwxLjAyNTExLC45OTI5OCwuOTY3NTIsLjk1ODAxLC45NDg1NiwxLjE2NTc5LC45NDg1NiwxLjIxMDcsLjk4MjQsMS4wMzQyNCwxLjAzNDI0LDEsMS4wMzQyNCwxLjE2NTc5LC44NzI3LDEuMzg3MSwxLjE4NjIyLDEuMTA4MTgsMS4wNDQ3OCwxLjIxMDcsMS4xODYyMiwuNzUxNTUsLjk0OTk0LDEuMjg4MjYsMS4yMTQwOCwxLjIxNDA4LC45MTA1NiwxLC45MTU3MiwuOTc1NCwuNjQ2NjMsMS4xODMyOCwxLjI0ODY2LDEuMDQ0NzgsMS4xNDE2OSwxLjE1NzQ5LDEuMTczODksLjcxNzAzLC45NzM2MywuOTczNjMsLjk3MzYzLC45NzM2MywuOTczNjMsLjk3MzYzLC45MzUwNiwuODY0MSwuNzk3OTUsLjc5Nzk1LC43OTc5NSwuNzk3OTUsMS4xNDA2LDEuMTQwNiwxLjE0MDYsMS4xNDA2LDEuMDIwOTYsMS4wOTM5OCwuOTc0MjYsLjk3NDI2LC45NzQyNiwuOTc0MjYsLjk3NDI2LDEuMjEwNywuOTc0ODksMS4wMDEzNSwxLjAwMTM1LDEuMDAxMzUsMS4wMDEzNSwuOTA5OTYsLjkyMDk0LDEuMDI3OTgsLjk2NzUyLC45Njc1MiwuOTY3NTIsLjk2NzUyLC45Njc1MiwuOTY3NTIsLjkzMTM2LC44NjMwNCwuOTcyNzgsLjk3Mjc4LC45NzI3OCwuOTcyNzgsMS4wMjI4NSwxLjAyMjg1LDEuMDIyODUsMS4wMjI4NSwuOTcxMjIsLjk5MDQxLDEsMSwxLDEsMSwxLjI4ODI2LDEuMDAwOCwuOTkwNDEsLjk5MDQxLC45OTA0MSwuOTkwNDEsLjk2NzUyLDEuMDE1MTksLjk2NzUyLC45NzM2MywuOTY3NTIsLjk3MzYzLC45Njc1MiwuOTczNjMsLjk2NzUyLC44NjQxLC44NjMwNCwuODY0MSwuODYzMDQsLjg2NDEsLjg2MzA0LC44NjQxLC44NjMwNCwxLjAyMDk2LDEuMDMwNTcsMS4wMjA5NiwxLjAzNTE3LC43OTc5NSwuOTcyNzgsLjc5Nzk1LC45NzI3OCwuNzk3OTUsLjk3Mjc4LC43OTc5NSwuOTcyNzgsLjc5Nzk1LC45NzI3OCwuOTE0LDEuMDEzNTksLjkxNCwxLjAxMzU5LC45MTQsMS4wMTM1OSwxLDEsMS4wNjA4NSwuOTg1NjEsMS4wNjA4NSwxLjAwODc5LDEuMTQwNiwxLjAyMjg1LDEuMTQwNiwxLjAyMjg1LDEuMTQwNiwxLjAyMjg1LDEuMTQwNiwxLjAyMjg1LDEuMTQwNiwxLjAyMjg1LC45NzEzOCwxLjA4NjkyLC44MDA3LDEuMDIyODUsMSwxLDEuMDA1MjcsLjgzNjkzLDEuMDIyODUsMSwxLC44MzY5MywuOTQ1NSwuODM2OTMsLjkwNDE4LC44MzY5MywxLjEzMDA1LDEuMDkzOTgsLjk5MDQxLDEsMSwxLjA5Mzk4LC45OTA0MSwuOTY2OTIsMS4wOTI1MSwuOTkwNDEsLjk3NDg5LDEuMDAwOCwuOTc0ODksMS4wMDA4LC45NzQ4OSwxLjAwMDgsLjkzOTk0LC45NzkzMSwuOTAzOTksMS4wMjI1OCwxLDEsLjkwMzk5LDEuMDIyNTgsLjg0MDQxLC43OTEwNCwuODQwNDEsLjc5MTA0LC44NDA0MSwuNzkxMDQsLjg0MDQxLC43OTEwNCwxLDEsLjk1OTIzLDEuMDcwMzQsLjk1OTIzLDEuMTY4NjIsMS4wMDEzNSwuOTkwNDEsMS4wMDEzNSwuOTkwNDEsMS4wMDEzNSwuOTkwNDEsMS4wMDEzNSwuOTkwNDEsMS4wMDEzNSwuOTkwNDEsMS4wMDEzNSwuOTkwNDEsMS4wNjQ2NywxLjAyNTExLC45MDk5NiwuOTY3NTIsLjkwOTk2LC45OTM2MSwuOTU4MDEsLjk5MzYxLC45NTgwMSwuOTkzNjEsLjk1ODAxLDEuMDc3MzMsMS4wMzQyNCwuOTczNjMsLjk2NzUyLC45MzUwNiwuOTMxMzYsLjk3NDg5LDEuMDAwOCwxLDEsLjk1OTIzLDEuMTY4NjIsMS4xNTEwMywxLjE1MTAzLDEuMDExNzMsMS4wMzk1OSwuNzU5NTMsLjgxMzc4LC43OTkxMiwxLjE1MTAzLDEuMjE5OTQsLjk1MTYxLC44NzgxNSwxLjAxMTQ5LC44MTUyNSwuNzY3NiwuOTgxNjcsMS4wMTEzNCwxLjAyNTQ2LC44NDA5NywxLjAzMDg5LDEuMTgxMDIsLjk3MzYzLC44ODc3NiwuODUxMzQsLjk3ODI2LC43OTc5NSwuOTkzNjEsMS4wNjA4NSwuOTc0ODksMS4xNDA2LC44OTg1OCwxLjAzODgsMS4xNDg4OSwxLjA5Mzk4LC44NjAzOSwuOTc0ODksMS4wNTk1LC45MjA5NCwuOTQ3OTMsLjk1OTIzLC45MDk5NiwuOTkzNDYsLjk4MjQzLDEuMDIxMTIsLjk1NDkzLDEuMTQwNiwuOTA5OTYsMS4wMzU3NCwxLjAyNTk3LDEuMDAwOCwxLjE4MTAyLDEuMDY2MjgsMS4wMzU3NCwxLjAxOTIsMS4wMTkzMiwxLjAwODg2LC45NzUzMSwxLjAxMDYsMS4wMDA4LDEuMTMxODksMS4xODEwMiwxLjAyMjc3LC45ODY4MywxLjAwMTYsLjk5NTYxLDEuMDcyMzcsMS4wMDA4LC45MDQzNCwuOTk5MjEsLjkzODAzLC44OTY1LDEuMjMwODUsMS4wNjYyOCwxLjA0OTgzLC45NjI2OCwxLjA0OTksLjk4NDM5LDEuMTgxMDIsMS4wNjYyOCwxLjAwMDgsMS4wNjYyOCwuOTg0MzksLjc5Nzk1LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuMDk0NjYsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjk3Mjc4LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuMDIwNjUsMSwxLDEsMSwxLDEsMS4wNjQ2NywxLjAyNTExLDEuMDY0NjcsMS4wMjUxMSwxLjA2NDY3LDEuMDI1MTEsLjkwOTk2LC45Njc1MiwxLDEuMjE0MDgsLjg5OTAzLDEsMSwuNzUxNTUsMS4wNDM5NCwxLjA0Mzk0LDEuMDQzOTQsMS4wNDM5NCwuOTg2MzMsLjk4NjMzLC45ODYzMywuNzMwNDcsLjczMDQ3LDEuMjA2NDIsLjkxMjExLDEuMjU2MzUsMS4yMjIsMS4wMjk1NiwxLjAzMzcyLDEuMDMzNzIsLjk2MDM5LDEuMjQ2MzMsMSwxLjEyNDU0LC45MzUwMywxLjAzNDI0LDEuMTk2ODcsMS4wMzQyNCwxLDEsMSwuNzcxLDEsMSwxLjE1NzQ5LDEuMTU3NDksMS4xNTc0OSwxLjEwOTQ4LC44NjI3OSwuOTQ0MzQsLjg2Mjc5LC45NDQzNCwuODYxODIsMSwxLDEuMTY4OTcsMSwuOTYwODUsLjkwMTM3LDEuMjEwNywxLjE4NDE2LDEuMTM5NzMsLjY5ODI1LC45NzE2LDIuMTAzMzksMS4yOTAwNCwxLjI5MDA0LDEuMjExNzIsMS4yOTAwNCwxLjI5MDA0LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMS40MjYwMywxLC45OTg2MiwuOTk4NjIsMSwuODcwMjUsLjg3MDI1LC44NzAyNSwuODcwMjUsMS4xODg3NCwxLjQyNjAzLDEsMS40MjYwMywxLjQyNjAzLC45OTg2MiwxLDEsMSwxLDEsMS4yODg2LDEuMDQzMTUsMS4xNTI5NiwxLjM0MTYzLDEsMSwxLDEuMDkxOTMsMS4wOTE5MywxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMV07dC5TZWdvZXVpQm9sZE1ldHJpY3M9e2xpbmVIZWlnaHQ6MS4zMzAwOCxsaW5lR2FwOjB9O3QuU2Vnb2V1aUJvbGRJdGFsaWNGYWN0b3JzPVsxLjc2NzM4LDEsMSwuOTg5NDYsMS4wMzk1OSwxLjA0MDE2LDEuMDI4MDksMS4wMzYsLjk3NjM5LDEuMTA5NTMsMS4yMzIwMywxLjExMTQ0LDEuMTExNDQsMS4xNjkzOSwxLjIxMjM3LC45NzU0LDEuMjEyNjEsLjk3NTQsMS41OTc1NCwxLjAzNiwxLjAzNiwxLjAzNiwxLjAzNiwxLjAzNiwxLjAzNiwxLjAzNiwxLjAzNiwxLjAzNiwxLjAzNiwuODEzNzgsLjgxMzc4LDEuMjEyMzcsMS4yMTIzNywxLjIxMjM3LC43MzU0MSwuOTc4NDcsLjk3MzYzLC44OTcyMywuODc4OTcsMS4wNDI2LC43OTQyOSwuODUyOTIsLjkxMTQ5LDEuMDU4MTUsMS4xNDA2LC43OTYzMSwuOTAxMjgsLjgzODUzLDEuMDQzOTYsMS4xMDYxNSwuOTc1NTIsLjk0NDM2LC45NzU1MiwuODg2NDEsLjgwNTI3LC45NjA4MywxLjAwMTM1LDEsMS4wNjc3NywuOTgxNywuOTExNDIsLjk5MzYxLDEuMTExNDQsMS41NzI5MywxLjExMTQ0LDEuMjEyMzcsLjc0NjI3LDEuMzE4MTgsMS4wNjU4NSwuOTcwNDIsLjgzMDU1LC45NzA0MiwuOTM1MDMsMS4xMjYxLC45NzA0MiwuOTc5MjIsMS4xNDIzNiwuOTQ1NTIsMS4wMTA1NCwxLjE0MjM2LDEuMDI0NzEsLjk3OTIyLC45NDE2NSwuOTcwNDIsLjk3MDQyLDEuMDI3NiwuNzg5MjksMS4xMjYxLC45NzkyMiwuOTU4NzQsMS4wMjE5NywuOTg1MDcsLjk2NzUyLC45NzE2OCwuOTUxMDcsMS4xNjU3OSwuOTUxMDcsMS4yMTIzNywxLjAzOTU5LDEuMDM2LDEuMDM2LDEsMS4wMzYsMS4xNjU3OSwuODczNTcsMS4zMTgxOCwxLjE4NzU0LDEuMjY3ODEsMS4wNTM1NiwxLjIxMjM3LDEuMTg2MjIsLjc5NDg3LC45NDk5NCwxLjI5MDA0LDEuMjQwNDcsMS4yNDA0NywxLjMxODE4LDEsLjkxNDg0LC45NzU0LDEuMzE4MTgsMS4xMzQ5LDEuMjQ4NjYsMS4wNTM1NiwxLjEzOTM0LDEuMTU1NzQsMS4xNzM4OSwuNzM1NDEsLjk3MzYzLC45NzM2MywuOTczNjMsLjk3MzYzLC45NzM2MywuOTczNjMsLjk0Mzg1LC44Nzg5NywuNzk0MjksLjc5NDI5LC43OTQyOSwuNzk0MjksMS4xNDA2LDEuMTQwNiwxLjE0MDYsMS4xNDA2LDEuMDQyNiwxLjEwNjE1LC45NzU1MiwuOTc1NTIsLjk3NTUyLC45NzU1MiwuOTc1NTIsMS4yMTIzNywuOTc1NTIsMS4wMDEzNSwxLjAwMTM1LDEuMDAxMzUsMS4wMDEzNSwuOTExNDIsLjk0NDM2LC45ODcyMSwxLjA2NTg1LDEuMDY1ODUsMS4wNjU4NSwxLjA2NTg1LDEuMDY1ODUsMS4wNjU4NSwuOTY3MDUsLjgzMDU1LC45MzUwMywuOTM1MDMsLjkzNTAzLC45MzUwMywxLjE0MjM2LDEuMTQyMzYsMS4xNDIzNiwxLjE0MjM2LC45MzEyNSwuOTc5MjIsLjk0MTY1LC45NDE2NSwuOTQxNjUsLjk0MTY1LC45NDE2NSwxLjI5MDA0LC45NDE2NSwuOTc5MjIsLjk3OTIyLC45NzkyMiwuOTc5MjIsLjk2NzUyLC45NzA0MiwuOTY3NTIsLjk3MzYzLDEuMDY1ODUsLjk3MzYzLDEuMDY1ODUsLjk3MzYzLDEuMDY1ODUsLjg3ODk3LC44MzA1NSwuODc4OTcsLjgzMDU1LC44Nzg5NywuODMwNTUsLjg3ODk3LC44MzA1NSwxLjA0MjYsMS4wMDMzLDEuMDQyNiwuOTcwNDIsLjc5NDI5LC45MzUwMywuNzk0MjksLjkzNTAzLC43OTQyOSwuOTM1MDMsLjc5NDI5LC45MzUwMywuNzk0MjksLjkzNTAzLC45MTE0OSwuOTcwNDIsLjkxMTQ5LC45NzA0MiwuOTExNDksLjk3MDQyLDEsMSwxLjA1ODE1LC45NzkyMiwxLjA1ODE1LC45NzkyMiwxLjE0MDYsMS4xNDIzNiwxLjE0MDYsMS4xNDIzNiwxLjE0MDYsMS4xNDIzNiwxLjE0MDYsMS4xNDIzNiwxLjE0MDYsMS4xNDIzNiwuOTc0NDEsMS4wNDMwMiwuNzk2MzEsMS4wMTU4MiwxLDEsMS4wMTA1NCwuODM4NTMsMS4xNDIzNiwxLDEsLjgzODUzLDEuMDkxMjUsLjgzODUzLC45MDQxOCwuODM4NTMsMS4xOTUwOCwxLjEwNjE1LC45NzkyMiwxLDEsMS4xMDYxNSwuOTc5MjIsMS4wMTAzNCwxLjEwNDY2LC45NzkyMiwuOTc1NTIsLjk0MTY1LC45NzU1MiwuOTQxNjUsLjk3NTUyLC45NDE2NSwuOTE2MDIsLjkxOTgxLC44ODY0MSwxLjAyNzYsMSwxLC44ODY0MSwxLjAyNzYsLjgwNTI3LC43ODkyOSwuODA1MjcsLjc4OTI5LC44MDUyNywuNzg5MjksLjgwNTI3LC43ODkyOSwxLDEsLjk2MDgzLDEuMDU0MDMsLjk1OTIzLDEuMTY4NjIsMS4wMDEzNSwuOTc5MjIsMS4wMDEzNSwuOTc5MjIsMS4wMDEzNSwuOTc5MjIsMS4wMDEzNSwuOTc5MjIsMS4wMDEzNSwuOTc5MjIsMS4wMDEzNSwuOTc5MjIsMS4wNjc3NywxLjAyMTk3LC45MTE0MiwuOTY3NTIsLjkxMTQyLC45OTM2MSwuOTcxNjgsLjk5MzYxLC45NzE2OCwuOTkzNjEsLjk3MTY4LDEuMjMxOTksMS4wMzYsLjk3MzYzLDEuMDY1ODUsLjk0Mzg1LC45NjcwNSwuOTc1NTIsLjk0MTY1LDEsMSwuOTYwODMsMS4xMjYxLDEuMzE4MTgsMS4zMTgxOCwxLjMxODE4LDEuMzE4MTgsMS4zMTgxOCwxLjMxODE4LDEuMzE4MTgsMS4zMTgxOCwxLjMxODE4LC45NTE2MSwxLjI3MTI2LDEuMDA4MTEsLjgzMjg0LC43NzcwMiwuOTkxMzcsLjk1MjUzLDEuMDM0NywuODYxNDIsMS4wNzIwNSwxLjE0MjM2LC45NzM2MywuODk3MjMsLjg2ODY5LDEuMDk4MTgsLjc5NDI5LC45OTM2MSwxLjA1ODE1LC45NzU1MiwxLjE0MDYsLjkwMTI4LDEuMDY2NjIsMS4wNDM5NiwxLjEwNjE1LC44NDkxOCwuOTc1NTIsMS4wNDY5NCwuOTQ0MzYsLjk4MDE1LC45NjA4MywuOTExNDIsMS4wMDM1NiwuOTgxNywxLjAxOTQ1LC45ODk5OSwxLjE0MDYsLjkxMTQyLDEuMDQ5NjEsLjk4OTgsMS4wMDYzOSwxLjE0MjM2LDEuMDc1MTQsMS4wNDk2MSwuOTk2MDcsMS4wMjg5NywxLjAwOCwuOTg5OCwuOTUxMzQsMS4wMDYzOSwxLjExMTIxLDEuMTQyMzYsMS4wMDUxOCwuOTc5ODEsMS4wMjE4NiwxLDEuMDg1NzgsLjk0MTY1LC45OTMxNCwuOTgzODcsLjkzMDI4LC45MzM3NywxLjM1MTI1LDEuMDc1MTQsMS4xMDY4NywuOTM0OTEsMS4wNDIzMiwxLjAwMzUxLDEuMTQyMzYsMS4wNzUxNCwuOTQxNjUsMS4wNzUxNCwxLjAwMzUxLC43OTQyOSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLjA5MDk3LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC45MzUwMywxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTY2MDksMSwxLDEsMSwxLDEsMS4wNjc3NywxLjAyMTk3LDEuMDY3NzcsMS4wMjE5NywxLjA2Nzc3LDEuMDIxOTcsLjkxMTQyLC45Njc1MiwxLDEuMjEyNjEsLjg5OTAzLDEsMSwuNzUxNTUsMS4wNDc0NSwxLjA0NzQ1LDEuMDQ3NDUsMS4wNDM5NCwuOTg2MzMsLjk4NjMzLC45ODYzMywuNzI5NTksLjcyOTU5LDEuMjA1MDIsLjkxNDA2LDEuMjY1MTQsMS4yMjIsMS4wMjk1NiwxLjAzMzcyLDEuMDMzNzIsLjk2MDM5LDEuMjQ2MzMsMSwxLjA5MTI1LC45MzMyNywxLjAzMzM2LDEuMTY1NDEsMS4wMzYsMSwxLDEsLjc3MSwxLDEsMS4xNTU3NCwxLjE1NTc0LDEuMTU1NzQsMS4xNTU3NCwuODYzNjQsLjk0NDM0LC44NjI3OSwuOTQ0MzQsLjg2MjI0LDEsMSwxLjE2Nzk4LDEsLjk2MDg1LC45MDA2OCwxLjIxMjM3LDEuMTg0MTYsMS4xMzkwNCwuNjk4MjUsLjk3MTYsMi4xMDMzOSwxLjI5MDA0LDEuMjkwMDQsMS4yMTMzOSwxLjI5MDA0LDEuMjkwMDQsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLjQyNjAzLDEsLjk5ODYyLC45OTg2MiwxLC44NzAyNSwuODcwMjUsLjg3MDI1LC44NzAyNSwxLjE4Nzc1LDEuNDI2MDMsMSwxLjQyNjAzLDEuNDI2MDMsLjk5ODYyLDEsMSwxLDEsMSwxLjI4ODYsMS4wNDMxNSwxLjE1Mjk2LDEuMzQxNjMsMSwxLDEsMS4xMzI2OSwxLjEzMjY5LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxXTt0LlNlZ29ldWlCb2xkSXRhbGljTWV0cmljcz17bGluZUhlaWdodDoxLjMzMDA4LGxpbmVHYXA6MH07dC5TZWdvZXVpSXRhbGljRmFjdG9ycz1bMS43NjczOCwxLDEsLjk4OTQ2LDEuMTQ3NjMsMS4wNTM2NSwxLjA2MjM0LC45NjkyNywuOTI1ODYsMS4xNTM3MywxLjE4NDE0LC45MTM0OSwuOTEzNDksMS4wNzQwMywxLjE3MzA4LC43ODM4MywxLjIwMDg4LC43ODM4MywxLjQyNTMxLC45NjkyNywuOTY5MjcsLjk2OTI3LC45NjkyNywuOTY5MjcsLjk2OTI3LC45NjkyNywuOTY5MjcsLjk2OTI3LC45NjkyNywuNzgzODMsLjc4MzgzLDEuMTczMDgsMS4xNzMwOCwxLjE3MzA4LC43NzM0OSwuOTQ1NjUsLjk0NzI5LC44NTk0NCwuODg1MDYsLjk4NTgsLjc0ODE3LC44MDAxNiwuODg0NDksLjk4MDM5LC45NTc4MiwuNjkyMzgsLjg5ODk4LC44MzIzMSwuOTgxODMsMS4wMzk4OSwuOTY5MjQsLjg2MjM3LC45NjkyNCwuODA1OTUsLjc0NTI0LC44NjA5MSwuOTU0MDIsLjk0MTQzLC45ODQ0OCwuODg1OCwuODMwODksLjkzMjg1LDEuMDk0OSwxLjM5MDE2LDEuMDk0OSwxLjQ1OTk0LC43NDYyNywxLjA0ODM5LC45NzQ1NCwuOTc0NTQsLjg3MjA3LC45NzQ1NCwuODc1MzMsMS4wNjE1MSwuOTc0NTQsMS4wMDE3NiwxLjE2NDg0LDEuMDgxMzIsLjk4MDQ3LDEuMTY0ODQsMS4wMjk4OSwxLjAxMDU0LC45NjIyNSwuOTc0NTQsLjk3NDU0LDEuMDY1OTgsLjc5MDA0LDEuMTYzNDQsMS4wMDM1MSwuOTQ2MjksLjk5NzMsLjkxMDE2LC45Njc3NywuOTA0MywuOTEwODIsLjkyNDgxLC45MTA4MiwxLjE3MzA4LC45NTc0OCwuOTY5MjcsLjk2OTI3LDEsLjk2OTI3LC45MjQ4MSwuODA1OTcsMS4wNDgzOSwxLjIzMzkzLDEuMTc4MSwuOTI0NSwxLjE3MzA4LDEuMjA4MDgsLjYzMjE4LC45NDI2MSwxLjI0ODIyLDEuMDk5NzEsMS4wOTk3MSwxLjA0ODM5LDEsLjg1MjczLC43ODAzMiwxLjA0ODM5LDEuMDk5NzEsMS4yMjMyNiwuOTI0NSwxLjA5ODM2LDEuMTM1MjUsMS4xNTIyMiwuNzA0MjQsLjk0NzI5LC45NDcyOSwuOTQ3MjksLjk0NzI5LC45NDcyOSwuOTQ3MjksLjg1NDk4LC44ODUwNiwuNzQ4MTcsLjc0ODE3LC43NDgxNywuNzQ4MTcsLjk1NzgyLC45NTc4MiwuOTU3ODIsLjk1NzgyLC45ODU4LDEuMDM5ODksLjk2OTI0LC45NjkyNCwuOTY5MjQsLjk2OTI0LC45NjkyNCwxLjE3MzA4LC45NjkyNCwuOTU0MDIsLjk1NDAyLC45NTQwMiwuOTU0MDIsLjgzMDg5LC44NjIzNywuODg0MDksLjk3NDU0LC45NzQ1NCwuOTc0NTQsLjk3NDU0LC45NzQ1NCwuOTc0NTQsLjkyOTE2LC44NzIwNywuODc1MzMsLjg3NTMzLC44NzUzMywuODc1MzMsLjkzMTQ2LC45MzE0NiwuOTMxNDYsLjkzMTQ2LC45Mzg1NCwxLjAxMDU0LC45NjIyNSwuOTYyMjUsLjk2MjI1LC45NjIyNSwuOTYyMjUsMS4yNDgyMiwuODc2MSwxLjAwMzUxLDEuMDAzNTEsMS4wMDM1MSwxLjAwMzUxLC45Njc3NywuOTc0NTQsLjk2Nzc3LC45NDcyOSwuOTc0NTQsLjk0NzI5LC45NzQ1NCwuOTQ3MjksLjk3NDU0LC44ODUwNiwuODcyMDcsLjg4NTA2LC44NzIwNywuODg1MDYsLjg3MjA3LC44ODUwNiwuODcyMDcsLjk4NTgsLjk1MzkxLC45ODU4LC45NzQ1NCwuNzQ4MTcsLjg3NTMzLC43NDgxNywuODc1MzMsLjc0ODE3LC44NzUzMywuNzQ4MTcsLjg3NTMzLC43NDgxNywuODc1MzMsLjg4NDQ5LC45NzQ1NCwuODg0NDksLjk3NDU0LC44ODQ0OSwuOTc0NTQsMSwxLC45ODAzOSwxLjAwMTc2LC45ODAzOSwxLjAwMTc2LC45NTc4MiwuOTMxNDYsLjk1NzgyLC45MzE0NiwuOTU3ODIsLjkzMTQ2LC45NTc4MiwxLjE2NDg0LC45NTc4MiwuOTMxNDYsLjg0NDIxLDEuMTI3NjEsLjY5MjM4LDEuMDgxMzIsMSwxLC45ODA0NywuODMyMzEsMS4xNjQ4NCwxLDEsLjg0NzIzLDEuMDQ4NjEsLjg0NzIzLC43ODc1NSwuODMyMzEsMS4yMzczNiwxLjAzOTg5LDEuMDEwNTQsMSwxLDEuMDM5ODksMS4wMTA1NCwuOTg1NywxLjAzODQ5LDEuMDEwNTQsLjk2OTI0LC45NjIyNSwuOTY5MjQsLjk2MjI1LC45NjkyNCwuOTYyMjUsLjkyMzgzLC45MDE3MSwuODA1OTUsMS4wNjU5OCwxLDEsLjgwNTk1LDEuMDY1OTgsLjc0NTI0LC43OTAwNCwuNzQ1MjQsLjc5MDA0LC43NDUyNCwuNzkwMDQsLjc0NTI0LC43OTAwNCwxLDEsLjg2MDkxLDEuMDI3NTksLjg1NzcxLDEuMTYzNDQsLjk1NDAyLDEuMDAzNTEsLjk1NDAyLDEuMDAzNTEsLjk1NDAyLDEuMDAzNTEsLjk1NDAyLDEuMDAzNTEsLjk1NDAyLDEuMDAzNTEsLjk1NDAyLDEuMDAzNTEsLjk4NDQ4LC45OTczLC44MzA4OSwuOTY3NzcsLjgzMDg5LC45MzI4NSwuOTA0MywuOTMyODUsLjkwNDMsLjkzMjg1LC45MDQzLDEuMzE4NjgsLjk2OTI3LC45NDcyOSwuOTc0NTQsLjg1NDk4LC45MjkxNiwuOTY5MjQsLjg3NjEsMSwxLC44NjA5MSwxLjE2MzQ0LDEuMDQ4MzksMS4wNDgzOSwxLjA0ODM5LDEuMDQ4MzksMS4wNDgzOSwxLjA0ODM5LDEuMDQ4MzksMS4wNDgzOSwxLjA0ODM5LC44MTk2NSwuODE5NjUsLjk0NzI5LC43ODAzMiwuNzEwMjIsLjkwODgzLC44NDE3MSwuOTk4NzcsLjc3NTk2LDEuMDU3MzQsMS4yLC45NDcyOSwuODU5NDQsLjgyNzkxLC45NjA3LC43NDgxNywuOTMyODUsLjk4MDM5LC45NjkyNCwuOTU3ODIsLjg5ODk4LC45ODMxNiwuOTgxODMsMS4wMzk4OSwuNzg2MTQsLjk2OTI0LC45NzY0MiwuODYyMzcsLjg2MDc1LC44NjA5MSwuODMwODksLjkwMDgyLC44ODU4LC45NzI5NiwxLjAxMjg0LC45NTc4MiwuODMwODksMS4wOTc2LDEuMDQsMS4wMzM0MiwxLjIsMS4wNjc1LDEuMDk3NiwuOTgyMDUsMS4wMzgwOSwxLjA1MDk3LDEuMDQsLjk1MzY0LDEuMDMzNDIsMS4wNTQwMSwxLjIsMS4wMjE0OCwxLjAxMTksMS4wNDcyNCwxLjAxMjcsMS4wMjczMiwuOTYyMjUsLjg5NjUsLjk3NzgzLC45MzU3NCwuOTQ4MTgsMS4zMDY3OSwxLjA2NzUsMS4xMTgyNiwuOTk4MjEsMS4wNTU3LDEuMDMyNiwxLjIsMS4wNjc1LC45NjIyNSwxLjA2NzUsMS4wMzI2LC43NDgxNywxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLjAzNzU0LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC44NzUzMywxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTg3MDUsMSwxLDEsMSwxLDEsLjk4NDQ4LC45OTczLC45ODQ0OCwuOTk3MywuOTg0NDgsLjk5NzMsLjgzMDg5LC45Njc3NywxLDEuMjAwODgsLjg5OTAzLDEsMSwuNzUxNTUsLjk0OTQ1LC45NDk0NSwuOTQ5NDUsLjk0OTQ1LDEuMTIzMTcsMS4xMjMxNywxLjEyMzE3LC42NzYwMywuNjc2MDMsMS4xNTYyMSwuNzM1ODQsMS4yMTE5MSwxLjIyMTM1LDEuMDY0ODMsLjk0ODY4LC45NDg2OCwuOTU5OTYsMS4yNDYzMywxLDEuMDc0OTcsLjg3NzA5LC45NjkyNywxLjAxNDczLC45NjkyNywxLDEsMSwuNzcyOTUsMSwxLDEuMDk4MzYsMS4wOTgzNiwxLjA5ODM2LDEuMDE1MjIsLjg2MzIxLC45NDQzNCwuODY0OSwuOTQ0MzQsLjg2MTgyLDEsMSwxLjA4MywxLC45MTU3OCwuODY0MzgsMS4xNzMwOCwxLjE4NDE2LDEuMTQ1ODksLjY5ODI1LC45NzYyMiwxLjk2NzkxLDEuMjQ4MjIsMS4yNDgyMiwxLjE3MzA4LDEuMjQ4MjIsMS4yNDgyMiwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuNDI2MDMsMSwuOTk4NjIsLjk5ODYyLDEsLjg3MDI1LC44NzAyNSwuODcwMjUsLjg3MDI1LDEuMTc5ODQsMS40MjYwMywxLDEuNDI2MDMsMS40MjYwMywuOTk4NjIsMSwxLDEsMSwxLDEuMjg4NiwxLjA0MzE1LDEuMTUyOTYsMS4zNDE2MywxLDEsMSwxLjEwNzQyLDEuMTA3NDIsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDFdO3QuU2Vnb2V1aUl0YWxpY01ldHJpY3M9e2xpbmVIZWlnaHQ6MS4zMzAwOCxsaW5lR2FwOjB9O3QuU2Vnb2V1aVJlZ3VsYXJGYWN0b3JzPVsxLjc2NzM4LDEsMSwuOTg1OTQsMS4wMjI4NSwxLjEwNDU0LDEuMDYyMzQsLjk2OTI3LC45MjAzNywxLjE5OTg1LDEuMjA0NiwuOTA2MTYsLjkwNjE2LDEuMDcxNTIsMS4xNzE0LC43ODAzMiwxLjIwMDg4LC43ODAzMiwxLjQwMjQ2LC45NjkyNywuOTY5MjcsLjk2OTI3LC45NjkyNywuOTY5MjcsLjk2OTI3LC45NjkyNywuOTY5MjcsLjk2OTI3LC45NjkyNywuNzgwMzIsLjc4MDMyLDEuMTcxNCwxLjE3MTQsMS4xNzE0LC44MDU5NywuOTQwODQsLjk2NzA2LC44NTk0NCwuODU3MzQsLjk3MDkzLC43NTg0MiwuNzk5MzYsLjg4MTk4LC45ODMxLC45NTc4MiwuNzEzODcsLjg2OTY5LC44NDYzNiwxLjA3Nzk2LDEuMDM1ODQsLjk2OTI0LC44Mzk2OCwuOTY5MjQsLjgyODI2LC43OTY0OSwuODU3NzEsLjk1MTMyLC45MzExOSwuOTg5NjUsLjg4NDMzLC44Mjg3LC45MzM2NSwxLjA4NjEyLDEuMzYzOCwxLjA4NjEyLDEuNDU3ODYsLjc0NjI3LC44MDQ5OSwuOTE0ODQsMS4wNTcwNywuOTIzODMsMS4wNTg4MiwuOTQwMywxLjEyNjU0LDEuMDU4ODIsMS4wMTc1NiwxLjA5MDExLDEuMDkwMTEsLjk5NDE0LDEuMDkwMTEsMS4wMzQsMS4wMTc1NiwxLjA1MzU2LDEuMDU3MDcsMS4wNTg4MiwxLjA0Mzk5LC44NDg2MywxLjIxOTY4LDEuMDE3NTYsLjk1ODAxLDEuMDAwNjgsLjkxNzk3LC45Njc3NywuOTA0MywuOTAzNTEsLjkyMTA1LC45MDM1MSwxLjE3MTQsLjg1MzM3LC45NjkyNywuOTY5MjcsLjk5OTEyLC45NjkyNywuOTIxMDUsLjgwNTk3LDEuMjQzNCwxLjIwODA4LDEuMDU5MzcsLjkwOTU3LDEuMTcxNCwxLjIwODA4LC43NTE1NSwuOTQyNjEsMS4yNDY0NCwxLjA5OTcxLDEuMDk5NzEsLjg0NzUxLDEsLjg1MjczLC43ODAzMiwuNjE1ODQsMS4wNTQyNSwxLjE3OTE0LC45MDk1NywxLjA4NjY1LDEuMTE1OTMsMS4xNDE2OSwuNzMzODEsLjk2NzA2LC45NjcwNiwuOTY3MDYsLjk2NzA2LC45NjcwNiwuOTY3MDYsLjg2MDM1LC44NTczNCwuNzU4NDIsLjc1ODQyLC43NTg0MiwuNzU4NDIsLjk1NzgyLC45NTc4MiwuOTU3ODIsLjk1NzgyLC45NzA5MywxLjAzNTg0LC45NjkyNCwuOTY5MjQsLjk2OTI0LC45NjkyNCwuOTY5MjQsMS4xNzE0LC45NjkyNCwuOTUxMzIsLjk1MTMyLC45NTEzMiwuOTUxMzIsLjgyODcsLjgzOTY4LC44OTA0OSwuOTE0ODQsLjkxNDg0LC45MTQ4NCwuOTE0ODQsLjkxNDg0LC45MTQ4NCwuOTM1NzUsLjkyMzgzLC45NDAzLC45NDAzLC45NDAzLC45NDAzLC44NzE3LC44NzE3LC44NzE3LC44NzE3LDEuMDA1MjcsMS4wMTc1NiwxLjA1MzU2LDEuMDUzNTYsMS4wNTM1NiwxLjA1MzU2LDEuMDUzNTYsMS4yNDY0NCwuOTU5MjMsMS4wMTc1NiwxLjAxNzU2LDEuMDE3NTYsMS4wMTc1NiwuOTY3NzcsMS4wNTcwNywuOTY3NzcsLjk2NzA2LC45MTQ4NCwuOTY3MDYsLjkxNDg0LC45NjcwNiwuOTE0ODQsLjg1NzM0LC45MjM4MywuODU3MzQsLjkyMzgzLC44NTczNCwuOTIzODMsLjg1NzM0LC45MjM4MywuOTcwOTMsMS4wOTY5LC45NzA5MywxLjA1ODgyLC43NTg0MiwuOTQwMywuNzU4NDIsLjk0MDMsLjc1ODQyLC45NDAzLC43NTg0MiwuOTQwMywuNzU4NDIsLjk0MDMsLjg4MTk4LDEuMDU4ODIsLjg4MTk4LDEuMDU4ODIsLjg4MTk4LDEuMDU4ODIsMSwxLC45ODMxLDEuMDE3NTYsLjk4MzEsMS4wMTc1NiwuOTU3ODIsLjg3MTcsLjk1NzgyLC44NzE3LC45NTc4MiwuODcxNywuOTU3ODIsMS4wOTAxMSwuOTU3ODIsLjg3MTcsLjg0Nzg0LDEuMTE1NTEsLjcxMzg3LDEuMDkwMTEsMSwxLC45OTQxNCwuODQ2MzYsMS4wOTAxMSwxLDEsLjg0NjM2LDEuMDUzNiwuODQ2MzYsLjk0Mjk4LC44NDYzNiwxLjIzMjk3LDEuMDM1ODQsMS4wMTc1NiwxLDEsMS4wMzU4NCwxLjAxNzU2LDEuMDAzMjMsMS4wMzQ0NCwxLjAxNzU2LC45NjkyNCwxLjA1MzU2LC45NjkyNCwxLjA1MzU2LC45NjkyNCwxLjA1MzU2LC45MzA2NiwuOTgyOTMsLjgyODI2LDEuMDQzOTksMSwxLC44MjgyNiwxLjA0Mzk5LC43OTY0OSwuODQ4NjMsLjc5NjQ5LC44NDg2MywuNzk2NDksLjg0ODYzLC43OTY0OSwuODQ4NjMsMSwxLC44NTc3MSwxLjE3MzE4LC44NTc3MSwxLjIxOTY4LC45NTEzMiwxLjAxNzU2LC45NTEzMiwxLjAxNzU2LC45NTEzMiwxLjAxNzU2LC45NTEzMiwxLjAxNzU2LC45NTEzMiwxLjAxNzU2LC45NTEzMiwxLjAxNzU2LC45ODk2NSwxLjAwMDY4LC44Mjg3LC45Njc3NywuODI4NywuOTMzNjUsLjkwNDMsLjkzMzY1LC45MDQzLC45MzM2NSwuOTA0MywxLjA4NTcxLC45NjkyNywuOTY3MDYsLjkxNDg0LC44NjAzNSwuOTM1NzUsLjk2OTI0LC45NTkyMywxLDEsLjg1NzcxLDEuMjE5NjgsMS4xMTQzNywxLjExNDM3LC45MzEwOSwuOTEyMDIsLjYwNDExLC44NDE2NCwuNTU1NzIsMS4wMTE3MywuOTczNjEsLjgxODE4LC44MTgxOCwuOTY2MzUsLjc4MDMyLC43MjcyNywuOTIzNjYsLjk4NjAxLDEuMDM0MDUsLjc3OTY4LDEuMDk3OTksMS4yLC45NjcwNiwuODU5NDQsLjg1NjM4LC45NjQ5MSwuNzU4NDIsLjkzMzY1LC45ODMxLC45NjkyNCwuOTU3ODIsLjg2OTY5LC45NDE1MiwxLjA3Nzk2LDEuMDM1ODQsLjc4NDM3LC45NjkyNCwuOTg3MTUsLjgzOTY4LC44MzQ5MSwuODU3NzEsLjgyODcsLjk0NDkyLC44ODQzMywuOTI4NywxLjAwOTgsLjk1NzgyLC44Mjg3LDEuMDYyNSwuOTgyNDgsMS4wMzQyNCwxLjIsMS4wMTA3MSwxLjA2MjUsLjk1MjQ2LDEuMDM4MDksMS4wNDkxMiwuOTgyNDgsMS4wMDIyMSwxLjAzNDI0LDEuMDU0NDMsMS4yLDEuMDQ3ODUsLjk5NjA5LDEuMDAxNjksMS4wNTE3NiwuOTkzNDYsMS4wNTM1NiwuOTA4NywxLjAzMDA0LC45NTU0MiwuOTMxMTcsMS4yMzM2MiwxLjAxMDcxLDEuMDc4MzEsMS4wMjUxMiwxLjA1MjA1LDEuMDM1MDIsMS4yLDEuMDEwNzEsMS4wNTM1NiwxLjAxMDcxLDEuMDM1MDIsLjc1ODQyLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuMDM3MTksMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjk0MDMsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMS4wNDAyMSwxLDEsMSwxLDEsMSwuOTg5NjUsMS4wMDA2OCwuOTg5NjUsMS4wMDA2OCwuOTg5NjUsMS4wMDA2OCwuODI4NywuOTY3NzcsMSwxLjIwMDg4LC44OTkwMywxLDEsLjc1MTU1LDEuMDMwNzcsMS4wMzA3NywxLjAzMDc3LDEuMDMwNzcsMS4xMzE5NiwxLjEzMTk2LDEuMTMxOTYsLjY3NDI4LC42NzQyOCwxLjE2MDM5LC43MzI5MSwxLjIwOTk2LDEuMjIxMzUsMS4wNjQ4MywuOTQ4NjgsLjk0ODY4LC45NTk5NiwxLjI0NjMzLDEsMS4wNzQ5NywuODc3OTYsLjk2OTI3LDEuMDE1MTgsLjk2OTI3LDEsMSwxLC43NzI5NSwxLDEsMS4xMDUzOSwxLjEwNTM5LDEuMTEzNTgsMS4wNjk2NywuODYyNzksLjk0NDM0LC44NjI3OSwuOTQ0MzQsLjg2MTgyLDEsMSwxLjA4MywxLC45MTU3OCwuODY1MDcsMS4xNzE0LDEuMTg0MTYsMS4xNDU4OSwuNjk4MjUsLjk3NjIyLDEuOTY5NywxLjI0ODIyLDEuMjQ4MjIsMS4xNzIzOCwxLjI0ODIyLDEuMjQ4MjIsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLjQyNjAzLDEsLjk5ODYyLC45OTg2MiwxLC44NzAyNSwuODcwMjUsLjg3MDI1LC44NzAyNSwxLjE4MDgzLDEuNDI2MDMsMSwxLjQyNjAzLDEuNDI2MDMsLjk5ODYyLDEsMSwxLDEsMSwxLjI4ODYsMS4wNDMxNSwxLjE1Mjk2LDEuMzQxNjMsMSwxLDEsMS4xMDkzOCwxLjEwOTM4LDEsMSwxLDEuMDU0MjUsMS4wOTk3MSwxLjA5OTcxLDEuMDk5NzEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxXTt0LlNlZ29ldWlSZWd1bGFyTWV0cmljcz17bGluZUhlaWdodDoxLjMzMDA4LGxpbmVHYXA6MH19LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5Qb3N0U2NyaXB0RXZhbHVhdG9yPXQuUG9zdFNjcmlwdENvbXBpbGVyPXQuUERGRnVuY3Rpb25GYWN0b3J5PXZvaWQgMDt0LmlzUERGRnVuY3Rpb249ZnVuY3Rpb24gaXNQREZGdW5jdGlvbihlKXtsZXQgdDtpZigib2JqZWN0IiE9dHlwZW9mIGUpcmV0dXJuITE7aWYoZSBpbnN0YW5jZW9mIHIuRGljdCl0PWU7ZWxzZXtpZighKGUgaW5zdGFuY2VvZiBzLkJhc2VTdHJlYW0pKXJldHVybiExO3Q9ZS5kaWN0fXJldHVybiB0LmhhcygiRnVuY3Rpb25UeXBlIil9O3ZhciByPWEoNSksbj1hKDIpLGk9YSg1OCkscz1hKDcpLG89YSg1OSk7dC5QREZGdW5jdGlvbkZhY3Rvcnk9Y2xhc3MgUERGRnVuY3Rpb25GYWN0b3J5e2NvbnN0cnVjdG9yKHt4cmVmOmUsaXNFdmFsU3VwcG9ydGVkOnQ9ITB9KXt0aGlzLnhyZWY9ZTt0aGlzLmlzRXZhbFN1cHBvcnRlZD0hMSE9PXR9Y3JlYXRlKGUpe2NvbnN0IHQ9dGhpcy5nZXRDYWNoZWQoZSk7aWYodClyZXR1cm4gdDtjb25zdCBhPVBERkZ1bmN0aW9uLnBhcnNlKHt4cmVmOnRoaXMueHJlZixpc0V2YWxTdXBwb3J0ZWQ6dGhpcy5pc0V2YWxTdXBwb3J0ZWQsZm46ZSBpbnN0YW5jZW9mIHIuUmVmP3RoaXMueHJlZi5mZXRjaChlKTplfSk7dGhpcy5fY2FjaGUoZSxhKTtyZXR1cm4gYX1jcmVhdGVGcm9tQXJyYXkoZSl7Y29uc3QgdD10aGlzLmdldENhY2hlZChlKTtpZih0KXJldHVybiB0O2NvbnN0IGE9UERGRnVuY3Rpb24ucGFyc2VBcnJheSh7eHJlZjp0aGlzLnhyZWYsaXNFdmFsU3VwcG9ydGVkOnRoaXMuaXNFdmFsU3VwcG9ydGVkLGZuT2JqOmUgaW5zdGFuY2VvZiByLlJlZj90aGlzLnhyZWYuZmV0Y2goZSk6ZX0pO3RoaXMuX2NhY2hlKGUsYSk7cmV0dXJuIGF9Z2V0Q2FjaGVkKGUpe2xldCB0O2UgaW5zdGFuY2VvZiByLlJlZj90PWU6ZSBpbnN0YW5jZW9mIHIuRGljdD90PWUub2JqSWQ6ZSBpbnN0YW5jZW9mIHMuQmFzZVN0cmVhbSYmKHQ9ZS5kaWN0JiZlLmRpY3Qub2JqSWQpO2lmKHQpe2NvbnN0IGU9dGhpcy5fbG9jYWxGdW5jdGlvbkNhY2hlLmdldEJ5UmVmKHQpO2lmKGUpcmV0dXJuIGV9cmV0dXJuIG51bGx9X2NhY2hlKGUsdCl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKCdQREZGdW5jdGlvbkZhY3RvcnkuX2NhY2hlIC0gZXhwZWN0ZWQgInBhcnNlZEZ1bmN0aW9uIiBhcmd1bWVudC4nKTtsZXQgYTtlIGluc3RhbmNlb2Ygci5SZWY/YT1lOmUgaW5zdGFuY2VvZiByLkRpY3Q/YT1lLm9iaklkOmUgaW5zdGFuY2VvZiBzLkJhc2VTdHJlYW0mJihhPWUuZGljdCYmZS5kaWN0Lm9iaklkKTthJiZ0aGlzLl9sb2NhbEZ1bmN0aW9uQ2FjaGUuc2V0KG51bGwsYSx0KX1nZXQgX2xvY2FsRnVuY3Rpb25DYWNoZSgpe3JldHVybigwLG4uc2hhZG93KSh0aGlzLCJfbG9jYWxGdW5jdGlvbkNhY2hlIixuZXcgby5Mb2NhbEZ1bmN0aW9uQ2FjaGUpfX07ZnVuY3Rpb24gdG9OdW1iZXJBcnJheShlKXtpZighQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gbnVsbDtjb25zdCB0PWUubGVuZ3RoO2ZvcihsZXQgYT0wO2E8dDthKyspaWYoIm51bWJlciIhPXR5cGVvZiBlW2FdKXtjb25zdCBhPW5ldyBBcnJheSh0KTtmb3IobGV0IHI9MDtyPHQ7cisrKWFbcl09K2Vbcl07cmV0dXJuIGF9cmV0dXJuIGV9Y2xhc3MgUERGRnVuY3Rpb257c3RhdGljIGdldFNhbXBsZUFycmF5KGUsdCxhLHIpe2xldCBuLGkscz0xO2ZvcihuPTAsaT1lLmxlbmd0aDtuPGk7bisrKXMqPWVbbl07cyo9dDtjb25zdCBvPW5ldyBBcnJheShzKTtsZXQgYz0wLGw9MDtjb25zdCBoPTEvKDIqKmEtMSksdT1yLmdldEJ5dGVzKChzKmErNykvOCk7bGV0IGQ9MDtmb3Iobj0wO248cztuKyspe2Zvcig7YzxhOyl7bDw8PTg7bHw9dVtkKytdO2MrPTh9Yy09YTtvW25dPShsPj5jKSpoO2wmPSgxPDxjKS0xfXJldHVybiBvfXN0YXRpYyBwYXJzZSh7eHJlZjplLGlzRXZhbFN1cHBvcnRlZDp0LGZuOmF9KXtjb25zdCByPWEuZGljdHx8YTtzd2l0Y2goci5nZXQoIkZ1bmN0aW9uVHlwZSIpKXtjYXNlIDA6cmV0dXJuIHRoaXMuY29uc3RydWN0U2FtcGxlZCh7eHJlZjplLGlzRXZhbFN1cHBvcnRlZDp0LGZuOmEsZGljdDpyfSk7Y2FzZSAxOmJyZWFrO2Nhc2UgMjpyZXR1cm4gdGhpcy5jb25zdHJ1Y3RJbnRlcnBvbGF0ZWQoe3hyZWY6ZSxpc0V2YWxTdXBwb3J0ZWQ6dCxkaWN0OnJ9KTtjYXNlIDM6cmV0dXJuIHRoaXMuY29uc3RydWN0U3RpY2hlZCh7eHJlZjplLGlzRXZhbFN1cHBvcnRlZDp0LGRpY3Q6cn0pO2Nhc2UgNDpyZXR1cm4gdGhpcy5jb25zdHJ1Y3RQb3N0U2NyaXB0KHt4cmVmOmUsaXNFdmFsU3VwcG9ydGVkOnQsZm46YSxkaWN0OnJ9KX10aHJvdyBuZXcgbi5Gb3JtYXRFcnJvcigiVW5rbm93biB0eXBlIG9mIGZ1bmN0aW9uIil9c3RhdGljIHBhcnNlQXJyYXkoe3hyZWY6ZSxpc0V2YWxTdXBwb3J0ZWQ6dCxmbk9iajphfSl7aWYoIUFycmF5LmlzQXJyYXkoYSkpcmV0dXJuIHRoaXMucGFyc2Uoe3hyZWY6ZSxpc0V2YWxTdXBwb3J0ZWQ6dCxmbjphfSk7Y29uc3Qgcj1bXTtmb3IobGV0IG49MCxpPWEubGVuZ3RoO248aTtuKyspci5wdXNoKHRoaXMucGFyc2Uoe3hyZWY6ZSxpc0V2YWxTdXBwb3J0ZWQ6dCxmbjplLmZldGNoSWZSZWYoYVtuXSl9KSk7cmV0dXJuIGZ1bmN0aW9uKGUsdCxhLG4pe2ZvcihsZXQgaT0wLHM9ci5sZW5ndGg7aTxzO2krKylyW2ldKGUsdCxhLG4raSl9fXN0YXRpYyBjb25zdHJ1Y3RTYW1wbGVkKHt4cmVmOmUsaXNFdmFsU3VwcG9ydGVkOnQsZm46YSxkaWN0OnJ9KXtmdW5jdGlvbiB0b011bHRpQXJyYXkoZSl7Y29uc3QgdD1lLmxlbmd0aCxhPVtdO2xldCByPTA7Zm9yKGxldCBuPTA7bjx0O24rPTIpYVtyKytdPVtlW25dLGVbbisxXV07cmV0dXJuIGF9ZnVuY3Rpb24gaW50ZXJwb2xhdGUoZSx0LGEscixuKXtyZXR1cm4gcisobi1yKS8oYS10KSooZS10KX1sZXQgaT10b051bWJlckFycmF5KHIuZ2V0QXJyYXkoIkRvbWFpbiIpKSxzPXRvTnVtYmVyQXJyYXkoci5nZXRBcnJheSgiUmFuZ2UiKSk7aWYoIWl8fCFzKXRocm93IG5ldyBuLkZvcm1hdEVycm9yKCJObyBkb21haW4gb3IgcmFuZ2UiKTtjb25zdCBvPWkubGVuZ3RoLzIsYz1zLmxlbmd0aC8yO2k9dG9NdWx0aUFycmF5KGkpO3M9dG9NdWx0aUFycmF5KHMpO2NvbnN0IGw9dG9OdW1iZXJBcnJheShyLmdldEFycmF5KCJTaXplIikpLGg9ci5nZXQoIkJpdHNQZXJTYW1wbGUiKSx1PXIuZ2V0KCJPcmRlciIpfHwxOzEhPT11JiYoMCxuLmluZm8pKCJObyBzdXBwb3J0IGZvciBjdWJpYyBzcGxpbmUgaW50ZXJwb2xhdGlvbjogIit1KTtsZXQgZD10b051bWJlckFycmF5KHIuZ2V0QXJyYXkoIkVuY29kZSIpKTtpZihkKWQ9dG9NdWx0aUFycmF5KGQpO2Vsc2V7ZD1bXTtmb3IobGV0IGU9MDtlPG87KytlKWQucHVzaChbMCxsW2VdLTFdKX1sZXQgZj10b051bWJlckFycmF5KHIuZ2V0QXJyYXkoIkRlY29kZSIpKTtmPWY/dG9NdWx0aUFycmF5KGYpOnM7Y29uc3QgZz10aGlzLmdldFNhbXBsZUFycmF5KGwsYyxoLGEpO3JldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RTYW1wbGVkRm4oZSx0LGEscil7Y29uc3Qgbj0xPDxvLGg9bmV3IEZsb2F0NjRBcnJheShuKSx1PW5ldyBVaW50MzJBcnJheShuKTtsZXQgcCxtO2ZvcihtPTA7bTxuO20rKyloW21dPTE7bGV0IGI9Yyx5PTE7Zm9yKHA9MDtwPG87KytwKXtjb25zdCBhPWlbcF1bMF0scj1pW3BdWzFdO2xldCBzPWludGVycG9sYXRlKE1hdGgubWluKE1hdGgubWF4KGVbdCtwXSxhKSxyKSxhLHIsZFtwXVswXSxkW3BdWzFdKTtjb25zdCBvPWxbcF07cz1NYXRoLm1pbihNYXRoLm1heChzLDApLG8tMSk7Y29uc3QgYz1zPG8tMT9NYXRoLmZsb29yKHMpOnMtMSxmPWMrMS1zLGc9cy1jLHc9YypiLFM9dytiO2ZvcihtPTA7bTxuO20rKylpZihtJnkpe2hbbV0qPWc7dVttXSs9U31lbHNle2hbbV0qPWY7dVttXSs9d31iKj1vO3k8PD0xfWZvcihtPTA7bTxjOysrbSl7bGV0IGU9MDtmb3IocD0wO3A8bjtwKyspZSs9Z1t1W3BdK21dKmhbcF07ZT1pbnRlcnBvbGF0ZShlLDAsMSxmW21dWzBdLGZbbV1bMV0pO2FbcittXT1NYXRoLm1pbihNYXRoLm1heChlLHNbbV1bMF0pLHNbbV1bMV0pfX19c3RhdGljIGNvbnN0cnVjdEludGVycG9sYXRlZCh7eHJlZjplLGlzRXZhbFN1cHBvcnRlZDp0LGRpY3Q6YX0pe2NvbnN0IHI9dG9OdW1iZXJBcnJheShhLmdldEFycmF5KCJDMCIpKXx8WzBdLG49dG9OdW1iZXJBcnJheShhLmdldEFycmF5KCJDMSIpKXx8WzFdLGk9YS5nZXQoIk4iKSxzPVtdO2ZvcihsZXQgZT0wLHQ9ci5sZW5ndGg7ZTx0OysrZSlzLnB1c2gobltlXS1yW2VdKTtjb25zdCBvPXMubGVuZ3RoO3JldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RJbnRlcnBvbGF0ZWRGbihlLHQsYSxuKXtjb25zdCBjPTE9PT1pP2VbdF06ZVt0XSoqaTtmb3IobGV0IGU9MDtlPG87KytlKWFbbitlXT1yW2VdK2Mqc1tlXX19c3RhdGljIGNvbnN0cnVjdFN0aWNoZWQoe3hyZWY6ZSxpc0V2YWxTdXBwb3J0ZWQ6dCxkaWN0OmF9KXtjb25zdCByPXRvTnVtYmVyQXJyYXkoYS5nZXRBcnJheSgiRG9tYWluIikpO2lmKCFyKXRocm93IG5ldyBuLkZvcm1hdEVycm9yKCJObyBkb21haW4iKTtpZigxIT09ci5sZW5ndGgvMil0aHJvdyBuZXcgbi5Gb3JtYXRFcnJvcigiQmFkIGRvbWFpbiBmb3Igc3RpY2hlZCBmdW5jdGlvbiIpO2NvbnN0IGk9YS5nZXQoIkZ1bmN0aW9ucyIpLHM9W107Zm9yKGxldCBhPTAscj1pLmxlbmd0aDthPHI7KythKXMucHVzaCh0aGlzLnBhcnNlKHt4cmVmOmUsaXNFdmFsU3VwcG9ydGVkOnQsZm46ZS5mZXRjaElmUmVmKGlbYV0pfSkpO2NvbnN0IG89dG9OdW1iZXJBcnJheShhLmdldEFycmF5KCJCb3VuZHMiKSksYz10b051bWJlckFycmF5KGEuZ2V0QXJyYXkoIkVuY29kZSIpKSxsPW5ldyBGbG9hdDMyQXJyYXkoMSk7cmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdFN0aWNoZWRGbihlLHQsYSxuKXtjb25zdCBpPWZ1bmN0aW9uIGNvbnN0cnVjdFN0aWNoZWRGcm9tSVJDbGlwKGUsdCxhKXtlPmE/ZT1hOmU8dCYmKGU9dCk7cmV0dXJuIGV9KGVbdF0sclswXSxyWzFdKSxoPW8ubGVuZ3RoO2xldCB1O2Zvcih1PTA7dTxoJiYhKGk8b1t1XSk7Kyt1KTtsZXQgZD1yWzBdO3U+MCYmKGQ9b1t1LTFdKTtsZXQgZj1yWzFdO3U8by5sZW5ndGgmJihmPW9bdV0pO2NvbnN0IGc9Y1syKnVdLHA9Y1syKnUrMV07bFswXT1kPT09Zj9nOmcrKGktZCkqKHAtZykvKGYtZCk7c1t1XShsLDAsYSxuKX19c3RhdGljIGNvbnN0cnVjdFBvc3RTY3JpcHQoe3hyZWY6ZSxpc0V2YWxTdXBwb3J0ZWQ6dCxmbjphLGRpY3Q6cn0pe2NvbnN0IHM9dG9OdW1iZXJBcnJheShyLmdldEFycmF5KCJEb21haW4iKSksbz10b051bWJlckFycmF5KHIuZ2V0QXJyYXkoIlJhbmdlIikpO2lmKCFzKXRocm93IG5ldyBuLkZvcm1hdEVycm9yKCJObyBkb21haW4uIik7aWYoIW8pdGhyb3cgbmV3IG4uRm9ybWF0RXJyb3IoIk5vIHJhbmdlLiIpO2NvbnN0IGM9bmV3IGkuUG9zdFNjcmlwdExleGVyKGEpLGw9bmV3IGkuUG9zdFNjcmlwdFBhcnNlcihjKS5wYXJzZSgpO2lmKHQmJm4uRmVhdHVyZVRlc3QuaXNFdmFsU3VwcG9ydGVkKXtjb25zdCBlPShuZXcgUG9zdFNjcmlwdENvbXBpbGVyKS5jb21waWxlKGwscyxvKTtpZihlKXJldHVybiBuZXcgRnVuY3Rpb24oInNyYyIsInNyY09mZnNldCIsImRlc3QiLCJkZXN0T2Zmc2V0IixlKX0oMCxuLmluZm8pKCJVbmFibGUgdG8gY29tcGlsZSBQUyBmdW5jdGlvbiIpO2NvbnN0IGg9by5sZW5ndGg+PjEsdT1zLmxlbmd0aD4+MSxkPW5ldyBQb3N0U2NyaXB0RXZhbHVhdG9yKGwpLGY9T2JqZWN0LmNyZWF0ZShudWxsKTtsZXQgZz04MTkyO2NvbnN0IHA9bmV3IEZsb2F0MzJBcnJheSh1KTtyZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0UG9zdFNjcmlwdEZuKGUsdCxhLHIpe2xldCBuLGkscz0iIjtjb25zdCBjPXA7Zm9yKG49MDtuPHU7bisrKXtpPWVbdCtuXTtjW25dPWk7cys9aSsiXyJ9Y29uc3QgbD1mW3NdO2lmKHZvaWQgMCE9PWwpe2Euc2V0KGwscik7cmV0dXJufWNvbnN0IG09bmV3IEZsb2F0MzJBcnJheShoKSxiPWQuZXhlY3V0ZShjKSx5PWIubGVuZ3RoLWg7Zm9yKG49MDtuPGg7bisrKXtpPWJbeStuXTtsZXQgZT1vWzIqbl07aWYoaTxlKWk9ZTtlbHNle2U9b1syKm4rMV07aT5lJiYoaT1lKX1tW25dPWl9aWYoZz4wKXtnLS07ZltzXT1tfWEuc2V0KG0scil9fX1jbGFzcyBQb3N0U2NyaXB0U3RhY2t7c3RhdGljIGdldCBNQVhfU1RBQ0tfU0laRSgpe3JldHVybigwLG4uc2hhZG93KSh0aGlzLCJNQVhfU1RBQ0tfU0laRSIsMTAwKX1jb25zdHJ1Y3RvcihlKXt0aGlzLnN0YWNrPWU/QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZSwwKTpbXX1wdXNoKGUpe2lmKHRoaXMuc3RhY2subGVuZ3RoPj1Qb3N0U2NyaXB0U3RhY2suTUFYX1NUQUNLX1NJWkUpdGhyb3cgbmV3IEVycm9yKCJQb3N0U2NyaXB0IGZ1bmN0aW9uIHN0YWNrIG92ZXJmbG93LiIpO3RoaXMuc3RhY2sucHVzaChlKX1wb3AoKXtpZih0aGlzLnN0YWNrLmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoIlBvc3RTY3JpcHQgZnVuY3Rpb24gc3RhY2sgdW5kZXJmbG93LiIpO3JldHVybiB0aGlzLnN0YWNrLnBvcCgpfWNvcHkoZSl7aWYodGhpcy5zdGFjay5sZW5ndGgrZT49UG9zdFNjcmlwdFN0YWNrLk1BWF9TVEFDS19TSVpFKXRocm93IG5ldyBFcnJvcigiUG9zdFNjcmlwdCBmdW5jdGlvbiBzdGFjayBvdmVyZmxvdy4iKTtjb25zdCB0PXRoaXMuc3RhY2s7Zm9yKGxldCBhPXQubGVuZ3RoLWUscj1lLTE7cj49MDtyLS0sYSsrKXQucHVzaCh0W2FdKX1pbmRleChlKXt0aGlzLnB1c2godGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC1lLTFdKX1yb2xsKGUsdCl7Y29uc3QgYT10aGlzLnN0YWNrLHI9YS5sZW5ndGgtZSxuPWEubGVuZ3RoLTEsaT1yKyh0LU1hdGguZmxvb3IodC9lKSplKTtmb3IobGV0IGU9cix0PW47ZTx0O2UrKyx0LS0pe2NvbnN0IHI9YVtlXTthW2VdPWFbdF07YVt0XT1yfWZvcihsZXQgZT1yLHQ9aS0xO2U8dDtlKyssdC0tKXtjb25zdCByPWFbZV07YVtlXT1hW3RdO2FbdF09cn1mb3IobGV0IGU9aSx0PW47ZTx0O2UrKyx0LS0pe2NvbnN0IHI9YVtlXTthW2VdPWFbdF07YVt0XT1yfX19Y2xhc3MgUG9zdFNjcmlwdEV2YWx1YXRvcntjb25zdHJ1Y3RvcihlKXt0aGlzLm9wZXJhdG9ycz1lfWV4ZWN1dGUoZSl7Y29uc3QgdD1uZXcgUG9zdFNjcmlwdFN0YWNrKGUpO2xldCBhPTA7Y29uc3Qgcj10aGlzLm9wZXJhdG9ycyxpPXIubGVuZ3RoO2xldCBzLG8sYztmb3IoO2E8aTspe3M9clthKytdO2lmKCJudW1iZXIiIT10eXBlb2Ygcylzd2l0Y2gocyl7Y2FzZSJqeiI6Yz10LnBvcCgpO289dC5wb3AoKTtvfHwoYT1jKTticmVhaztjYXNlImoiOm89dC5wb3AoKTthPW87YnJlYWs7Y2FzZSJhYnMiOm89dC5wb3AoKTt0LnB1c2goTWF0aC5hYnMobykpO2JyZWFrO2Nhc2UiYWRkIjpjPXQucG9wKCk7bz10LnBvcCgpO3QucHVzaChvK2MpO2JyZWFrO2Nhc2UiYW5kIjpjPXQucG9wKCk7bz10LnBvcCgpOyJib29sZWFuIj09dHlwZW9mIG8mJiJib29sZWFuIj09dHlwZW9mIGM/dC5wdXNoKG8mJmMpOnQucHVzaChvJmMpO2JyZWFrO2Nhc2UiYXRhbiI6bz10LnBvcCgpO3QucHVzaChNYXRoLmF0YW4obykpO2JyZWFrO2Nhc2UiYml0c2hpZnQiOmM9dC5wb3AoKTtvPXQucG9wKCk7bz4wP3QucHVzaChvPDxjKTp0LnB1c2gobz4+Yyk7YnJlYWs7Y2FzZSJjZWlsaW5nIjpvPXQucG9wKCk7dC5wdXNoKE1hdGguY2VpbChvKSk7YnJlYWs7Y2FzZSJjb3B5IjpvPXQucG9wKCk7dC5jb3B5KG8pO2JyZWFrO2Nhc2UiY29zIjpvPXQucG9wKCk7dC5wdXNoKE1hdGguY29zKG8pKTticmVhaztjYXNlImN2aSI6bz0wfHQucG9wKCk7dC5wdXNoKG8pO2JyZWFrO2Nhc2UiY3ZyIjpicmVhaztjYXNlImRpdiI6Yz10LnBvcCgpO289dC5wb3AoKTt0LnB1c2goby9jKTticmVhaztjYXNlImR1cCI6dC5jb3B5KDEpO2JyZWFrO2Nhc2UiZXEiOmM9dC5wb3AoKTtvPXQucG9wKCk7dC5wdXNoKG89PT1jKTticmVhaztjYXNlImV4Y2giOnQucm9sbCgyLDEpO2JyZWFrO2Nhc2UiZXhwIjpjPXQucG9wKCk7bz10LnBvcCgpO3QucHVzaChvKipjKTticmVhaztjYXNlImZhbHNlIjp0LnB1c2goITEpO2JyZWFrO2Nhc2UiZmxvb3IiOm89dC5wb3AoKTt0LnB1c2goTWF0aC5mbG9vcihvKSk7YnJlYWs7Y2FzZSJnZSI6Yz10LnBvcCgpO289dC5wb3AoKTt0LnB1c2gobz49Yyk7YnJlYWs7Y2FzZSJndCI6Yz10LnBvcCgpO289dC5wb3AoKTt0LnB1c2gobz5jKTticmVhaztjYXNlImlkaXYiOmM9dC5wb3AoKTtvPXQucG9wKCk7dC5wdXNoKG8vY3wwKTticmVhaztjYXNlImluZGV4IjpvPXQucG9wKCk7dC5pbmRleChvKTticmVhaztjYXNlImxlIjpjPXQucG9wKCk7bz10LnBvcCgpO3QucHVzaChvPD1jKTticmVhaztjYXNlImxuIjpvPXQucG9wKCk7dC5wdXNoKE1hdGgubG9nKG8pKTticmVhaztjYXNlImxvZyI6bz10LnBvcCgpO3QucHVzaChNYXRoLmxvZyhvKS9NYXRoLkxOMTApO2JyZWFrO2Nhc2UibHQiOmM9dC5wb3AoKTtvPXQucG9wKCk7dC5wdXNoKG88Yyk7YnJlYWs7Y2FzZSJtb2QiOmM9dC5wb3AoKTtvPXQucG9wKCk7dC5wdXNoKG8lYyk7YnJlYWs7Y2FzZSJtdWwiOmM9dC5wb3AoKTtvPXQucG9wKCk7dC5wdXNoKG8qYyk7YnJlYWs7Y2FzZSJuZSI6Yz10LnBvcCgpO289dC5wb3AoKTt0LnB1c2gobyE9PWMpO2JyZWFrO2Nhc2UibmVnIjpvPXQucG9wKCk7dC5wdXNoKC1vKTticmVhaztjYXNlIm5vdCI6bz10LnBvcCgpOyJib29sZWFuIj09dHlwZW9mIG8/dC5wdXNoKCFvKTp0LnB1c2gofm8pO2JyZWFrO2Nhc2Uib3IiOmM9dC5wb3AoKTtvPXQucG9wKCk7ImJvb2xlYW4iPT10eXBlb2YgbyYmImJvb2xlYW4iPT10eXBlb2YgYz90LnB1c2gob3x8Yyk6dC5wdXNoKG98Yyk7YnJlYWs7Y2FzZSJwb3AiOnQucG9wKCk7YnJlYWs7Y2FzZSJyb2xsIjpjPXQucG9wKCk7bz10LnBvcCgpO3Qucm9sbChvLGMpO2JyZWFrO2Nhc2Uicm91bmQiOm89dC5wb3AoKTt0LnB1c2goTWF0aC5yb3VuZChvKSk7YnJlYWs7Y2FzZSJzaW4iOm89dC5wb3AoKTt0LnB1c2goTWF0aC5zaW4obykpO2JyZWFrO2Nhc2Uic3FydCI6bz10LnBvcCgpO3QucHVzaChNYXRoLnNxcnQobykpO2JyZWFrO2Nhc2Uic3ViIjpjPXQucG9wKCk7bz10LnBvcCgpO3QucHVzaChvLWMpO2JyZWFrO2Nhc2UidHJ1ZSI6dC5wdXNoKCEwKTticmVhaztjYXNlInRydW5jYXRlIjpvPXQucG9wKCk7bz1vPDA/TWF0aC5jZWlsKG8pOk1hdGguZmxvb3Iobyk7dC5wdXNoKG8pO2JyZWFrO2Nhc2UieG9yIjpjPXQucG9wKCk7bz10LnBvcCgpOyJib29sZWFuIj09dHlwZW9mIG8mJiJib29sZWFuIj09dHlwZW9mIGM/dC5wdXNoKG8hPT1jKTp0LnB1c2gob15jKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBuLkZvcm1hdEVycm9yKGBVbmtub3duIG9wZXJhdG9yICR7c31gKX1lbHNlIHQucHVzaChzKX1yZXR1cm4gdC5zdGFja319dC5Qb3N0U2NyaXB0RXZhbHVhdG9yPVBvc3RTY3JpcHRFdmFsdWF0b3I7Y2xhc3MgQXN0Tm9kZXtjb25zdHJ1Y3RvcihlKXt0aGlzLnR5cGU9ZX12aXNpdChlKXsoMCxuLnVucmVhY2hhYmxlKSgiYWJzdHJhY3QgbWV0aG9kIil9fWNsYXNzIEFzdEFyZ3VtZW50IGV4dGVuZHMgQXN0Tm9kZXtjb25zdHJ1Y3RvcihlLHQsYSl7c3VwZXIoImFyZ3MiKTt0aGlzLmluZGV4PWU7dGhpcy5taW49dDt0aGlzLm1heD1hfXZpc2l0KGUpe2UudmlzaXRBcmd1bWVudCh0aGlzKX19Y2xhc3MgQXN0TGl0ZXJhbCBleHRlbmRzIEFzdE5vZGV7Y29uc3RydWN0b3IoZSl7c3VwZXIoImxpdGVyYWwiKTt0aGlzLm51bWJlcj1lO3RoaXMubWluPWU7dGhpcy5tYXg9ZX12aXNpdChlKXtlLnZpc2l0TGl0ZXJhbCh0aGlzKX19Y2xhc3MgQXN0QmluYXJ5T3BlcmF0aW9uIGV4dGVuZHMgQXN0Tm9kZXtjb25zdHJ1Y3RvcihlLHQsYSxyLG4pe3N1cGVyKCJiaW5hcnkiKTt0aGlzLm9wPWU7dGhpcy5hcmcxPXQ7dGhpcy5hcmcyPWE7dGhpcy5taW49cjt0aGlzLm1heD1ufXZpc2l0KGUpe2UudmlzaXRCaW5hcnlPcGVyYXRpb24odGhpcyl9fWNsYXNzIEFzdE1pbiBleHRlbmRzIEFzdE5vZGV7Y29uc3RydWN0b3IoZSx0KXtzdXBlcigibWF4Iik7dGhpcy5hcmc9ZTt0aGlzLm1pbj1lLm1pbjt0aGlzLm1heD10fXZpc2l0KGUpe2UudmlzaXRNaW4odGhpcyl9fWNsYXNzIEFzdFZhcmlhYmxlIGV4dGVuZHMgQXN0Tm9kZXtjb25zdHJ1Y3RvcihlLHQsYSl7c3VwZXIoInZhciIpO3RoaXMuaW5kZXg9ZTt0aGlzLm1pbj10O3RoaXMubWF4PWF9dmlzaXQoZSl7ZS52aXNpdFZhcmlhYmxlKHRoaXMpfX1jbGFzcyBBc3RWYXJpYWJsZURlZmluaXRpb24gZXh0ZW5kcyBBc3ROb2Rle2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoImRlZmluaXRpb24iKTt0aGlzLnZhcmlhYmxlPWU7dGhpcy5hcmc9dH12aXNpdChlKXtlLnZpc2l0VmFyaWFibGVEZWZpbml0aW9uKHRoaXMpfX1jbGFzcyBFeHByZXNzaW9uQnVpbGRlclZpc2l0b3J7Y29uc3RydWN0b3IoKXt0aGlzLnBhcnRzPVtdfXZpc2l0QXJndW1lbnQoZSl7dGhpcy5wYXJ0cy5wdXNoKCJNYXRoLm1heCgiLGUubWluLCIsIE1hdGgubWluKCIsZS5tYXgsIiwgc3JjW3NyY09mZnNldCArICIsZS5pbmRleCwiXSkpIil9dmlzaXRWYXJpYWJsZShlKXt0aGlzLnBhcnRzLnB1c2goInYiLGUuaW5kZXgpfXZpc2l0TGl0ZXJhbChlKXt0aGlzLnBhcnRzLnB1c2goZS5udW1iZXIpfXZpc2l0QmluYXJ5T3BlcmF0aW9uKGUpe3RoaXMucGFydHMucHVzaCgiKCIpO2UuYXJnMS52aXNpdCh0aGlzKTt0aGlzLnBhcnRzLnB1c2goIiAiLGUub3AsIiAiKTtlLmFyZzIudmlzaXQodGhpcyk7dGhpcy5wYXJ0cy5wdXNoKCIpIil9dmlzaXRWYXJpYWJsZURlZmluaXRpb24oZSl7dGhpcy5wYXJ0cy5wdXNoKCJ2YXIgIik7ZS52YXJpYWJsZS52aXNpdCh0aGlzKTt0aGlzLnBhcnRzLnB1c2goIiA9ICIpO2UuYXJnLnZpc2l0KHRoaXMpO3RoaXMucGFydHMucHVzaCgiOyIpfXZpc2l0TWluKGUpe3RoaXMucGFydHMucHVzaCgiTWF0aC5taW4oIik7ZS5hcmcudmlzaXQodGhpcyk7dGhpcy5wYXJ0cy5wdXNoKCIsICIsZS5tYXgsIikiKX10b1N0cmluZygpe3JldHVybiB0aGlzLnBhcnRzLmpvaW4oIiIpfX1mdW5jdGlvbiBidWlsZEFkZE9wZXJhdGlvbihlLHQpe3JldHVybiJsaXRlcmFsIj09PXQudHlwZSYmMD09PXQubnVtYmVyP2U6ImxpdGVyYWwiPT09ZS50eXBlJiYwPT09ZS5udW1iZXI/dDoibGl0ZXJhbCI9PT10LnR5cGUmJiJsaXRlcmFsIj09PWUudHlwZT9uZXcgQXN0TGl0ZXJhbChlLm51bWJlcit0Lm51bWJlcik6bmV3IEFzdEJpbmFyeU9wZXJhdGlvbigiKyIsZSx0LGUubWluK3QubWluLGUubWF4K3QubWF4KX1mdW5jdGlvbiBidWlsZE11bE9wZXJhdGlvbihlLHQpe2lmKCJsaXRlcmFsIj09PXQudHlwZSl7aWYoMD09PXQubnVtYmVyKXJldHVybiBuZXcgQXN0TGl0ZXJhbCgwKTtpZigxPT09dC5udW1iZXIpcmV0dXJuIGU7aWYoImxpdGVyYWwiPT09ZS50eXBlKXJldHVybiBuZXcgQXN0TGl0ZXJhbChlLm51bWJlcip0Lm51bWJlcil9aWYoImxpdGVyYWwiPT09ZS50eXBlKXtpZigwPT09ZS5udW1iZXIpcmV0dXJuIG5ldyBBc3RMaXRlcmFsKDApO2lmKDE9PT1lLm51bWJlcilyZXR1cm4gdH1jb25zdCBhPU1hdGgubWluKGUubWluKnQubWluLGUubWluKnQubWF4LGUubWF4KnQubWluLGUubWF4KnQubWF4KSxyPU1hdGgubWF4KGUubWluKnQubWluLGUubWluKnQubWF4LGUubWF4KnQubWluLGUubWF4KnQubWF4KTtyZXR1cm4gbmV3IEFzdEJpbmFyeU9wZXJhdGlvbigiKiIsZSx0LGEscil9ZnVuY3Rpb24gYnVpbGRTdWJPcGVyYXRpb24oZSx0KXtpZigibGl0ZXJhbCI9PT10LnR5cGUpe2lmKDA9PT10Lm51bWJlcilyZXR1cm4gZTtpZigibGl0ZXJhbCI9PT1lLnR5cGUpcmV0dXJuIG5ldyBBc3RMaXRlcmFsKGUubnVtYmVyLXQubnVtYmVyKX1yZXR1cm4iYmluYXJ5Ij09PXQudHlwZSYmIi0iPT09dC5vcCYmImxpdGVyYWwiPT09ZS50eXBlJiYxPT09ZS5udW1iZXImJiJsaXRlcmFsIj09PXQuYXJnMS50eXBlJiYxPT09dC5hcmcxLm51bWJlcj90LmFyZzI6bmV3IEFzdEJpbmFyeU9wZXJhdGlvbigiLSIsZSx0LGUubWluLXQubWF4LGUubWF4LXQubWluKX1mdW5jdGlvbiBidWlsZE1pbk9wZXJhdGlvbihlLHQpe3JldHVybiBlLm1pbj49dD9uZXcgQXN0TGl0ZXJhbCh0KTplLm1heDw9dD9lOm5ldyBBc3RNaW4oZSx0KX1jbGFzcyBQb3N0U2NyaXB0Q29tcGlsZXJ7Y29tcGlsZShlLHQsYSl7Y29uc3Qgcj1bXSxuPVtdLGk9dC5sZW5ndGg+PjEscz1hLmxlbmd0aD4+MTtsZXQgbyxjLGwsaCx1LGQsZixnLHA9MDtmb3IobGV0IGU9MDtlPGk7ZSsrKXIucHVzaChuZXcgQXN0QXJndW1lbnQoZSx0WzIqZV0sdFsyKmUrMV0pKTtmb3IobGV0IHQ9MCxhPWUubGVuZ3RoO3Q8YTt0Kyspe2c9ZVt0XTtpZigibnVtYmVyIiE9dHlwZW9mIGcpc3dpdGNoKGcpe2Nhc2UiYWRkIjppZihyLmxlbmd0aDwyKXJldHVybiBudWxsO2g9ci5wb3AoKTtsPXIucG9wKCk7ci5wdXNoKGJ1aWxkQWRkT3BlcmF0aW9uKGwsaCkpO2JyZWFrO2Nhc2UiY3ZyIjppZihyLmxlbmd0aDwxKXJldHVybiBudWxsO2JyZWFrO2Nhc2UibXVsIjppZihyLmxlbmd0aDwyKXJldHVybiBudWxsO2g9ci5wb3AoKTtsPXIucG9wKCk7ci5wdXNoKGJ1aWxkTXVsT3BlcmF0aW9uKGwsaCkpO2JyZWFrO2Nhc2Uic3ViIjppZihyLmxlbmd0aDwyKXJldHVybiBudWxsO2g9ci5wb3AoKTtsPXIucG9wKCk7ci5wdXNoKGJ1aWxkU3ViT3BlcmF0aW9uKGwsaCkpO2JyZWFrO2Nhc2UiZXhjaCI6aWYoci5sZW5ndGg8MilyZXR1cm4gbnVsbDt1PXIucG9wKCk7ZD1yLnBvcCgpO3IucHVzaCh1LGQpO2JyZWFrO2Nhc2UicG9wIjppZihyLmxlbmd0aDwxKXJldHVybiBudWxsO3IucG9wKCk7YnJlYWs7Y2FzZSJpbmRleCI6aWYoci5sZW5ndGg8MSlyZXR1cm4gbnVsbDtsPXIucG9wKCk7aWYoImxpdGVyYWwiIT09bC50eXBlKXJldHVybiBudWxsO289bC5udW1iZXI7aWYobzwwfHwhTnVtYmVyLmlzSW50ZWdlcihvKXx8ci5sZW5ndGg8bylyZXR1cm4gbnVsbDt1PXJbci5sZW5ndGgtby0xXTtpZigibGl0ZXJhbCI9PT11LnR5cGV8fCJ2YXIiPT09dS50eXBlKXtyLnB1c2godSk7YnJlYWt9Zj1uZXcgQXN0VmFyaWFibGUocCsrLHUubWluLHUubWF4KTtyW3IubGVuZ3RoLW8tMV09ZjtyLnB1c2goZik7bi5wdXNoKG5ldyBBc3RWYXJpYWJsZURlZmluaXRpb24oZix1KSk7YnJlYWs7Y2FzZSJkdXAiOmlmKHIubGVuZ3RoPDEpcmV0dXJuIG51bGw7aWYoIm51bWJlciI9PXR5cGVvZiBlW3QrMV0mJiJndCI9PT1lW3QrMl0mJmVbdCszXT09PXQrNyYmImp6Ij09PWVbdCs0XSYmInBvcCI9PT1lW3QrNV0mJmVbdCs2XT09PWVbdCsxXSl7bD1yLnBvcCgpO3IucHVzaChidWlsZE1pbk9wZXJhdGlvbihsLGVbdCsxXSkpO3QrPTY7YnJlYWt9dT1yLmF0KC0xKTtpZigibGl0ZXJhbCI9PT11LnR5cGV8fCJ2YXIiPT09dS50eXBlKXtyLnB1c2godSk7YnJlYWt9Zj1uZXcgQXN0VmFyaWFibGUocCsrLHUubWluLHUubWF4KTtyW3IubGVuZ3RoLTFdPWY7ci5wdXNoKGYpO24ucHVzaChuZXcgQXN0VmFyaWFibGVEZWZpbml0aW9uKGYsdSkpO2JyZWFrO2Nhc2Uicm9sbCI6aWYoci5sZW5ndGg8MilyZXR1cm4gbnVsbDtoPXIucG9wKCk7bD1yLnBvcCgpO2lmKCJsaXRlcmFsIiE9PWgudHlwZXx8ImxpdGVyYWwiIT09bC50eXBlKXJldHVybiBudWxsO2M9aC5udW1iZXI7bz1sLm51bWJlcjtpZihvPD0wfHwhTnVtYmVyLmlzSW50ZWdlcihvKXx8IU51bWJlci5pc0ludGVnZXIoYyl8fHIubGVuZ3RoPG8pcmV0dXJuIG51bGw7Yz0oYyVvK28pJW87aWYoMD09PWMpYnJlYWs7QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocixyLnNwbGljZShyLmxlbmd0aC1vLG8tYykpO2JyZWFrO2RlZmF1bHQ6cmV0dXJuIG51bGx9ZWxzZSByLnB1c2gobmV3IEFzdExpdGVyYWwoZykpfWlmKHIubGVuZ3RoIT09cylyZXR1cm4gbnVsbDtjb25zdCBtPVtdO2Zvcihjb25zdCBlIG9mIG4pe2NvbnN0IHQ9bmV3IEV4cHJlc3Npb25CdWlsZGVyVmlzaXRvcjtlLnZpc2l0KHQpO20ucHVzaCh0LnRvU3RyaW5nKCkpfWZvcihsZXQgZT0wLHQ9ci5sZW5ndGg7ZTx0O2UrKyl7Y29uc3QgdD1yW2VdLG49bmV3IEV4cHJlc3Npb25CdWlsZGVyVmlzaXRvcjt0LnZpc2l0KG4pO2NvbnN0IGk9YVsyKmVdLHM9YVsyKmUrMV0sbz1bbi50b1N0cmluZygpXTtpZihpPnQubWluKXtvLnVuc2hpZnQoIk1hdGgubWF4KCIsaSwiLCAiKTtvLnB1c2goIikiKX1pZihzPHQubWF4KXtvLnVuc2hpZnQoIk1hdGgubWluKCIscywiLCAiKTtvLnB1c2goIikiKX1vLnVuc2hpZnQoImRlc3RbZGVzdE9mZnNldCArICIsZSwiXSA9ICIpO28ucHVzaCgiOyIpO20ucHVzaChvLmpvaW4oIiIpKX1yZXR1cm4gbS5qb2luKCJcbiIpfX10LlBvc3RTY3JpcHRDb21waWxlcj1Qb3N0U2NyaXB0Q29tcGlsZXJ9LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5Qb3N0U2NyaXB0UGFyc2VyPXQuUG9zdFNjcmlwdExleGVyPXZvaWQgMDt2YXIgcj1hKDIpLG49YSg1KSxpPWEoNik7dC5Qb3N0U2NyaXB0UGFyc2VyPWNsYXNzIFBvc3RTY3JpcHRQYXJzZXJ7Y29uc3RydWN0b3IoZSl7dGhpcy5sZXhlcj1lO3RoaXMub3BlcmF0b3JzPVtdO3RoaXMudG9rZW49bnVsbDt0aGlzLnByZXY9bnVsbH1uZXh0VG9rZW4oKXt0aGlzLnByZXY9dGhpcy50b2tlbjt0aGlzLnRva2VuPXRoaXMubGV4ZXIuZ2V0VG9rZW4oKX1hY2NlcHQoZSl7aWYodGhpcy50b2tlbi50eXBlPT09ZSl7dGhpcy5uZXh0VG9rZW4oKTtyZXR1cm4hMH1yZXR1cm4hMX1leHBlY3QoZSl7aWYodGhpcy5hY2NlcHQoZSkpcmV0dXJuITA7dGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoYFVuZXhwZWN0ZWQgc3ltYm9sOiBmb3VuZCAke3RoaXMudG9rZW4udHlwZX0gZXhwZWN0ZWQgJHtlfS5gKX1wYXJzZSgpe3RoaXMubmV4dFRva2VuKCk7dGhpcy5leHBlY3Qocy5MQlJBQ0UpO3RoaXMucGFyc2VCbG9jaygpO3RoaXMuZXhwZWN0KHMuUkJSQUNFKTtyZXR1cm4gdGhpcy5vcGVyYXRvcnN9cGFyc2VCbG9jaygpe2Zvcig7OylpZih0aGlzLmFjY2VwdChzLk5VTUJFUikpdGhpcy5vcGVyYXRvcnMucHVzaCh0aGlzLnByZXYudmFsdWUpO2Vsc2UgaWYodGhpcy5hY2NlcHQocy5PUEVSQVRPUikpdGhpcy5vcGVyYXRvcnMucHVzaCh0aGlzLnByZXYudmFsdWUpO2Vsc2V7aWYoIXRoaXMuYWNjZXB0KHMuTEJSQUNFKSlyZXR1cm47dGhpcy5wYXJzZUNvbmRpdGlvbigpfX1wYXJzZUNvbmRpdGlvbigpe2NvbnN0IGU9dGhpcy5vcGVyYXRvcnMubGVuZ3RoO3RoaXMub3BlcmF0b3JzLnB1c2gobnVsbCxudWxsKTt0aGlzLnBhcnNlQmxvY2soKTt0aGlzLmV4cGVjdChzLlJCUkFDRSk7aWYodGhpcy5hY2NlcHQocy5JRikpe3RoaXMub3BlcmF0b3JzW2VdPXRoaXMub3BlcmF0b3JzLmxlbmd0aDt0aGlzLm9wZXJhdG9yc1tlKzFdPSJqeiJ9ZWxzZXtpZighdGhpcy5hY2NlcHQocy5MQlJBQ0UpKXRocm93IG5ldyByLkZvcm1hdEVycm9yKCJQUyBGdW5jdGlvbjogZXJyb3IgcGFyc2luZyBjb25kaXRpb25hbC4iKTt7Y29uc3QgdD10aGlzLm9wZXJhdG9ycy5sZW5ndGg7dGhpcy5vcGVyYXRvcnMucHVzaChudWxsLG51bGwpO2NvbnN0IGE9dGhpcy5vcGVyYXRvcnMubGVuZ3RoO3RoaXMucGFyc2VCbG9jaygpO3RoaXMuZXhwZWN0KHMuUkJSQUNFKTt0aGlzLmV4cGVjdChzLklGRUxTRSk7dGhpcy5vcGVyYXRvcnNbdF09dGhpcy5vcGVyYXRvcnMubGVuZ3RoO3RoaXMub3BlcmF0b3JzW3QrMV09ImoiO3RoaXMub3BlcmF0b3JzW2VdPWE7dGhpcy5vcGVyYXRvcnNbZSsxXT0ianoifX19fTtjb25zdCBzPXtMQlJBQ0U6MCxSQlJBQ0U6MSxOVU1CRVI6MixPUEVSQVRPUjozLElGOjQsSUZFTFNFOjV9O2NsYXNzIFBvc3RTY3JpcHRUb2tlbntzdGF0aWMgZ2V0IG9wQ2FjaGUoKXtyZXR1cm4oMCxyLnNoYWRvdykodGhpcywib3BDYWNoZSIsT2JqZWN0LmNyZWF0ZShudWxsKSl9Y29uc3RydWN0b3IoZSx0KXt0aGlzLnR5cGU9ZTt0aGlzLnZhbHVlPXR9c3RhdGljIGdldE9wZXJhdG9yKGUpe2NvbnN0IHQ9UG9zdFNjcmlwdFRva2VuLm9wQ2FjaGVbZV07cmV0dXJuIHR8fChQb3N0U2NyaXB0VG9rZW4ub3BDYWNoZVtlXT1uZXcgUG9zdFNjcmlwdFRva2VuKHMuT1BFUkFUT1IsZSkpfXN0YXRpYyBnZXQgTEJSQUNFKCl7cmV0dXJuKDAsci5zaGFkb3cpKHRoaXMsIkxCUkFDRSIsbmV3IFBvc3RTY3JpcHRUb2tlbihzLkxCUkFDRSwieyIpKX1zdGF0aWMgZ2V0IFJCUkFDRSgpe3JldHVybigwLHIuc2hhZG93KSh0aGlzLCJSQlJBQ0UiLG5ldyBQb3N0U2NyaXB0VG9rZW4ocy5SQlJBQ0UsIn0iKSl9c3RhdGljIGdldCBJRigpe3JldHVybigwLHIuc2hhZG93KSh0aGlzLCJJRiIsbmV3IFBvc3RTY3JpcHRUb2tlbihzLklGLCJJRiIpKX1zdGF0aWMgZ2V0IElGRUxTRSgpe3JldHVybigwLHIuc2hhZG93KSh0aGlzLCJJRkVMU0UiLG5ldyBQb3N0U2NyaXB0VG9rZW4ocy5JRkVMU0UsIklGRUxTRSIpKX19dC5Qb3N0U2NyaXB0TGV4ZXI9Y2xhc3MgUG9zdFNjcmlwdExleGVye2NvbnN0cnVjdG9yKGUpe3RoaXMuc3RyZWFtPWU7dGhpcy5uZXh0Q2hhcigpO3RoaXMuc3RyQnVmPVtdfW5leHRDaGFyKCl7cmV0dXJuIHRoaXMuY3VycmVudENoYXI9dGhpcy5zdHJlYW0uZ2V0Qnl0ZSgpfWdldFRva2VuKCl7bGV0IGU9ITEsdD10aGlzLmN1cnJlbnRDaGFyO2Zvcig7Oyl7aWYodDwwKXJldHVybiBuLkVPRjtpZihlKTEwIT09dCYmMTMhPT10fHwoZT0hMSk7ZWxzZSBpZigzNz09PXQpZT0hMDtlbHNlIGlmKCEoMCxpLmlzV2hpdGVTcGFjZSkodCkpYnJlYWs7dD10aGlzLm5leHRDaGFyKCl9c3dpdGNoKDB8dCl7Y2FzZSA0ODpjYXNlIDQ5OmNhc2UgNTA6Y2FzZSA1MTpjYXNlIDUyOmNhc2UgNTM6Y2FzZSA1NDpjYXNlIDU1OmNhc2UgNTY6Y2FzZSA1NzpjYXNlIDQzOmNhc2UgNDU6Y2FzZSA0NjpyZXR1cm4gbmV3IFBvc3RTY3JpcHRUb2tlbihzLk5VTUJFUix0aGlzLmdldE51bWJlcigpKTtjYXNlIDEyMzp0aGlzLm5leHRDaGFyKCk7cmV0dXJuIFBvc3RTY3JpcHRUb2tlbi5MQlJBQ0U7Y2FzZSAxMjU6dGhpcy5uZXh0Q2hhcigpO3JldHVybiBQb3N0U2NyaXB0VG9rZW4uUkJSQUNFfWNvbnN0IGE9dGhpcy5zdHJCdWY7YS5sZW5ndGg9MDthWzBdPVN0cmluZy5mcm9tQ2hhckNvZGUodCk7Zm9yKDsodD10aGlzLm5leHRDaGFyKCkpPj0wJiYodD49NjUmJnQ8PTkwfHx0Pj05NyYmdDw9MTIyKTspYS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUodCkpO2NvbnN0IHI9YS5qb2luKCIiKTtzd2l0Y2goci50b0xvd2VyQ2FzZSgpKXtjYXNlImlmIjpyZXR1cm4gUG9zdFNjcmlwdFRva2VuLklGO2Nhc2UiaWZlbHNlIjpyZXR1cm4gUG9zdFNjcmlwdFRva2VuLklGRUxTRTtkZWZhdWx0OnJldHVybiBQb3N0U2NyaXB0VG9rZW4uZ2V0T3BlcmF0b3Iocil9fWdldE51bWJlcigpe2xldCBlPXRoaXMuY3VycmVudENoYXI7Y29uc3QgdD10aGlzLnN0ckJ1Zjt0Lmxlbmd0aD0wO3RbMF09U3RyaW5nLmZyb21DaGFyQ29kZShlKTtmb3IoOyhlPXRoaXMubmV4dENoYXIoKSk+PTAmJihlPj00OCYmZTw9NTd8fDQ1PT09ZXx8NDY9PT1lKTspdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoZSkpO2NvbnN0IGE9cGFyc2VGbG9hdCh0LmpvaW4oIiIpKTtpZihpc05hTihhKSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcihgSW52YWxpZCBmbG9hdGluZyBwb2ludCBudW1iZXI6ICR7YX1gKTtyZXR1cm4gYX19fSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuTG9jYWxUaWxpbmdQYXR0ZXJuQ2FjaGU9dC5Mb2NhbEltYWdlQ2FjaGU9dC5Mb2NhbEdTdGF0ZUNhY2hlPXQuTG9jYWxGdW5jdGlvbkNhY2hlPXQuTG9jYWxDb2xvclNwYWNlQ2FjaGU9dC5HbG9iYWxJbWFnZUNhY2hlPXZvaWQgMDt2YXIgcj1hKDIpLG49YSg1KTtjbGFzcyBCYXNlTG9jYWxDYWNoZXtjb25zdHJ1Y3RvcihlKXt0aGlzLmNvbnN0cnVjdG9yPT09QmFzZUxvY2FsQ2FjaGUmJigwLHIudW5yZWFjaGFibGUpKCJDYW5ub3QgaW5pdGlhbGl6ZSBCYXNlTG9jYWxDYWNoZS4iKTt0aGlzLl9vbmx5UmVmcz0hMD09PShlJiZlLm9ubHlSZWZzKTtpZighdGhpcy5fb25seVJlZnMpe3RoaXMuX25hbWVSZWZNYXA9bmV3IE1hcDt0aGlzLl9pbWFnZU1hcD1uZXcgTWFwfXRoaXMuX2ltYWdlQ2FjaGU9bmV3IG4uUmVmU2V0Q2FjaGV9Z2V0QnlOYW1lKGUpe3RoaXMuX29ubHlSZWZzJiYoMCxyLnVucmVhY2hhYmxlKSgiU2hvdWxkIG5vdCBjYWxsIGBnZXRCeU5hbWVgIG1ldGhvZC4iKTtjb25zdCB0PXRoaXMuX25hbWVSZWZNYXAuZ2V0KGUpO3JldHVybiB0P3RoaXMuZ2V0QnlSZWYodCk6dGhpcy5faW1hZ2VNYXAuZ2V0KGUpfHxudWxsfWdldEJ5UmVmKGUpe3JldHVybiB0aGlzLl9pbWFnZUNhY2hlLmdldChlKXx8bnVsbH1zZXQoZSx0LGEpeygwLHIudW5yZWFjaGFibGUpKCJBYnN0cmFjdCBtZXRob2QgYHNldGAgY2FsbGVkLiIpfX10LkxvY2FsSW1hZ2VDYWNoZT1jbGFzcyBMb2NhbEltYWdlQ2FjaGUgZXh0ZW5kcyBCYXNlTG9jYWxDYWNoZXtzZXQoZSx0PW51bGwsYSl7aWYoInN0cmluZyIhPXR5cGVvZiBlKXRocm93IG5ldyBFcnJvcignTG9jYWxJbWFnZUNhY2hlLnNldCAtIGV4cGVjdGVkICJuYW1lIiBhcmd1bWVudC4nKTtpZih0KXtpZih0aGlzLl9pbWFnZUNhY2hlLmhhcyh0KSlyZXR1cm47dGhpcy5fbmFtZVJlZk1hcC5zZXQoZSx0KTt0aGlzLl9pbWFnZUNhY2hlLnB1dCh0LGEpfWVsc2UgdGhpcy5faW1hZ2VNYXAuaGFzKGUpfHx0aGlzLl9pbWFnZU1hcC5zZXQoZSxhKX19O3QuTG9jYWxDb2xvclNwYWNlQ2FjaGU9Y2xhc3MgTG9jYWxDb2xvclNwYWNlQ2FjaGUgZXh0ZW5kcyBCYXNlTG9jYWxDYWNoZXtzZXQoZT1udWxsLHQ9bnVsbCxhKXtpZigic3RyaW5nIiE9dHlwZW9mIGUmJiF0KXRocm93IG5ldyBFcnJvcignTG9jYWxDb2xvclNwYWNlQ2FjaGUuc2V0IC0gZXhwZWN0ZWQgIm5hbWUiIGFuZC9vciAicmVmIiBhcmd1bWVudC4nKTtpZih0KXtpZih0aGlzLl9pbWFnZUNhY2hlLmhhcyh0KSlyZXR1cm47bnVsbCE9PWUmJnRoaXMuX25hbWVSZWZNYXAuc2V0KGUsdCk7dGhpcy5faW1hZ2VDYWNoZS5wdXQodCxhKX1lbHNlIHRoaXMuX2ltYWdlTWFwLmhhcyhlKXx8dGhpcy5faW1hZ2VNYXAuc2V0KGUsYSl9fTt0LkxvY2FsRnVuY3Rpb25DYWNoZT1jbGFzcyBMb2NhbEZ1bmN0aW9uQ2FjaGUgZXh0ZW5kcyBCYXNlTG9jYWxDYWNoZXtjb25zdHJ1Y3RvcihlKXtzdXBlcih7b25seVJlZnM6ITB9KX1zZXQoZT1udWxsLHQsYSl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKCdMb2NhbEZ1bmN0aW9uQ2FjaGUuc2V0IC0gZXhwZWN0ZWQgInJlZiIgYXJndW1lbnQuJyk7dGhpcy5faW1hZ2VDYWNoZS5oYXModCl8fHRoaXMuX2ltYWdlQ2FjaGUucHV0KHQsYSl9fTt0LkxvY2FsR1N0YXRlQ2FjaGU9Y2xhc3MgTG9jYWxHU3RhdGVDYWNoZSBleHRlbmRzIEJhc2VMb2NhbENhY2hle3NldChlLHQ9bnVsbCxhKXtpZigic3RyaW5nIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKCdMb2NhbEdTdGF0ZUNhY2hlLnNldCAtIGV4cGVjdGVkICJuYW1lIiBhcmd1bWVudC4nKTtpZih0KXtpZih0aGlzLl9pbWFnZUNhY2hlLmhhcyh0KSlyZXR1cm47dGhpcy5fbmFtZVJlZk1hcC5zZXQoZSx0KTt0aGlzLl9pbWFnZUNhY2hlLnB1dCh0LGEpfWVsc2UgdGhpcy5faW1hZ2VNYXAuaGFzKGUpfHx0aGlzLl9pbWFnZU1hcC5zZXQoZSxhKX19O3QuTG9jYWxUaWxpbmdQYXR0ZXJuQ2FjaGU9Y2xhc3MgTG9jYWxUaWxpbmdQYXR0ZXJuQ2FjaGUgZXh0ZW5kcyBCYXNlTG9jYWxDYWNoZXtjb25zdHJ1Y3RvcihlKXtzdXBlcih7b25seVJlZnM6ITB9KX1zZXQoZT1udWxsLHQsYSl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKCdMb2NhbFRpbGluZ1BhdHRlcm5DYWNoZS5zZXQgLSBleHBlY3RlZCAicmVmIiBhcmd1bWVudC4nKTt0aGlzLl9pbWFnZUNhY2hlLmhhcyh0KXx8dGhpcy5faW1hZ2VDYWNoZS5wdXQodCxhKX19O2NsYXNzIEdsb2JhbEltYWdlQ2FjaGV7c3RhdGljIGdldCBOVU1fUEFHRVNfVEhSRVNIT0xEKCl7cmV0dXJuKDAsci5zaGFkb3cpKHRoaXMsIk5VTV9QQUdFU19USFJFU0hPTEQiLDIpfXN0YXRpYyBnZXQgTUlOX0lNQUdFU19UT19DQUNIRSgpe3JldHVybigwLHIuc2hhZG93KSh0aGlzLCJNSU5fSU1BR0VTX1RPX0NBQ0hFIiwxMCl9c3RhdGljIGdldCBNQVhfQllURV9TSVpFKCl7cmV0dXJuKDAsci5zaGFkb3cpKHRoaXMsIk1BWF9CWVRFX1NJWkUiLDRlNyl9Y29uc3RydWN0b3IoKXt0aGlzLl9yZWZDYWNoZT1uZXcgbi5SZWZTZXRDYWNoZTt0aGlzLl9pbWFnZUNhY2hlPW5ldyBuLlJlZlNldENhY2hlfWdldCBfYnl0ZVNpemUoKXtsZXQgZT0wO2Zvcihjb25zdCB0IG9mIHRoaXMuX2ltYWdlQ2FjaGUpZSs9dC5ieXRlU2l6ZTtyZXR1cm4gZX1nZXQgX2NhY2hlTGltaXRSZWFjaGVkKCl7cmV0dXJuISh0aGlzLl9pbWFnZUNhY2hlLnNpemU8R2xvYmFsSW1hZ2VDYWNoZS5NSU5fSU1BR0VTX1RPX0NBQ0hFKSYmISh0aGlzLl9ieXRlU2l6ZTxHbG9iYWxJbWFnZUNhY2hlLk1BWF9CWVRFX1NJWkUpfXNob3VsZENhY2hlKGUsdCl7Y29uc3QgYT10aGlzLl9yZWZDYWNoZS5nZXQoZSk7cmV0dXJuISgoYT9hLnNpemUrKGEuaGFzKHQpPzA6MSk6MSk8R2xvYmFsSW1hZ2VDYWNoZS5OVU1fUEFHRVNfVEhSRVNIT0xEKSYmISghdGhpcy5faW1hZ2VDYWNoZS5oYXMoZSkmJnRoaXMuX2NhY2hlTGltaXRSZWFjaGVkKX1hZGRQYWdlSW5kZXgoZSx0KXtsZXQgYT10aGlzLl9yZWZDYWNoZS5nZXQoZSk7aWYoIWEpe2E9bmV3IFNldDt0aGlzLl9yZWZDYWNoZS5wdXQoZSxhKX1hLmFkZCh0KX1hZGRCeXRlU2l6ZShlLHQpe2NvbnN0IGE9dGhpcy5faW1hZ2VDYWNoZS5nZXQoZSk7YSYmKGEuYnl0ZVNpemV8fChhLmJ5dGVTaXplPXQpKX1nZXREYXRhKGUsdCl7Y29uc3QgYT10aGlzLl9yZWZDYWNoZS5nZXQoZSk7aWYoIWEpcmV0dXJuIG51bGw7aWYoYS5zaXplPEdsb2JhbEltYWdlQ2FjaGUuTlVNX1BBR0VTX1RIUkVTSE9MRClyZXR1cm4gbnVsbDtjb25zdCByPXRoaXMuX2ltYWdlQ2FjaGUuZ2V0KGUpO2lmKCFyKXJldHVybiBudWxsO2EuYWRkKHQpO3JldHVybiByfXNldERhdGEoZSx0KXtpZighdGhpcy5fcmVmQ2FjaGUuaGFzKGUpKXRocm93IG5ldyBFcnJvcignR2xvYmFsSW1hZ2VDYWNoZS5zZXREYXRhIC0gZXhwZWN0ZWQgImFkZFBhZ2VJbmRleCIgdG8gaGF2ZSBiZWVuIGNhbGxlZC4nKTt0aGlzLl9pbWFnZUNhY2hlLmhhcyhlKXx8KHRoaXMuX2NhY2hlTGltaXRSZWFjaGVkPygwLHIud2FybikoIkdsb2JhbEltYWdlQ2FjaGUuc2V0RGF0YSAtIGNhY2hlIGxpbWl0IHJlYWNoZWQuIik6dGhpcy5faW1hZ2VDYWNoZS5wdXQoZSx0KSl9Y2xlYXIoZT0hMSl7ZXx8dGhpcy5fcmVmQ2FjaGUuY2xlYXIoKTt0aGlzLl9pbWFnZUNhY2hlLmNsZWFyKCl9fXQuR2xvYmFsSW1hZ2VDYWNoZT1HbG9iYWxJbWFnZUNhY2hlfSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuYmlkaT1mdW5jdGlvbiBiaWRpKGUsdD0tMSxhPSExKXtsZXQgYz0hMDtjb25zdCBsPWUubGVuZ3RoO2lmKDA9PT1sfHxhKXJldHVybiBjcmVhdGVCaWRpVGV4dChlLGMsYSk7cy5sZW5ndGg9bDtvLmxlbmd0aD1sO2xldCBoLHUsZD0wO2ZvcihoPTA7aDxsOysraCl7c1toXT1lLmNoYXJBdChoKTtjb25zdCB0PWUuY2hhckNvZGVBdChoKTtsZXQgYT0iTCI7aWYodDw9MjU1KWE9blt0XTtlbHNlIGlmKDE0MjQ8PXQmJnQ8PTE1MjQpYT0iUiI7ZWxzZSBpZigxNTM2PD10JiZ0PD0xNzkxKXthPWlbMjU1JnRdO2F8fCgwLHIud2FybikoIkJpZGk6IGludmFsaWQgVW5pY29kZSBjaGFyYWN0ZXIgIit0LnRvU3RyaW5nKDE2KSl9ZWxzZSAxNzkyPD10JiZ0PD0yMjIwJiYoYT0iQUwiKTsiUiIhPT1hJiYiQUwiIT09YSYmIkFOIiE9PWF8fGQrKztvW2hdPWF9aWYoMD09PWQpe2M9ITA7cmV0dXJuIGNyZWF0ZUJpZGlUZXh0KGUsYyl9aWYoLTE9PT10KWlmKGQvbDwuMyYmbD40KXtjPSEwO3Q9MH1lbHNle2M9ITE7dD0xfWNvbnN0IGY9W107Zm9yKGg9MDtoPGw7KytoKWZbaF09dDtjb25zdCBnPWlzT2RkKHQpPyJSIjoiTCIscD1nLG09cDtsZXQgYix5PXA7Zm9yKGg9MDtoPGw7KytoKSJOU00iPT09b1toXT9vW2hdPXk6eT1vW2hdO3k9cDtmb3IoaD0wO2g8bDsrK2gpe2I9b1toXTsiRU4iPT09Yj9vW2hdPSJBTCI9PT15PyJBTiI6IkVOIjoiUiIhPT1iJiYiTCIhPT1iJiYiQUwiIT09Ynx8KHk9Yil9Zm9yKGg9MDtoPGw7KytoKXtiPW9baF07IkFMIj09PWImJihvW2hdPSJSIil9Zm9yKGg9MTtoPGwtMTsrK2gpeyJFUyI9PT1vW2hdJiYiRU4iPT09b1toLTFdJiYiRU4iPT09b1toKzFdJiYob1toXT0iRU4iKTsiQ1MiIT09b1toXXx8IkVOIiE9PW9baC0xXSYmIkFOIiE9PW9baC0xXXx8b1toKzFdIT09b1toLTFdfHwob1toXT1vW2gtMV0pfWZvcihoPTA7aDxsOysraClpZigiRU4iPT09b1toXSl7Zm9yKGxldCBlPWgtMTtlPj0wJiYiRVQiPT09b1tlXTstLWUpb1tlXT0iRU4iO2ZvcihsZXQgZT1oKzE7ZTxsJiYiRVQiPT09b1tlXTsrK2Upb1tlXT0iRU4ifWZvcihoPTA7aDxsOysraCl7Yj1vW2hdOyJXUyIhPT1iJiYiRVMiIT09YiYmIkVUIiE9PWImJiJDUyIhPT1ifHwob1toXT0iT04iKX15PXA7Zm9yKGg9MDtoPGw7KytoKXtiPW9baF07IkVOIj09PWI/b1toXT0iTCI9PT15PyJMIjoiRU4iOiJSIiE9PWImJiJMIiE9PWJ8fCh5PWIpfWZvcihoPTA7aDxsOysraClpZigiT04iPT09b1toXSl7Y29uc3QgZT1maW5kVW5lcXVhbChvLGgrMSwiT04iKTtsZXQgdD1wO2g+MCYmKHQ9b1toLTFdKTtsZXQgYT1tO2UrMTxsJiYoYT1vW2UrMV0pOyJMIiE9PXQmJih0PSJSIik7IkwiIT09YSYmKGE9IlIiKTt0PT09YSYmc2V0VmFsdWVzKG8saCxlLHQpO2g9ZS0xfWZvcihoPTA7aDxsOysraCkiT04iPT09b1toXSYmKG9baF09Zyk7Zm9yKGg9MDtoPGw7KytoKXtiPW9baF07aXNFdmVuKGZbaF0pPyJSIj09PWI/ZltoXSs9MToiQU4iIT09YiYmIkVOIiE9PWJ8fChmW2hdKz0yKToiTCIhPT1iJiYiQU4iIT09YiYmIkVOIiE9PWJ8fChmW2hdKz0xKX1sZXQgdyxTPS0xLHg9OTk7Zm9yKGg9MCx1PWYubGVuZ3RoO2g8dTsrK2gpe3c9ZltoXTtTPHcmJihTPXcpO3g+dyYmaXNPZGQodykmJih4PXcpfWZvcih3PVM7dz49eDstLXcpe2xldCBlPS0xO2ZvcihoPTAsdT1mLmxlbmd0aDtoPHU7KytoKWlmKGZbaF08dyl7aWYoZT49MCl7cmV2ZXJzZVZhbHVlcyhzLGUsaCk7ZT0tMX19ZWxzZSBlPDAmJihlPWgpO2U+PTAmJnJldmVyc2VWYWx1ZXMocyxlLGYubGVuZ3RoKX1mb3IoaD0wLHU9cy5sZW5ndGg7aDx1OysraCl7Y29uc3QgZT1zW2hdOyI8IiE9PWUmJiI+IiE9PWV8fChzW2hdPSIiKX1yZXR1cm4gY3JlYXRlQmlkaVRleHQocy5qb2luKCIiKSxjKX07dmFyIHI9YSgyKTtjb25zdCBuPVsiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiUyIsIkIiLCJTIiwiV1MiLCJCIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkIiLCJCIiwiQiIsIlMiLCJXUyIsIk9OIiwiT04iLCJFVCIsIkVUIiwiRVQiLCJPTiIsIk9OIiwiT04iLCJPTiIsIk9OIiwiRVMiLCJDUyIsIkVTIiwiQ1MiLCJDUyIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiQ1MiLCJPTiIsIk9OIiwiT04iLCJPTiIsIk9OIiwiT04iLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIk9OIiwiT04iLCJPTiIsIk9OIiwiT04iLCJPTiIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiT04iLCJPTiIsIk9OIiwiT04iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkNTIiwiT04iLCJFVCIsIkVUIiwiRVQiLCJFVCIsIk9OIiwiT04iLCJPTiIsIk9OIiwiTCIsIk9OIiwiT04iLCJCTiIsIk9OIiwiT04iLCJFVCIsIkVUIiwiRU4iLCJFTiIsIk9OIiwiTCIsIk9OIiwiT04iLCJPTiIsIkVOIiwiTCIsIk9OIiwiT04iLCJPTiIsIk9OIiwiT04iLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIk9OIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIk9OIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiXSxpPVsiQU4iLCJBTiIsIkFOIiwiQU4iLCJBTiIsIkFOIiwiT04iLCJPTiIsIkFMIiwiRVQiLCJFVCIsIkFMIiwiQ1MiLCJBTCIsIk9OIiwiT04iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJBTCIsIkFMIiwiIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiQU4iLCJBTiIsIkFOIiwiQU4iLCJBTiIsIkFOIiwiQU4iLCJBTiIsIkFOIiwiQU4iLCJFVCIsIkFOIiwiQU4iLCJBTCIsIkFMIiwiQUwiLCJOU00iLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiQU4iLCJPTiIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIkFMIiwiQUwiLCJOU00iLCJOU00iLCJPTiIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIkFMIiwiQUwiLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCJdO2Z1bmN0aW9uIGlzT2RkKGUpe3JldHVybiAwIT0oMSZlKX1mdW5jdGlvbiBpc0V2ZW4oZSl7cmV0dXJuIDA9PSgxJmUpfWZ1bmN0aW9uIGZpbmRVbmVxdWFsKGUsdCxhKXtsZXQgcixuO2ZvcihyPXQsbj1lLmxlbmd0aDtyPG47KytyKWlmKGVbcl0hPT1hKXJldHVybiByO3JldHVybiByfWZ1bmN0aW9uIHNldFZhbHVlcyhlLHQsYSxyKXtmb3IobGV0IG49dDtuPGE7KytuKWVbbl09cn1mdW5jdGlvbiByZXZlcnNlVmFsdWVzKGUsdCxhKXtmb3IobGV0IHI9dCxuPWEtMTtyPG47KytyLC0tbil7Y29uc3QgdD1lW3JdO2Vbcl09ZVtuXTtlW25dPXR9fWZ1bmN0aW9uIGNyZWF0ZUJpZGlUZXh0KGUsdCxhPSExKXtsZXQgcj0ibHRyIjthP3I9InR0YiI6dHx8KHI9InJ0bCIpO3JldHVybntzdHI6ZSxkaXI6cn19Y29uc3Qgcz1bXSxvPVtdfSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuTXVybXVySGFzaDNfNjQ9dm9pZCAwO3ZhciByPWEoMik7Y29uc3Qgbj0zMjg1Mzc3NTIwLGk9NDI5NDkwMTc2MCxzPTY1NTM1O3QuTXVybXVySGFzaDNfNjQ9Y2xhc3MgTXVybXVySGFzaDNfNjR7Y29uc3RydWN0b3IoZSl7dGhpcy5oMT1lPzQyOTQ5NjcyOTUmZTpuO3RoaXMuaDI9ZT80Mjk0OTY3Mjk1JmU6bn11cGRhdGUoZSl7bGV0IHQsYTtpZigic3RyaW5nIj09dHlwZW9mIGUpe3Q9bmV3IFVpbnQ4QXJyYXkoMiplLmxlbmd0aCk7YT0wO2ZvcihsZXQgcj0wLG49ZS5sZW5ndGg7cjxuO3IrKyl7Y29uc3Qgbj1lLmNoYXJDb2RlQXQocik7aWYobjw9MjU1KXRbYSsrXT1uO2Vsc2V7dFthKytdPW4+Pj44O3RbYSsrXT0yNTUmbn19fWVsc2V7aWYoISgwLHIuaXNBcnJheUJ1ZmZlcikoZSkpdGhyb3cgbmV3IEVycm9yKCJXcm9uZyBkYXRhIGZvcm1hdCBpbiBNdXJtdXJIYXNoM182NF91cGRhdGUuIElucHV0IG11c3QgYmUgYSBzdHJpbmcgb3IgYXJyYXkuIik7dD1lLnNsaWNlKCk7YT10LmJ5dGVMZW5ndGh9Y29uc3Qgbj1hPj4yLG89YS00Km4sYz1uZXcgVWludDMyQXJyYXkodC5idWZmZXIsMCxuKTtsZXQgbD0wLGg9MCx1PXRoaXMuaDEsZD10aGlzLmgyO2NvbnN0IGY9MzQzMjkxODM1MyxnPTQ2MTg0NTkwNyxwPTExNjAxLG09MTM3MTU7Zm9yKGxldCBlPTA7ZTxuO2UrKylpZigxJmUpe2w9Y1tlXTtsPWwqZiZpfGwqcCZzO2w9bDw8MTV8bD4+PjE3O2w9bCpnJml8bCptJnM7dV49bDt1PXU8PDEzfHU+Pj4xOTt1PTUqdSszODY0MjkyMTk2fWVsc2V7aD1jW2VdO2g9aCpmJml8aCpwJnM7aD1oPDwxNXxoPj4+MTc7aD1oKmcmaXxoKm0mcztkXj1oO2Q9ZDw8MTN8ZD4+PjE5O2Q9NSpkKzM4NjQyOTIxOTZ9bD0wO3N3aXRjaChvKXtjYXNlIDM6bF49dFs0Km4rMl08PDE2O2Nhc2UgMjpsXj10WzQqbisxXTw8ODtjYXNlIDE6bF49dFs0Km5dO2w9bCpmJml8bCpwJnM7bD1sPDwxNXxsPj4+MTc7bD1sKmcmaXxsKm0mczsxJm4/dV49bDpkXj1sfXRoaXMuaDE9dTt0aGlzLmgyPWR9aGV4ZGlnZXN0KCl7bGV0IGU9dGhpcy5oMSx0PXRoaXMuaDI7ZV49dD4+PjE7ZT0zOTgxODA2Nzk3KmUmaXwzNjA0NSplJnM7dD00MjgzNTQzNTExKnQmaXwoMjk1MDE2Mzc5NyoodDw8MTZ8ZT4+PjE2KSZpKT4+PjE2O2VePXQ+Pj4xO2U9NDQ0OTg0NDAzKmUmaXw2MDQ5OSplJnM7dD0zMzAxODgyMzY2KnQmaXwoMzEyMDQzNzg5MyoodDw8MTZ8ZT4+PjE2KSZpKT4+PjE2O2VePXQ+Pj4xO2NvbnN0IGE9KGU+Pj4wKS50b1N0cmluZygxNikscj0odD4+PjApLnRvU3RyaW5nKDE2KTtyZXR1cm4gYS5wYWRTdGFydCg4LCIwIikrci5wYWRTdGFydCg4LCIwIil9fX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0Lk9wZXJhdG9yTGlzdD12b2lkIDA7dmFyIHI9YSgyKTtmdW5jdGlvbiBhZGRTdGF0ZShlLHQsYSxyLG4pe2xldCBpPWU7Zm9yKGxldCBlPTAsYT10Lmxlbmd0aC0xO2U8YTtlKyspe2NvbnN0IGE9dFtlXTtpPWlbYV18fChpW2FdPVtdKX1pW3QuYXQoLTEpXT17Y2hlY2tGbjphLGl0ZXJhdGVGbjpyLHByb2Nlc3NGbjpufX1jb25zdCBuPVtdO2FkZFN0YXRlKG4sW3IuT1BTLnNhdmUsci5PUFMudHJhbnNmb3JtLHIuT1BTLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0LHIuT1BTLnJlc3RvcmVdLG51bGwsKGZ1bmN0aW9uIGl0ZXJhdGVJbmxpbmVJbWFnZUdyb3VwKGUsdCl7Y29uc3QgYT1lLmZuQXJyYXksbj0odC0oZS5pQ3Vyci0zKSklNDtzd2l0Y2gobil7Y2FzZSAwOnJldHVybiBhW3RdPT09ci5PUFMuc2F2ZTtjYXNlIDE6cmV0dXJuIGFbdF09PT1yLk9QUy50cmFuc2Zvcm07Y2FzZSAyOnJldHVybiBhW3RdPT09ci5PUFMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3Q7Y2FzZSAzOnJldHVybiBhW3RdPT09ci5PUFMucmVzdG9yZX10aHJvdyBuZXcgRXJyb3IoYGl0ZXJhdGVJbmxpbmVJbWFnZUdyb3VwIC0gaW52YWxpZCBwb3M6ICR7bn1gKX0pLChmdW5jdGlvbiBmb3VuZElubGluZUltYWdlR3JvdXAoZSx0KXtjb25zdCBhPWUuZm5BcnJheSxuPWUuYXJnc0FycmF5LGk9ZS5pQ3VycixzPWktMyxvPWktMixjPWktMSxsPU1hdGgubWluKE1hdGguZmxvb3IoKHQtcykvNCksMjAwKTtpZihsPDEwKXJldHVybiB0LSh0LXMpJTQ7bGV0IGg9MDtjb25zdCB1PVtdO2xldCBkPTAsZj0xLGc9MTtmb3IobGV0IGU9MDtlPGw7ZSsrKXtjb25zdCB0PW5bbysoZTw8MildLGE9bltjKyhlPDwyKV1bMF07aWYoZithLndpZHRoPjFlMyl7aD1NYXRoLm1heChoLGYpO2crPWQrMjtmPTA7ZD0wfXUucHVzaCh7dHJhbnNmb3JtOnQseDpmLHk6Zyx3OmEud2lkdGgsaDphLmhlaWdodH0pO2YrPWEud2lkdGgrMjtkPU1hdGgubWF4KGQsYS5oZWlnaHQpfWNvbnN0IHA9TWF0aC5tYXgoaCxmKSsxLG09ZytkKzEsYj1uZXcgVWludDhBcnJheShwKm0qNCkseT1wPDwyO2ZvcihsZXQgZT0wO2U8bDtlKyspe2NvbnN0IHQ9bltjKyhlPDwyKV1bMF0uZGF0YSxhPXVbZV0udzw8MjtsZXQgcj0wLGk9dVtlXS54K3VbZV0ueSpwPDwyO2Iuc2V0KHQuc3ViYXJyYXkoMCxhKSxpLXkpO2ZvcihsZXQgbj0wLHM9dVtlXS5oO248cztuKyspe2Iuc2V0KHQuc3ViYXJyYXkocixyK2EpLGkpO3IrPWE7aSs9eX1iLnNldCh0LnN1YmFycmF5KHItYSxyKSxpKTtmb3IoO2k+PTA7KXt0W2ktNF09dFtpXTt0W2ktM109dFtpKzFdO3RbaS0yXT10W2krMl07dFtpLTFdPXRbaSszXTt0W2krYV09dFtpK2EtNF07dFtpK2ErMV09dFtpK2EtM107dFtpK2ErMl09dFtpK2EtMl07dFtpK2ErM109dFtpK2EtMV07aS09eX19YS5zcGxpY2Uocyw0Kmwsci5PUFMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cCk7bi5zcGxpY2Uocyw0KmwsW3t3aWR0aDpwLGhlaWdodDptLGtpbmQ6ci5JbWFnZUtpbmQuUkdCQV8zMkJQUCxkYXRhOmJ9LHVdKTtyZXR1cm4gcysxfSkpO2FkZFN0YXRlKG4sW3IuT1BTLnNhdmUsci5PUFMudHJhbnNmb3JtLHIuT1BTLnBhaW50SW1hZ2VNYXNrWE9iamVjdCxyLk9QUy5yZXN0b3JlXSxudWxsLChmdW5jdGlvbiBpdGVyYXRlSW1hZ2VNYXNrR3JvdXAoZSx0KXtjb25zdCBhPWUuZm5BcnJheSxuPSh0LShlLmlDdXJyLTMpKSU0O3N3aXRjaChuKXtjYXNlIDA6cmV0dXJuIGFbdF09PT1yLk9QUy5zYXZlO2Nhc2UgMTpyZXR1cm4gYVt0XT09PXIuT1BTLnRyYW5zZm9ybTtjYXNlIDI6cmV0dXJuIGFbdF09PT1yLk9QUy5wYWludEltYWdlTWFza1hPYmplY3Q7Y2FzZSAzOnJldHVybiBhW3RdPT09ci5PUFMucmVzdG9yZX10aHJvdyBuZXcgRXJyb3IoYGl0ZXJhdGVJbWFnZU1hc2tHcm91cCAtIGludmFsaWQgcG9zOiAke259YCl9KSwoZnVuY3Rpb24gZm91bmRJbWFnZU1hc2tHcm91cChlLHQpe2NvbnN0IGE9ZS5mbkFycmF5LG49ZS5hcmdzQXJyYXksaT1lLmlDdXJyLHM9aS0zLG89aS0yLGM9aS0xO2xldCBsPU1hdGguZmxvb3IoKHQtcykvNCk7aWYobDwxMClyZXR1cm4gdC0odC1zKSU0O2xldCBoLHUsZD0hMTtjb25zdCBmPW5bY11bMF0sZz1uW29dWzBdLHA9bltvXVsxXSxtPW5bb11bMl0sYj1uW29dWzNdO2lmKHA9PT1tKXtkPSEwO2g9bys0O2xldCBlPWMrNDtmb3IobGV0IHQ9MTt0PGw7dCsrLGgrPTQsZSs9NCl7dT1uW2hdO2lmKG5bZV1bMF0hPT1mfHx1WzBdIT09Z3x8dVsxXSE9PXB8fHVbMl0hPT1tfHx1WzNdIT09Yil7dDwxMD9kPSExOmw9dDticmVha319fWlmKGQpe2w9TWF0aC5taW4obCwxZTMpO2NvbnN0IGU9bmV3IEZsb2F0MzJBcnJheSgyKmwpO2g9bztmb3IobGV0IHQ9MDt0PGw7dCsrLGgrPTQpe3U9bltoXTtlW3Q8PDFdPXVbNF07ZVsxKyh0PDwxKV09dVs1XX1hLnNwbGljZShzLDQqbCxyLk9QUy5wYWludEltYWdlTWFza1hPYmplY3RSZXBlYXQpO24uc3BsaWNlKHMsNCpsLFtmLGcscCxtLGIsZV0pfWVsc2V7bD1NYXRoLm1pbihsLDEwMCk7Y29uc3QgZT1bXTtmb3IobGV0IHQ9MDt0PGw7dCsrKXt1PW5bbysodDw8MildO2NvbnN0IGE9bltjKyh0PDwyKV1bMF07ZS5wdXNoKHtkYXRhOmEuZGF0YSx3aWR0aDphLndpZHRoLGhlaWdodDphLmhlaWdodCxpbnRlcnBvbGF0ZTphLmludGVycG9sYXRlLGNvdW50OmEuY291bnQsdHJhbnNmb3JtOnV9KX1hLnNwbGljZShzLDQqbCxyLk9QUy5wYWludEltYWdlTWFza1hPYmplY3RHcm91cCk7bi5zcGxpY2Uocyw0KmwsW2VdKX1yZXR1cm4gcysxfSkpO2FkZFN0YXRlKG4sW3IuT1BTLnNhdmUsci5PUFMudHJhbnNmb3JtLHIuT1BTLnBhaW50SW1hZ2VYT2JqZWN0LHIuT1BTLnJlc3RvcmVdLChmdW5jdGlvbihlKXtjb25zdCB0PWUuYXJnc0FycmF5LGE9ZS5pQ3Vyci0yO3JldHVybiAwPT09dFthXVsxXSYmMD09PXRbYV1bMl19KSwoZnVuY3Rpb24gaXRlcmF0ZUltYWdlR3JvdXAoZSx0KXtjb25zdCBhPWUuZm5BcnJheSxuPWUuYXJnc0FycmF5LGk9KHQtKGUuaUN1cnItMykpJTQ7c3dpdGNoKGkpe2Nhc2UgMDpyZXR1cm4gYVt0XT09PXIuT1BTLnNhdmU7Y2FzZSAxOmlmKGFbdF0hPT1yLk9QUy50cmFuc2Zvcm0pcmV0dXJuITE7Y29uc3QgaT1lLmlDdXJyLTIscz1uW2ldWzBdLG89bltpXVszXTtyZXR1cm4gblt0XVswXT09PXMmJjA9PT1uW3RdWzFdJiYwPT09blt0XVsyXSYmblt0XVszXT09PW87Y2FzZSAyOmlmKGFbdF0hPT1yLk9QUy5wYWludEltYWdlWE9iamVjdClyZXR1cm4hMTtjb25zdCBjPW5bZS5pQ3Vyci0xXVswXTtyZXR1cm4gblt0XVswXT09PWM7Y2FzZSAzOnJldHVybiBhW3RdPT09ci5PUFMucmVzdG9yZX10aHJvdyBuZXcgRXJyb3IoYGl0ZXJhdGVJbWFnZUdyb3VwIC0gaW52YWxpZCBwb3M6ICR7aX1gKX0pLChmdW5jdGlvbihlLHQpe2NvbnN0IGE9ZS5mbkFycmF5LG49ZS5hcmdzQXJyYXksaT1lLmlDdXJyLHM9aS0zLG89aS0yLGM9bltpLTFdWzBdLGw9bltvXVswXSxoPW5bb11bM10sdT1NYXRoLm1pbihNYXRoLmZsb29yKCh0LXMpLzQpLDFlMyk7aWYodTwzKXJldHVybiB0LSh0LXMpJTQ7Y29uc3QgZD1uZXcgRmxvYXQzMkFycmF5KDIqdSk7bGV0IGY9bztmb3IobGV0IGU9MDtlPHU7ZSsrLGYrPTQpe2NvbnN0IHQ9bltmXTtkW2U8PDFdPXRbNF07ZFsxKyhlPDwxKV09dFs1XX1jb25zdCBnPVtjLGwsaCxkXTthLnNwbGljZShzLDQqdSxyLk9QUy5wYWludEltYWdlWE9iamVjdFJlcGVhdCk7bi5zcGxpY2Uocyw0KnUsZyk7cmV0dXJuIHMrMX0pKTthZGRTdGF0ZShuLFtyLk9QUy5iZWdpblRleHQsci5PUFMuc2V0Rm9udCxyLk9QUy5zZXRUZXh0TWF0cml4LHIuT1BTLnNob3dUZXh0LHIuT1BTLmVuZFRleHRdLG51bGwsKGZ1bmN0aW9uIGl0ZXJhdGVTaG93VGV4dEdyb3VwKGUsdCl7Y29uc3QgYT1lLmZuQXJyYXksbj1lLmFyZ3NBcnJheSxpPSh0LShlLmlDdXJyLTQpKSU1O3N3aXRjaChpKXtjYXNlIDA6cmV0dXJuIGFbdF09PT1yLk9QUy5iZWdpblRleHQ7Y2FzZSAxOnJldHVybiBhW3RdPT09ci5PUFMuc2V0Rm9udDtjYXNlIDI6cmV0dXJuIGFbdF09PT1yLk9QUy5zZXRUZXh0TWF0cml4O2Nhc2UgMzppZihhW3RdIT09ci5PUFMuc2hvd1RleHQpcmV0dXJuITE7Y29uc3QgaT1lLmlDdXJyLTMscz1uW2ldWzBdLG89bltpXVsxXTtyZXR1cm4gblt0XVswXT09PXMmJm5bdF1bMV09PT1vO2Nhc2UgNDpyZXR1cm4gYVt0XT09PXIuT1BTLmVuZFRleHR9dGhyb3cgbmV3IEVycm9yKGBpdGVyYXRlU2hvd1RleHRHcm91cCAtIGludmFsaWQgcG9zOiAke2l9YCl9KSwoZnVuY3Rpb24oZSx0KXtjb25zdCBhPWUuZm5BcnJheSxyPWUuYXJnc0FycmF5LG49ZS5pQ3VycixpPW4tNCxzPW4tMyxvPW4tMixjPW4tMSxsPW4saD1yW3NdWzBdLHU9cltzXVsxXTtsZXQgZD1NYXRoLm1pbihNYXRoLmZsb29yKCh0LWkpLzUpLDFlMyk7aWYoZDwzKXJldHVybiB0LSh0LWkpJTU7bGV0IGY9aTtpZihpPj00JiZhW2ktNF09PT1hW3NdJiZhW2ktM109PT1hW29dJiZhW2ktMl09PT1hW2NdJiZhW2ktMV09PT1hW2xdJiZyW2ktNF1bMF09PT1oJiZyW2ktNF1bMV09PT11KXtkKys7Zi09NX1sZXQgZz1mKzQ7Zm9yKGxldCBlPTE7ZTxkO2UrKyl7YS5zcGxpY2UoZywzKTtyLnNwbGljZShnLDMpO2crPTJ9cmV0dXJuIGcrMX0pKTtjbGFzcyBOdWxsT3B0aW1pemVye2NvbnN0cnVjdG9yKGUpe3RoaXMucXVldWU9ZX1fb3B0aW1pemUoKXt9cHVzaChlLHQpe3RoaXMucXVldWUuZm5BcnJheS5wdXNoKGUpO3RoaXMucXVldWUuYXJnc0FycmF5LnB1c2godCk7dGhpcy5fb3B0aW1pemUoKX1mbHVzaCgpe31yZXNldCgpe319Y2xhc3MgUXVldWVPcHRpbWl6ZXIgZXh0ZW5kcyBOdWxsT3B0aW1pemVye2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO3RoaXMuc3RhdGU9bnVsbDt0aGlzLmNvbnRleHQ9e2lDdXJyOjAsZm5BcnJheTplLmZuQXJyYXksYXJnc0FycmF5OmUuYXJnc0FycmF5fTt0aGlzLm1hdGNoPW51bGw7dGhpcy5sYXN0UHJvY2Vzc2VkPTB9X29wdGltaXplKCl7Y29uc3QgZT10aGlzLnF1ZXVlLmZuQXJyYXk7bGV0IHQ9dGhpcy5sYXN0UHJvY2Vzc2VkLGE9ZS5sZW5ndGgscj10aGlzLnN0YXRlLGk9dGhpcy5tYXRjaDtpZighciYmIWkmJnQrMT09PWEmJiFuW2VbdF1dKXt0aGlzLmxhc3RQcm9jZXNzZWQ9YTtyZXR1cm59Y29uc3Qgcz10aGlzLmNvbnRleHQ7Zm9yKDt0PGE7KXtpZihpKXtpZigoMCxpLml0ZXJhdGVGbikocyx0KSl7dCsrO2NvbnRpbnVlfXQ9KDAsaS5wcm9jZXNzRm4pKHMsdCsxKTthPWUubGVuZ3RoO2k9bnVsbDtyPW51bGw7aWYodD49YSlicmVha31yPShyfHxuKVtlW3RdXTtpZihyJiYhQXJyYXkuaXNBcnJheShyKSl7cy5pQ3Vycj10O3QrKztpZighci5jaGVja0ZufHwoMCxyLmNoZWNrRm4pKHMpKXtpPXI7cj1udWxsfWVsc2Ugcj1udWxsfWVsc2UgdCsrfXRoaXMuc3RhdGU9cjt0aGlzLm1hdGNoPWk7dGhpcy5sYXN0UHJvY2Vzc2VkPXR9Zmx1c2goKXtmb3IoO3RoaXMubWF0Y2g7KXtjb25zdCBlPXRoaXMucXVldWUuZm5BcnJheS5sZW5ndGg7dGhpcy5sYXN0UHJvY2Vzc2VkPSgwLHRoaXMubWF0Y2gucHJvY2Vzc0ZuKSh0aGlzLmNvbnRleHQsZSk7dGhpcy5tYXRjaD1udWxsO3RoaXMuc3RhdGU9bnVsbDt0aGlzLl9vcHRpbWl6ZSgpfX1yZXNldCgpe3RoaXMuc3RhdGU9bnVsbDt0aGlzLm1hdGNoPW51bGw7dGhpcy5sYXN0UHJvY2Vzc2VkPTB9fWNsYXNzIE9wZXJhdG9yTGlzdHtzdGF0aWMgZ2V0IENIVU5LX1NJWkUoKXtyZXR1cm4oMCxyLnNoYWRvdykodGhpcywiQ0hVTktfU0laRSIsMWUzKX1zdGF0aWMgZ2V0IENIVU5LX1NJWkVfQUJPVVQoKXtyZXR1cm4oMCxyLnNoYWRvdykodGhpcywiQ0hVTktfU0laRV9BQk9VVCIsdGhpcy5DSFVOS19TSVpFLTUpfWNvbnN0cnVjdG9yKGU9MCx0KXt0aGlzLl9zdHJlYW1TaW5rPXQ7dGhpcy5mbkFycmF5PVtdO3RoaXMuYXJnc0FycmF5PVtdOyF0fHxlJnIuUmVuZGVyaW5nSW50ZW50RmxhZy5PUExJU1Q/dGhpcy5vcHRpbWl6ZXI9bmV3IE51bGxPcHRpbWl6ZXIodGhpcyk6dGhpcy5vcHRpbWl6ZXI9bmV3IFF1ZXVlT3B0aW1pemVyKHRoaXMpO3RoaXMuZGVwZW5kZW5jaWVzPW5ldyBTZXQ7dGhpcy5fdG90YWxMZW5ndGg9MDt0aGlzLndlaWdodD0wO3RoaXMuX3Jlc29sdmVkPXQ/bnVsbDpQcm9taXNlLnJlc29sdmUoKX1nZXQgbGVuZ3RoKCl7cmV0dXJuIHRoaXMuYXJnc0FycmF5Lmxlbmd0aH1nZXQgcmVhZHkoKXtyZXR1cm4gdGhpcy5fcmVzb2x2ZWR8fHRoaXMuX3N0cmVhbVNpbmsucmVhZHl9Z2V0IHRvdGFsTGVuZ3RoKCl7cmV0dXJuIHRoaXMuX3RvdGFsTGVuZ3RoK3RoaXMubGVuZ3RofWFkZE9wKGUsdCl7dGhpcy5vcHRpbWl6ZXIucHVzaChlLHQpO3RoaXMud2VpZ2h0Kys7dGhpcy5fc3RyZWFtU2luayYmKHRoaXMud2VpZ2h0Pj1PcGVyYXRvckxpc3QuQ0hVTktfU0laRXx8dGhpcy53ZWlnaHQ+PU9wZXJhdG9yTGlzdC5DSFVOS19TSVpFX0FCT1VUJiYoZT09PXIuT1BTLnJlc3RvcmV8fGU9PT1yLk9QUy5lbmRUZXh0KSkmJnRoaXMuZmx1c2goKX1hZGRJbWFnZU9wcyhlLHQsYSl7dm9pZCAwIT09YSYmdGhpcy5hZGRPcChyLk9QUy5iZWdpbk1hcmtlZENvbnRlbnRQcm9wcyxbIk9DIixhXSk7dGhpcy5hZGRPcChlLHQpO3ZvaWQgMCE9PWEmJnRoaXMuYWRkT3Aoci5PUFMuZW5kTWFya2VkQ29udGVudCxbXSl9YWRkRGVwZW5kZW5jeShlKXtpZighdGhpcy5kZXBlbmRlbmNpZXMuaGFzKGUpKXt0aGlzLmRlcGVuZGVuY2llcy5hZGQoZSk7dGhpcy5hZGRPcChyLk9QUy5kZXBlbmRlbmN5LFtlXSl9fWFkZERlcGVuZGVuY2llcyhlKXtmb3IoY29uc3QgdCBvZiBlKXRoaXMuYWRkRGVwZW5kZW5jeSh0KX1hZGRPcExpc3QoZSl7aWYoZSBpbnN0YW5jZW9mIE9wZXJhdG9yTGlzdCl7Zm9yKGNvbnN0IHQgb2YgZS5kZXBlbmRlbmNpZXMpdGhpcy5kZXBlbmRlbmNpZXMuYWRkKHQpO2ZvcihsZXQgdD0wLGE9ZS5sZW5ndGg7dDxhO3QrKyl0aGlzLmFkZE9wKGUuZm5BcnJheVt0XSxlLmFyZ3NBcnJheVt0XSl9ZWxzZSgwLHIud2FybikoJ2FkZE9wTGlzdCAtIGlnbm9yaW5nIGludmFsaWQgIm9wTGlzdCIgcGFyYW1ldGVyLicpfWdldElSKCl7cmV0dXJue2ZuQXJyYXk6dGhpcy5mbkFycmF5LGFyZ3NBcnJheTp0aGlzLmFyZ3NBcnJheSxsZW5ndGg6dGhpcy5sZW5ndGh9fWdldCBfdHJhbnNmZXJzKCl7Y29uc3QgZT1bXSx7Zm5BcnJheTp0LGFyZ3NBcnJheTphLGxlbmd0aDpufT10aGlzO2ZvcihsZXQgaT0wO2k8bjtpKyspc3dpdGNoKHRbaV0pe2Nhc2Ugci5PUFMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3Q6Y2FzZSByLk9QUy5wYWludElubGluZUltYWdlWE9iamVjdEdyb3VwOmNhc2Ugci5PUFMucGFpbnRJbWFnZU1hc2tYT2JqZWN0OmNvbnN0IHQ9YVtpXVswXTshdC5jYWNoZWQmJnQuZGF0YSYmdC5kYXRhLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyJiZlLnB1c2godC5kYXRhLmJ1ZmZlcil9cmV0dXJuIGV9Zmx1c2goZT0hMSx0PW51bGwpe3RoaXMub3B0aW1pemVyLmZsdXNoKCk7Y29uc3QgYT10aGlzLmxlbmd0aDt0aGlzLl90b3RhbExlbmd0aCs9YTt0aGlzLl9zdHJlYW1TaW5rLmVucXVldWUoe2ZuQXJyYXk6dGhpcy5mbkFycmF5LGFyZ3NBcnJheTp0aGlzLmFyZ3NBcnJheSxsYXN0Q2h1bms6ZSxzZXBhcmF0ZUFubm90czp0LGxlbmd0aDphfSwxLHRoaXMuX3RyYW5zZmVycyk7dGhpcy5kZXBlbmRlbmNpZXMuY2xlYXIoKTt0aGlzLmZuQXJyYXkubGVuZ3RoPTA7dGhpcy5hcmdzQXJyYXkubGVuZ3RoPTA7dGhpcy53ZWlnaHQ9MDt0aGlzLm9wdGltaXplci5yZXNldCgpfX10Lk9wZXJhdG9yTGlzdD1PcGVyYXRvckxpc3R9LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5QREZJbWFnZT12b2lkIDA7dmFyIHI9YSgyKSxuPWEoNjQpLGk9YSg3KSxzPWEoMTQpLG89YSgxOSksYz1hKDI3KSxsPWEoMzApLGg9YSg1KTtmdW5jdGlvbiBkZWNvZGVBbmRDbGFtcChlLHQsYSxyKXsoZT10K2UqYSk8MD9lPTA6ZT5yJiYoZT1yKTtyZXR1cm4gZX1mdW5jdGlvbiByZXNpemVJbWFnZU1hc2soZSx0LGEscixuLGkpe2NvbnN0IHM9bippO2xldCBvO289dDw9OD9uZXcgVWludDhBcnJheShzKTp0PD0xNj9uZXcgVWludDE2QXJyYXkocyk6bmV3IFVpbnQzMkFycmF5KHMpO2NvbnN0IGM9YS9uLGw9ci9pO2xldCBoLHUsZCxmLGc9MDtjb25zdCBwPW5ldyBVaW50MTZBcnJheShuKSxtPWE7Zm9yKGg9MDtoPG47aCsrKXBbaF09TWF0aC5mbG9vcihoKmMpO2ZvcihoPTA7aDxpO2grKyl7ZD1NYXRoLmZsb29yKGgqbCkqbTtmb3IodT0wO3U8bjt1Kyspe2Y9ZCtwW3VdO29bZysrXT1lW2ZdfX1yZXR1cm4gb31jbGFzcyBQREZJbWFnZXtjb25zdHJ1Y3Rvcih7eHJlZjplLHJlczp0LGltYWdlOmEsaXNJbmxpbmU6bj0hMSxzbWFzazpvPW51bGwsbWFzazpjPW51bGwsaXNNYXNrOnU9ITEscGRmRnVuY3Rpb25GYWN0b3J5OmQsbG9jYWxDb2xvclNwYWNlQ2FjaGU6Zn0pe3RoaXMuaW1hZ2U9YTtjb25zdCBnPWEuZGljdCxwPWcuZ2V0KCJGIiwiRmlsdGVyIik7bGV0IG07aWYocCBpbnN0YW5jZW9mIGguTmFtZSltPXAubmFtZTtlbHNlIGlmKEFycmF5LmlzQXJyYXkocCkpe2NvbnN0IHQ9ZS5mZXRjaElmUmVmKHBbMF0pO3QgaW5zdGFuY2VvZiBoLk5hbWUmJihtPXQubmFtZSl9c3dpdGNoKG0pe2Nhc2UiSlBYRGVjb2RlIjpjb25zdCBlPW5ldyBsLkpweEltYWdlO2UucGFyc2VJbWFnZVByb3BlcnRpZXMoYS5zdHJlYW0pO2Euc3RyZWFtLnJlc2V0KCk7YS53aWR0aD1lLndpZHRoO2EuaGVpZ2h0PWUuaGVpZ2h0O2EuYml0c1BlckNvbXBvbmVudD1lLmJpdHNQZXJDb21wb25lbnQ7YS5udW1Db21wcz1lLmNvbXBvbmVudHNDb3VudDticmVhaztjYXNlIkpCSUcyRGVjb2RlIjphLmJpdHNQZXJDb21wb25lbnQ9MTthLm51bUNvbXBzPTF9bGV0IGI9Zy5nZXQoIlciLCJXaWR0aCIpLHk9Zy5nZXQoIkgiLCJIZWlnaHQiKTtpZihOdW1iZXIuaXNJbnRlZ2VyKGEud2lkdGgpJiZhLndpZHRoPjAmJk51bWJlci5pc0ludGVnZXIoYS5oZWlnaHQpJiZhLmhlaWdodD4wJiYoYS53aWR0aCE9PWJ8fGEuaGVpZ2h0IT09eSkpeygwLHIud2FybikoIlBERkltYWdlIC0gdXNpbmcgdGhlIFdpZHRoL0hlaWdodCBvZiB0aGUgaW1hZ2UgZGF0YSwgcmF0aGVyIHRoYW4gdGhlIGltYWdlIGRpY3Rpb25hcnkuIik7Yj1hLndpZHRoO3k9YS5oZWlnaHR9aWYoYjwxfHx5PDEpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoYEludmFsaWQgaW1hZ2Ugd2lkdGg6ICR7Yn0gb3IgaGVpZ2h0OiAke3l9YCk7dGhpcy53aWR0aD1iO3RoaXMuaGVpZ2h0PXk7dGhpcy5pbnRlcnBvbGF0ZT1nLmdldCgiSSIsIkludGVycG9sYXRlIik7dGhpcy5pbWFnZU1hc2s9Zy5nZXQoIklNIiwiSW1hZ2VNYXNrIil8fCExO3RoaXMubWF0dGU9Zy5nZXQoIk1hdHRlIil8fCExO2xldCB3PWEuYml0c1BlckNvbXBvbmVudDtpZighdyl7dz1nLmdldCgiQlBDIiwiQml0c1BlckNvbXBvbmVudCIpO2lmKCF3KXtpZighdGhpcy5pbWFnZU1hc2spdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoYEJpdHMgcGVyIGNvbXBvbmVudCBtaXNzaW5nIGluIGltYWdlOiAke3RoaXMuaW1hZ2VNYXNrfWApO3c9MX19dGhpcy5icGM9dztpZighdGhpcy5pbWFnZU1hc2spe2xldCBpPWcuZ2V0UmF3KCJDUyIpfHxnLmdldFJhdygiQ29sb3JTcGFjZSIpO2lmKCFpKXsoMCxyLmluZm8pKCJKUFggaW1hZ2VzICh3aGljaCBkbyBub3QgcmVxdWlyZSBjb2xvciBzcGFjZXMpIik7c3dpdGNoKGEubnVtQ29tcHMpe2Nhc2UgMTppPWguTmFtZS5nZXQoIkRldmljZUdyYXkiKTticmVhaztjYXNlIDM6aT1oLk5hbWUuZ2V0KCJEZXZpY2VSR0IiKTticmVhaztjYXNlIDQ6aT1oLk5hbWUuZ2V0KCJEZXZpY2VDTVlLIik7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEpQWCBpbWFnZXMgd2l0aCAke2EubnVtQ29tcHN9IGNvbG9yIGNvbXBvbmVudHMgbm90IHN1cHBvcnRlZC5gKX19dGhpcy5jb2xvclNwYWNlPXMuQ29sb3JTcGFjZS5wYXJzZSh7Y3M6aSx4cmVmOmUscmVzb3VyY2VzOm4/dDpudWxsLHBkZkZ1bmN0aW9uRmFjdG9yeTpkLGxvY2FsQ29sb3JTcGFjZUNhY2hlOmZ9KTt0aGlzLm51bUNvbXBzPXRoaXMuY29sb3JTcGFjZS5udW1Db21wc310aGlzLmRlY29kZT1nLmdldEFycmF5KCJEIiwiRGVjb2RlIik7dGhpcy5uZWVkc0RlY29kZT0hMTtpZih0aGlzLmRlY29kZSYmKHRoaXMuY29sb3JTcGFjZSYmIXRoaXMuY29sb3JTcGFjZS5pc0RlZmF1bHREZWNvZGUodGhpcy5kZWNvZGUsdyl8fHUmJiFzLkNvbG9yU3BhY2UuaXNEZWZhdWx0RGVjb2RlKHRoaXMuZGVjb2RlLDEpKSl7dGhpcy5uZWVkc0RlY29kZT0hMDtjb25zdCBlPSgxPDx3KS0xO3RoaXMuZGVjb2RlQ29lZmZpY2llbnRzPVtdO3RoaXMuZGVjb2RlQWRkZW5kcz1bXTtjb25zdCB0PXRoaXMuY29sb3JTcGFjZSYmIkluZGV4ZWQiPT09dGhpcy5jb2xvclNwYWNlLm5hbWU7Zm9yKGxldCBhPTAscj0wO2E8dGhpcy5kZWNvZGUubGVuZ3RoO2ErPTIsKytyKXtjb25zdCBuPXRoaXMuZGVjb2RlW2FdLGk9dGhpcy5kZWNvZGVbYSsxXTt0aGlzLmRlY29kZUNvZWZmaWNpZW50c1tyXT10PyhpLW4pL2U6aS1uO3RoaXMuZGVjb2RlQWRkZW5kc1tyXT10P246ZSpufX1pZihvKXRoaXMuc21hc2s9bmV3IFBERkltYWdlKHt4cmVmOmUscmVzOnQsaW1hZ2U6byxpc0lubGluZTpuLHBkZkZ1bmN0aW9uRmFjdG9yeTpkLGxvY2FsQ29sb3JTcGFjZUNhY2hlOmZ9KTtlbHNlIGlmKGMpaWYoYyBpbnN0YW5jZW9mIGkuQmFzZVN0cmVhbSl7Yy5kaWN0LmdldCgiSU0iLCJJbWFnZU1hc2siKT90aGlzLm1hc2s9bmV3IFBERkltYWdlKHt4cmVmOmUscmVzOnQsaW1hZ2U6Yyxpc0lubGluZTpuLGlzTWFzazohMCxwZGZGdW5jdGlvbkZhY3Rvcnk6ZCxsb2NhbENvbG9yU3BhY2VDYWNoZTpmfSk6KDAsci53YXJuKSgiSWdub3JpbmcgL01hc2sgaW4gaW1hZ2Ugd2l0aG91dCAvSW1hZ2VNYXNrLiIpfWVsc2UgdGhpcy5tYXNrPWN9c3RhdGljIGFzeW5jIGJ1aWxkSW1hZ2Uoe3hyZWY6ZSxyZXM6dCxpbWFnZTphLGlzSW5saW5lOm49ITEscGRmRnVuY3Rpb25GYWN0b3J5OnMsbG9jYWxDb2xvclNwYWNlQ2FjaGU6b30pe2NvbnN0IGM9YTtsZXQgbD1udWxsLGg9bnVsbDtjb25zdCB1PWEuZGljdC5nZXQoIlNNYXNrIiksZD1hLmRpY3QuZ2V0KCJNYXNrIik7dT91IGluc3RhbmNlb2YgaS5CYXNlU3RyZWFtP2w9dTooMCxyLndhcm4pKCJVbnN1cHBvcnRlZCAvU01hc2sgZm9ybWF0LiIpOmQmJihkIGluc3RhbmNlb2YgaS5CYXNlU3RyZWFtfHxBcnJheS5pc0FycmF5KGQpP2g9ZDooMCxyLndhcm4pKCJVbnN1cHBvcnRlZCAvTWFzayBmb3JtYXQuIikpO3JldHVybiBuZXcgUERGSW1hZ2Uoe3hyZWY6ZSxyZXM6dCxpbWFnZTpjLGlzSW5saW5lOm4sc21hc2s6bCxtYXNrOmgscGRmRnVuY3Rpb25GYWN0b3J5OnMsbG9jYWxDb2xvclNwYWNlQ2FjaGU6b30pfXN0YXRpYyBjcmVhdGVSYXdNYXNrKHtpbWdBcnJheTplLHdpZHRoOnQsaGVpZ2h0OmEsaW1hZ2VJc0Zyb21EZWNvZGVTdHJlYW06cixpbnZlcnNlRGVjb2RlOm4saW50ZXJwb2xhdGU6aX0pe2NvbnN0IHM9KHQrNz4+MykqYSxvPWUuYnl0ZUxlbmd0aDtsZXQgYyxsO2lmKCFyfHxuJiYhKHM9PT1vKSlpZihuKXtjPW5ldyBVaW50OEFycmF5KHMpO2Muc2V0KGUpO2MuZmlsbCgyNTUsbyl9ZWxzZSBjPW5ldyBVaW50OEFycmF5KGUpO2Vsc2UgYz1lO2lmKG4pZm9yKGw9MDtsPG87bCsrKWNbbF1ePTI1NTtyZXR1cm57ZGF0YTpjLHdpZHRoOnQsaGVpZ2h0OmEsaW50ZXJwb2xhdGU6aX19c3RhdGljIGNyZWF0ZU1hc2soe2ltZ0FycmF5OmUsd2lkdGg6dCxoZWlnaHQ6YSxpbWFnZUlzRnJvbURlY29kZVN0cmVhbTppLGludmVyc2VEZWNvZGU6cyxpbnRlcnBvbGF0ZTpvfSl7Y29uc3QgYz0xPT09dCYmMT09PWEmJnM9PT0oMD09PWUubGVuZ3RofHwhISgxMjgmZVswXSkpO2lmKGMpcmV0dXJue2lzU2luZ2xlT3BhcXVlUGl4ZWw6Y307aWYoci5GZWF0dXJlVGVzdC5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCl7Y29uc3Qgcj1uZXcgT2Zmc2NyZWVuQ2FudmFzKHQsYSksaT1yLmdldENvbnRleHQoIjJkIiksYz1pLmNyZWF0ZUltYWdlRGF0YSh0LGEpOygwLG4uYXBwbHlNYXNrSW1hZ2VEYXRhKSh7c3JjOmUsZGVzdDpjLmRhdGEsd2lkdGg6dCxoZWlnaHQ6YSxpbnZlcnNlRGVjb2RlOnN9KTtpLnB1dEltYWdlRGF0YShjLDAsMCk7cmV0dXJue2RhdGE6bnVsbCx3aWR0aDp0LGhlaWdodDphLGludGVycG9sYXRlOm8sYml0bWFwOnIudHJhbnNmZXJUb0ltYWdlQml0bWFwKCl9fXJldHVybiB0aGlzLmNyZWF0ZVJhd01hc2soe2ltZ0FycmF5OmUsd2lkdGg6dCxoZWlnaHQ6YSxpbnZlcnNlRGVjb2RlOnMsaW1hZ2VJc0Zyb21EZWNvZGVTdHJlYW06aSxpbnRlcnBvbGF0ZTpvfSl9Z2V0IGRyYXdXaWR0aCgpe3JldHVybiBNYXRoLm1heCh0aGlzLndpZHRoLHRoaXMuc21hc2smJnRoaXMuc21hc2sud2lkdGh8fDAsdGhpcy5tYXNrJiZ0aGlzLm1hc2sud2lkdGh8fDApfWdldCBkcmF3SGVpZ2h0KCl7cmV0dXJuIE1hdGgubWF4KHRoaXMuaGVpZ2h0LHRoaXMuc21hc2smJnRoaXMuc21hc2suaGVpZ2h0fHwwLHRoaXMubWFzayYmdGhpcy5tYXNrLmhlaWdodHx8MCl9ZGVjb2RlQnVmZmVyKGUpe2NvbnN0IHQ9dGhpcy5icGMsYT10aGlzLm51bUNvbXBzLHI9dGhpcy5kZWNvZGVBZGRlbmRzLG49dGhpcy5kZWNvZGVDb2VmZmljaWVudHMsaT0oMTw8dCktMTtsZXQgcyxvO2lmKDE9PT10KXtmb3Iocz0wLG89ZS5sZW5ndGg7czxvO3MrKyllW3NdPSshZVtzXTtyZXR1cm59bGV0IGM9MDtmb3Iocz0wLG89dGhpcy53aWR0aCp0aGlzLmhlaWdodDtzPG87cysrKWZvcihsZXQgdD0wO3Q8YTt0Kyspe2VbY109ZGVjb2RlQW5kQ2xhbXAoZVtjXSxyW3RdLG5bdF0saSk7YysrfX1nZXRDb21wb25lbnRzKGUpe2NvbnN0IHQ9dGhpcy5icGM7aWYoOD09PXQpcmV0dXJuIGU7Y29uc3QgYT10aGlzLndpZHRoLHI9dGhpcy5oZWlnaHQsbj10aGlzLm51bUNvbXBzLGk9YSpyKm47bGV0IHMsbz0wO3M9dDw9OD9uZXcgVWludDhBcnJheShpKTp0PD0xNj9uZXcgVWludDE2QXJyYXkoaSk6bmV3IFVpbnQzMkFycmF5KGkpO2NvbnN0IGM9YSpuLGw9KDE8PHQpLTE7bGV0IGgsdSxkPTA7aWYoMT09PXQpe2xldCB0LGEsbjtmb3IobGV0IGk9MDtpPHI7aSsrKXthPWQrKC04JmMpO249ZCtjO2Zvcig7ZDxhOyl7dT1lW28rK107c1tkXT11Pj43JjE7c1tkKzFdPXU+PjYmMTtzW2QrMl09dT4+NSYxO3NbZCszXT11Pj40JjE7c1tkKzRdPXU+PjMmMTtzW2QrNV09dT4+MiYxO3NbZCs2XT11Pj4xJjE7c1tkKzddPTEmdTtkKz04fWlmKGQ8bil7dT1lW28rK107dD0xMjg7Zm9yKDtkPG47KXtzW2QrK109KyEhKHUmdCk7dD4+PTF9fX19ZWxzZXtsZXQgYT0wO3U9MDtmb3IoZD0wLGg9aTtkPGg7KytkKXtpZihkJWM9PTApe3U9MDthPTB9Zm9yKDthPHQ7KXt1PXU8PDh8ZVtvKytdO2ErPTh9Y29uc3Qgcj1hLXQ7bGV0IG49dT4+cjtuPDA/bj0wOm4+bCYmKG49bCk7c1tkXT1uO3UmPSgxPDxyKS0xO2E9cn19cmV0dXJuIHN9ZmlsbE9wYWNpdHkoZSx0LGEsbixpKXtjb25zdCBzPXRoaXMuc21hc2ssbz10aGlzLm1hc2s7bGV0IGMsbCxoLHUsZCxmO2lmKHMpe2w9cy53aWR0aDtoPXMuaGVpZ2h0O2M9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGwqaCk7cy5maWxsR3JheUJ1ZmZlcihjKTtsPT09dCYmaD09PWF8fChjPXJlc2l6ZUltYWdlTWFzayhjLHMuYnBjLGwsaCx0LGEpKX1lbHNlIGlmKG8paWYobyBpbnN0YW5jZW9mIFBERkltYWdlKXtsPW8ud2lkdGg7aD1vLmhlaWdodDtjPW5ldyBVaW50OENsYW1wZWRBcnJheShsKmgpO28ubnVtQ29tcHM9MTtvLmZpbGxHcmF5QnVmZmVyKGMpO2Zvcih1PTAsZD1sKmg7dTxkOysrdSljW3VdPTI1NS1jW3VdO2w9PT10JiZoPT09YXx8KGM9cmVzaXplSW1hZ2VNYXNrKGMsby5icGMsbCxoLHQsYSkpfWVsc2V7aWYoIUFycmF5LmlzQXJyYXkobykpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoIlVua25vd24gbWFzayBmb3JtYXQuIik7e2M9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHQqYSk7Y29uc3QgZT10aGlzLm51bUNvbXBzO2Zvcih1PTAsZD10KmE7dTxkOysrdSl7bGV0IHQ9MDtjb25zdCBhPXUqZTtmb3IoZj0wO2Y8ZTsrK2Ype2NvbnN0IGU9aVthK2ZdLHI9MipmO2lmKGU8b1tyXXx8ZT5vW3IrMV0pe3Q9MjU1O2JyZWFrfX1jW3VdPXR9fX1pZihjKWZvcih1PTAsZj0zLGQ9dCpuO3U8ZDsrK3UsZis9NCllW2ZdPWNbdV07ZWxzZSBmb3IodT0wLGY9MyxkPXQqbjt1PGQ7Kyt1LGYrPTQpZVtmXT0yNTV9dW5kb1ByZWJsZW5kKGUsdCxhKXtjb25zdCByPXRoaXMuc21hc2smJnRoaXMuc21hc2subWF0dGU7aWYoIXIpcmV0dXJuO2NvbnN0IG49dGhpcy5jb2xvclNwYWNlLmdldFJnYihyLDApLGk9blswXSxzPW5bMV0sbz1uWzJdLGM9dCphKjQ7Zm9yKGxldCB0PTA7dDxjO3QrPTQpe2NvbnN0IGE9ZVt0KzNdO2lmKDA9PT1hKXtlW3RdPTI1NTtlW3QrMV09MjU1O2VbdCsyXT0yNTU7Y29udGludWV9Y29uc3Qgcj0yNTUvYTtlW3RdPShlW3RdLWkpKnIraTtlW3QrMV09KGVbdCsxXS1zKSpyK3M7ZVt0KzJdPShlW3QrMl0tbykqcitvfX1jcmVhdGVJbWFnZURhdGEoZT0hMSl7Y29uc3QgdD10aGlzLmRyYXdXaWR0aCxhPXRoaXMuZHJhd0hlaWdodCxuPXt3aWR0aDp0LGhlaWdodDphLGludGVycG9sYXRlOnRoaXMuaW50ZXJwb2xhdGUsa2luZDowLGRhdGE6bnVsbH0saT10aGlzLm51bUNvbXBzLHM9dGhpcy53aWR0aCxvPXRoaXMuaGVpZ2h0LGw9dGhpcy5icGMsaD1zKmkqbCs3Pj4zO2lmKCFlKXtsZXQgZTsiRGV2aWNlR3JheSI9PT10aGlzLmNvbG9yU3BhY2UubmFtZSYmMT09PWw/ZT1yLkltYWdlS2luZC5HUkFZU0NBTEVfMUJQUDoiRGV2aWNlUkdCIiE9PXRoaXMuY29sb3JTcGFjZS5uYW1lfHw4IT09bHx8dGhpcy5uZWVkc0RlY29kZXx8KGU9ci5JbWFnZUtpbmQuUkdCXzI0QlBQKTtpZihlJiYhdGhpcy5zbWFzayYmIXRoaXMubWFzayYmdD09PXMmJmE9PT1vKXtuLmtpbmQ9ZTtuLmRhdGE9dGhpcy5nZXRJbWFnZUJ5dGVzKG8qaCx7fSk7aWYodGhpcy5uZWVkc0RlY29kZSl7KDAsci5hc3NlcnQpKGU9PT1yLkltYWdlS2luZC5HUkFZU0NBTEVfMUJQUCwiUERGSW1hZ2UuY3JlYXRlSW1hZ2VEYXRhOiBUaGUgaW1hZ2UgbXVzdCBiZSBncmF5c2NhbGUuIik7Y29uc3QgdD1uLmRhdGE7Zm9yKGxldCBlPTAsYT10Lmxlbmd0aDtlPGE7ZSsrKXRbZV1ePTI1NX1yZXR1cm4gbn1pZih0aGlzLmltYWdlIGluc3RhbmNlb2YgYy5KcGVnU3RyZWFtJiYhdGhpcy5zbWFzayYmIXRoaXMubWFzayl7bGV0IGU9bypoO3N3aXRjaCh0aGlzLmNvbG9yU3BhY2UubmFtZSl7Y2FzZSJEZXZpY2VHcmF5IjplKj0zO2Nhc2UiRGV2aWNlUkdCIjpjYXNlIkRldmljZUNNWUsiOm4ua2luZD1yLkltYWdlS2luZC5SR0JfMjRCUFA7bi5kYXRhPXRoaXMuZ2V0SW1hZ2VCeXRlcyhlLHtkcmF3V2lkdGg6dCxkcmF3SGVpZ2h0OmEsZm9yY2VSR0I6ITB9KTtyZXR1cm4gbn19fWNvbnN0IHU9dGhpcy5nZXRJbWFnZUJ5dGVzKG8qaCx7aW50ZXJuYWw6ITB9KSxkPTB8dS5sZW5ndGgvaCphL28sZj10aGlzLmdldENvbXBvbmVudHModSk7bGV0IGcscDtpZihlfHx0aGlzLnNtYXNrfHx0aGlzLm1hc2spe24ua2luZD1yLkltYWdlS2luZC5SR0JBXzMyQlBQO24uZGF0YT1uZXcgVWludDhDbGFtcGVkQXJyYXkodCphKjQpO2c9MTtwPSEwO3RoaXMuZmlsbE9wYWNpdHkobi5kYXRhLHQsYSxkLGYpfWVsc2V7bi5raW5kPXIuSW1hZ2VLaW5kLlJHQl8yNEJQUDtuLmRhdGE9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHQqYSozKTtnPTA7cD0hMX10aGlzLm5lZWRzRGVjb2RlJiZ0aGlzLmRlY29kZUJ1ZmZlcihmKTt0aGlzLmNvbG9yU3BhY2UuZmlsbFJnYihuLmRhdGEscyxvLHQsYSxkLGwsZixnKTtwJiZ0aGlzLnVuZG9QcmVibGVuZChuLmRhdGEsdCxkKTtyZXR1cm4gbn1maWxsR3JheUJ1ZmZlcihlKXtjb25zdCB0PXRoaXMubnVtQ29tcHM7aWYoMSE9PXQpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoYFJlYWRpbmcgZ3JheSBzY2FsZSBmcm9tIGEgY29sb3IgaW1hZ2U6ICR7dH1gKTtjb25zdCBhPXRoaXMud2lkdGgsbj10aGlzLmhlaWdodCxpPXRoaXMuYnBjLHM9YSp0KmkrNz4+MyxvPXRoaXMuZ2V0SW1hZ2VCeXRlcyhuKnMse2ludGVybmFsOiEwfSksYz10aGlzLmdldENvbXBvbmVudHMobyk7bGV0IGwsaDtpZigxPT09aSl7aD1hKm47aWYodGhpcy5uZWVkc0RlY29kZSlmb3IobD0wO2w8aDsrK2wpZVtsXT1jW2xdLTEmMjU1O2Vsc2UgZm9yKGw9MDtsPGg7KytsKWVbbF09MjU1Ji1jW2xdO3JldHVybn10aGlzLm5lZWRzRGVjb2RlJiZ0aGlzLmRlY29kZUJ1ZmZlcihjKTtoPWEqbjtjb25zdCB1PTI1NS8oKDE8PGkpLTEpO2ZvcihsPTA7bDxoOysrbCllW2xdPXUqY1tsXX1nZXRJbWFnZUJ5dGVzKGUse2RyYXdXaWR0aDp0LGRyYXdIZWlnaHQ6YSxmb3JjZVJHQjpuPSExLGludGVybmFsOmk9ITF9KXt0aGlzLmltYWdlLnJlc2V0KCk7dGhpcy5pbWFnZS5kcmF3V2lkdGg9dHx8dGhpcy53aWR0aDt0aGlzLmltYWdlLmRyYXdIZWlnaHQ9YXx8dGhpcy5oZWlnaHQ7dGhpcy5pbWFnZS5mb3JjZVJHQj0hIW47Y29uc3Qgcz10aGlzLmltYWdlLmdldEJ5dGVzKGUpO2lmKGl8fHRoaXMuaW1hZ2UgaW5zdGFuY2VvZiBvLkRlY29kZVN0cmVhbSlyZXR1cm4gczsoMCxyLmFzc2VydCkocyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksJ1BERkltYWdlLmdldEltYWdlQnl0ZXM6IFVuc3VwcG9ydGVkICJpbWFnZUJ5dGVzIiB0eXBlLicpO3JldHVybiBuZXcgVWludDhBcnJheShzKX19dC5QREZJbWFnZT1QREZJbWFnZX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LmFwcGx5TWFza0ltYWdlRGF0YT1mdW5jdGlvbiBhcHBseU1hc2tJbWFnZURhdGEoe3NyYzplLHNyY1Bvczp0PTAsZGVzdDphLGRlc3RQb3M6bj0wLHdpZHRoOmksaGVpZ2h0OnMsaW52ZXJzZURlY29kZTpvPSExfSl7Y29uc3QgYz1yLkZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuPzQyNzgxOTAwODA6MjU1LFtsLGhdPW8/WzAsY106W2MsMF0sdT1pPj4zLGQ9NyZpLGY9ZS5sZW5ndGg7YT1uZXcgVWludDMyQXJyYXkoYS5idWZmZXIpO2ZvcihsZXQgcj0wO3I8cztyKyspe2Zvcihjb25zdCByPXQrdTt0PHI7dCsrKXtjb25zdCByPXQ8Zj9lW3RdOjI1NTthW24rK109MTI4JnI/aDpsO2FbbisrXT02NCZyP2g6bDthW24rK109MzImcj9oOmw7YVtuKytdPTE2JnI/aDpsO2FbbisrXT04JnI/aDpsO2FbbisrXT00JnI/aDpsO2FbbisrXT0yJnI/aDpsO2FbbisrXT0xJnI/aDpsfWlmKDA9PT1kKWNvbnRpbnVlO2NvbnN0IHI9dDxmP2VbdCsrXToyNTU7Zm9yKGxldCBlPTA7ZTxkO2UrKylhW24rK109ciYxPDw3LWU/aDpsfXJldHVybntzcmNQb3M6dCxkZXN0UG9zOm59fTt2YXIgcj1hKDIpfSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuaW5jcmVtZW50YWxVcGRhdGU9ZnVuY3Rpb24gaW5jcmVtZW50YWxVcGRhdGUoe29yaWdpbmFsRGF0YTplLHhyZWZJbmZvOnQsbmV3UmVmczphLHhyZWY6bz1udWxsLGhhc1hmYTpsPSExLHhmYURhdGFzZXRzUmVmOmg9bnVsbCxoYXNYZmFEYXRhc2V0c0VudHJ5OnU9ITEsYWNyb0Zvcm1SZWY6ZD1udWxsLGFjcm9Gb3JtOmY9bnVsbCx4ZmFEYXRhOmc9bnVsbH0pe2wmJmZ1bmN0aW9uIHVwZGF0ZVhGQSh7eGZhRGF0YTplLHhmYURhdGFzZXRzUmVmOnQsaGFzWGZhRGF0YXNldHNFbnRyeTphLGFjcm9Gb3JtUmVmOm4sYWNyb0Zvcm06byxuZXdSZWZzOmMseHJlZjpsLHhyZWZJbmZvOmh9KXtpZihudWxsPT09bClyZXR1cm47aWYoIWEpe2lmKCFuKXsoMCxyLndhcm4pKCJYRkEgLSBDYW5ub3Qgc2F2ZSBpdCIpO3JldHVybn1jb25zdCBlPW8uZ2V0KCJYRkEiKSxhPWUuc2xpY2UoKTthLnNwbGljZSgyLDAsImRhdGFzZXRzIik7YS5zcGxpY2UoMywwLHQpO28uc2V0KCJYRkEiLGEpO2NvbnN0IGk9bC5lbmNyeXB0O2xldCBzPW51bGw7aSYmKHM9aS5jcmVhdGVDaXBoZXJUcmFuc2Zvcm0obi5udW0sbi5nZW4pKTtjb25zdCBoPVtgJHtuLm51bX0gJHtuLmdlbn0gb2JqXG5gXTt3cml0ZURpY3QobyxoLHMpO2gucHVzaCgiXG4iKTtvLnNldCgiWEZBIixlKTtjLnB1c2goe3JlZjpuLGRhdGE6aC5qb2luKCIiKX0pfWlmKG51bGw9PT1lKXtlPWZ1bmN0aW9uIHdyaXRlWEZBRGF0YUZvckFjcm9mb3JtKGUsdCl7Y29uc3QgYT1uZXcgcy5TaW1wbGVYTUxQYXJzZXIoe2hhc0F0dHJpYnV0ZXM6ITB9KS5wYXJzZUZyb21TdHJpbmcoZSk7Zm9yKGNvbnN0e3hmYTplfW9mIHQpe2lmKCFlKWNvbnRpbnVlO2NvbnN0e3BhdGg6dCx2YWx1ZTpufT1lO2lmKCF0KWNvbnRpbnVlO2NvbnN0IG89YS5kb2N1bWVudEVsZW1lbnQuc2VhcmNoTm9kZSgoMCxpLnBhcnNlWEZBUGF0aCkodCksMCk7bz9BcnJheS5pc0FycmF5KG4pP28uY2hpbGROb2Rlcz1uLm1hcCgoZT0+bmV3IHMuU2ltcGxlRE9NTm9kZSgidmFsdWUiLGUpKSk6by5jaGlsZE5vZGVzPVtuZXcgcy5TaW1wbGVET01Ob2RlKCIjdGV4dCIsbildOigwLHIud2FybikoYE5vZGUgbm90IGZvdW5kIGZvciBwYXRoOiAke3R9YCl9Y29uc3Qgbj1bXTthLmRvY3VtZW50RWxlbWVudC5kdW1wKG4pO3JldHVybiBuLmpvaW4oIiIpfShsLmZldGNoSWZSZWYodCkuZ2V0U3RyaW5nKCksYyl9Y29uc3QgdT1sLmVuY3J5cHQ7aWYodSl7ZT11LmNyZWF0ZUNpcGhlclRyYW5zZm9ybSh0Lm51bSx0LmdlbikuZW5jcnlwdFN0cmluZyhlKX1jb25zdCBkPWAke3QubnVtfSAke3QuZ2VufSBvYmpcbjw8IC9UeXBlIC9FbWJlZGRlZEZpbGUgL0xlbmd0aCAke2UubGVuZ3RofT4+XG5zdHJlYW1cbmArZSsiXG5lbmRzdHJlYW1cbmVuZG9ialxuIjtjLnB1c2goe3JlZjp0LGRhdGE6ZH0pfSh7eGZhRGF0YTpnLHhmYURhdGFzZXRzUmVmOmgsaGFzWGZhRGF0YXNldHNFbnRyeTp1LGFjcm9Gb3JtUmVmOmQsYWNyb0Zvcm06ZixuZXdSZWZzOmEseHJlZjpvLHhyZWZJbmZvOnR9KTtjb25zdCBwPW5ldyBuLkRpY3QobnVsbCksbT10Lm5ld1JlZjtsZXQgYix5O2NvbnN0IHc9ZS5hdCgtMSk7aWYoMTA9PT13fHwxMz09PXcpe2I9W107eT1lLmxlbmd0aH1lbHNle2I9WyJcbiJdO3k9ZS5sZW5ndGgrMX1wLnNldCgiU2l6ZSIsbS5udW0rMSk7cC5zZXQoIlByZXYiLHQuc3RhcnRYUmVmKTtwLnNldCgiVHlwZSIsbi5OYW1lLmdldCgiWFJlZiIpKTtudWxsIT09dC5yb290UmVmJiZwLnNldCgiUm9vdCIsdC5yb290UmVmKTtudWxsIT09dC5pbmZvUmVmJiZwLnNldCgiSW5mbyIsdC5pbmZvUmVmKTtudWxsIT09dC5lbmNyeXB0UmVmJiZwLnNldCgiRW5jcnlwdCIsdC5lbmNyeXB0UmVmKTthLnB1c2goe3JlZjptLGRhdGE6IiJ9KTthPWEuc29ydCgoKGUsdCk9PmUucmVmLm51bS10LnJlZi5udW0pKTtjb25zdCBTPVtbMCwxLDY1NTM1XV0seD1bMCwxXTtsZXQgaz0wO2Zvcihjb25zdHtyZWY6ZSxkYXRhOnR9b2YgYSl7az1NYXRoLm1heChrLHkpO1MucHVzaChbMSx5LE1hdGgubWluKGUuZ2VuLDY1NTM1KV0pO3krPXQubGVuZ3RoO3gucHVzaChlLm51bSwxKTtiLnB1c2godCl9cC5zZXQoIkluZGV4Iix4KTtpZihBcnJheS5pc0FycmF5KHQuZmlsZUlkcykmJnQuZmlsZUlkcy5sZW5ndGg+MCl7Y29uc3QgZT1mdW5jdGlvbiBjb21wdXRlTUQ1KGUsdCl7Y29uc3QgYT1NYXRoLmZsb29yKERhdGUubm93KCkvMWUzKSxuPXQuZmlsZW5hbWV8fCIiLGk9W2EudG9TdHJpbmcoKSxuLGUudG9TdHJpbmcoKV07bGV0IHM9aS5yZWR1Y2UoKChlLHQpPT5lK3QubGVuZ3RoKSwwKTtmb3IoY29uc3QgZSBvZiBPYmplY3QudmFsdWVzKHQuaW5mbykpe2kucHVzaChlKTtzKz1lLmxlbmd0aH1jb25zdCBvPW5ldyBVaW50OEFycmF5KHMpO2xldCBsPTA7Zm9yKGNvbnN0IGUgb2YgaSl7d3JpdGVTdHJpbmcoZSxsLG8pO2wrPWUubGVuZ3RofXJldHVybigwLHIuYnl0ZXNUb1N0cmluZykoKDAsYy5jYWxjdWxhdGVNRDUpKG8pKX0oeSx0KTtwLnNldCgiSUQiLFt0LmZpbGVJZHNbMF0sZV0pfWNvbnN0IEM9WzEsTWF0aC5jZWlsKE1hdGgubG9nMihrKS84KSwyXSx2PShDWzBdK0NbMV0rQ1syXSkqUy5sZW5ndGg7cC5zZXQoIlciLEMpO3Auc2V0KCJMZW5ndGgiLHYpO2IucHVzaChgJHttLm51bX0gJHttLmdlbn0gb2JqXG5gKTt3cml0ZURpY3QocCxiLG51bGwpO2IucHVzaCgiIHN0cmVhbVxuIik7Y29uc3QgRj1iLnJlZHVjZSgoKGUsdCk9PmUrdC5sZW5ndGgpLDApLE89YFxuZW5kc3RyZWFtXG5lbmRvYmpcbnN0YXJ0eHJlZlxuJHt5fVxuJSVFT0ZcbmAsVD1uZXcgVWludDhBcnJheShlLmxlbmd0aCtGK3YrTy5sZW5ndGgpO1Quc2V0KGUpO2xldCBNPWUubGVuZ3RoO2Zvcihjb25zdCBlIG9mIGIpe3dyaXRlU3RyaW5nKGUsTSxUKTtNKz1lLmxlbmd0aH1mb3IoY29uc3RbZSx0LGFdb2YgUyl7TT13cml0ZUludChlLENbMF0sTSxUKTtNPXdyaXRlSW50KHQsQ1sxXSxNLFQpO009d3JpdGVJbnQoYSxDWzJdLE0sVCl9d3JpdGVTdHJpbmcoTyxNLFQpO3JldHVybiBUfTt0LndyaXRlRGljdD13cml0ZURpY3Q7dC53cml0ZU9iamVjdD1mdW5jdGlvbiB3cml0ZU9iamVjdChlLHQsYSxyKXthLnB1c2goYCR7ZS5udW19ICR7ZS5nZW59IG9ialxuYCk7dCBpbnN0YW5jZW9mIG4uRGljdD93cml0ZURpY3QodCxhLHIpOnQgaW5zdGFuY2VvZiBvLkJhc2VTdHJlYW0mJndyaXRlU3RyZWFtKHQsYSxyKTthLnB1c2goIlxuZW5kb2JqXG4iKX07dmFyIHI9YSgyKSxuPWEoNSksaT1hKDYpLHM9YSg2Niksbz1hKDcpLGM9YSg2Nyk7ZnVuY3Rpb24gd3JpdGVEaWN0KGUsdCxhKXt0LnB1c2goIjw8Iik7Zm9yKGNvbnN0IHIgb2YgZS5nZXRLZXlzKCkpe3QucHVzaChgIC8keygwLGkuZXNjYXBlUERGTmFtZSkocil9IGApO3dyaXRlVmFsdWUoZS5nZXRSYXcociksdCxhKX10LnB1c2goIj4+Iil9ZnVuY3Rpb24gd3JpdGVTdHJlYW0oZSx0LGEpe3dyaXRlRGljdChlLmRpY3QsdCxhKTt0LnB1c2goIiBzdHJlYW1cbiIpO2xldCByPWUuZ2V0U3RyaW5nKCk7bnVsbCE9PWEmJihyPWEuZW5jcnlwdFN0cmluZyhyKSk7dC5wdXNoKHIsIlxuZW5kc3RyZWFtXG4iKX1mdW5jdGlvbiB3cml0ZVZhbHVlKGUsdCxhKXtpZihlIGluc3RhbmNlb2Ygbi5OYW1lKXQucHVzaChgLyR7KDAsaS5lc2NhcGVQREZOYW1lKShlLm5hbWUpfWApO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIG4uUmVmKXQucHVzaChgJHtlLm51bX0gJHtlLmdlbn0gUmApO2Vsc2UgaWYoQXJyYXkuaXNBcnJheShlKSkhZnVuY3Rpb24gd3JpdGVBcnJheShlLHQsYSl7dC5wdXNoKCJbIik7bGV0IHI9ITA7Zm9yKGNvbnN0IG4gb2YgZSl7cj9yPSExOnQucHVzaCgiICIpO3dyaXRlVmFsdWUobix0LGEpfXQucHVzaCgiXSIpfShlLHQsYSk7ZWxzZSBpZigic3RyaW5nIj09dHlwZW9mIGUpe251bGwhPT1hJiYoZT1hLmVuY3J5cHRTdHJpbmcoZSkpO3QucHVzaChgKCR7KDAsci5lc2NhcGVTdHJpbmcpKGUpfSlgKX1lbHNlIm51bWJlciI9PXR5cGVvZiBlP3QucHVzaCgoMCxpLm51bWJlclRvU3RyaW5nKShlKSk6ImJvb2xlYW4iPT10eXBlb2YgZT90LnB1c2goZS50b1N0cmluZygpKTplIGluc3RhbmNlb2Ygbi5EaWN0P3dyaXRlRGljdChlLHQsYSk6ZSBpbnN0YW5jZW9mIG8uQmFzZVN0cmVhbT93cml0ZVN0cmVhbShlLHQsYSk6bnVsbD09PWU/dC5wdXNoKCJudWxsIik6KDAsci53YXJuKShgVW5oYW5kbGVkIHZhbHVlIGluIHdyaXRlcjogJHt0eXBlb2YgZX0sIHBsZWFzZSBmaWxlIGEgYnVnLmApfWZ1bmN0aW9uIHdyaXRlSW50KGUsdCxhLHIpe2ZvcihsZXQgbj10K2EtMTtuPmEtMTtuLS0pe3Jbbl09MjU1JmU7ZT4+PTh9cmV0dXJuIGErdH1mdW5jdGlvbiB3cml0ZVN0cmluZyhlLHQsYSl7Zm9yKGxldCByPTAsbj1lLmxlbmd0aDtyPG47cisrKWFbdCtyXT0yNTUmZS5jaGFyQ29kZUF0KHIpfX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LlhNTFBhcnNlckVycm9yQ29kZT10LlhNTFBhcnNlckJhc2U9dC5TaW1wbGVYTUxQYXJzZXI9dC5TaW1wbGVET01Ob2RlPXZvaWQgMDt2YXIgcj1hKDYpO2NvbnN0IG49e05vRXJyb3I6MCxFbmRPZkRvY3VtZW50Oi0xLFVudGVybWluYXRlZENkYXQ6LTIsVW50ZXJtaW5hdGVkWG1sRGVjbGFyYXRpb246LTMsVW50ZXJtaW5hdGVkRG9jdHlwZURlY2xhcmF0aW9uOi00LFVudGVybWluYXRlZENvbW1lbnQ6LTUsTWFsZm9ybWVkRWxlbWVudDotNixPdXRPZk1lbW9yeTotNyxVbnRlcm1pbmF0ZWRBdHRyaWJ1dGVWYWx1ZTotOCxVbnRlcm1pbmF0ZWRFbGVtZW50Oi05LEVsZW1lbnROZXZlckJlZ3VuOi0xMH07dC5YTUxQYXJzZXJFcnJvckNvZGU9bjtmdW5jdGlvbiBpc1doaXRlc3BhY2UoZSx0KXtjb25zdCBhPWVbdF07cmV0dXJuIiAiPT09YXx8IlxuIj09PWF8fCJcciI9PT1hfHwiXHQiPT09YX1jbGFzcyBYTUxQYXJzZXJCYXNle19yZXNvbHZlRW50aXRpZXMoZSl7cmV0dXJuIGUucmVwbGFjZSgvJihbXjtdKyk7L2csKChlLHQpPT57aWYoIiN4Ij09PXQuc3Vic3RyaW5nKDAsMikpcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KHBhcnNlSW50KHQuc3Vic3RyaW5nKDIpLDE2KSk7aWYoIiMiPT09dC5zdWJzdHJpbmcoMCwxKSlyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQocGFyc2VJbnQodC5zdWJzdHJpbmcoMSksMTApKTtzd2l0Y2godCl7Y2FzZSJsdCI6cmV0dXJuIjwiO2Nhc2UiZ3QiOnJldHVybiI+IjtjYXNlImFtcCI6cmV0dXJuIiYiO2Nhc2UicXVvdCI6cmV0dXJuJyInO2Nhc2UiYXBvcyI6cmV0dXJuIicifXJldHVybiB0aGlzLm9uUmVzb2x2ZUVudGl0eSh0KX0pKX1fcGFyc2VDb250ZW50KGUsdCl7Y29uc3QgYT1bXTtsZXQgcj10O2Z1bmN0aW9uIHNraXBXcygpe2Zvcig7cjxlLmxlbmd0aCYmaXNXaGl0ZXNwYWNlKGUscik7KSsrcn1mb3IoO3I8ZS5sZW5ndGgmJiFpc1doaXRlc3BhY2UoZSxyKSYmIj4iIT09ZVtyXSYmIi8iIT09ZVtyXTspKytyO2NvbnN0IG49ZS5zdWJzdHJpbmcodCxyKTtza2lwV3MoKTtmb3IoO3I8ZS5sZW5ndGgmJiI+IiE9PWVbcl0mJiIvIiE9PWVbcl0mJiI/IiE9PWVbcl07KXtza2lwV3MoKTtsZXQgdD0iIixuPSIiO2Zvcig7cjxlLmxlbmd0aCYmIWlzV2hpdGVzcGFjZShlLHIpJiYiPSIhPT1lW3JdOyl7dCs9ZVtyXTsrK3J9c2tpcFdzKCk7aWYoIj0iIT09ZVtyXSlyZXR1cm4gbnVsbDsrK3I7c2tpcFdzKCk7Y29uc3QgaT1lW3JdO2lmKCciJyE9PWkmJiInIiE9PWkpcmV0dXJuIG51bGw7Y29uc3Qgcz1lLmluZGV4T2YoaSwrK3IpO2lmKHM8MClyZXR1cm4gbnVsbDtuPWUuc3Vic3RyaW5nKHIscyk7YS5wdXNoKHtuYW1lOnQsdmFsdWU6dGhpcy5fcmVzb2x2ZUVudGl0aWVzKG4pfSk7cj1zKzE7c2tpcFdzKCl9cmV0dXJue25hbWU6bixhdHRyaWJ1dGVzOmEscGFyc2VkOnItdH19X3BhcnNlUHJvY2Vzc2luZ0luc3RydWN0aW9uKGUsdCl7bGV0IGE9dDtmb3IoO2E8ZS5sZW5ndGgmJiFpc1doaXRlc3BhY2UoZSxhKSYmIj4iIT09ZVthXSYmIj8iIT09ZVthXSYmIi8iIT09ZVthXTspKythO2NvbnN0IHI9ZS5zdWJzdHJpbmcodCxhKTshZnVuY3Rpb24gc2tpcFdzKCl7Zm9yKDthPGUubGVuZ3RoJiZpc1doaXRlc3BhY2UoZSxhKTspKythfSgpO2NvbnN0IG49YTtmb3IoO2E8ZS5sZW5ndGgmJigiPyIhPT1lW2FdfHwiPiIhPT1lW2ErMV0pOykrK2E7cmV0dXJue25hbWU6cix2YWx1ZTplLnN1YnN0cmluZyhuLGEpLHBhcnNlZDphLXR9fXBhcnNlWG1sKGUpe2xldCB0PTA7Zm9yKDt0PGUubGVuZ3RoOyl7bGV0IGE9dDtpZigiPCI9PT1lW3RdKXsrK2E7bGV0IHQ7c3dpdGNoKGVbYV0pe2Nhc2UiLyI6KythO3Q9ZS5pbmRleE9mKCI+IixhKTtpZih0PDApe3RoaXMub25FcnJvcihuLlVudGVybWluYXRlZEVsZW1lbnQpO3JldHVybn10aGlzLm9uRW5kRWxlbWVudChlLnN1YnN0cmluZyhhLHQpKTthPXQrMTticmVhaztjYXNlIj8iOisrYTtjb25zdCByPXRoaXMuX3BhcnNlUHJvY2Vzc2luZ0luc3RydWN0aW9uKGUsYSk7aWYoIj8+IiE9PWUuc3Vic3RyaW5nKGErci5wYXJzZWQsYStyLnBhcnNlZCsyKSl7dGhpcy5vbkVycm9yKG4uVW50ZXJtaW5hdGVkWG1sRGVjbGFyYXRpb24pO3JldHVybn10aGlzLm9uUGkoci5uYW1lLHIudmFsdWUpO2ErPXIucGFyc2VkKzI7YnJlYWs7Y2FzZSIhIjppZigiLS0iPT09ZS5zdWJzdHJpbmcoYSsxLGErMykpe3Q9ZS5pbmRleE9mKCItLVx4M2UiLGErMyk7aWYodDwwKXt0aGlzLm9uRXJyb3Iobi5VbnRlcm1pbmF0ZWRDb21tZW50KTtyZXR1cm59dGhpcy5vbkNvbW1lbnQoZS5zdWJzdHJpbmcoYSszLHQpKTthPXQrM31lbHNlIGlmKCJbQ0RBVEFbIj09PWUuc3Vic3RyaW5nKGErMSxhKzgpKXt0PWUuaW5kZXhPZigiXV0+IixhKzgpO2lmKHQ8MCl7dGhpcy5vbkVycm9yKG4uVW50ZXJtaW5hdGVkQ2RhdCk7cmV0dXJufXRoaXMub25DZGF0YShlLnN1YnN0cmluZyhhKzgsdCkpO2E9dCszfWVsc2V7aWYoIkRPQ1RZUEUiIT09ZS5zdWJzdHJpbmcoYSsxLGErOCkpe3RoaXMub25FcnJvcihuLk1hbGZvcm1lZEVsZW1lbnQpO3JldHVybn17Y29uc3Qgcj1lLmluZGV4T2YoIlsiLGErOCk7bGV0IGk9ITE7dD1lLmluZGV4T2YoIj4iLGErOCk7aWYodDwwKXt0aGlzLm9uRXJyb3Iobi5VbnRlcm1pbmF0ZWREb2N0eXBlRGVjbGFyYXRpb24pO3JldHVybn1pZihyPjAmJnQ+cil7dD1lLmluZGV4T2YoIl0+IixhKzgpO2lmKHQ8MCl7dGhpcy5vbkVycm9yKG4uVW50ZXJtaW5hdGVkRG9jdHlwZURlY2xhcmF0aW9uKTtyZXR1cm59aT0hMH1jb25zdCBzPWUuc3Vic3RyaW5nKGErOCx0KyhpPzE6MCkpO3RoaXMub25Eb2N0eXBlKHMpO2E9dCsoaT8yOjEpfX1icmVhaztkZWZhdWx0OmNvbnN0IGk9dGhpcy5fcGFyc2VDb250ZW50KGUsYSk7aWYobnVsbD09PWkpe3RoaXMub25FcnJvcihuLk1hbGZvcm1lZEVsZW1lbnQpO3JldHVybn1sZXQgcz0hMTtpZigiLz4iPT09ZS5zdWJzdHJpbmcoYStpLnBhcnNlZCxhK2kucGFyc2VkKzIpKXM9ITA7ZWxzZSBpZigiPiIhPT1lLnN1YnN0cmluZyhhK2kucGFyc2VkLGEraS5wYXJzZWQrMSkpe3RoaXMub25FcnJvcihuLlVudGVybWluYXRlZEVsZW1lbnQpO3JldHVybn10aGlzLm9uQmVnaW5FbGVtZW50KGkubmFtZSxpLmF0dHJpYnV0ZXMscyk7YSs9aS5wYXJzZWQrKHM/MjoxKX19ZWxzZXtmb3IoO2E8ZS5sZW5ndGgmJiI8IiE9PWVbYV07KWErKztjb25zdCByPWUuc3Vic3RyaW5nKHQsYSk7dGhpcy5vblRleHQodGhpcy5fcmVzb2x2ZUVudGl0aWVzKHIpKX10PWF9fW9uUmVzb2x2ZUVudGl0eShlKXtyZXR1cm5gJiR7ZX07YH1vblBpKGUsdCl7fW9uQ29tbWVudChlKXt9b25DZGF0YShlKXt9b25Eb2N0eXBlKGUpe31vblRleHQoZSl7fW9uQmVnaW5FbGVtZW50KGUsdCxhKXt9b25FbmRFbGVtZW50KGUpe31vbkVycm9yKGUpe319dC5YTUxQYXJzZXJCYXNlPVhNTFBhcnNlckJhc2U7Y2xhc3MgU2ltcGxlRE9NTm9kZXtjb25zdHJ1Y3RvcihlLHQpe3RoaXMubm9kZU5hbWU9ZTt0aGlzLm5vZGVWYWx1ZT10O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJwYXJlbnROb2RlIix7dmFsdWU6bnVsbCx3cml0YWJsZTohMH0pfWdldCBmaXJzdENoaWxkKCl7cmV0dXJuIHRoaXMuY2hpbGROb2RlcyYmdGhpcy5jaGlsZE5vZGVzWzBdfWdldCBuZXh0U2libGluZygpe2NvbnN0IGU9dGhpcy5wYXJlbnROb2RlLmNoaWxkTm9kZXM7aWYoIWUpcmV0dXJuO2NvbnN0IHQ9ZS5pbmRleE9mKHRoaXMpO3JldHVybi0xIT09dD9lW3QrMV06dm9pZCAwfWdldCB0ZXh0Q29udGVudCgpe3JldHVybiB0aGlzLmNoaWxkTm9kZXM/dGhpcy5jaGlsZE5vZGVzLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUudGV4dENvbnRlbnR9KSkuam9pbigiIik6dGhpcy5ub2RlVmFsdWV8fCIifWdldCBjaGlsZHJlbigpe3JldHVybiB0aGlzLmNoaWxkTm9kZXN8fFtdfWhhc0NoaWxkTm9kZXMoKXtyZXR1cm4gdGhpcy5jaGlsZE5vZGVzJiZ0aGlzLmNoaWxkTm9kZXMubGVuZ3RoPjB9c2VhcmNoTm9kZShlLHQpe2lmKHQ+PWUubGVuZ3RoKXJldHVybiB0aGlzO2NvbnN0IGE9ZVt0XSxyPVtdO2xldCBuPXRoaXM7Zm9yKDs7KXtpZihhLm5hbWU9PT1uLm5vZGVOYW1lKXtpZigwIT09YS5wb3Mpe2lmKDA9PT1yLmxlbmd0aClyZXR1cm4gbnVsbDt7Y29uc3RbaV09ci5wb3AoKTtsZXQgcz0wO2Zvcihjb25zdCByIG9mIGkuY2hpbGROb2RlcylpZihhLm5hbWU9PT1yLm5vZGVOYW1lKXtpZihzPT09YS5wb3MpcmV0dXJuIHIuc2VhcmNoTm9kZShlLHQrMSk7cysrfXJldHVybiBuLnNlYXJjaE5vZGUoZSx0KzEpfX17Y29uc3QgYT1uLnNlYXJjaE5vZGUoZSx0KzEpO2lmKG51bGwhPT1hKXJldHVybiBhfX1pZihuLmNoaWxkTm9kZXMmJjAhPT1uLmNoaWxkTm9kZXMubGVuZ3RoKXtyLnB1c2goW24sMF0pO249bi5jaGlsZE5vZGVzWzBdfWVsc2V7aWYoMD09PXIubGVuZ3RoKXJldHVybiBudWxsO2Zvcig7MCE9PXIubGVuZ3RoOyl7Y29uc3RbZSx0XT1yLnBvcCgpLGE9dCsxO2lmKGE8ZS5jaGlsZE5vZGVzLmxlbmd0aCl7ci5wdXNoKFtlLGFdKTtuPWUuY2hpbGROb2Rlc1thXTticmVha319aWYoMD09PXIubGVuZ3RoKXJldHVybiBudWxsfX19ZHVtcChlKXtpZigiI3RleHQiIT09dGhpcy5ub2RlTmFtZSl7ZS5wdXNoKGA8JHt0aGlzLm5vZGVOYW1lfWApO2lmKHRoaXMuYXR0cmlidXRlcylmb3IoY29uc3QgdCBvZiB0aGlzLmF0dHJpYnV0ZXMpZS5wdXNoKGAgJHt0Lm5hbWV9PSIkeygwLHIuZW5jb2RlVG9YbWxTdHJpbmcpKHQudmFsdWUpfSJgKTtpZih0aGlzLmhhc0NoaWxkTm9kZXMoKSl7ZS5wdXNoKCI+Iik7Zm9yKGNvbnN0IHQgb2YgdGhpcy5jaGlsZE5vZGVzKXQuZHVtcChlKTtlLnB1c2goYDwvJHt0aGlzLm5vZGVOYW1lfT5gKX1lbHNlIHRoaXMubm9kZVZhbHVlP2UucHVzaChgPiR7KDAsci5lbmNvZGVUb1htbFN0cmluZykodGhpcy5ub2RlVmFsdWUpfTwvJHt0aGlzLm5vZGVOYW1lfT5gKTplLnB1c2goIi8+Iil9ZWxzZSBlLnB1c2goKDAsci5lbmNvZGVUb1htbFN0cmluZykodGhpcy5ub2RlVmFsdWUpKX19dC5TaW1wbGVET01Ob2RlPVNpbXBsZURPTU5vZGU7dC5TaW1wbGVYTUxQYXJzZXI9Y2xhc3MgU2ltcGxlWE1MUGFyc2VyIGV4dGVuZHMgWE1MUGFyc2VyQmFzZXtjb25zdHJ1Y3Rvcih7aGFzQXR0cmlidXRlczplPSExLGxvd2VyQ2FzZU5hbWU6dD0hMX0pe3N1cGVyKCk7dGhpcy5fY3VycmVudEZyYWdtZW50PW51bGw7dGhpcy5fc3RhY2s9bnVsbDt0aGlzLl9lcnJvckNvZGU9bi5Ob0Vycm9yO3RoaXMuX2hhc0F0dHJpYnV0ZXM9ZTt0aGlzLl9sb3dlckNhc2VOYW1lPXR9cGFyc2VGcm9tU3RyaW5nKGUpe3RoaXMuX2N1cnJlbnRGcmFnbWVudD1bXTt0aGlzLl9zdGFjaz1bXTt0aGlzLl9lcnJvckNvZGU9bi5Ob0Vycm9yO3RoaXMucGFyc2VYbWwoZSk7aWYodGhpcy5fZXJyb3JDb2RlIT09bi5Ob0Vycm9yKXJldHVybjtjb25zdFt0XT10aGlzLl9jdXJyZW50RnJhZ21lbnQ7cmV0dXJuIHQ/e2RvY3VtZW50RWxlbWVudDp0fTp2b2lkIDB9b25UZXh0KGUpe2lmKGZ1bmN0aW9uIGlzV2hpdGVzcGFjZVN0cmluZyhlKXtmb3IobGV0IHQ9MCxhPWUubGVuZ3RoO3Q8YTt0KyspaWYoIWlzV2hpdGVzcGFjZShlLHQpKXJldHVybiExO3JldHVybiEwfShlKSlyZXR1cm47Y29uc3QgdD1uZXcgU2ltcGxlRE9NTm9kZSgiI3RleHQiLGUpO3RoaXMuX2N1cnJlbnRGcmFnbWVudC5wdXNoKHQpfW9uQ2RhdGEoZSl7Y29uc3QgdD1uZXcgU2ltcGxlRE9NTm9kZSgiI3RleHQiLGUpO3RoaXMuX2N1cnJlbnRGcmFnbWVudC5wdXNoKHQpfW9uQmVnaW5FbGVtZW50KGUsdCxhKXt0aGlzLl9sb3dlckNhc2VOYW1lJiYoZT1lLnRvTG93ZXJDYXNlKCkpO2NvbnN0IHI9bmV3IFNpbXBsZURPTU5vZGUoZSk7ci5jaGlsZE5vZGVzPVtdO3RoaXMuX2hhc0F0dHJpYnV0ZXMmJihyLmF0dHJpYnV0ZXM9dCk7dGhpcy5fY3VycmVudEZyYWdtZW50LnB1c2gocik7aWYoIWEpe3RoaXMuX3N0YWNrLnB1c2godGhpcy5fY3VycmVudEZyYWdtZW50KTt0aGlzLl9jdXJyZW50RnJhZ21lbnQ9ci5jaGlsZE5vZGVzfX1vbkVuZEVsZW1lbnQoZSl7dGhpcy5fY3VycmVudEZyYWdtZW50PXRoaXMuX3N0YWNrLnBvcCgpfHxbXTtjb25zdCB0PXRoaXMuX2N1cnJlbnRGcmFnbWVudC5hdCgtMSk7aWYoIXQpcmV0dXJuIG51bGw7Zm9yKGxldCBlPTAsYT10LmNoaWxkTm9kZXMubGVuZ3RoO2U8YTtlKyspdC5jaGlsZE5vZGVzW2VdLnBhcmVudE5vZGU9dDtyZXR1cm4gdH1vbkVycm9yKGUpe3RoaXMuX2Vycm9yQ29kZT1lfX19LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5jYWxjdWxhdGVTSEEyNTY9dC5jYWxjdWxhdGVNRDU9dC5QREYyMD10LlBERjE3PXQuQ2lwaGVyVHJhbnNmb3JtRmFjdG9yeT10LkFSQ0ZvdXJDaXBoZXI9dC5BRVMyNTZDaXBoZXI9dC5BRVMxMjhDaXBoZXI9dm9pZCAwO3QuY2FsY3VsYXRlU0hBMzg0PWNhbGN1bGF0ZVNIQTM4NDt0LmNhbGN1bGF0ZVNIQTUxMj12b2lkIDA7dmFyIHI9YSgyKSxuPWEoNSksaT1hKDY4KTtjbGFzcyBBUkNGb3VyQ2lwaGVye2NvbnN0cnVjdG9yKGUpe3RoaXMuYT0wO3RoaXMuYj0wO2NvbnN0IHQ9bmV3IFVpbnQ4QXJyYXkoMjU2KSxhPWUubGVuZ3RoO2ZvcihsZXQgZT0wO2U8MjU2OysrZSl0W2VdPWU7Zm9yKGxldCByPTAsbj0wO3I8MjU2Oysrcil7Y29uc3QgaT10W3JdO249bitpK2VbciVhXSYyNTU7dFtyXT10W25dO3Rbbl09aX10aGlzLnM9dH1lbmNyeXB0QmxvY2soZSl7bGV0IHQ9dGhpcy5hLGE9dGhpcy5iO2NvbnN0IHI9dGhpcy5zLG49ZS5sZW5ndGgsaT1uZXcgVWludDhBcnJheShuKTtmb3IobGV0IHM9MDtzPG47KytzKXt0PXQrMSYyNTU7Y29uc3Qgbj1yW3RdO2E9YStuJjI1NTtjb25zdCBvPXJbYV07clt0XT1vO3JbYV09bjtpW3NdPWVbc11ecltuK28mMjU1XX10aGlzLmE9dDt0aGlzLmI9YTtyZXR1cm4gaX1kZWNyeXB0QmxvY2soZSl7cmV0dXJuIHRoaXMuZW5jcnlwdEJsb2NrKGUpfWVuY3J5cHQoZSl7cmV0dXJuIHRoaXMuZW5jcnlwdEJsb2NrKGUpfX10LkFSQ0ZvdXJDaXBoZXI9QVJDRm91ckNpcGhlcjtjb25zdCBzPWZ1bmN0aW9uIGNhbGN1bGF0ZU1ENUNsb3N1cmUoKXtjb25zdCBlPW5ldyBVaW50OEFycmF5KFs3LDEyLDE3LDIyLDcsMTIsMTcsMjIsNywxMiwxNywyMiw3LDEyLDE3LDIyLDUsOSwxNCwyMCw1LDksMTQsMjAsNSw5LDE0LDIwLDUsOSwxNCwyMCw0LDExLDE2LDIzLDQsMTEsMTYsMjMsNCwxMSwxNiwyMyw0LDExLDE2LDIzLDYsMTAsMTUsMjEsNiwxMCwxNSwyMSw2LDEwLDE1LDIxLDYsMTAsMTUsMjFdKSx0PW5ldyBJbnQzMkFycmF5KFstNjgwODc2OTM2LC0zODk1NjQ1ODYsNjA2MTA1ODE5LC0xMDQ0NTI1MzMwLC0xNzY0MTg4OTcsMTIwMDA4MDQyNiwtMTQ3MzIzMTM0MSwtNDU3MDU5ODMsMTc3MDAzNTQxNiwtMTk1ODQxNDQxNywtNDIwNjMsLTE5OTA0MDQxNjIsMTgwNDYwMzY4MiwtNDAzNDExMDEsLTE1MDIwMDIyOTAsMTIzNjUzNTMyOSwtMTY1Nzk2NTEwLC0xMDY5NTAxNjMyLDY0MzcxNzcxMywtMzczODk3MzAyLC03MDE1NTg2OTEsMzgwMTYwODMsLTY2MDQ3ODMzNSwtNDA1NTM3ODQ4LDU2ODQ0NjQzOCwtMTAxOTgwMzY5MCwtMTg3MzYzOTYxLDExNjM1MzE1MDEsLTE0NDQ2ODE0NjcsLTUxNDAzNzg0LDE3MzUzMjg0NzMsLTE5MjY2MDc3MzQsLTM3ODU1OCwtMjAyMjU3NDQ2MywxODM5MDMwNTYyLC0zNTMwOTU1NiwtMTUzMDk5MjA2MCwxMjcyODkzMzUzLC0xNTU0OTc2MzIsLTEwOTQ3MzA2NDAsNjgxMjc5MTc0LC0zNTg1MzcyMjIsLTcyMjUyMTk3OSw3NjAyOTE4OSwtNjQwMzY0NDg3LC00MjE4MTU4MzUsNTMwNzQyNTIwLC05OTUzMzg2NTEsLTE5ODYzMDg0NCwxMTI2ODkxNDE1LC0xNDE2MzU0OTA1LC01NzQzNDA1NSwxNzAwNDg1NTcxLC0xODk0OTg2NjA2LC0xMDUxNTIzLC0yMDU0OTIyNzk5LDE4NzMzMTMzNTksLTMwNjExNzQ0LC0xNTYwMTk4MzgwLDEzMDkxNTE2NDksLTE0NTUyMzA3MCwtMTEyMDIxMDM3OSw3MTg3ODcyNTksLTM0MzQ4NTU1MV0pO3JldHVybiBmdW5jdGlvbiBoYXNoKGEscixuKXtsZXQgaT0xNzMyNTg0MTkzLHM9LTI3MTczMzg3OSxvPS0xNzMyNTg0MTk0LGM9MjcxNzMzODc4O2NvbnN0IGw9bis3MiYtNjQsaD1uZXcgVWludDhBcnJheShsKTtsZXQgdSxkO2Zvcih1PTA7dTxuOysrdSloW3VdPWFbcisrXTtoW3UrK109MTI4O2NvbnN0IGY9bC04O2Zvcig7dTxmOyloW3UrK109MDtoW3UrK109bjw8MyYyNTU7aFt1KytdPW4+PjUmMjU1O2hbdSsrXT1uPj4xMyYyNTU7aFt1KytdPW4+PjIxJjI1NTtoW3UrK109bj4+PjI5JjI1NTtoW3UrK109MDtoW3UrK109MDtoW3UrK109MDtjb25zdCBnPW5ldyBJbnQzMkFycmF5KDE2KTtmb3IodT0wO3U8bDspe2ZvcihkPTA7ZDwxNjsrK2QsdSs9NClnW2RdPWhbdV18aFt1KzFdPDw4fGhbdSsyXTw8MTZ8aFt1KzNdPDwyNDtsZXQgYSxyLG49aSxsPXMsZj1vLHA9Yztmb3IoZD0wO2Q8NjQ7KytkKXtpZihkPDE2KXthPWwmZnx+bCZwO3I9ZH1lbHNlIGlmKGQ8MzIpe2E9cCZsfH5wJmY7cj01KmQrMSYxNX1lbHNlIGlmKGQ8NDgpe2E9bF5mXnA7cj0zKmQrNSYxNX1lbHNle2E9Zl4obHx+cCk7cj03KmQmMTV9Y29uc3QgaT1wLHM9bithK3RbZF0rZ1tyXXwwLG89ZVtkXTtwPWY7Zj1sO2w9bCsoczw8b3xzPj4+MzItbyl8MDtuPWl9aT1pK258MDtzPXMrbHwwO289bytmfDA7Yz1jK3B8MH1yZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzI1NSZpLGk+PjgmMjU1LGk+PjE2JjI1NSxpPj4+MjQmMjU1LDI1NSZzLHM+PjgmMjU1LHM+PjE2JjI1NSxzPj4+MjQmMjU1LDI1NSZvLG8+PjgmMjU1LG8+PjE2JjI1NSxvPj4+MjQmMjU1LDI1NSZjLGM+PjgmMjU1LGM+PjE2JjI1NSxjPj4+MjQmMjU1XSl9fSgpO3QuY2FsY3VsYXRlTUQ1PXM7Y2xhc3MgV29yZDY0e2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5oaWdoPTB8ZTt0aGlzLmxvdz0wfHR9YW5kKGUpe3RoaXMuaGlnaCY9ZS5oaWdoO3RoaXMubG93Jj1lLmxvd314b3IoZSl7dGhpcy5oaWdoXj1lLmhpZ2g7dGhpcy5sb3dePWUubG93fW9yKGUpe3RoaXMuaGlnaHw9ZS5oaWdoO3RoaXMubG93fD1lLmxvd31zaGlmdFJpZ2h0KGUpe2lmKGU+PTMyKXt0aGlzLmxvdz10aGlzLmhpZ2g+Pj5lLTMyfDA7dGhpcy5oaWdoPTB9ZWxzZXt0aGlzLmxvdz10aGlzLmxvdz4+PmV8dGhpcy5oaWdoPDwzMi1lO3RoaXMuaGlnaD10aGlzLmhpZ2g+Pj5lfDB9fXNoaWZ0TGVmdChlKXtpZihlPj0zMil7dGhpcy5oaWdoPXRoaXMubG93PDxlLTMyO3RoaXMubG93PTB9ZWxzZXt0aGlzLmhpZ2g9dGhpcy5oaWdoPDxlfHRoaXMubG93Pj4+MzItZTt0aGlzLmxvdzw8PWV9fXJvdGF0ZVJpZ2h0KGUpe2xldCB0LGE7aWYoMzImZSl7YT10aGlzLmxvdzt0PXRoaXMuaGlnaH1lbHNle3Q9dGhpcy5sb3c7YT10aGlzLmhpZ2h9ZSY9MzE7dGhpcy5sb3c9dD4+PmV8YTw8MzItZTt0aGlzLmhpZ2g9YT4+PmV8dDw8MzItZX1ub3QoKXt0aGlzLmhpZ2g9fnRoaXMuaGlnaDt0aGlzLmxvdz1+dGhpcy5sb3d9YWRkKGUpe2NvbnN0IHQ9KHRoaXMubG93Pj4+MCkrKGUubG93Pj4+MCk7bGV0IGE9KHRoaXMuaGlnaD4+PjApKyhlLmhpZ2g+Pj4wKTt0PjQyOTQ5NjcyOTUmJihhKz0xKTt0aGlzLmxvdz0wfHQ7dGhpcy5oaWdoPTB8YX1jb3B5VG8oZSx0KXtlW3RdPXRoaXMuaGlnaD4+PjI0JjI1NTtlW3QrMV09dGhpcy5oaWdoPj4xNiYyNTU7ZVt0KzJdPXRoaXMuaGlnaD4+OCYyNTU7ZVt0KzNdPTI1NSZ0aGlzLmhpZ2g7ZVt0KzRdPXRoaXMubG93Pj4+MjQmMjU1O2VbdCs1XT10aGlzLmxvdz4+MTYmMjU1O2VbdCs2XT10aGlzLmxvdz4+OCYyNTU7ZVt0KzddPTI1NSZ0aGlzLmxvd31hc3NpZ24oZSl7dGhpcy5oaWdoPWUuaGlnaDt0aGlzLmxvdz1lLmxvd319Y29uc3Qgbz1mdW5jdGlvbiBjYWxjdWxhdGVTSEEyNTZDbG9zdXJlKCl7ZnVuY3Rpb24gcm90cihlLHQpe3JldHVybiBlPj4+dHxlPDwzMi10fWZ1bmN0aW9uIGNoKGUsdCxhKXtyZXR1cm4gZSZ0Xn5lJmF9ZnVuY3Rpb24gbWFqKGUsdCxhKXtyZXR1cm4gZSZ0XmUmYV50JmF9ZnVuY3Rpb24gc2lnbWEoZSl7cmV0dXJuIHJvdHIoZSwyKV5yb3RyKGUsMTMpXnJvdHIoZSwyMil9ZnVuY3Rpb24gc2lnbWFQcmltZShlKXtyZXR1cm4gcm90cihlLDYpXnJvdHIoZSwxMSlecm90cihlLDI1KX1mdW5jdGlvbiBsaXR0bGVTaWdtYShlKXtyZXR1cm4gcm90cihlLDcpXnJvdHIoZSwxOCleZT4+PjN9Y29uc3QgZT1bMTExNjM1MjQwOCwxODk5NDQ3NDQxLDMwNDkzMjM0NzEsMzkyMTAwOTU3Myw5NjE5ODcxNjMsMTUwODk3MDk5MywyNDUzNjM1NzQ4LDI4NzA3NjMyMjEsMzYyNDM4MTA4MCwzMTA1OTg0MDEsNjA3MjI1Mjc4LDE0MjY4ODE5ODcsMTkyNTA3ODM4OCwyMTYyMDc4MjA2LDI2MTQ4ODgxMDMsMzI0ODIyMjU4MCwzODM1MzkwNDAxLDQwMjIyMjQ3NzQsMjY0MzQ3MDc4LDYwNDgwNzYyOCw3NzAyNTU5ODMsMTI0OTE1MDEyMiwxNTU1MDgxNjkyLDE5OTYwNjQ5ODYsMjU1NDIyMDg4MiwyODIxODM0MzQ5LDI5NTI5OTY4MDgsMzIxMDMxMzY3MSwzMzM2NTcxODkxLDM1ODQ1Mjg3MTEsMTEzOTI2OTkzLDMzODI0MTg5NSw2NjYzMDcyMDUsNzczNTI5OTEyLDEyOTQ3NTczNzIsMTM5NjE4MjI5MSwxNjk1MTgzNzAwLDE5ODY2NjEwNTEsMjE3NzAyNjM1MCwyNDU2OTU2MDM3LDI3MzA0ODU5MjEsMjgyMDMwMjQxMSwzMjU5NzMwODAwLDMzNDU3NjQ3NzEsMzUxNjA2NTgxNywzNjAwMzUyODA0LDQwOTQ1NzE5MDksMjc1NDIzMzQ0LDQzMDIyNzczNCw1MDY5NDg2MTYsNjU5MDYwNTU2LDg4Mzk5Nzg3Nyw5NTgxMzk1NzEsMTMyMjgyMjIxOCwxNTM3MDAyMDYzLDE3NDc4NzM3NzksMTk1NTU2MjIyMiwyMDI0MTA0ODE1LDIyMjc3MzA0NTIsMjM2MTg1MjQyNCwyNDI4NDM2NDc0LDI3NTY3MzQxODcsMzIwNDAzMTQ3OSwzMzI5MzI1Mjk4XTtyZXR1cm4gZnVuY3Rpb24gaGFzaCh0LGEscil7bGV0IG49MTc3OTAzMzcwMyxpPTMxNDQxMzQyNzcscz0xMDEzOTA0MjQyLG89Mjc3MzQ4MDc2MixjPTEzNTk4OTMxMTksbD0yNjAwODIyOTI0LGg9NTI4NzM0NjM1LHU9MTU0MTQ1OTIyNTtjb25zdCBkPTY0Kk1hdGguY2VpbCgocis5KS82NCksZj1uZXcgVWludDhBcnJheShkKTtsZXQgZyxwO2ZvcihnPTA7ZzxyOysrZylmW2ddPXRbYSsrXTtmW2crK109MTI4O2NvbnN0IG09ZC04O2Zvcig7ZzxtOylmW2crK109MDtmW2crK109MDtmW2crK109MDtmW2crK109MDtmW2crK109cj4+PjI5JjI1NTtmW2crK109cj4+MjEmMjU1O2ZbZysrXT1yPj4xMyYyNTU7ZltnKytdPXI+PjUmMjU1O2ZbZysrXT1yPDwzJjI1NTtjb25zdCBiPW5ldyBVaW50MzJBcnJheSg2NCk7Zm9yKGc9MDtnPGQ7KXtmb3IocD0wO3A8MTY7KytwKXtiW3BdPWZbZ108PDI0fGZbZysxXTw8MTZ8ZltnKzJdPDw4fGZbZyszXTtnKz00fWZvcihwPTE2O3A8NjQ7KytwKWJbcF09KHJvdHIoeT1iW3AtMl0sMTcpXnJvdHIoeSwxOSleeT4+PjEwKStiW3AtN10rbGl0dGxlU2lnbWEoYltwLTE1XSkrYltwLTE2XXwwO2xldCB0LGEscj1uLGQ9aSxtPXMsdz1vLFM9Yyx4PWwsaz1oLEM9dTtmb3IocD0wO3A8NjQ7KytwKXt0PUMrc2lnbWFQcmltZShTKStjaChTLHgsaykrZVtwXStiW3BdO2E9c2lnbWEocikrbWFqKHIsZCxtKTtDPWs7az14O3g9UztTPXcrdHwwO3c9bTttPWQ7ZD1yO3I9dCthfDB9bj1uK3J8MDtpPWkrZHwwO3M9cyttfDA7bz1vK3d8MDtjPWMrU3wwO2w9bCt4fDA7aD1oK2t8MDt1PXUrQ3wwfXZhciB5O3JldHVybiBuZXcgVWludDhBcnJheShbbj4+MjQmMjU1LG4+PjE2JjI1NSxuPj44JjI1NSwyNTUmbixpPj4yNCYyNTUsaT4+MTYmMjU1LGk+PjgmMjU1LDI1NSZpLHM+PjI0JjI1NSxzPj4xNiYyNTUscz4+OCYyNTUsMjU1JnMsbz4+MjQmMjU1LG8+PjE2JjI1NSxvPj44JjI1NSwyNTUmbyxjPj4yNCYyNTUsYz4+MTYmMjU1LGM+PjgmMjU1LDI1NSZjLGw+PjI0JjI1NSxsPj4xNiYyNTUsbD4+OCYyNTUsMjU1JmwsaD4+MjQmMjU1LGg+PjE2JjI1NSxoPj44JjI1NSwyNTUmaCx1Pj4yNCYyNTUsdT4+MTYmMjU1LHU+PjgmMjU1LDI1NSZ1XSl9fSgpO3QuY2FsY3VsYXRlU0hBMjU2PW87Y29uc3QgYz1mdW5jdGlvbiBjYWxjdWxhdGVTSEE1MTJDbG9zdXJlKCl7ZnVuY3Rpb24gY2goZSx0LGEscixuKXtlLmFzc2lnbih0KTtlLmFuZChhKTtuLmFzc2lnbih0KTtuLm5vdCgpO24uYW5kKHIpO2UueG9yKG4pfWZ1bmN0aW9uIG1haihlLHQsYSxyLG4pe2UuYXNzaWduKHQpO2UuYW5kKGEpO24uYXNzaWduKHQpO24uYW5kKHIpO2UueG9yKG4pO24uYXNzaWduKGEpO24uYW5kKHIpO2UueG9yKG4pfWZ1bmN0aW9uIHNpZ21hKGUsdCxhKXtlLmFzc2lnbih0KTtlLnJvdGF0ZVJpZ2h0KDI4KTthLmFzc2lnbih0KTthLnJvdGF0ZVJpZ2h0KDM0KTtlLnhvcihhKTthLmFzc2lnbih0KTthLnJvdGF0ZVJpZ2h0KDM5KTtlLnhvcihhKX1mdW5jdGlvbiBzaWdtYVByaW1lKGUsdCxhKXtlLmFzc2lnbih0KTtlLnJvdGF0ZVJpZ2h0KDE0KTthLmFzc2lnbih0KTthLnJvdGF0ZVJpZ2h0KDE4KTtlLnhvcihhKTthLmFzc2lnbih0KTthLnJvdGF0ZVJpZ2h0KDQxKTtlLnhvcihhKX1mdW5jdGlvbiBsaXR0bGVTaWdtYShlLHQsYSl7ZS5hc3NpZ24odCk7ZS5yb3RhdGVSaWdodCgxKTthLmFzc2lnbih0KTthLnJvdGF0ZVJpZ2h0KDgpO2UueG9yKGEpO2EuYXNzaWduKHQpO2Euc2hpZnRSaWdodCg3KTtlLnhvcihhKX1mdW5jdGlvbiBsaXR0bGVTaWdtYVByaW1lKGUsdCxhKXtlLmFzc2lnbih0KTtlLnJvdGF0ZVJpZ2h0KDE5KTthLmFzc2lnbih0KTthLnJvdGF0ZVJpZ2h0KDYxKTtlLnhvcihhKTthLmFzc2lnbih0KTthLnNoaWZ0UmlnaHQoNik7ZS54b3IoYSl9Y29uc3QgZT1bbmV3IFdvcmQ2NCgxMTE2MzUyNDA4LDM2MDk3Njc0NTgpLG5ldyBXb3JkNjQoMTg5OTQ0NzQ0MSw2MDI4OTE3MjUpLG5ldyBXb3JkNjQoMzA0OTMyMzQ3MSwzOTY0NDg0Mzk5KSxuZXcgV29yZDY0KDM5MjEwMDk1NzMsMjE3MzI5NTU0OCksbmV3IFdvcmQ2NCg5NjE5ODcxNjMsNDA4MTYyODQ3MiksbmV3IFdvcmQ2NCgxNTA4OTcwOTkzLDMwNTM4MzQyNjUpLG5ldyBXb3JkNjQoMjQ1MzYzNTc0OCwyOTM3NjcxNTc5KSxuZXcgV29yZDY0KDI4NzA3NjMyMjEsMzY2NDYwOTU2MCksbmV3IFdvcmQ2NCgzNjI0MzgxMDgwLDI3MzQ4ODMzOTQpLG5ldyBXb3JkNjQoMzEwNTk4NDAxLDExNjQ5OTY1NDIpLG5ldyBXb3JkNjQoNjA3MjI1Mjc4LDEzMjM2MTA3NjQpLG5ldyBXb3JkNjQoMTQyNjg4MTk4NywzNTkwMzA0OTk0KSxuZXcgV29yZDY0KDE5MjUwNzgzODgsNDA2ODE4MjM4MyksbmV3IFdvcmQ2NCgyMTYyMDc4MjA2LDk5MTMzNjExMyksbmV3IFdvcmQ2NCgyNjE0ODg4MTAzLDYzMzgwMzMxNyksbmV3IFdvcmQ2NCgzMjQ4MjIyNTgwLDM0Nzk3NzQ4NjgpLG5ldyBXb3JkNjQoMzgzNTM5MDQwMSwyNjY2NjEzNDU4KSxuZXcgV29yZDY0KDQwMjIyMjQ3NzQsOTQ0NzExMTM5KSxuZXcgV29yZDY0KDI2NDM0NzA3OCwyMzQxMjYyNzczKSxuZXcgV29yZDY0KDYwNDgwNzYyOCwyMDA3ODAwOTMzKSxuZXcgV29yZDY0KDc3MDI1NTk4MywxNDk1OTkwOTAxKSxuZXcgV29yZDY0KDEyNDkxNTAxMjIsMTg1NjQzMTIzNSksbmV3IFdvcmQ2NCgxNTU1MDgxNjkyLDMxNzUyMTgxMzIpLG5ldyBXb3JkNjQoMTk5NjA2NDk4NiwyMTk4OTUwODM3KSxuZXcgV29yZDY0KDI1NTQyMjA4ODIsMzk5OTcxOTMzOSksbmV3IFdvcmQ2NCgyODIxODM0MzQ5LDc2Njc4NDAxNiksbmV3IFdvcmQ2NCgyOTUyOTk2ODA4LDI1NjY1OTQ4NzkpLG5ldyBXb3JkNjQoMzIxMDMxMzY3MSwzMjAzMzM3OTU2KSxuZXcgV29yZDY0KDMzMzY1NzE4OTEsMTAzNDQ1NzAyNiksbmV3IFdvcmQ2NCgzNTg0NTI4NzExLDI0NjY5NDg5MDEpLG5ldyBXb3JkNjQoMTEzOTI2OTkzLDM3NTgzMjYzODMpLG5ldyBXb3JkNjQoMzM4MjQxODk1LDE2ODcxNzkzNiksbmV3IFdvcmQ2NCg2NjYzMDcyMDUsMTE4ODE3OTk2NCksbmV3IFdvcmQ2NCg3NzM1Mjk5MTIsMTU0NjA0NTczNCksbmV3IFdvcmQ2NCgxMjk0NzU3MzcyLDE1MjI4MDU0ODUpLG5ldyBXb3JkNjQoMTM5NjE4MjI5MSwyNjQzODMzODIzKSxuZXcgV29yZDY0KDE2OTUxODM3MDAsMjM0MzUyNzM5MCksbmV3IFdvcmQ2NCgxOTg2NjYxMDUxLDEwMTQ0Nzc0ODApLG5ldyBXb3JkNjQoMjE3NzAyNjM1MCwxMjA2NzU5MTQyKSxuZXcgV29yZDY0KDI0NTY5NTYwMzcsMzQ0MDc3NjI3KSxuZXcgV29yZDY0KDI3MzA0ODU5MjEsMTI5MDg2MzQ2MCksbmV3IFdvcmQ2NCgyODIwMzAyNDExLDMxNTg0NTQyNzMpLG5ldyBXb3JkNjQoMzI1OTczMDgwMCwzNTA1OTUyNjU3KSxuZXcgV29yZDY0KDMzNDU3NjQ3NzEsMTA2MjE3MDA4KSxuZXcgV29yZDY0KDM1MTYwNjU4MTcsMzYwNjAwODM0NCksbmV3IFdvcmQ2NCgzNjAwMzUyODA0LDE0MzI3MjU3NzYpLG5ldyBXb3JkNjQoNDA5NDU3MTkwOSwxNDY3MDMxNTk0KSxuZXcgV29yZDY0KDI3NTQyMzM0NCw4NTExNjk3MjApLG5ldyBXb3JkNjQoNDMwMjI3NzM0LDMxMDA4MjM3NTIpLG5ldyBXb3JkNjQoNTA2OTQ4NjE2LDEzNjMyNTgxOTUpLG5ldyBXb3JkNjQoNjU5MDYwNTU2LDM3NTA2ODU1OTMpLG5ldyBXb3JkNjQoODgzOTk3ODc3LDM3ODUwNTAyODApLG5ldyBXb3JkNjQoOTU4MTM5NTcxLDMzMTgzMDc0MjcpLG5ldyBXb3JkNjQoMTMyMjgyMjIxOCwzODEyNzIzNDAzKSxuZXcgV29yZDY0KDE1MzcwMDIwNjMsMjAwMzAzNDk5NSksbmV3IFdvcmQ2NCgxNzQ3ODczNzc5LDM2MDIwMzY4OTkpLG5ldyBXb3JkNjQoMTk1NTU2MjIyMiwxNTc1OTkwMDEyKSxuZXcgV29yZDY0KDIwMjQxMDQ4MTUsMTEyNTU5MjkyOCksbmV3IFdvcmQ2NCgyMjI3NzMwNDUyLDI3MTY5MDQzMDYpLG5ldyBXb3JkNjQoMjM2MTg1MjQyNCw0NDI3NzYwNDQpLG5ldyBXb3JkNjQoMjQyODQzNjQ3NCw1OTM2OTgzNDQpLG5ldyBXb3JkNjQoMjc1NjczNDE4NywzNzMzMTEwMjQ5KSxuZXcgV29yZDY0KDMyMDQwMzE0NzksMjk5OTM1MTU3MyksbmV3IFdvcmQ2NCgzMzI5MzI1Mjk4LDM4MTU5MjA0MjcpLG5ldyBXb3JkNjQoMzM5MTU2OTYxNCwzOTI4MzgzOTAwKSxuZXcgV29yZDY0KDM1MTUyNjcyNzEsNTY2MjgwNzExKSxuZXcgV29yZDY0KDM5NDAxODc2MDYsMzQ1NDA2OTUzNCksbmV3IFdvcmQ2NCg0MTE4NjMwMjcxLDQwMDAyMzk5OTIpLG5ldyBXb3JkNjQoMTE2NDE4NDc0LDE5MTQxMzg1NTQpLG5ldyBXb3JkNjQoMTc0MjkyNDIxLDI3MzEwNTUyNzApLG5ldyBXb3JkNjQoMjg5MzgwMzU2LDMyMDM5OTMwMDYpLG5ldyBXb3JkNjQoNDYwMzkzMjY5LDMyMDYyMDMxNSksbmV3IFdvcmQ2NCg2ODU0NzE3MzMsNTg3NDk2ODM2KSxuZXcgV29yZDY0KDg1MjE0Mjk3MSwxMDg2NzkyODUxKSxuZXcgV29yZDY0KDEwMTcwMzYyOTgsMzY1NTQzMTAwKSxuZXcgV29yZDY0KDExMjYwMDA1ODAsMjYxODI5NzY3NiksbmV3IFdvcmQ2NCgxMjg4MDMzNDcwLDM0MDk4NTUxNTgpLG5ldyBXb3JkNjQoMTUwMTUwNTk0OCw0MjM0NTA5ODY2KSxuZXcgV29yZDY0KDE2MDcxNjc5MTUsOTg3MTY3NDY4KSxuZXcgV29yZDY0KDE4MTY0MDIzMTYsMTI0NjE4OTU5MSldO3JldHVybiBmdW5jdGlvbiBoYXNoKHQsYSxyLG49ITEpe2xldCBpLHMsbyxjLGwsaCx1LGQ7aWYobil7aT1uZXcgV29yZDY0KDM0MTgwNzAzNjUsMzIzODM3MTAzMik7cz1uZXcgV29yZDY0KDE2NTQyNzAyNTAsOTE0MTUwNjYzKTtvPW5ldyBXb3JkNjQoMjQzODUyOTM3MCw4MTI3MDI5OTkpO2M9bmV3IFdvcmQ2NCgzNTU0NjIzNjAsNDE0NDkxMjY5Nyk7bD1uZXcgV29yZDY0KDE3MzE0MDU0MTUsNDI5MDc3NTg1Nyk7aD1uZXcgV29yZDY0KDIzOTQxODAyMzEsMTc1MDYwMzAyNSk7dT1uZXcgV29yZDY0KDM2NzUwMDg1MjUsMTY5NDA3NjgzOSk7ZD1uZXcgV29yZDY0KDEyMDMwNjI4MTMsMzIwNDA3NTQyOCl9ZWxzZXtpPW5ldyBXb3JkNjQoMTc3OTAzMzcwMyw0MDg5MjM1NzIwKTtzPW5ldyBXb3JkNjQoMzE0NDEzNDI3NywyMjI3ODczNTk1KTtvPW5ldyBXb3JkNjQoMTAxMzkwNDI0Miw0MjcxMTc1NzIzKTtjPW5ldyBXb3JkNjQoMjc3MzQ4MDc2MiwxNTk1NzUwMTI5KTtsPW5ldyBXb3JkNjQoMTM1OTg5MzExOSwyOTE3NTY1MTM3KTtoPW5ldyBXb3JkNjQoMjYwMDgyMjkyNCw3MjU1MTExOTkpO3U9bmV3IFdvcmQ2NCg1Mjg3MzQ2MzUsNDIxNTM4OTU0Nyk7ZD1uZXcgV29yZDY0KDE1NDE0NTkyMjUsMzI3MDMzMjA5KX1jb25zdCBmPTEyOCpNYXRoLmNlaWwoKHIrMTcpLzEyOCksZz1uZXcgVWludDhBcnJheShmKTtsZXQgcCxtO2ZvcihwPTA7cDxyOysrcClnW3BdPXRbYSsrXTtnW3ArK109MTI4O2NvbnN0IGI9Zi0xNjtmb3IoO3A8YjspZ1twKytdPTA7Z1twKytdPTA7Z1twKytdPTA7Z1twKytdPTA7Z1twKytdPTA7Z1twKytdPTA7Z1twKytdPTA7Z1twKytdPTA7Z1twKytdPTA7Z1twKytdPTA7Z1twKytdPTA7Z1twKytdPTA7Z1twKytdPXI+Pj4yOSYyNTU7Z1twKytdPXI+PjIxJjI1NTtnW3ArK109cj4+MTMmMjU1O2dbcCsrXT1yPj41JjI1NTtnW3ArK109cjw8MyYyNTU7Y29uc3QgeT1uZXcgQXJyYXkoODApO2ZvcihwPTA7cDw4MDtwKyspeVtwXT1uZXcgV29yZDY0KDAsMCk7bGV0IHc9bmV3IFdvcmQ2NCgwLDApLFM9bmV3IFdvcmQ2NCgwLDApLHg9bmV3IFdvcmQ2NCgwLDApLGs9bmV3IFdvcmQ2NCgwLDApLEM9bmV3IFdvcmQ2NCgwLDApLHY9bmV3IFdvcmQ2NCgwLDApLEY9bmV3IFdvcmQ2NCgwLDApLE89bmV3IFdvcmQ2NCgwLDApO2NvbnN0IFQ9bmV3IFdvcmQ2NCgwLDApLE09bmV3IFdvcmQ2NCgwLDApLEU9bmV3IFdvcmQ2NCgwLDApLEQ9bmV3IFdvcmQ2NCgwLDApO2xldCBOLFI7Zm9yKHA9MDtwPGY7KXtmb3IobT0wO208MTY7KyttKXt5W21dLmhpZ2g9Z1twXTw8MjR8Z1twKzFdPDwxNnxnW3ArMl08PDh8Z1twKzNdO3lbbV0ubG93PWdbcCs0XTw8MjR8Z1twKzVdPDwxNnxnW3ArNl08PDh8Z1twKzddO3ArPTh9Zm9yKG09MTY7bTw4MDsrK20pe049eVttXTtsaXR0bGVTaWdtYVByaW1lKE4seVttLTJdLEQpO04uYWRkKHlbbS03XSk7bGl0dGxlU2lnbWEoRSx5W20tMTVdLEQpO04uYWRkKEUpO04uYWRkKHlbbS0xNl0pfXcuYXNzaWduKGkpO1MuYXNzaWduKHMpO3guYXNzaWduKG8pO2suYXNzaWduKGMpO0MuYXNzaWduKGwpO3YuYXNzaWduKGgpO0YuYXNzaWduKHUpO08uYXNzaWduKGQpO2ZvcihtPTA7bTw4MDsrK20pe1QuYXNzaWduKE8pO3NpZ21hUHJpbWUoRSxDLEQpO1QuYWRkKEUpO2NoKEUsQyx2LEYsRCk7VC5hZGQoRSk7VC5hZGQoZVttXSk7VC5hZGQoeVttXSk7c2lnbWEoTSx3LEQpO21haihFLHcsUyx4LEQpO00uYWRkKEUpO049TztPPUY7Rj12O3Y9QztrLmFkZChUKTtDPWs7az14O3g9UztTPXc7Ti5hc3NpZ24oVCk7Ti5hZGQoTSk7dz1OfWkuYWRkKHcpO3MuYWRkKFMpO28uYWRkKHgpO2MuYWRkKGspO2wuYWRkKEMpO2guYWRkKHYpO3UuYWRkKEYpO2QuYWRkKE8pfWlmKG4pe1I9bmV3IFVpbnQ4QXJyYXkoNDgpO2kuY29weVRvKFIsMCk7cy5jb3B5VG8oUiw4KTtvLmNvcHlUbyhSLDE2KTtjLmNvcHlUbyhSLDI0KTtsLmNvcHlUbyhSLDMyKTtoLmNvcHlUbyhSLDQwKX1lbHNle1I9bmV3IFVpbnQ4QXJyYXkoNjQpO2kuY29weVRvKFIsMCk7cy5jb3B5VG8oUiw4KTtvLmNvcHlUbyhSLDE2KTtjLmNvcHlUbyhSLDI0KTtsLmNvcHlUbyhSLDMyKTtoLmNvcHlUbyhSLDQwKTt1LmNvcHlUbyhSLDQ4KTtkLmNvcHlUbyhSLDU2KX1yZXR1cm4gUn19KCk7dC5jYWxjdWxhdGVTSEE1MTI9YztmdW5jdGlvbiBjYWxjdWxhdGVTSEEzODQoZSx0LGEpe3JldHVybiBjKGUsdCxhLCEwKX1jbGFzcyBOdWxsQ2lwaGVye2RlY3J5cHRCbG9jayhlKXtyZXR1cm4gZX1lbmNyeXB0KGUpe3JldHVybiBlfX1jbGFzcyBBRVNCYXNlQ2lwaGVye2NvbnN0cnVjdG9yKCl7dGhpcy5jb25zdHJ1Y3Rvcj09PUFFU0Jhc2VDaXBoZXImJigwLHIudW5yZWFjaGFibGUpKCJDYW5ub3QgaW5pdGlhbGl6ZSBBRVNCYXNlQ2lwaGVyLiIpO3RoaXMuX3M9bmV3IFVpbnQ4QXJyYXkoWzk5LDEyNCwxMTksMTIzLDI0MiwxMDcsMTExLDE5Nyw0OCwxLDEwMyw0MywyNTQsMjE1LDE3MSwxMTgsMjAyLDEzMCwyMDEsMTI1LDI1MCw4OSw3MSwyNDAsMTczLDIxMiwxNjIsMTc1LDE1NiwxNjQsMTE0LDE5MiwxODMsMjUzLDE0NywzOCw1NCw2MywyNDcsMjA0LDUyLDE2NSwyMjksMjQxLDExMywyMTYsNDksMjEsNCwxOTksMzUsMTk1LDI0LDE1MCw1LDE1NCw3LDE4LDEyOCwyMjYsMjM1LDM5LDE3OCwxMTcsOSwxMzEsNDQsMjYsMjcsMTEwLDkwLDE2MCw4Miw1OSwyMTQsMTc5LDQxLDIyNyw0NywxMzIsODMsMjA5LDAsMjM3LDMyLDI1MiwxNzcsOTEsMTA2LDIwMywxOTAsNTcsNzQsNzYsODgsMjA3LDIwOCwyMzksMTcwLDI1MSw2Nyw3Nyw1MSwxMzMsNjksMjQ5LDIsMTI3LDgwLDYwLDE1OSwxNjgsODEsMTYzLDY0LDE0MywxNDYsMTU3LDU2LDI0NSwxODgsMTgyLDIxOCwzMywxNiwyNTUsMjQzLDIxMCwyMDUsMTIsMTksMjM2LDk1LDE1MSw2OCwyMywxOTYsMTY3LDEyNiw2MSwxMDAsOTMsMjUsMTE1LDk2LDEyOSw3OSwyMjAsMzQsNDIsMTQ0LDEzNiw3MCwyMzgsMTg0LDIwLDIyMiw5NCwxMSwyMTksMjI0LDUwLDU4LDEwLDczLDYsMzYsOTIsMTk0LDIxMSwxNzIsOTgsMTQ1LDE0OSwyMjgsMTIxLDIzMSwyMDAsNTUsMTA5LDE0MSwyMTMsNzgsMTY5LDEwOCw4NiwyNDQsMjM0LDEwMSwxMjIsMTc0LDgsMTg2LDEyMCwzNyw0NiwyOCwxNjYsMTgwLDE5OCwyMzIsMjIxLDExNiwzMSw3NSwxODksMTM5LDEzOCwxMTIsNjIsMTgxLDEwMiw3MiwzLDI0NiwxNCw5Nyw1Myw4NywxODUsMTM0LDE5MywyOSwxNTgsMjI1LDI0OCwxNTIsMTcsMTA1LDIxNywxNDIsMTQ4LDE1NSwzMCwxMzUsMjMzLDIwNiw4NSw0MCwyMjMsMTQwLDE2MSwxMzcsMTMsMTkxLDIzMCw2NiwxMDQsNjUsMTUzLDQ1LDE1LDE3Niw4NCwxODcsMjJdKTt0aGlzLl9pbnZfcz1uZXcgVWludDhBcnJheShbODIsOSwxMDYsMjEzLDQ4LDU0LDE2NSw1NiwxOTEsNjQsMTYzLDE1OCwxMjksMjQzLDIxNSwyNTEsMTI0LDIyNyw1NywxMzAsMTU1LDQ3LDI1NSwxMzUsNTIsMTQyLDY3LDY4LDE5NiwyMjIsMjMzLDIwMyw4NCwxMjMsMTQ4LDUwLDE2NiwxOTQsMzUsNjEsMjM4LDc2LDE0OSwxMSw2NiwyNTAsMTk1LDc4LDgsNDYsMTYxLDEwMiw0MCwyMTcsMzYsMTc4LDExOCw5MSwxNjIsNzMsMTA5LDEzOSwyMDksMzcsMTE0LDI0OCwyNDYsMTAwLDEzNCwxMDQsMTUyLDIyLDIxMiwxNjQsOTIsMjA0LDkzLDEwMSwxODIsMTQ2LDEwOCwxMTIsNzIsODAsMjUzLDIzNywxODUsMjE4LDk0LDIxLDcwLDg3LDE2NywxNDEsMTU3LDEzMiwxNDQsMjE2LDE3MSwwLDE0MCwxODgsMjExLDEwLDI0NywyMjgsODgsNSwxODQsMTc5LDY5LDYsMjA4LDQ0LDMwLDE0MywyMDIsNjMsMTUsMiwxOTMsMTc1LDE4OSwzLDEsMTksMTM4LDEwNyw1OCwxNDUsMTcsNjUsNzksMTAzLDIyMCwyMzQsMTUxLDI0MiwyMDcsMjA2LDI0MCwxODAsMjMwLDExNSwxNTAsMTcyLDExNiwzNCwyMzEsMTczLDUzLDEzMywyMjYsMjQ5LDU1LDIzMiwyOCwxMTcsMjIzLDExMCw3MSwyNDEsMjYsMTEzLDI5LDQxLDE5NywxMzcsMTExLDE4Myw5OCwxNCwxNzAsMjQsMTkwLDI3LDI1Miw4Niw2Miw3NSwxOTgsMjEwLDEyMSwzMiwxNTQsMjE5LDE5MiwyNTQsMTIwLDIwNSw5MCwyNDQsMzEsMjIxLDE2OCw1MSwxMzYsNywxOTksNDksMTc3LDE4LDE2LDg5LDM5LDEyOCwyMzYsOTUsOTYsODEsMTI3LDE2OSwyNSwxODEsNzQsMTMsNDUsMjI5LDEyMiwxNTksMTQ3LDIwMSwxNTYsMjM5LDE2MCwyMjQsNTksNzcsMTc0LDQyLDI0NSwxNzYsMjAwLDIzNSwxODcsNjAsMTMxLDgzLDE1Myw5NywyMyw0Myw0LDEyNiwxODYsMTE5LDIxNCwzOCwyMjUsMTA1LDIwLDk5LDg1LDMzLDEyLDEyNV0pO3RoaXMuX21peD1uZXcgVWludDMyQXJyYXkoWzAsMjM1NDc0MTg3LDQ3MDk0ODM3NCwzMDM3NjUyNzcsOTQxODk2NzQ4LDkwODkzMzQxNSw2MDc1MzA1NTQsNzA4NzgwODQ5LDE4ODM3OTM0OTYsMjExODIxNDk5NSwxODE3ODY2ODMwLDE2NDk2MzkyMzcsMTIxNTA2MTEwOCwxMTgxMDQ1MTE5LDE0MTc1NjE2OTgsMTUxNzc2NzUyOSwzNzY3NTg2OTkyLDQwMDMwNjExNzksNDIzNjQyOTk5MCw0MDY5MjQ2ODkzLDM2MzU3MzM2NjAsMzYwMjc3MDMyNywzMjk5Mjc4NDc0LDM0MDA1Mjg3NjksMjQzMDEyMjIxNiwyNjY0NTQzNzE1LDIzNjIwOTAyMzgsMjE5Mzg2MjY0NSwyODM1MTIzMzk2LDI4MDExMDc0MDcsMzAzNTUzNTA1OCwzMTM1NzQwODg5LDM2NzgxMjQ5MjMsMzU3Njg3MDUxMiwzMzQxMzk0Mjg1LDMzNzQzNjE3MDIsMzgxMDQ5NjM0MywzOTc3Njc1MzU2LDQyNzkwODAyNTcsNDA0MzYxMDE4NiwyODc2NDk0NjI3LDI3NzYyOTI5MDQsMzA3NjYzOTAyOSwzMTEwNjUwOTQyLDI0NzIwMTE1MzUsMjY0MDI0MzIwNCwyNDAzNzI4NjY1LDIxNjkzMDMwNTgsMTAwMTA4OTk5NSw4OTk4MzU1ODQsNjY2NDY0NzMzLDY5OTQzMjE1MCw1OTcyNzg0NywyMjY5MDY4NjAsNTMwNDAwNzUzLDI5NDkzMDY4MiwxMjczMTY4Nzg3LDExNzI5NjcwNjQsMTQ3NTQxODUwMSwxNTA5NDMwNDE0LDE5NDI0MzU3NzUsMjExMDY2NzQ0NCwxODc2MjQxODMzLDE2NDE4MTYyMjYsMjkxMDIxOTc2NiwyNzQzMDM0MTA5LDI5NzYxNTE1MjAsMzIxMTYyMzE0NywyNTA1MjAyMTM4LDI2MDY0NTM5NjksMjMwMjY5MDI1MiwyMjY5NzI4NDU1LDM3MTE4Mjk0MjIsMzU0MzU5OTI2OSwzMjQwODk0MzkyLDM0NzUzMTMzMzEsMzg0MzY5OTA3NCwzOTQzOTA2NDQxLDQxNzgwNjIyMjgsNDE0NDA0Nzc3NSwxMzA2OTY3MzY2LDExMzk3ODE3MDksMTM3NDk4ODExMiwxNjEwNDU5NzM5LDE5NzU2ODM0MzQsMjA3NjkzNTI2NSwxNzc1Mjc2OTI0LDE3NDIzMTUxMjcsMTAzNDg2Nzk5OCw4NjY2Mzc4NDUsNTY2MDIxODk2LDgwMDQ0MDgzNSw5Mjk4NzY5OCwxOTMxOTUwNjUsNDI5NDU2MTY0LDM5NTQ0MTcxMSwxOTg0ODEyNjg1LDIwMTc3Nzg1NjYsMTc4NDY2MzE5NSwxNjgzNDA3MjQ4LDEzMTU1NjIxNDUsMTA4MDA5NDYzNCwxMzgzODU2MzExLDE1NTEwMzc4ODQsMTAxMDM5ODI5LDEzNTA1MDIwNiw0Mzc3NTcxMjMsMzM3NTUzODY0LDEwNDIzODU2NTcsODA3OTYyNjEwLDU3MzgwNDc4Myw3NDIwMzkwMTIsMjUzMTA2NzQ1MywyNTY0MDMzMzM0LDIzMjg4Mjg5NzEsMjIyNzU3MzAyNCwyOTM1NTY2ODY1LDI3MDAwOTkzNTQsMzAwMTc1NTY1NSwzMTY4OTM3MjI4LDM4Njg1NTI4MDUsMzkwMjU2MzE4Miw0MjAzMTgxMTcxLDQxMDI5Nzc5MTIsMzczNjE2NDkzNywzNTAxNzQxODkwLDMyNjU0Nzg3NTEsMzQzMzcxMjk4MCwxMTA2MDQxNTkxLDEzNDA0NjMxMDAsMTU3Njk3NjYwOSwxNDA4NzQ5MDM0LDIwNDMyMTE0ODMsMjAwOTE5NTQ3MiwxNzA4ODQ4MzMzLDE4MDkwNTQxNTAsODMyODc3MjMxLDEwNjgzNTEzOTYsNzY2OTQ1NDY1LDU5OTc2MjM1NCwxNTk0MTc5ODcsMTI2NDU0NjY0LDM2MTkyOTg3Nyw0NjMxODAxOTAsMjcwOTI2MDg3MSwyOTQzNjgyMzgwLDMxNzgxMDY5NjEsMzAwOTg3OTM4NiwyNTcyNjk3MTk1LDI1Mzg2ODExODQsMjIzNjIyODczMywyMzM2NDM0NTUwLDM1MDk4NzExMzUsMzc0NTM0NTMwMCwzNDQxODUwMzc3LDMyNzQ2NjcyNjYsMzkxMDE2MTk3MSwzODc3MTk4NjQ4LDQxMTA1Njg0ODUsNDIxMTgxODc5OCwyNTk3ODA2NDc2LDI0OTc2MDQ3NDMsMjI2MTA4OTE3OCwyMjk1MTAxMDczLDI3MzM4NTYxNjAsMjkwMjA4Nzg1MSwzMjAyNDM3MDQ2LDI5NjgwMTE0NTMsMzkzNjI5MTI4NCwzODM1MDM2ODk1LDQxMzY0NDA3NzAsNDE2OTQwODIwMSwzNTM1NDg2NDU2LDM3MDI2NjU0NTksMzQ2NzE5MjMwMiwzMjMxNzIyMjEzLDIwNTE1MTg3ODAsMTk1MTMxNzA0NywxNzE2ODkwNDEwLDE3NTA5MDIzMDUsMTExMzgxODM4NCwxMjgyMDUwMDc1LDE1ODQ1MDQ1ODIsMTM1MDA3ODk4OSwxNjg4MTA4NTIsNjc1NTY0NjMsMzcxMDQ5MzMwLDQwNDAxNjc2MSw4NDE3Mzk1OTIsMTAwODkxODU5NSw3NzU1NTA4MTQsNTQwMDgwNzI1LDM5Njk1NjIzNjksMzgwMTMzMjIzNCw0MDM1NDg5MDQ3LDQyNjk5MDc5OTYsMzU2OTI1NTIxMywzNjY5NDYyNTY2LDMzNjY3NTQ2MTksMzMzMjc0MDE0NCwyNjMxMDY1NDMzLDI0NjM4Nzk3NjIsMjE2MDExNzA3MSwyMzk1NTg4Njc2LDI3Njc2NDU1NTcsMjg2ODg5NzQwNiwzMTAyMDExNzQ3LDMwNjkwNDk5NjAsMjAyMDA4NDk3LDMzNzc4MzYyLDI3MDA0MDQ4Nyw1MDQ0NTk0MzYsODc1NDUxMjkzLDk3NTY1ODY0Niw2NzUwMzk2MjcsNjQxMDI1MTUyLDIwODQ3MDQyMzMsMTkxNzUxODU2MiwxNjE1ODYxMjQ3LDE4NTEzMzI4NTIsMTE0NzU1MDY2MSwxMjQ4ODAyNTEwLDE0ODQwMDU4NDMsMTQ1MTA0NDA1Niw5MzMzMDEzNzAsOTY3MzExNzI5LDczMzE1Njk3Miw2MzI5NTM3MDMsMjYwMzg4OTUwLDI1OTY1OTE3LDMyODY3MTgwOCw0OTY5MDYwNTksMTIwNjQ3Nzg1OCwxMjM5NDQzNzUzLDE1NDMyMDg1MDAsMTQ0MTk1MjU3NSwyMTQ0MTYxODA2LDE5MDg2OTQyNzcsMTY3NTU3Nzg4MCwxODQyNzU5NDQzLDM2MTAzNjkyMjYsMzY0NDM3OTU4NSwzNDA4MTE5NTE2LDMzMDc5MTYyNDcsNDAxMTE5MDUwMiwzNzc2NzY3NDY5LDQwNzczODQ0MzIsNDI0NTYxODY4MywyODA5NzcxMTU0LDI4NDI3MzcwNDksMzE0NDM5NjQyMCwzMDQzMTQwNDk1LDI2NzM3MDUxNTAsMjQzODIzNzYyMSwyMjAzMDMyMjMyLDIzNzAyMTM3OTVdKTt0aGlzLl9taXhDb2w9bmV3IFVpbnQ4QXJyYXkoMjU2KTtmb3IobGV0IGU9MDtlPDI1NjtlKyspdGhpcy5fbWl4Q29sW2VdPWU8MTI4P2U8PDE6ZTw8MV4yNzt0aGlzLmJ1ZmZlcj1uZXcgVWludDhBcnJheSgxNik7dGhpcy5idWZmZXJQb3NpdGlvbj0wfV9leHBhbmRLZXkoZSl7KDAsci51bnJlYWNoYWJsZSkoIkNhbm5vdCBjYWxsIGBfZXhwYW5kS2V5YCBvbiB0aGUgYmFzZSBjbGFzcyIpfV9kZWNyeXB0KGUsdCl7bGV0IGEscixuO2NvbnN0IGk9bmV3IFVpbnQ4QXJyYXkoMTYpO2kuc2V0KGUpO2ZvcihsZXQgZT0wLGE9dGhpcy5fa2V5U2l6ZTtlPDE2OysrZSwrK2EpaVtlXV49dFthXTtmb3IobGV0IGU9dGhpcy5fY3ljbGVzT2ZSZXBldGl0aW9uLTE7ZT49MTstLWUpe2E9aVsxM107aVsxM109aVs5XTtpWzldPWlbNV07aVs1XT1pWzFdO2lbMV09YTthPWlbMTRdO3I9aVsxMF07aVsxNF09aVs2XTtpWzEwXT1pWzJdO2lbNl09YTtpWzJdPXI7YT1pWzE1XTtyPWlbMTFdO249aVs3XTtpWzE1XT1pWzNdO2lbMTFdPWE7aVs3XT1yO2lbM109bjtmb3IobGV0IGU9MDtlPDE2OysrZSlpW2VdPXRoaXMuX2ludl9zW2lbZV1dO2ZvcihsZXQgYT0wLHI9MTYqZTthPDE2OysrYSwrK3IpaVthXV49dFtyXTtmb3IobGV0IGU9MDtlPDE2O2UrPTQpe2NvbnN0IHQ9dGhpcy5fbWl4W2lbZV1dLHI9dGhpcy5fbWl4W2lbZSsxXV0sbj10aGlzLl9taXhbaVtlKzJdXSxzPXRoaXMuX21peFtpW2UrM11dO2E9dF5yPj4+OF5yPDwyNF5uPj4+MTZebjw8MTZecz4+PjI0XnM8PDg7aVtlXT1hPj4+MjQmMjU1O2lbZSsxXT1hPj4xNiYyNTU7aVtlKzJdPWE+PjgmMjU1O2lbZSszXT0yNTUmYX19YT1pWzEzXTtpWzEzXT1pWzldO2lbOV09aVs1XTtpWzVdPWlbMV07aVsxXT1hO2E9aVsxNF07cj1pWzEwXTtpWzE0XT1pWzZdO2lbMTBdPWlbMl07aVs2XT1hO2lbMl09cjthPWlbMTVdO3I9aVsxMV07bj1pWzddO2lbMTVdPWlbM107aVsxMV09YTtpWzddPXI7aVszXT1uO2ZvcihsZXQgZT0wO2U8MTY7KytlKXtpW2VdPXRoaXMuX2ludl9zW2lbZV1dO2lbZV1ePXRbZV19cmV0dXJuIGl9X2VuY3J5cHQoZSx0KXtjb25zdCBhPXRoaXMuX3M7bGV0IHIsbixpO2NvbnN0IHM9bmV3IFVpbnQ4QXJyYXkoMTYpO3Muc2V0KGUpO2ZvcihsZXQgZT0wO2U8MTY7KytlKXNbZV1ePXRbZV07Zm9yKGxldCBlPTE7ZTx0aGlzLl9jeWNsZXNPZlJlcGV0aXRpb247ZSsrKXtmb3IobGV0IGU9MDtlPDE2OysrZSlzW2VdPWFbc1tlXV07aT1zWzFdO3NbMV09c1s1XTtzWzVdPXNbOV07c1s5XT1zWzEzXTtzWzEzXT1pO2k9c1syXTtuPXNbNl07c1syXT1zWzEwXTtzWzZdPXNbMTRdO3NbMTBdPWk7c1sxNF09bjtpPXNbM107bj1zWzddO3I9c1sxMV07c1szXT1zWzE1XTtzWzddPWk7c1sxMV09bjtzWzE1XT1yO2ZvcihsZXQgZT0wO2U8MTY7ZSs9NCl7Y29uc3QgdD1zW2UrMF0sYT1zW2UrMV0sbj1zW2UrMl0saT1zW2UrM107cj10XmFebl5pO3NbZSswXV49cl50aGlzLl9taXhDb2xbdF5hXTtzW2UrMV1ePXJedGhpcy5fbWl4Q29sW2Febl07c1tlKzJdXj1yXnRoaXMuX21peENvbFtuXmldO3NbZSszXV49cl50aGlzLl9taXhDb2xbaV50XX1mb3IobGV0IGE9MCxyPTE2KmU7YTwxNjsrK2EsKytyKXNbYV1ePXRbcl19Zm9yKGxldCBlPTA7ZTwxNjsrK2Upc1tlXT1hW3NbZV1dO2k9c1sxXTtzWzFdPXNbNV07c1s1XT1zWzldO3NbOV09c1sxM107c1sxM109aTtpPXNbMl07bj1zWzZdO3NbMl09c1sxMF07c1s2XT1zWzE0XTtzWzEwXT1pO3NbMTRdPW47aT1zWzNdO249c1s3XTtyPXNbMTFdO3NbM109c1sxNV07c1s3XT1pO3NbMTFdPW47c1sxNV09cjtmb3IobGV0IGU9MCxhPXRoaXMuX2tleVNpemU7ZTwxNjsrK2UsKythKXNbZV1ePXRbYV07cmV0dXJuIHN9X2RlY3J5cHRCbG9jazIoZSx0KXtjb25zdCBhPWUubGVuZ3RoO2xldCByPXRoaXMuYnVmZmVyLG49dGhpcy5idWZmZXJQb3NpdGlvbjtjb25zdCBpPVtdO2xldCBzPXRoaXMuaXY7Zm9yKGxldCB0PTA7dDxhOysrdCl7cltuXT1lW3RdOysrbjtpZihuPDE2KWNvbnRpbnVlO2NvbnN0IGE9dGhpcy5fZGVjcnlwdChyLHRoaXMuX2tleSk7Zm9yKGxldCBlPTA7ZTwxNjsrK2UpYVtlXV49c1tlXTtzPXI7aS5wdXNoKGEpO3I9bmV3IFVpbnQ4QXJyYXkoMTYpO249MH10aGlzLmJ1ZmZlcj1yO3RoaXMuYnVmZmVyTGVuZ3RoPW47dGhpcy5pdj1zO2lmKDA9PT1pLmxlbmd0aClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7bGV0IG89MTYqaS5sZW5ndGg7aWYodCl7Y29uc3QgZT1pLmF0KC0xKTtsZXQgdD1lWzE1XTtpZih0PD0xNil7Zm9yKGxldCBhPTE1LHI9MTYtdDthPj1yOy0tYSlpZihlW2FdIT09dCl7dD0wO2JyZWFrfW8tPXQ7aVtpLmxlbmd0aC0xXT1lLnN1YmFycmF5KDAsMTYtdCl9fWNvbnN0IGM9bmV3IFVpbnQ4QXJyYXkobyk7Zm9yKGxldCBlPTAsdD0wLGE9aS5sZW5ndGg7ZTxhOysrZSx0Kz0xNiljLnNldChpW2VdLHQpO3JldHVybiBjfWRlY3J5cHRCbG9jayhlLHQsYT1udWxsKXtjb25zdCByPWUubGVuZ3RoLG49dGhpcy5idWZmZXI7bGV0IGk9dGhpcy5idWZmZXJQb3NpdGlvbjtpZihhKXRoaXMuaXY9YTtlbHNle2ZvcihsZXQgdD0wO2k8MTYmJnQ8cjsrK3QsKytpKW5baV09ZVt0XTtpZihpPDE2KXt0aGlzLmJ1ZmZlckxlbmd0aD1pO3JldHVybiBuZXcgVWludDhBcnJheSgwKX10aGlzLml2PW47ZT1lLnN1YmFycmF5KDE2KX10aGlzLmJ1ZmZlcj1uZXcgVWludDhBcnJheSgxNik7dGhpcy5idWZmZXJMZW5ndGg9MDt0aGlzLmRlY3J5cHRCbG9jaz10aGlzLl9kZWNyeXB0QmxvY2syO3JldHVybiB0aGlzLmRlY3J5cHRCbG9jayhlLHQpfWVuY3J5cHQoZSx0KXtjb25zdCBhPWUubGVuZ3RoO2xldCByPXRoaXMuYnVmZmVyLG49dGhpcy5idWZmZXJQb3NpdGlvbjtjb25zdCBpPVtdO3R8fCh0PW5ldyBVaW50OEFycmF5KDE2KSk7Zm9yKGxldCBzPTA7czxhOysrcyl7cltuXT1lW3NdOysrbjtpZihuPDE2KWNvbnRpbnVlO2ZvcihsZXQgZT0wO2U8MTY7KytlKXJbZV1ePXRbZV07Y29uc3QgYT10aGlzLl9lbmNyeXB0KHIsdGhpcy5fa2V5KTt0PWE7aS5wdXNoKGEpO3I9bmV3IFVpbnQ4QXJyYXkoMTYpO249MH10aGlzLmJ1ZmZlcj1yO3RoaXMuYnVmZmVyTGVuZ3RoPW47dGhpcy5pdj10O2lmKDA9PT1pLmxlbmd0aClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7Y29uc3Qgcz0xNippLmxlbmd0aCxvPW5ldyBVaW50OEFycmF5KHMpO2ZvcihsZXQgZT0wLHQ9MCxhPWkubGVuZ3RoO2U8YTsrK2UsdCs9MTYpby5zZXQoaVtlXSx0KTtyZXR1cm4gb319Y2xhc3MgQUVTMTI4Q2lwaGVyIGV4dGVuZHMgQUVTQmFzZUNpcGhlcntjb25zdHJ1Y3RvcihlKXtzdXBlcigpO3RoaXMuX2N5Y2xlc09mUmVwZXRpdGlvbj0xMDt0aGlzLl9rZXlTaXplPTE2MDt0aGlzLl9yY29uPW5ldyBVaW50OEFycmF5KFsxNDEsMSwyLDQsOCwxNiwzMiw2NCwxMjgsMjcsNTQsMTA4LDIxNiwxNzEsNzcsMTU0LDQ3LDk0LDE4OCw5OSwxOTgsMTUxLDUzLDEwNiwyMTIsMTc5LDEyNSwyNTAsMjM5LDE5NywxNDUsNTcsMTE0LDIyOCwyMTEsMTg5LDk3LDE5NCwxNTksMzcsNzQsMTQ4LDUxLDEwMiwyMDQsMTMxLDI5LDU4LDExNiwyMzIsMjAzLDE0MSwxLDIsNCw4LDE2LDMyLDY0LDEyOCwyNyw1NCwxMDgsMjE2LDE3MSw3NywxNTQsNDcsOTQsMTg4LDk5LDE5OCwxNTEsNTMsMTA2LDIxMiwxNzksMTI1LDI1MCwyMzksMTk3LDE0NSw1NywxMTQsMjI4LDIxMSwxODksOTcsMTk0LDE1OSwzNyw3NCwxNDgsNTEsMTAyLDIwNCwxMzEsMjksNTgsMTE2LDIzMiwyMDMsMTQxLDEsMiw0LDgsMTYsMzIsNjQsMTI4LDI3LDU0LDEwOCwyMTYsMTcxLDc3LDE1NCw0Nyw5NCwxODgsOTksMTk4LDE1MSw1MywxMDYsMjEyLDE3OSwxMjUsMjUwLDIzOSwxOTcsMTQ1LDU3LDExNCwyMjgsMjExLDE4OSw5NywxOTQsMTU5LDM3LDc0LDE0OCw1MSwxMDIsMjA0LDEzMSwyOSw1OCwxMTYsMjMyLDIwMywxNDEsMSwyLDQsOCwxNiwzMiw2NCwxMjgsMjcsNTQsMTA4LDIxNiwxNzEsNzcsMTU0LDQ3LDk0LDE4OCw5OSwxOTgsMTUxLDUzLDEwNiwyMTIsMTc5LDEyNSwyNTAsMjM5LDE5NywxNDUsNTcsMTE0LDIyOCwyMTEsMTg5LDk3LDE5NCwxNTksMzcsNzQsMTQ4LDUxLDEwMiwyMDQsMTMxLDI5LDU4LDExNiwyMzIsMjAzLDE0MSwxLDIsNCw4LDE2LDMyLDY0LDEyOCwyNyw1NCwxMDgsMjE2LDE3MSw3NywxNTQsNDcsOTQsMTg4LDk5LDE5OCwxNTEsNTMsMTA2LDIxMiwxNzksMTI1LDI1MCwyMzksMTk3LDE0NSw1NywxMTQsMjI4LDIxMSwxODksOTcsMTk0LDE1OSwzNyw3NCwxNDgsNTEsMTAyLDIwNCwxMzEsMjksNTgsMTE2LDIzMiwyMDMsMTQxXSk7dGhpcy5fa2V5PXRoaXMuX2V4cGFuZEtleShlKX1fZXhwYW5kS2V5KGUpe2NvbnN0IHQ9dGhpcy5fcyxhPXRoaXMuX3Jjb24scj1uZXcgVWludDhBcnJheSgxNzYpO3Iuc2V0KGUpO2ZvcihsZXQgZT0xNixuPTE7ZTwxNzY7KytuKXtsZXQgaT1yW2UtM10scz1yW2UtMl0sbz1yW2UtMV0sYz1yW2UtNF07aT10W2ldO3M9dFtzXTtvPXRbb107Yz10W2NdO2lePWFbbl07Zm9yKGxldCB0PTA7dDw0OysrdCl7cltlXT1pXj1yW2UtMTZdO2UrKztyW2VdPXNePXJbZS0xNl07ZSsrO3JbZV09b149cltlLTE2XTtlKys7cltlXT1jXj1yW2UtMTZdO2UrK319cmV0dXJuIHJ9fXQuQUVTMTI4Q2lwaGVyPUFFUzEyOENpcGhlcjtjbGFzcyBBRVMyNTZDaXBoZXIgZXh0ZW5kcyBBRVNCYXNlQ2lwaGVye2NvbnN0cnVjdG9yKGUpe3N1cGVyKCk7dGhpcy5fY3ljbGVzT2ZSZXBldGl0aW9uPTE0O3RoaXMuX2tleVNpemU9MjI0O3RoaXMuX2tleT10aGlzLl9leHBhbmRLZXkoZSl9X2V4cGFuZEtleShlKXtjb25zdCB0PXRoaXMuX3MsYT1uZXcgVWludDhBcnJheSgyNDApO2Euc2V0KGUpO2xldCByLG4saSxzLG89MTtmb3IobGV0IGU9MzIsYz0xO2U8MjQwOysrYyl7aWYoZSUzMj09MTYpe3I9dFtyXTtuPXRbbl07aT10W2ldO3M9dFtzXX1lbHNlIGlmKGUlMzI9PTApe3I9YVtlLTNdO249YVtlLTJdO2k9YVtlLTFdO3M9YVtlLTRdO3I9dFtyXTtuPXRbbl07aT10W2ldO3M9dFtzXTtyXj1vOyhvPDw9MSk+PTI1NiYmKG89MjU1JigyN15vKSl9Zm9yKGxldCB0PTA7dDw0OysrdCl7YVtlXT1yXj1hW2UtMzJdO2UrKzthW2VdPW5ePWFbZS0zMl07ZSsrO2FbZV09aV49YVtlLTMyXTtlKys7YVtlXT1zXj1hW2UtMzJdO2UrK319cmV0dXJuIGF9fXQuQUVTMjU2Q2lwaGVyPUFFUzI1NkNpcGhlcjtjbGFzcyBQREYxN3tjaGVja093bmVyUGFzc3dvcmQoZSx0LGEsbil7Y29uc3QgaT1uZXcgVWludDhBcnJheShlLmxlbmd0aCs1Nik7aS5zZXQoZSwwKTtpLnNldCh0LGUubGVuZ3RoKTtpLnNldChhLGUubGVuZ3RoK3QubGVuZ3RoKTtjb25zdCBzPW8oaSwwLGkubGVuZ3RoKTtyZXR1cm4oMCxyLmlzQXJyYXlFcXVhbCkocyxuKX1jaGVja1VzZXJQYXNzd29yZChlLHQsYSl7Y29uc3Qgbj1uZXcgVWludDhBcnJheShlLmxlbmd0aCs4KTtuLnNldChlLDApO24uc2V0KHQsZS5sZW5ndGgpO2NvbnN0IGk9byhuLDAsbi5sZW5ndGgpO3JldHVybigwLHIuaXNBcnJheUVxdWFsKShpLGEpfWdldE93bmVyS2V5KGUsdCxhLHIpe2NvbnN0IG49bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgrNTYpO24uc2V0KGUsMCk7bi5zZXQodCxlLmxlbmd0aCk7bi5zZXQoYSxlLmxlbmd0aCt0Lmxlbmd0aCk7Y29uc3QgaT1vKG4sMCxuLmxlbmd0aCk7cmV0dXJuIG5ldyBBRVMyNTZDaXBoZXIoaSkuZGVjcnlwdEJsb2NrKHIsITEsbmV3IFVpbnQ4QXJyYXkoMTYpKX1nZXRVc2VyS2V5KGUsdCxhKXtjb25zdCByPW5ldyBVaW50OEFycmF5KGUubGVuZ3RoKzgpO3Iuc2V0KGUsMCk7ci5zZXQodCxlLmxlbmd0aCk7Y29uc3Qgbj1vKHIsMCxyLmxlbmd0aCk7cmV0dXJuIG5ldyBBRVMyNTZDaXBoZXIobikuZGVjcnlwdEJsb2NrKGEsITEsbmV3IFVpbnQ4QXJyYXkoMTYpKX19dC5QREYxNz1QREYxNztjb25zdCBsPWZ1bmN0aW9uIFBERjIwQ2xvc3VyZSgpe2Z1bmN0aW9uIGNhbGN1bGF0ZVBERjIwSGFzaChlLHQsYSl7bGV0IHI9byh0LDAsdC5sZW5ndGgpLnN1YmFycmF5KDAsMzIpLG49WzBdLGk9MDtmb3IoO2k8NjR8fG4uYXQoLTEpPmktMzI7KXtjb25zdCB0PWUubGVuZ3RoK3IubGVuZ3RoK2EubGVuZ3RoLHM9bmV3IFVpbnQ4QXJyYXkodCk7bGV0IGw9MDtzLnNldChlLGwpO2wrPWUubGVuZ3RoO3Muc2V0KHIsbCk7bCs9ci5sZW5ndGg7cy5zZXQoYSxsKTtjb25zdCBoPW5ldyBVaW50OEFycmF5KDY0KnQpO2ZvcihsZXQgZT0wLGE9MDtlPDY0O2UrKyxhKz10KWguc2V0KHMsYSk7bj1uZXcgQUVTMTI4Q2lwaGVyKHIuc3ViYXJyYXkoMCwxNikpLmVuY3J5cHQoaCxyLnN1YmFycmF5KDE2LDMyKSk7bGV0IHU9MDtmb3IobGV0IGU9MDtlPDE2O2UrKyl7dSo9MTt1JT0zO3UrPShuW2VdPj4+MCklMzt1JT0zfTA9PT11P3I9byhuLDAsbi5sZW5ndGgpOjE9PT11P3I9Y2FsY3VsYXRlU0hBMzg0KG4sMCxuLmxlbmd0aCk6Mj09PXUmJihyPWMobiwwLG4ubGVuZ3RoKSk7aSsrfXJldHVybiByLnN1YmFycmF5KDAsMzIpfXJldHVybiBjbGFzcyBQREYyMHtoYXNoKGUsdCxhKXtyZXR1cm4gY2FsY3VsYXRlUERGMjBIYXNoKGUsdCxhKX1jaGVja093bmVyUGFzc3dvcmQoZSx0LGEsbil7Y29uc3QgaT1uZXcgVWludDhBcnJheShlLmxlbmd0aCs1Nik7aS5zZXQoZSwwKTtpLnNldCh0LGUubGVuZ3RoKTtpLnNldChhLGUubGVuZ3RoK3QubGVuZ3RoKTtjb25zdCBzPWNhbGN1bGF0ZVBERjIwSGFzaChlLGksYSk7cmV0dXJuKDAsci5pc0FycmF5RXF1YWwpKHMsbil9Y2hlY2tVc2VyUGFzc3dvcmQoZSx0LGEpe2NvbnN0IG49bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgrOCk7bi5zZXQoZSwwKTtuLnNldCh0LGUubGVuZ3RoKTtjb25zdCBpPWNhbGN1bGF0ZVBERjIwSGFzaChlLG4sW10pO3JldHVybigwLHIuaXNBcnJheUVxdWFsKShpLGEpfWdldE93bmVyS2V5KGUsdCxhLHIpe2NvbnN0IG49bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgrNTYpO24uc2V0KGUsMCk7bi5zZXQodCxlLmxlbmd0aCk7bi5zZXQoYSxlLmxlbmd0aCt0Lmxlbmd0aCk7Y29uc3QgaT1jYWxjdWxhdGVQREYyMEhhc2goZSxuLGEpO3JldHVybiBuZXcgQUVTMjU2Q2lwaGVyKGkpLmRlY3J5cHRCbG9jayhyLCExLG5ldyBVaW50OEFycmF5KDE2KSl9Z2V0VXNlcktleShlLHQsYSl7Y29uc3Qgcj1uZXcgVWludDhBcnJheShlLmxlbmd0aCs4KTtyLnNldChlLDApO3Iuc2V0KHQsZS5sZW5ndGgpO2NvbnN0IG49Y2FsY3VsYXRlUERGMjBIYXNoKGUscixbXSk7cmV0dXJuIG5ldyBBRVMyNTZDaXBoZXIobikuZGVjcnlwdEJsb2NrKGEsITEsbmV3IFVpbnQ4QXJyYXkoMTYpKX19fSgpO3QuUERGMjA9bDtjbGFzcyBDaXBoZXJUcmFuc2Zvcm17Y29uc3RydWN0b3IoZSx0KXt0aGlzLlN0cmluZ0NpcGhlckNvbnN0cnVjdG9yPWU7dGhpcy5TdHJlYW1DaXBoZXJDb25zdHJ1Y3Rvcj10fWNyZWF0ZVN0cmVhbShlLHQpe2NvbnN0IGE9bmV3IHRoaXMuU3RyZWFtQ2lwaGVyQ29uc3RydWN0b3I7cmV0dXJuIG5ldyBpLkRlY3J5cHRTdHJlYW0oZSx0LChmdW5jdGlvbiBjaXBoZXJUcmFuc2Zvcm1EZWNyeXB0U3RyZWFtKGUsdCl7cmV0dXJuIGEuZGVjcnlwdEJsb2NrKGUsdCl9KSl9ZGVjcnlwdFN0cmluZyhlKXtjb25zdCB0PW5ldyB0aGlzLlN0cmluZ0NpcGhlckNvbnN0cnVjdG9yO2xldCBhPSgwLHIuc3RyaW5nVG9CeXRlcykoZSk7YT10LmRlY3J5cHRCbG9jayhhLCEwKTtyZXR1cm4oMCxyLmJ5dGVzVG9TdHJpbmcpKGEpfWVuY3J5cHRTdHJpbmcoZSl7Y29uc3QgdD1uZXcgdGhpcy5TdHJpbmdDaXBoZXJDb25zdHJ1Y3RvcjtpZih0IGluc3RhbmNlb2YgQUVTQmFzZUNpcGhlcil7Y29uc3QgYT0xNi1lLmxlbmd0aCUxNjtlKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpLnJlcGVhdChhKTtjb25zdCBuPW5ldyBVaW50OEFycmF5KDE2KTtpZigidW5kZWZpbmVkIiE9dHlwZW9mIGNyeXB0byljcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG4pO2Vsc2UgZm9yKGxldCBlPTA7ZTwxNjtlKyspbltlXT1NYXRoLmZsb29yKDI1NipNYXRoLnJhbmRvbSgpKTtsZXQgaT0oMCxyLnN0cmluZ1RvQnl0ZXMpKGUpO2k9dC5lbmNyeXB0KGksbik7Y29uc3Qgcz1uZXcgVWludDhBcnJheSgxNitpLmxlbmd0aCk7cy5zZXQobik7cy5zZXQoaSwxNik7cmV0dXJuKDAsci5ieXRlc1RvU3RyaW5nKShzKX1sZXQgYT0oMCxyLnN0cmluZ1RvQnl0ZXMpKGUpO2E9dC5lbmNyeXB0KGEpO3JldHVybigwLHIuYnl0ZXNUb1N0cmluZykoYSl9fWNvbnN0IGg9ZnVuY3Rpb24gQ2lwaGVyVHJhbnNmb3JtRmFjdG9yeUNsb3N1cmUoKXtjb25zdCBlPW5ldyBVaW50OEFycmF5KFs0MCwxOTEsNzgsOTQsNzgsMTE3LDEzOCw2NSwxMDAsMCw3OCw4NiwyNTUsMjUwLDEsOCw0Niw0NiwwLDE4MiwyMDgsMTA0LDYyLDEyOCw0NywxMiwxNjksMjU0LDEwMCw4MywxMDUsMTIyXSk7ZnVuY3Rpb24gcHJlcGFyZUtleURhdGEodCxhLHIsbixpLG8sYyxsKXtjb25zdCBoPTQwK3IubGVuZ3RoK3QubGVuZ3RoLHU9bmV3IFVpbnQ4QXJyYXkoaCk7bGV0IGQsZixnPTA7aWYoYSl7Zj1NYXRoLm1pbigzMixhLmxlbmd0aCk7Zm9yKDtnPGY7KytnKXVbZ109YVtnXX1kPTA7Zm9yKDtnPDMyOyl1W2crK109ZVtkKytdO2ZvcihkPTAsZj1yLmxlbmd0aDtkPGY7KytkKXVbZysrXT1yW2RdO3VbZysrXT0yNTUmaTt1W2crK109aT4+OCYyNTU7dVtnKytdPWk+PjE2JjI1NTt1W2crK109aT4+PjI0JjI1NTtmb3IoZD0wLGY9dC5sZW5ndGg7ZDxmOysrZCl1W2crK109dFtkXTtpZihvPj00JiYhbCl7dVtnKytdPTI1NTt1W2crK109MjU1O3VbZysrXT0yNTU7dVtnKytdPTI1NX1sZXQgcD1zKHUsMCxnKTtjb25zdCBtPWM+PjM7aWYobz49Mylmb3IoZD0wO2Q8NTA7KytkKXA9cyhwLDAsbSk7Y29uc3QgYj1wLnN1YmFycmF5KDAsbSk7bGV0IHksdztpZihvPj0zKXtmb3IoZz0wO2c8MzI7KytnKXVbZ109ZVtnXTtmb3IoZD0wLGY9dC5sZW5ndGg7ZDxmOysrZCl1W2crK109dFtkXTt5PW5ldyBBUkNGb3VyQ2lwaGVyKGIpO3c9eS5lbmNyeXB0QmxvY2socyh1LDAsZykpO2Y9Yi5sZW5ndGg7Y29uc3QgYT1uZXcgVWludDhBcnJheShmKTtmb3IoZD0xO2Q8PTE5OysrZCl7Zm9yKGxldCBlPTA7ZTxmOysrZSlhW2VdPWJbZV1eZDt5PW5ldyBBUkNGb3VyQ2lwaGVyKGEpO3c9eS5lbmNyeXB0QmxvY2sodyl9Zm9yKGQ9MCxmPXcubGVuZ3RoO2Q8ZjsrK2QpaWYobltkXSE9PXdbZF0pcmV0dXJuIG51bGx9ZWxzZXt5PW5ldyBBUkNGb3VyQ2lwaGVyKGIpO3c9eS5lbmNyeXB0QmxvY2soZSk7Zm9yKGQ9MCxmPXcubGVuZ3RoO2Q8ZjsrK2QpaWYobltkXSE9PXdbZF0pcmV0dXJuIG51bGx9cmV0dXJuIGJ9Y29uc3QgdD1uLk5hbWUuZ2V0KCJJZGVudGl0eSIpO2Z1bmN0aW9uIGJ1aWxkT2JqZWN0S2V5KGUsdCxhLHI9ITEpe2NvbnN0IG49bmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGgrOSksaT1hLmxlbmd0aDtsZXQgbztmb3Iobz0wO288aTsrK28pbltvXT1hW29dO25bbysrXT0yNTUmZTtuW28rK109ZT4+OCYyNTU7bltvKytdPWU+PjE2JjI1NTtuW28rK109MjU1JnQ7bltvKytdPXQ+PjgmMjU1O2lmKHIpe25bbysrXT0xMTU7bltvKytdPTY1O25bbysrXT0xMDg7bltvKytdPTg0fXJldHVybiBzKG4sMCxvKS5zdWJhcnJheSgwLE1hdGgubWluKGEubGVuZ3RoKzUsMTYpKX1mdW5jdGlvbiBidWlsZENpcGhlckNvbnN0cnVjdG9yKGUsdCxhLGkscyl7aWYoISh0IGluc3RhbmNlb2Ygbi5OYW1lKSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiSW52YWxpZCBjcnlwdCBmaWx0ZXIgbmFtZS4iKTtjb25zdCBvPWUuZ2V0KHQubmFtZSk7bGV0IGM7bnVsbCE9byYmKGM9by5nZXQoIkNGTSIpKTtpZighY3x8Ik5vbmUiPT09Yy5uYW1lKXJldHVybiBmdW5jdGlvbiBjaXBoZXJUcmFuc2Zvcm1GYWN0b3J5QnVpbGRDaXBoZXJDb25zdHJ1Y3Rvck5vbmUoKXtyZXR1cm4gbmV3IE51bGxDaXBoZXJ9O2lmKCJWMiI9PT1jLm5hbWUpcmV0dXJuIGZ1bmN0aW9uIGNpcGhlclRyYW5zZm9ybUZhY3RvcnlCdWlsZENpcGhlckNvbnN0cnVjdG9yVjIoKXtyZXR1cm4gbmV3IEFSQ0ZvdXJDaXBoZXIoYnVpbGRPYmplY3RLZXkoYSxpLHMsITEpKX07aWYoIkFFU1YyIj09PWMubmFtZSlyZXR1cm4gZnVuY3Rpb24gY2lwaGVyVHJhbnNmb3JtRmFjdG9yeUJ1aWxkQ2lwaGVyQ29uc3RydWN0b3JBRVNWMigpe3JldHVybiBuZXcgQUVTMTI4Q2lwaGVyKGJ1aWxkT2JqZWN0S2V5KGEsaSxzLCEwKSl9O2lmKCJBRVNWMyI9PT1jLm5hbWUpcmV0dXJuIGZ1bmN0aW9uIGNpcGhlclRyYW5zZm9ybUZhY3RvcnlCdWlsZENpcGhlckNvbnN0cnVjdG9yQUVTVjMoKXtyZXR1cm4gbmV3IEFFUzI1NkNpcGhlcihzKX07dGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoIlVua25vd24gY3J5cHRvIG1ldGhvZCIpfXJldHVybiBjbGFzcyBDaXBoZXJUcmFuc2Zvcm1GYWN0b3J5e2NvbnN0cnVjdG9yKGEsaSxvKXtjb25zdCBjPWEuZ2V0KCJGaWx0ZXIiKTtpZighKDAsbi5pc05hbWUpKGMsIlN0YW5kYXJkIikpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoInVua25vd24gZW5jcnlwdGlvbiBtZXRob2QiKTt0aGlzLmZpbHRlck5hbWU9Yy5uYW1lO3RoaXMuZGljdD1hO2NvbnN0IGg9YS5nZXQoIlYiKTtpZighTnVtYmVyLmlzSW50ZWdlcihoKXx8MSE9PWgmJjIhPT1oJiY0IT09aCYmNSE9PWgpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoInVuc3VwcG9ydGVkIGVuY3J5cHRpb24gYWxnb3JpdGhtIik7dGhpcy5hbGdvcml0aG09aDtsZXQgdT1hLmdldCgiTGVuZ3RoIik7aWYoIXUpaWYoaDw9Myl1PTQwO2Vsc2V7Y29uc3QgZT1hLmdldCgiQ0YiKSx0PWEuZ2V0KCJTdG1GIik7aWYoZSBpbnN0YW5jZW9mIG4uRGljdCYmdCBpbnN0YW5jZW9mIG4uTmFtZSl7ZS5zdXBwcmVzc0VuY3J5cHRpb249ITA7Y29uc3QgYT1lLmdldCh0Lm5hbWUpO3U9YSYmYS5nZXQoIkxlbmd0aCIpfHwxMjg7dTw0MCYmKHU8PD0zKX19aWYoIU51bWJlci5pc0ludGVnZXIodSl8fHU8NDB8fHUlOCE9MCl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiaW52YWxpZCBrZXkgbGVuZ3RoIik7Y29uc3QgZD0oMCxyLnN0cmluZ1RvQnl0ZXMpKGEuZ2V0KCJPIikpLnN1YmFycmF5KDAsMzIpLGY9KDAsci5zdHJpbmdUb0J5dGVzKShhLmdldCgiVSIpKS5zdWJhcnJheSgwLDMyKSxnPWEuZ2V0KCJQIikscD1hLmdldCgiUiIpLG09KDQ9PT1ofHw1PT09aCkmJiExIT09YS5nZXQoIkVuY3J5cHRNZXRhZGF0YSIpO3RoaXMuZW5jcnlwdE1ldGFkYXRhPW07Y29uc3QgYj0oMCxyLnN0cmluZ1RvQnl0ZXMpKGkpO2xldCB5LHc7aWYobyl7aWYoNj09PXApdHJ5e289KDAsci51dGY4U3RyaW5nVG9TdHJpbmcpKG8pfWNhdGNoKGUpeygwLHIud2FybikoIkNpcGhlclRyYW5zZm9ybUZhY3Rvcnk6IFVuYWJsZSB0byBjb252ZXJ0IFVURjggZW5jb2RlZCBwYXNzd29yZC4iKX15PSgwLHIuc3RyaW5nVG9CeXRlcykobyl9aWYoNSE9PWgpdz1wcmVwYXJlS2V5RGF0YShiLHksZCxmLGcscCx1LG0pO2Vsc2V7Y29uc3QgZT0oMCxyLnN0cmluZ1RvQnl0ZXMpKGEuZ2V0KCJPIikpLnN1YmFycmF5KDMyLDQwKSx0PSgwLHIuc3RyaW5nVG9CeXRlcykoYS5nZXQoIk8iKSkuc3ViYXJyYXkoNDAsNDgpLG49KDAsci5zdHJpbmdUb0J5dGVzKShhLmdldCgiVSIpKS5zdWJhcnJheSgwLDQ4KSxpPSgwLHIuc3RyaW5nVG9CeXRlcykoYS5nZXQoIlUiKSkuc3ViYXJyYXkoMzIsNDApLHM9KDAsci5zdHJpbmdUb0J5dGVzKShhLmdldCgiVSIpKS5zdWJhcnJheSg0MCw0OCksbz0oMCxyLnN0cmluZ1RvQnl0ZXMpKGEuZ2V0KCJPRSIpKSxjPSgwLHIuc3RyaW5nVG9CeXRlcykoYS5nZXQoIlVFIikpOygwLHIuc3RyaW5nVG9CeXRlcykoYS5nZXQoIlBlcm1zIikpO3c9ZnVuY3Rpb24gY3JlYXRlRW5jcnlwdGlvbktleTIwKGUsdCxhLHIsbixpLHMsbyxjLGgsdSxkKXtpZih0KXtjb25zdCBlPU1hdGgubWluKDEyNyx0Lmxlbmd0aCk7dD10LnN1YmFycmF5KDAsZSl9ZWxzZSB0PVtdO2xldCBmO2Y9Nj09PWU/bmV3IGw6bmV3IFBERjE3O3JldHVybiBmLmNoZWNrVXNlclBhc3N3b3JkKHQsbyxzKT9mLmdldFVzZXJLZXkodCxjLHUpOnQubGVuZ3RoJiZmLmNoZWNrT3duZXJQYXNzd29yZCh0LHIsaSxhKT9mLmdldE93bmVyS2V5KHQsbixpLGgpOm51bGx9KHAseSxkLGUsdCxuLGYsaSxzLG8sYyl9aWYoIXcmJiFvKXRocm93IG5ldyByLlBhc3N3b3JkRXhjZXB0aW9uKCJObyBwYXNzd29yZCBnaXZlbiIsci5QYXNzd29yZFJlc3BvbnNlcy5ORUVEX1BBU1NXT1JEKTtpZighdyYmbyl7Y29uc3QgdD1mdW5jdGlvbiBkZWNvZGVVc2VyUGFzc3dvcmQodCxhLHIsbil7Y29uc3QgaT1uZXcgVWludDhBcnJheSgzMik7bGV0IG89MDtjb25zdCBjPU1hdGgubWluKDMyLHQubGVuZ3RoKTtmb3IoO288YzsrK28paVtvXT10W29dO2xldCBsPTA7Zm9yKDtvPDMyOylpW28rK109ZVtsKytdO2xldCBoPXMoaSwwLG8pO2NvbnN0IHU9bj4+MztpZihyPj0zKWZvcihsPTA7bDw1MDsrK2wpaD1zKGgsMCxoLmxlbmd0aCk7bGV0IGQsZjtpZihyPj0zKXtmPWE7Y29uc3QgZT1uZXcgVWludDhBcnJheSh1KTtmb3IobD0xOTtsPj0wO2wtLSl7Zm9yKGxldCB0PTA7dDx1OysrdCllW3RdPWhbdF1ebDtkPW5ldyBBUkNGb3VyQ2lwaGVyKGUpO2Y9ZC5lbmNyeXB0QmxvY2soZil9fWVsc2V7ZD1uZXcgQVJDRm91ckNpcGhlcihoLnN1YmFycmF5KDAsdSkpO2Y9ZC5lbmNyeXB0QmxvY2soYSl9cmV0dXJuIGZ9KHksZCxwLHUpO3c9cHJlcGFyZUtleURhdGEoYix0LGQsZixnLHAsdSxtKX1pZighdyl0aHJvdyBuZXcgci5QYXNzd29yZEV4Y2VwdGlvbigiSW5jb3JyZWN0IFBhc3N3b3JkIixyLlBhc3N3b3JkUmVzcG9uc2VzLklOQ09SUkVDVF9QQVNTV09SRCk7dGhpcy5lbmNyeXB0aW9uS2V5PXc7aWYoaD49NCl7Y29uc3QgZT1hLmdldCgiQ0YiKTtlIGluc3RhbmNlb2Ygbi5EaWN0JiYoZS5zdXBwcmVzc0VuY3J5cHRpb249ITApO3RoaXMuY2Y9ZTt0aGlzLnN0bWY9YS5nZXQoIlN0bUYiKXx8dDt0aGlzLnN0cmY9YS5nZXQoIlN0ckYiKXx8dDt0aGlzLmVmZj1hLmdldCgiRUZGIil8fHRoaXMuc3RtZn19Y3JlYXRlQ2lwaGVyVHJhbnNmb3JtKGUsdCl7aWYoND09PXRoaXMuYWxnb3JpdGhtfHw1PT09dGhpcy5hbGdvcml0aG0pcmV0dXJuIG5ldyBDaXBoZXJUcmFuc2Zvcm0oYnVpbGRDaXBoZXJDb25zdHJ1Y3Rvcih0aGlzLmNmLHRoaXMuc3RyZixlLHQsdGhpcy5lbmNyeXB0aW9uS2V5KSxidWlsZENpcGhlckNvbnN0cnVjdG9yKHRoaXMuY2YsdGhpcy5zdG1mLGUsdCx0aGlzLmVuY3J5cHRpb25LZXkpKTtjb25zdCBhPWJ1aWxkT2JqZWN0S2V5KGUsdCx0aGlzLmVuY3J5cHRpb25LZXksITEpLHI9ZnVuY3Rpb24gYnVpbGRDaXBoZXJDaXBoZXJDb25zdHJ1Y3Rvcigpe3JldHVybiBuZXcgQVJDRm91ckNpcGhlcihhKX07cmV0dXJuIG5ldyBDaXBoZXJUcmFuc2Zvcm0ocixyKX19fSgpO3QuQ2lwaGVyVHJhbnNmb3JtRmFjdG9yeT1ofSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuRGVjcnlwdFN0cmVhbT12b2lkIDA7dmFyIHI9YSgxOSk7Y2xhc3MgRGVjcnlwdFN0cmVhbSBleHRlbmRzIHIuRGVjb2RlU3RyZWFte2NvbnN0cnVjdG9yKGUsdCxhKXtzdXBlcih0KTt0aGlzLnN0cj1lO3RoaXMuZGljdD1lLmRpY3Q7dGhpcy5kZWNyeXB0PWE7dGhpcy5uZXh0Q2h1bms9bnVsbDt0aGlzLmluaXRpYWxpemVkPSExfXJlYWRCbG9jaygpe2xldCBlO2lmKHRoaXMuaW5pdGlhbGl6ZWQpZT10aGlzLm5leHRDaHVuaztlbHNle2U9dGhpcy5zdHIuZ2V0Qnl0ZXMoNTEyKTt0aGlzLmluaXRpYWxpemVkPSEwfWlmKCFlfHwwPT09ZS5sZW5ndGgpe3RoaXMuZW9mPSEwO3JldHVybn10aGlzLm5leHRDaHVuaz10aGlzLnN0ci5nZXRCeXRlcyg1MTIpO2NvbnN0IHQ9dGhpcy5uZXh0Q2h1bmsmJnRoaXMubmV4dENodW5rLmxlbmd0aD4wO2U9KDAsdGhpcy5kZWNyeXB0KShlLCF0KTtsZXQgYT10aGlzLmJ1ZmZlckxlbmd0aDtjb25zdCByPWUubGVuZ3RoLG49dGhpcy5lbnN1cmVCdWZmZXIoYStyKTtmb3IobGV0IHQ9MDt0PHI7dCsrKW5bYSsrXT1lW3RdO3RoaXMuYnVmZmVyTGVuZ3RoPWF9fXQuRGVjcnlwdFN0cmVhbT1EZWNyeXB0U3RyZWFtfSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuQ2F0YWxvZz12b2lkIDA7dmFyIHI9YSg2KSxuPWEoMiksaT1hKDUpLHM9YSg3MCksbz1hKDcpLGM9YSg3MSksbD1hKDE0KSxoPWEoNzIpLHU9YSg1OSksZD1hKDczKSxmPWEoNzQpO2Z1bmN0aW9uIGZldGNoRGVzdGluYXRpb24oZSl7ZSBpbnN0YW5jZW9mIGkuRGljdCYmKGU9ZS5nZXQoIkQiKSk7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/ZTpudWxsfWNsYXNzIENhdGFsb2d7Y29uc3RydWN0b3IoZSx0KXt0aGlzLnBkZk1hbmFnZXI9ZTt0aGlzLnhyZWY9dDt0aGlzLl9jYXREaWN0PXQuZ2V0Q2F0YWxvZ09iaigpO2lmKCEodGhpcy5fY2F0RGljdCBpbnN0YW5jZW9mIGkuRGljdCkpdGhyb3cgbmV3IG4uRm9ybWF0RXJyb3IoIkNhdGFsb2cgb2JqZWN0IGlzIG5vdCBhIGRpY3Rpb25hcnkuIik7dGhpcy50b3BsZXZlbFBhZ2VzRGljdDt0aGlzLl9hY3R1YWxOdW1QYWdlcz1udWxsO3RoaXMuZm9udENhY2hlPW5ldyBpLlJlZlNldENhY2hlO3RoaXMuYnVpbHRJbkNNYXBDYWNoZT1uZXcgTWFwO3RoaXMuc3RhbmRhcmRGb250RGF0YUNhY2hlPW5ldyBNYXA7dGhpcy5nbG9iYWxJbWFnZUNhY2hlPW5ldyB1Lkdsb2JhbEltYWdlQ2FjaGU7dGhpcy5wYWdlS2lkc0NvdW50Q2FjaGU9bmV3IGkuUmVmU2V0Q2FjaGU7dGhpcy5wYWdlSW5kZXhDYWNoZT1uZXcgaS5SZWZTZXRDYWNoZTt0aGlzLm5vbkJsZW5kTW9kZXNTZXQ9bmV3IGkuUmVmU2V0fWdldCB2ZXJzaW9uKCl7Y29uc3QgZT10aGlzLl9jYXREaWN0LmdldCgiVmVyc2lvbiIpO3JldHVybigwLG4uc2hhZG93KSh0aGlzLCJ2ZXJzaW9uIixlIGluc3RhbmNlb2YgaS5OYW1lP2UubmFtZTpudWxsKX1nZXQgbGFuZygpe2NvbnN0IGU9dGhpcy5fY2F0RGljdC5nZXQoIkxhbmciKTtyZXR1cm4oMCxuLnNoYWRvdykodGhpcywibGFuZyIsInN0cmluZyI9PXR5cGVvZiBlPygwLG4uc3RyaW5nVG9QREZTdHJpbmcpKGUpOm51bGwpfWdldCBuZWVkc1JlbmRlcmluZygpe2NvbnN0IGU9dGhpcy5fY2F0RGljdC5nZXQoIk5lZWRzUmVuZGVyaW5nIik7cmV0dXJuKDAsbi5zaGFkb3cpKHRoaXMsIm5lZWRzUmVuZGVyaW5nIiwiYm9vbGVhbiI9PXR5cGVvZiBlJiZlKX1nZXQgY29sbGVjdGlvbigpe2xldCBlPW51bGw7dHJ5e2NvbnN0IHQ9dGhpcy5fY2F0RGljdC5nZXQoIkNvbGxlY3Rpb24iKTt0IGluc3RhbmNlb2YgaS5EaWN0JiZ0LnNpemU+MCYmKGU9dCl9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIHIuTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZTsoMCxuLmluZm8pKCJDYW5ub3QgZmV0Y2ggQ29sbGVjdGlvbiBlbnRyeTsgYXNzdW1pbmcgbm8gY29sbGVjdGlvbiBpcyBwcmVzZW50LiIpfXJldHVybigwLG4uc2hhZG93KSh0aGlzLCJjb2xsZWN0aW9uIixlKX1nZXQgYWNyb0Zvcm0oKXtsZXQgZT1udWxsO3RyeXtjb25zdCB0PXRoaXMuX2NhdERpY3QuZ2V0KCJBY3JvRm9ybSIpO3QgaW5zdGFuY2VvZiBpLkRpY3QmJnQuc2l6ZT4wJiYoZT10KX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2Ygci5NaXNzaW5nRGF0YUV4Y2VwdGlvbil0aHJvdyBlOygwLG4uaW5mbykoIkNhbm5vdCBmZXRjaCBBY3JvRm9ybSBlbnRyeTsgYXNzdW1pbmcgbm8gZm9ybXMgYXJlIHByZXNlbnQuIil9cmV0dXJuKDAsbi5zaGFkb3cpKHRoaXMsImFjcm9Gb3JtIixlKX1nZXQgYWNyb0Zvcm1SZWYoKXtjb25zdCBlPXRoaXMuX2NhdERpY3QuZ2V0UmF3KCJBY3JvRm9ybSIpO3JldHVybigwLG4uc2hhZG93KSh0aGlzLCJhY3JvRm9ybVJlZiIsZSBpbnN0YW5jZW9mIGkuUmVmP2U6bnVsbCl9Z2V0IG1ldGFkYXRhKCl7Y29uc3QgZT10aGlzLl9jYXREaWN0LmdldFJhdygiTWV0YWRhdGEiKTtpZighKGUgaW5zdGFuY2VvZiBpLlJlZikpcmV0dXJuKDAsbi5zaGFkb3cpKHRoaXMsIm1ldGFkYXRhIixudWxsKTtsZXQgdD1udWxsO3RyeXtjb25zdCBhPSEodGhpcy54cmVmLmVuY3J5cHQmJnRoaXMueHJlZi5lbmNyeXB0LmVuY3J5cHRNZXRhZGF0YSkscj10aGlzLnhyZWYuZmV0Y2goZSxhKTtpZihyIGluc3RhbmNlb2Ygby5CYXNlU3RyZWFtJiZyLmRpY3QgaW5zdGFuY2VvZiBpLkRpY3Qpe2NvbnN0IGU9ci5kaWN0LmdldCgiVHlwZSIpLGE9ci5kaWN0LmdldCgiU3VidHlwZSIpO2lmKCgwLGkuaXNOYW1lKShlLCJNZXRhZGF0YSIpJiYoMCxpLmlzTmFtZSkoYSwiWE1MIikpe2NvbnN0IGU9KDAsbi5zdHJpbmdUb1VURjhTdHJpbmcpKHIuZ2V0U3RyaW5nKCkpO2UmJih0PW5ldyBkLk1ldGFkYXRhUGFyc2VyKGUpLnNlcmlhbGl6YWJsZSl9fX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2Ygci5NaXNzaW5nRGF0YUV4Y2VwdGlvbil0aHJvdyBlOygwLG4uaW5mbykoYFNraXBwaW5nIGludmFsaWQgTWV0YWRhdGE6ICIke2V9Ii5gKX1yZXR1cm4oMCxuLnNoYWRvdykodGhpcywibWV0YWRhdGEiLHQpfWdldCBtYXJrSW5mbygpe2xldCBlPW51bGw7dHJ5e2U9dGhpcy5fcmVhZE1hcmtJbmZvKCl9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIHIuTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZTsoMCxuLndhcm4pKCJVbmFibGUgdG8gcmVhZCBtYXJrIGluZm8uIil9cmV0dXJuKDAsbi5zaGFkb3cpKHRoaXMsIm1hcmtJbmZvIixlKX1fcmVhZE1hcmtJbmZvKCl7Y29uc3QgZT10aGlzLl9jYXREaWN0LmdldCgiTWFya0luZm8iKTtpZighKGUgaW5zdGFuY2VvZiBpLkRpY3QpKXJldHVybiBudWxsO2NvbnN0IHQ9e01hcmtlZDohMSxVc2VyUHJvcGVydGllczohMSxTdXNwZWN0czohMX07Zm9yKGNvbnN0IGEgaW4gdCl7Y29uc3Qgcj1lLmdldChhKTsiYm9vbGVhbiI9PXR5cGVvZiByJiYodFthXT1yKX1yZXR1cm4gdH1nZXQgc3RydWN0VHJlZVJvb3QoKXtsZXQgZT1udWxsO3RyeXtlPXRoaXMuX3JlYWRTdHJ1Y3RUcmVlUm9vdCgpfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiByLk1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7KDAsbi53YXJuKSgiVW5hYmxlIHJlYWQgdG8gc3RydWN0VHJlZVJvb3QgaW5mby4iKX1yZXR1cm4oMCxuLnNoYWRvdykodGhpcywic3RydWN0VHJlZVJvb3QiLGUpfV9yZWFkU3RydWN0VHJlZVJvb3QoKXtjb25zdCBlPXRoaXMuX2NhdERpY3QuZ2V0KCJTdHJ1Y3RUcmVlUm9vdCIpO2lmKCEoZSBpbnN0YW5jZW9mIGkuRGljdCkpcmV0dXJuIG51bGw7Y29uc3QgdD1uZXcgZi5TdHJ1Y3RUcmVlUm9vdChlKTt0LmluaXQoKTtyZXR1cm4gdH1nZXQgdG9wbGV2ZWxQYWdlc0RpY3QoKXtjb25zdCBlPXRoaXMuX2NhdERpY3QuZ2V0KCJQYWdlcyIpO2lmKCEoZSBpbnN0YW5jZW9mIGkuRGljdCkpdGhyb3cgbmV3IG4uRm9ybWF0RXJyb3IoIkludmFsaWQgdG9wLWxldmVsIHBhZ2VzIGRpY3Rpb25hcnkuIik7cmV0dXJuKDAsbi5zaGFkb3cpKHRoaXMsInRvcGxldmVsUGFnZXNEaWN0IixlKX1nZXQgZG9jdW1lbnRPdXRsaW5lKCl7bGV0IGU9bnVsbDt0cnl7ZT10aGlzLl9yZWFkRG9jdW1lbnRPdXRsaW5lKCl9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIHIuTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZTsoMCxuLndhcm4pKCJVbmFibGUgdG8gcmVhZCBkb2N1bWVudCBvdXRsaW5lLiIpfXJldHVybigwLG4uc2hhZG93KSh0aGlzLCJkb2N1bWVudE91dGxpbmUiLGUpfV9yZWFkRG9jdW1lbnRPdXRsaW5lKCl7bGV0IGU9dGhpcy5fY2F0RGljdC5nZXQoIk91dGxpbmVzIik7aWYoIShlIGluc3RhbmNlb2YgaS5EaWN0KSlyZXR1cm4gbnVsbDtlPWUuZ2V0UmF3KCJGaXJzdCIpO2lmKCEoZSBpbnN0YW5jZW9mIGkuUmVmKSlyZXR1cm4gbnVsbDtjb25zdCB0PXtpdGVtczpbXX0sYT1be29iajplLHBhcmVudDp0fV0scj1uZXcgaS5SZWZTZXQ7ci5wdXQoZSk7Y29uc3Qgcz10aGlzLnhyZWYsbz1uZXcgVWludDhDbGFtcGVkQXJyYXkoMyk7Zm9yKDthLmxlbmd0aD4wOyl7Y29uc3QgdD1hLnNoaWZ0KCksYz1zLmZldGNoSWZSZWYodC5vYmopO2lmKG51bGw9PT1jKWNvbnRpbnVlO2lmKCFjLmhhcygiVGl0bGUiKSl0aHJvdyBuZXcgbi5Gb3JtYXRFcnJvcigiSW52YWxpZCBvdXRsaW5lIGl0ZW0gZW5jb3VudGVyZWQuIik7Y29uc3QgaD17dXJsOm51bGwsZGVzdDpudWxsfTtDYXRhbG9nLnBhcnNlRGVzdERpY3Rpb25hcnkoe2Rlc3REaWN0OmMscmVzdWx0T2JqOmgsZG9jQmFzZVVybDp0aGlzLnBkZk1hbmFnZXIuZG9jQmFzZVVybH0pO2NvbnN0IHU9Yy5nZXQoIlRpdGxlIiksZD1jLmdldCgiRiIpfHwwLGY9Yy5nZXRBcnJheSgiQyIpLGc9Yy5nZXQoIkNvdW50Iik7bGV0IHA9bzshQXJyYXkuaXNBcnJheShmKXx8MyE9PWYubGVuZ3RofHwwPT09ZlswXSYmMD09PWZbMV0mJjA9PT1mWzJdfHwocD1sLkNvbG9yU3BhY2Uuc2luZ2xldG9ucy5yZ2IuZ2V0UmdiKGYsMCkpO2NvbnN0IG09e2Rlc3Q6aC5kZXN0LHVybDpoLnVybCx1bnNhZmVVcmw6aC51bnNhZmVVcmwsbmV3V2luZG93OmgubmV3V2luZG93LHRpdGxlOigwLG4uc3RyaW5nVG9QREZTdHJpbmcpKHUpLGNvbG9yOnAsY291bnQ6TnVtYmVyLmlzSW50ZWdlcihnKT9nOnZvaWQgMCxib2xkOiEhKDImZCksaXRhbGljOiEhKDEmZCksaXRlbXM6W119O3QucGFyZW50Lml0ZW1zLnB1c2gobSk7ZT1jLmdldFJhdygiRmlyc3QiKTtpZihlIGluc3RhbmNlb2YgaS5SZWYmJiFyLmhhcyhlKSl7YS5wdXNoKHtvYmo6ZSxwYXJlbnQ6bX0pO3IucHV0KGUpfWU9Yy5nZXRSYXcoIk5leHQiKTtpZihlIGluc3RhbmNlb2YgaS5SZWYmJiFyLmhhcyhlKSl7YS5wdXNoKHtvYmo6ZSxwYXJlbnQ6dC5wYXJlbnR9KTtyLnB1dChlKX19cmV0dXJuIHQuaXRlbXMubGVuZ3RoPjA/dC5pdGVtczpudWxsfWdldCBwZXJtaXNzaW9ucygpe2xldCBlPW51bGw7dHJ5e2U9dGhpcy5fcmVhZFBlcm1pc3Npb25zKCl9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIHIuTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZTsoMCxuLndhcm4pKCJVbmFibGUgdG8gcmVhZCBwZXJtaXNzaW9ucy4iKX1yZXR1cm4oMCxuLnNoYWRvdykodGhpcywicGVybWlzc2lvbnMiLGUpfV9yZWFkUGVybWlzc2lvbnMoKXtjb25zdCBlPXRoaXMueHJlZi50cmFpbGVyLmdldCgiRW5jcnlwdCIpO2lmKCEoZSBpbnN0YW5jZW9mIGkuRGljdCkpcmV0dXJuIG51bGw7bGV0IHQ9ZS5nZXQoIlAiKTtpZigibnVtYmVyIiE9dHlwZW9mIHQpcmV0dXJuIG51bGw7dCs9MioqMzI7Y29uc3QgYT1bXTtmb3IoY29uc3QgZSBpbiBuLlBlcm1pc3Npb25GbGFnKXtjb25zdCByPW4uUGVybWlzc2lvbkZsYWdbZV07dCZyJiZhLnB1c2gocil9cmV0dXJuIGF9Z2V0IG9wdGlvbmFsQ29udGVudENvbmZpZygpe2xldCBlPW51bGw7dHJ5e2NvbnN0IHQ9dGhpcy5fY2F0RGljdC5nZXQoIk9DUHJvcGVydGllcyIpO2lmKCF0KXJldHVybigwLG4uc2hhZG93KSh0aGlzLCJvcHRpb25hbENvbnRlbnRDb25maWciLG51bGwpO2NvbnN0IGE9dC5nZXQoIkQiKTtpZighYSlyZXR1cm4oMCxuLnNoYWRvdykodGhpcywib3B0aW9uYWxDb250ZW50Q29uZmlnIixudWxsKTtjb25zdCByPXQuZ2V0KCJPQ0dzIik7aWYoIUFycmF5LmlzQXJyYXkocikpcmV0dXJuKDAsbi5zaGFkb3cpKHRoaXMsIm9wdGlvbmFsQ29udGVudENvbmZpZyIsbnVsbCk7Y29uc3Qgcz1bXSxvPVtdO2Zvcihjb25zdCBlIG9mIHIpe2lmKCEoZSBpbnN0YW5jZW9mIGkuUmVmKSljb250aW51ZTtvLnB1c2goZSk7Y29uc3QgdD10aGlzLnhyZWYuZmV0Y2hJZlJlZihlKTtzLnB1c2goe2lkOmUudG9TdHJpbmcoKSxuYW1lOiJzdHJpbmciPT10eXBlb2YgdC5nZXQoIk5hbWUiKT8oMCxuLnN0cmluZ1RvUERGU3RyaW5nKSh0LmdldCgiTmFtZSIpKTpudWxsLGludGVudDoic3RyaW5nIj09dHlwZW9mIHQuZ2V0KCJJbnRlbnQiKT8oMCxuLnN0cmluZ1RvUERGU3RyaW5nKSh0LmdldCgiSW50ZW50IikpOm51bGx9KX1lPXRoaXMuX3JlYWRPcHRpb25hbENvbnRlbnRDb25maWcoYSxvKTtlLmdyb3Vwcz1zfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiByLk1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7KDAsbi53YXJuKShgVW5hYmxlIHRvIHJlYWQgb3B0aW9uYWwgY29udGVudCBjb25maWc6ICR7ZX1gKX1yZXR1cm4oMCxuLnNoYWRvdykodGhpcywib3B0aW9uYWxDb250ZW50Q29uZmlnIixlKX1fcmVhZE9wdGlvbmFsQ29udGVudENvbmZpZyhlLHQpe2Z1bmN0aW9uIHBhcnNlT25PZmYoZSl7Y29uc3QgYT1bXTtpZihBcnJheS5pc0FycmF5KGUpKWZvcihjb25zdCByIG9mIGUpciBpbnN0YW5jZW9mIGkuUmVmJiZ0LmluY2x1ZGVzKHIpJiZhLnB1c2goci50b1N0cmluZygpKTtyZXR1cm4gYX1mdW5jdGlvbiBwYXJzZU9yZGVyKGUsYT0wKXtpZighQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gbnVsbDtjb25zdCBuPVtdO2Zvcihjb25zdCBzIG9mIGUpe2lmKHMgaW5zdGFuY2VvZiBpLlJlZiYmdC5pbmNsdWRlcyhzKSl7ci5wdXQocyk7bi5wdXNoKHMudG9TdHJpbmcoKSk7Y29udGludWV9Y29uc3QgZT1wYXJzZU5lc3RlZE9yZGVyKHMsYSk7ZSYmbi5wdXNoKGUpfWlmKGE+MClyZXR1cm4gbjtjb25zdCBzPVtdO2Zvcihjb25zdCBlIG9mIHQpci5oYXMoZSl8fHMucHVzaChlLnRvU3RyaW5nKCkpO3MubGVuZ3RoJiZuLnB1c2goe25hbWU6bnVsbCxvcmRlcjpzfSk7cmV0dXJuIG59ZnVuY3Rpb24gcGFyc2VOZXN0ZWRPcmRlcihlLHQpe2lmKCsrdD5zKXsoMCxuLndhcm4pKCJwYXJzZU5lc3RlZE9yZGVyIC0gcmVhY2hlZCBNQVhfTkVTVEVEX0xFVkVMUy4iKTtyZXR1cm4gbnVsbH1jb25zdCByPWEuZmV0Y2hJZlJlZihlKTtpZighQXJyYXkuaXNBcnJheShyKSlyZXR1cm4gbnVsbDtjb25zdCBpPWEuZmV0Y2hJZlJlZihyWzBdKTtpZigic3RyaW5nIiE9dHlwZW9mIGkpcmV0dXJuIG51bGw7Y29uc3Qgbz1wYXJzZU9yZGVyKHIuc2xpY2UoMSksdCk7cmV0dXJuIG8mJm8ubGVuZ3RoP3tuYW1lOigwLG4uc3RyaW5nVG9QREZTdHJpbmcpKGkpLG9yZGVyOm99Om51bGx9Y29uc3QgYT10aGlzLnhyZWYscj1uZXcgaS5SZWZTZXQscz0xMDtyZXR1cm57bmFtZToic3RyaW5nIj09dHlwZW9mIGUuZ2V0KCJOYW1lIik/KDAsbi5zdHJpbmdUb1BERlN0cmluZykoZS5nZXQoIk5hbWUiKSk6bnVsbCxjcmVhdG9yOiJzdHJpbmciPT10eXBlb2YgZS5nZXQoIkNyZWF0b3IiKT8oMCxuLnN0cmluZ1RvUERGU3RyaW5nKShlLmdldCgiQ3JlYXRvciIpKTpudWxsLGJhc2VTdGF0ZTplLmdldCgiQmFzZVN0YXRlIilpbnN0YW5jZW9mIGkuTmFtZT9lLmdldCgiQmFzZVN0YXRlIikubmFtZTpudWxsLG9uOnBhcnNlT25PZmYoZS5nZXQoIk9OIikpLG9mZjpwYXJzZU9uT2ZmKGUuZ2V0KCJPRkYiKSksb3JkZXI6cGFyc2VPcmRlcihlLmdldCgiT3JkZXIiKSksZ3JvdXBzOm51bGx9fXNldEFjdHVhbE51bVBhZ2VzKGU9bnVsbCl7dGhpcy5fYWN0dWFsTnVtUGFnZXM9ZX1nZXQgaGFzQWN0dWFsTnVtUGFnZXMoKXtyZXR1cm4gbnVsbCE9PXRoaXMuX2FjdHVhbE51bVBhZ2VzfWdldCBfcGFnZXNDb3VudCgpe2NvbnN0IGU9dGhpcy50b3BsZXZlbFBhZ2VzRGljdC5nZXQoIkNvdW50Iik7aWYoIU51bWJlci5pc0ludGVnZXIoZSkpdGhyb3cgbmV3IG4uRm9ybWF0RXJyb3IoIlBhZ2UgY291bnQgaW4gdG9wLWxldmVsIHBhZ2VzIGRpY3Rpb25hcnkgaXMgbm90IGFuIGludGVnZXIuIik7cmV0dXJuKDAsbi5zaGFkb3cpKHRoaXMsIl9wYWdlc0NvdW50IixlKX1nZXQgbnVtUGFnZXMoKXtyZXR1cm4gdGhpcy5oYXNBY3R1YWxOdW1QYWdlcz90aGlzLl9hY3R1YWxOdW1QYWdlczp0aGlzLl9wYWdlc0NvdW50fWdldCBkZXN0aW5hdGlvbnMoKXtjb25zdCBlPXRoaXMuX3JlYWREZXN0cygpLHQ9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihlIGluc3RhbmNlb2Ygcy5OYW1lVHJlZSlmb3IoY29uc3RbYSxyXW9mIGUuZ2V0QWxsKCkpe2NvbnN0IGU9ZmV0Y2hEZXN0aW5hdGlvbihyKTtlJiYodFsoMCxuLnN0cmluZ1RvUERGU3RyaW5nKShhKV09ZSl9ZWxzZSBlIGluc3RhbmNlb2YgaS5EaWN0JiZlLmZvckVhY2goKGZ1bmN0aW9uKGUsYSl7Y29uc3Qgcj1mZXRjaERlc3RpbmF0aW9uKGEpO3ImJih0W2VdPXIpfSkpO3JldHVybigwLG4uc2hhZG93KSh0aGlzLCJkZXN0aW5hdGlvbnMiLHQpfWdldERlc3RpbmF0aW9uKGUpe2NvbnN0IHQ9dGhpcy5fcmVhZERlc3RzKCk7aWYodCBpbnN0YW5jZW9mIHMuTmFtZVRyZWUpe2NvbnN0IGE9ZmV0Y2hEZXN0aW5hdGlvbih0LmdldChlKSk7aWYoYSlyZXR1cm4gYTtjb25zdCByPXRoaXMuZGVzdGluYXRpb25zW2VdO2lmKHIpeygwLG4ud2FybikoYEZvdW5kICIke2V9IiBhdCBhbiBpbmNvcnJlY3QgcG9zaXRpb24gaW4gdGhlIE5hbWVUcmVlLmApO3JldHVybiByfX1lbHNlIGlmKHQgaW5zdGFuY2VvZiBpLkRpY3Qpe2NvbnN0IGE9ZmV0Y2hEZXN0aW5hdGlvbih0LmdldChlKSk7aWYoYSlyZXR1cm4gYX1yZXR1cm4gbnVsbH1fcmVhZERlc3RzKCl7Y29uc3QgZT10aGlzLl9jYXREaWN0LmdldCgiTmFtZXMiKTtyZXR1cm4gZSYmZS5oYXMoIkRlc3RzIik/bmV3IHMuTmFtZVRyZWUoZS5nZXRSYXcoIkRlc3RzIiksdGhpcy54cmVmKTp0aGlzLl9jYXREaWN0LmhhcygiRGVzdHMiKT90aGlzLl9jYXREaWN0LmdldCgiRGVzdHMiKTp2b2lkIDB9Z2V0IHBhZ2VMYWJlbHMoKXtsZXQgZT1udWxsO3RyeXtlPXRoaXMuX3JlYWRQYWdlTGFiZWxzKCl9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIHIuTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZTsoMCxuLndhcm4pKCJVbmFibGUgdG8gcmVhZCBwYWdlIGxhYmVscy4iKX1yZXR1cm4oMCxuLnNoYWRvdykodGhpcywicGFnZUxhYmVscyIsZSl9X3JlYWRQYWdlTGFiZWxzKCl7Y29uc3QgZT10aGlzLl9jYXREaWN0LmdldFJhdygiUGFnZUxhYmVscyIpO2lmKCFlKXJldHVybiBudWxsO2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMubnVtUGFnZXMpO2xldCBhPW51bGwsbz0iIjtjb25zdCBjPW5ldyBzLk51bWJlclRyZWUoZSx0aGlzLnhyZWYpLmdldEFsbCgpO2xldCBsPSIiLGg9MTtmb3IobGV0IGU9MCxzPXRoaXMubnVtUGFnZXM7ZTxzO2UrKyl7Y29uc3Qgcz1jLmdldChlKTtpZih2b2lkIDAhPT1zKXtpZighKHMgaW5zdGFuY2VvZiBpLkRpY3QpKXRocm93IG5ldyBuLkZvcm1hdEVycm9yKCJQYWdlTGFiZWwgaXMgbm90IGEgZGljdGlvbmFyeS4iKTtpZihzLmhhcygiVHlwZSIpJiYhKDAsaS5pc05hbWUpKHMuZ2V0KCJUeXBlIiksIlBhZ2VMYWJlbCIpKXRocm93IG5ldyBuLkZvcm1hdEVycm9yKCJJbnZhbGlkIHR5cGUgaW4gUGFnZUxhYmVsIGRpY3Rpb25hcnkuIik7aWYocy5oYXMoIlMiKSl7Y29uc3QgZT1zLmdldCgiUyIpO2lmKCEoZSBpbnN0YW5jZW9mIGkuTmFtZSkpdGhyb3cgbmV3IG4uRm9ybWF0RXJyb3IoIkludmFsaWQgc3R5bGUgaW4gUGFnZUxhYmVsIGRpY3Rpb25hcnkuIik7YT1lLm5hbWV9ZWxzZSBhPW51bGw7aWYocy5oYXMoIlAiKSl7Y29uc3QgZT1zLmdldCgiUCIpO2lmKCJzdHJpbmciIT10eXBlb2YgZSl0aHJvdyBuZXcgbi5Gb3JtYXRFcnJvcigiSW52YWxpZCBwcmVmaXggaW4gUGFnZUxhYmVsIGRpY3Rpb25hcnkuIik7bz0oMCxuLnN0cmluZ1RvUERGU3RyaW5nKShlKX1lbHNlIG89IiI7aWYocy5oYXMoIlN0Iikpe2NvbnN0IGU9cy5nZXQoIlN0Iik7aWYoIShOdW1iZXIuaXNJbnRlZ2VyKGUpJiZlPj0xKSl0aHJvdyBuZXcgbi5Gb3JtYXRFcnJvcigiSW52YWxpZCBzdGFydCBpbiBQYWdlTGFiZWwgZGljdGlvbmFyeS4iKTtoPWV9ZWxzZSBoPTF9c3dpdGNoKGEpe2Nhc2UiRCI6bD1oO2JyZWFrO2Nhc2UiUiI6Y2FzZSJyIjpsPSgwLHIudG9Sb21hbk51bWVyYWxzKShoLCJyIj09PWEpO2JyZWFrO2Nhc2UiQSI6Y2FzZSJhIjpjb25zdCBlPTI2LHQ9NjUsaT05NyxzPSJhIj09PWE/aTp0LG89aC0xO2w9U3RyaW5nLmZyb21DaGFyQ29kZShzK28lZSkucmVwZWF0KE1hdGguZmxvb3Ioby9lKSsxKTticmVhaztkZWZhdWx0OmlmKGEpdGhyb3cgbmV3IG4uRm9ybWF0RXJyb3IoYEludmFsaWQgc3R5bGUgIiR7YX0iIGluIFBhZ2VMYWJlbCBkaWN0aW9uYXJ5LmApO2w9IiJ9dFtlXT1vK2w7aCsrfXJldHVybiB0fWdldCBwYWdlTGF5b3V0KCl7Y29uc3QgZT10aGlzLl9jYXREaWN0LmdldCgiUGFnZUxheW91dCIpO2xldCB0PSIiO2lmKGUgaW5zdGFuY2VvZiBpLk5hbWUpc3dpdGNoKGUubmFtZSl7Y2FzZSJTaW5nbGVQYWdlIjpjYXNlIk9uZUNvbHVtbiI6Y2FzZSJUd29Db2x1bW5MZWZ0IjpjYXNlIlR3b0NvbHVtblJpZ2h0IjpjYXNlIlR3b1BhZ2VMZWZ0IjpjYXNlIlR3b1BhZ2VSaWdodCI6dD1lLm5hbWV9cmV0dXJuKDAsbi5zaGFkb3cpKHRoaXMsInBhZ2VMYXlvdXQiLHQpfWdldCBwYWdlTW9kZSgpe2NvbnN0IGU9dGhpcy5fY2F0RGljdC5nZXQoIlBhZ2VNb2RlIik7bGV0IHQ9IlVzZU5vbmUiO2lmKGUgaW5zdGFuY2VvZiBpLk5hbWUpc3dpdGNoKGUubmFtZSl7Y2FzZSJVc2VOb25lIjpjYXNlIlVzZU91dGxpbmVzIjpjYXNlIlVzZVRodW1icyI6Y2FzZSJGdWxsU2NyZWVuIjpjYXNlIlVzZU9DIjpjYXNlIlVzZUF0dGFjaG1lbnRzIjp0PWUubmFtZX1yZXR1cm4oMCxuLnNoYWRvdykodGhpcywicGFnZU1vZGUiLHQpfWdldCB2aWV3ZXJQcmVmZXJlbmNlcygpe2NvbnN0IGU9dGhpcy5fY2F0RGljdC5nZXQoIlZpZXdlclByZWZlcmVuY2VzIik7aWYoIShlIGluc3RhbmNlb2YgaS5EaWN0KSlyZXR1cm4oMCxuLnNoYWRvdykodGhpcywidmlld2VyUHJlZmVyZW5jZXMiLG51bGwpO2xldCB0PW51bGw7Zm9yKGNvbnN0IGEgb2YgZS5nZXRLZXlzKCkpe2NvbnN0IHI9ZS5nZXQoYSk7bGV0IHM7c3dpdGNoKGEpe2Nhc2UiSGlkZVRvb2xiYXIiOmNhc2UiSGlkZU1lbnViYXIiOmNhc2UiSGlkZVdpbmRvd1VJIjpjYXNlIkZpdFdpbmRvdyI6Y2FzZSJDZW50ZXJXaW5kb3ciOmNhc2UiRGlzcGxheURvY1RpdGxlIjpjYXNlIlBpY2tUcmF5QnlQREZTaXplIjoiYm9vbGVhbiI9PXR5cGVvZiByJiYocz1yKTticmVhaztjYXNlIk5vbkZ1bGxTY3JlZW5QYWdlTW9kZSI6aWYociBpbnN0YW5jZW9mIGkuTmFtZSlzd2l0Y2goci5uYW1lKXtjYXNlIlVzZU5vbmUiOmNhc2UiVXNlT3V0bGluZXMiOmNhc2UiVXNlVGh1bWJzIjpjYXNlIlVzZU9DIjpzPXIubmFtZTticmVhaztkZWZhdWx0OnM9IlVzZU5vbmUifWJyZWFrO2Nhc2UiRGlyZWN0aW9uIjppZihyIGluc3RhbmNlb2YgaS5OYW1lKXN3aXRjaChyLm5hbWUpe2Nhc2UiTDJSIjpjYXNlIlIyTCI6cz1yLm5hbWU7YnJlYWs7ZGVmYXVsdDpzPSJMMlIifWJyZWFrO2Nhc2UiVmlld0FyZWEiOmNhc2UiVmlld0NsaXAiOmNhc2UiUHJpbnRBcmVhIjpjYXNlIlByaW50Q2xpcCI6aWYociBpbnN0YW5jZW9mIGkuTmFtZSlzd2l0Y2goci5uYW1lKXtjYXNlIk1lZGlhQm94IjpjYXNlIkNyb3BCb3giOmNhc2UiQmxlZWRCb3giOmNhc2UiVHJpbUJveCI6Y2FzZSJBcnRCb3giOnM9ci5uYW1lO2JyZWFrO2RlZmF1bHQ6cz0iQ3JvcEJveCJ9YnJlYWs7Y2FzZSJQcmludFNjYWxpbmciOmlmKHIgaW5zdGFuY2VvZiBpLk5hbWUpc3dpdGNoKHIubmFtZSl7Y2FzZSJOb25lIjpjYXNlIkFwcERlZmF1bHQiOnM9ci5uYW1lO2JyZWFrO2RlZmF1bHQ6cz0iQXBwRGVmYXVsdCJ9YnJlYWs7Y2FzZSJEdXBsZXgiOmlmKHIgaW5zdGFuY2VvZiBpLk5hbWUpc3dpdGNoKHIubmFtZSl7Y2FzZSJTaW1wbGV4IjpjYXNlIkR1cGxleEZsaXBTaG9ydEVkZ2UiOmNhc2UiRHVwbGV4RmxpcExvbmdFZGdlIjpzPXIubmFtZTticmVhaztkZWZhdWx0OnM9Ik5vbmUifWJyZWFrO2Nhc2UiUHJpbnRQYWdlUmFuZ2UiOmlmKEFycmF5LmlzQXJyYXkocikmJnIubGVuZ3RoJTI9PTApe3IuZXZlcnkoKChlLHQsYSk9Pk51bWJlci5pc0ludGVnZXIoZSkmJmU+MCYmKDA9PT10fHxlPj1hW3QtMV0pJiZlPD10aGlzLm51bVBhZ2VzKSkmJihzPXIpfWJyZWFrO2Nhc2UiTnVtQ29waWVzIjpOdW1iZXIuaXNJbnRlZ2VyKHIpJiZyPjAmJihzPXIpO2JyZWFrO2RlZmF1bHQ6KDAsbi53YXJuKShgSWdub3Jpbmcgbm9uLXN0YW5kYXJkIGtleSBpbiBWaWV3ZXJQcmVmZXJlbmNlczogJHthfS5gKTtjb250aW51ZX1pZih2b2lkIDAhPT1zKXt0fHwodD1PYmplY3QuY3JlYXRlKG51bGwpKTt0W2FdPXN9ZWxzZSgwLG4ud2FybikoYEJhZCB2YWx1ZSwgZm9yIGtleSAiJHthfSIsIGluIFZpZXdlclByZWZlcmVuY2VzOiAke3J9LmApfXJldHVybigwLG4uc2hhZG93KSh0aGlzLCJ2aWV3ZXJQcmVmZXJlbmNlcyIsdCl9Z2V0IG9wZW5BY3Rpb24oKXtjb25zdCBlPXRoaXMuX2NhdERpY3QuZ2V0KCJPcGVuQWN0aW9uIiksdD1PYmplY3QuY3JlYXRlKG51bGwpO2lmKGUgaW5zdGFuY2VvZiBpLkRpY3Qpe2NvbnN0IGE9bmV3IGkuRGljdCh0aGlzLnhyZWYpO2Euc2V0KCJBIixlKTtjb25zdCByPXt1cmw6bnVsbCxkZXN0Om51bGwsYWN0aW9uOm51bGx9O0NhdGFsb2cucGFyc2VEZXN0RGljdGlvbmFyeSh7ZGVzdERpY3Q6YSxyZXN1bHRPYmo6cn0pO0FycmF5LmlzQXJyYXkoci5kZXN0KT90LmRlc3Q9ci5kZXN0OnIuYWN0aW9uJiYodC5hY3Rpb249ci5hY3Rpb24pfWVsc2UgQXJyYXkuaXNBcnJheShlKSYmKHQuZGVzdD1lKTtyZXR1cm4oMCxuLnNoYWRvdykodGhpcywib3BlbkFjdGlvbiIsKDAsbi5vYmplY3RTaXplKSh0KT4wP3Q6bnVsbCl9Z2V0IGF0dGFjaG1lbnRzKCl7Y29uc3QgZT10aGlzLl9jYXREaWN0LmdldCgiTmFtZXMiKTtsZXQgdD1udWxsO2lmKGUgaW5zdGFuY2VvZiBpLkRpY3QmJmUuaGFzKCJFbWJlZGRlZEZpbGVzIikpe2NvbnN0IGE9bmV3IHMuTmFtZVRyZWUoZS5nZXRSYXcoIkVtYmVkZGVkRmlsZXMiKSx0aGlzLnhyZWYpO2Zvcihjb25zdFtlLHJdb2YgYS5nZXRBbGwoKSl7Y29uc3QgYT1uZXcgaC5GaWxlU3BlYyhyLHRoaXMueHJlZik7dHx8KHQ9T2JqZWN0LmNyZWF0ZShudWxsKSk7dFsoMCxuLnN0cmluZ1RvUERGU3RyaW5nKShlKV09YS5zZXJpYWxpemFibGV9fXJldHVybigwLG4uc2hhZG93KSh0aGlzLCJhdHRhY2htZW50cyIsdCl9Z2V0IHhmYUltYWdlcygpe2NvbnN0IGU9dGhpcy5fY2F0RGljdC5nZXQoIk5hbWVzIik7bGV0IHQ9bnVsbDtpZihlIGluc3RhbmNlb2YgaS5EaWN0JiZlLmhhcygiWEZBSW1hZ2VzIikpe2NvbnN0IGE9bmV3IHMuTmFtZVRyZWUoZS5nZXRSYXcoIlhGQUltYWdlcyIpLHRoaXMueHJlZik7Zm9yKGNvbnN0W2Uscl1vZiBhLmdldEFsbCgpKXt0fHwodD1uZXcgaS5EaWN0KHRoaXMueHJlZikpO3Quc2V0KCgwLG4uc3RyaW5nVG9QREZTdHJpbmcpKGUpLHIpfX1yZXR1cm4oMCxuLnNoYWRvdykodGhpcywieGZhSW1hZ2VzIix0KX1fY29sbGVjdEphdmFTY3JpcHQoKXtjb25zdCBlPXRoaXMuX2NhdERpY3QuZ2V0KCJOYW1lcyIpO2xldCB0PW51bGw7ZnVuY3Rpb24gYXBwZW5kSWZKYXZhU2NyaXB0RGljdChlLGEpe2lmKCEoYSBpbnN0YW5jZW9mIGkuRGljdCkpcmV0dXJuO2lmKCEoMCxpLmlzTmFtZSkoYS5nZXQoIlMiKSwiSmF2YVNjcmlwdCIpKXJldHVybjtsZXQgcj1hLmdldCgiSlMiKTtpZihyIGluc3RhbmNlb2Ygby5CYXNlU3RyZWFtKXI9ci5nZXRTdHJpbmcoKTtlbHNlIGlmKCJzdHJpbmciIT10eXBlb2YgcilyZXR1cm47bnVsbD09PXQmJih0PW5ldyBNYXApO3I9KDAsbi5zdHJpbmdUb1BERlN0cmluZykocikucmVwbGFjZSgvXHUwMDAwL2csIiIpO3Quc2V0KGUscil9aWYoZSBpbnN0YW5jZW9mIGkuRGljdCYmZS5oYXMoIkphdmFTY3JpcHQiKSl7Y29uc3QgdD1uZXcgcy5OYW1lVHJlZShlLmdldFJhdygiSmF2YVNjcmlwdCIpLHRoaXMueHJlZik7Zm9yKGNvbnN0W2UsYV1vZiB0LmdldEFsbCgpKWFwcGVuZElmSmF2YVNjcmlwdERpY3QoKDAsbi5zdHJpbmdUb1BERlN0cmluZykoZSksYSl9Y29uc3QgYT10aGlzLl9jYXREaWN0LmdldCgiT3BlbkFjdGlvbiIpO2EmJmFwcGVuZElmSmF2YVNjcmlwdERpY3QoIk9wZW5BY3Rpb24iLGEpO3JldHVybiB0fWdldCBqYXZhU2NyaXB0KCl7Y29uc3QgZT10aGlzLl9jb2xsZWN0SmF2YVNjcmlwdCgpO3JldHVybigwLG4uc2hhZG93KSh0aGlzLCJqYXZhU2NyaXB0IixlP1suLi5lLnZhbHVlcygpXTpudWxsKX1nZXQganNBY3Rpb25zKCl7Y29uc3QgZT10aGlzLl9jb2xsZWN0SmF2YVNjcmlwdCgpO2xldCB0PSgwLHIuY29sbGVjdEFjdGlvbnMpKHRoaXMueHJlZix0aGlzLl9jYXREaWN0LG4uRG9jdW1lbnRBY3Rpb25FdmVudFR5cGUpO2lmKGUpe3R8fCh0PU9iamVjdC5jcmVhdGUobnVsbCkpO2Zvcihjb25zdFthLHJdb2YgZSlhIGluIHQ/dFthXS5wdXNoKHIpOnRbYV09W3JdfXJldHVybigwLG4uc2hhZG93KSh0aGlzLCJqc0FjdGlvbnMiLHQpfWFzeW5jIGZvbnRGYWxsYmFjayhlLHQpe2NvbnN0IGE9YXdhaXQgUHJvbWlzZS5hbGwodGhpcy5mb250Q2FjaGUpO2Zvcihjb25zdCByIG9mIGEpaWYoci5sb2FkZWROYW1lPT09ZSl7ci5mYWxsYmFjayh0KTtyZXR1cm59fWFzeW5jIGNsZWFudXAoZT0hMSl7KDAsYy5jbGVhckdsb2JhbENhY2hlcykoKTt0aGlzLmdsb2JhbEltYWdlQ2FjaGUuY2xlYXIoZSk7dGhpcy5wYWdlS2lkc0NvdW50Q2FjaGUuY2xlYXIoKTt0aGlzLnBhZ2VJbmRleENhY2hlLmNsZWFyKCk7dGhpcy5ub25CbGVuZE1vZGVzU2V0LmNsZWFyKCk7Y29uc3QgdD1hd2FpdCBQcm9taXNlLmFsbCh0aGlzLmZvbnRDYWNoZSk7Zm9yKGNvbnN0e2RpY3Q6ZX1vZiB0KWRlbGV0ZSBlLmNhY2hlS2V5O3RoaXMuZm9udENhY2hlLmNsZWFyKCk7dGhpcy5idWlsdEluQ01hcENhY2hlLmNsZWFyKCk7dGhpcy5zdGFuZGFyZEZvbnREYXRhQ2FjaGUuY2xlYXIoKX1hc3luYyBnZXRQYWdlRGljdChlKXtjb25zdCB0PVt0aGlzLnRvcGxldmVsUGFnZXNEaWN0XSxhPW5ldyBpLlJlZlNldCxyPXRoaXMuX2NhdERpY3QuZ2V0UmF3KCJQYWdlcyIpO3IgaW5zdGFuY2VvZiBpLlJlZiYmYS5wdXQocik7Y29uc3Qgcz10aGlzLnhyZWYsbz10aGlzLnBhZ2VLaWRzQ291bnRDYWNoZSxjPXRoaXMucGFnZUluZGV4Q2FjaGU7bGV0IGw9MDtmb3IoO3QubGVuZ3RoOyl7Y29uc3Qgcj10LnBvcCgpO2lmKHIgaW5zdGFuY2VvZiBpLlJlZil7Y29uc3QgaD1vLmdldChyKTtpZihoPj0wJiZsK2g8PWUpe2wrPWg7Y29udGludWV9aWYoYS5oYXMocikpdGhyb3cgbmV3IG4uRm9ybWF0RXJyb3IoIlBhZ2VzIHRyZWUgY29udGFpbnMgY2lyY3VsYXIgcmVmZXJlbmNlLiIpO2EucHV0KHIpO2NvbnN0IHU9YXdhaXQgcy5mZXRjaEFzeW5jKHIpO2lmKHUgaW5zdGFuY2VvZiBpLkRpY3Qpe2xldCB0PXUuZ2V0UmF3KCJUeXBlIik7dCBpbnN0YW5jZW9mIGkuUmVmJiYodD1hd2FpdCBzLmZldGNoQXN5bmModCkpO2lmKCgwLGkuaXNOYW1lKSh0LCJQYWdlIil8fCF1LmhhcygiS2lkcyIpKXtvLmhhcyhyKXx8by5wdXQociwxKTtjLmhhcyhyKXx8Yy5wdXQocixsKTtpZihsPT09ZSlyZXR1cm5bdSxyXTtsKys7Y29udGludWV9fXQucHVzaCh1KTtjb250aW51ZX1pZighKHIgaW5zdGFuY2VvZiBpLkRpY3QpKXRocm93IG5ldyBuLkZvcm1hdEVycm9yKCJQYWdlIGRpY3Rpb25hcnkga2lkIHJlZmVyZW5jZSBwb2ludHMgdG8gd3JvbmcgdHlwZSBvZiBvYmplY3QuIik7Y29uc3R7b2JqSWQ6aH09cjtsZXQgdT1yLmdldFJhdygiQ291bnQiKTt1IGluc3RhbmNlb2YgaS5SZWYmJih1PWF3YWl0IHMuZmV0Y2hBc3luYyh1KSk7aWYoTnVtYmVyLmlzSW50ZWdlcih1KSYmdT49MCl7aCYmIW8uaGFzKGgpJiZvLnB1dChoLHUpO2lmKGwrdTw9ZSl7bCs9dTtjb250aW51ZX19bGV0IGQ9ci5nZXRSYXcoIktpZHMiKTtkIGluc3RhbmNlb2YgaS5SZWYmJihkPWF3YWl0IHMuZmV0Y2hBc3luYyhkKSk7aWYoIUFycmF5LmlzQXJyYXkoZCkpe2xldCB0PXIuZ2V0UmF3KCJUeXBlIik7dCBpbnN0YW5jZW9mIGkuUmVmJiYodD1hd2FpdCBzLmZldGNoQXN5bmModCkpO2lmKCgwLGkuaXNOYW1lKSh0LCJQYWdlIil8fCFyLmhhcygiS2lkcyIpKXtpZihsPT09ZSlyZXR1cm5bcixudWxsXTtsKys7Y29udGludWV9dGhyb3cgbmV3IG4uRm9ybWF0RXJyb3IoIlBhZ2UgZGljdGlvbmFyeSBraWRzIG9iamVjdCBpcyBub3QgYW4gYXJyYXkuIil9Zm9yKGxldCBlPWQubGVuZ3RoLTE7ZT49MDtlLS0pdC5wdXNoKGRbZV0pfXRocm93IG5ldyBFcnJvcihgUGFnZSBpbmRleCAke2V9IG5vdCBmb3VuZC5gKX1hc3luYyBnZXRBbGxQYWdlRGljdHMoZT0hMSl7Y29uc3QgdD1be2N1cnJlbnROb2RlOnRoaXMudG9wbGV2ZWxQYWdlc0RpY3QscG9zSW5LaWRzOjB9XSxhPW5ldyBpLlJlZlNldCxzPXRoaXMuX2NhdERpY3QuZ2V0UmF3KCJQYWdlcyIpO3MgaW5zdGFuY2VvZiBpLlJlZiYmYS5wdXQocyk7Y29uc3Qgbz1uZXcgTWFwLGM9dGhpcy54cmVmLGw9dGhpcy5wYWdlSW5kZXhDYWNoZTtsZXQgaD0wO2Z1bmN0aW9uIGFkZFBhZ2VEaWN0KGUsdCl7dCYmIWwuaGFzKHQpJiZsLnB1dCh0LGgpO28uc2V0KGgrKyxbZSx0XSl9ZnVuY3Rpb24gYWRkUGFnZUVycm9yKHQpe2lmKHQgaW5zdGFuY2VvZiByLlhSZWZFbnRyeUV4Y2VwdGlvbiYmIWUpdGhyb3cgdDtvLnNldChoKyssW3QsbnVsbF0pfWZvcig7dC5sZW5ndGg+MDspe2NvbnN0IGU9dC5hdCgtMSkse2N1cnJlbnROb2RlOnIscG9zSW5LaWRzOnN9PWU7bGV0IG89ci5nZXRSYXcoIktpZHMiKTtpZihvIGluc3RhbmNlb2YgaS5SZWYpdHJ5e289YXdhaXQgYy5mZXRjaEFzeW5jKG8pfWNhdGNoKGUpe2FkZFBhZ2VFcnJvcihlKTticmVha31pZighQXJyYXkuaXNBcnJheShvKSl7YWRkUGFnZUVycm9yKG5ldyBuLkZvcm1hdEVycm9yKCJQYWdlIGRpY3Rpb25hcnkga2lkcyBvYmplY3QgaXMgbm90IGFuIGFycmF5LiIpKTticmVha31pZihzPj1vLmxlbmd0aCl7dC5wb3AoKTtjb250aW51ZX1jb25zdCBsPW9bc107bGV0IGg7aWYobCBpbnN0YW5jZW9mIGkuUmVmKXtpZihhLmhhcyhsKSl7YWRkUGFnZUVycm9yKG5ldyBuLkZvcm1hdEVycm9yKCJQYWdlcyB0cmVlIGNvbnRhaW5zIGNpcmN1bGFyIHJlZmVyZW5jZS4iKSk7YnJlYWt9YS5wdXQobCk7dHJ5e2g9YXdhaXQgYy5mZXRjaEFzeW5jKGwpfWNhdGNoKGUpe2FkZFBhZ2VFcnJvcihlKTticmVha319ZWxzZSBoPWw7aWYoIShoIGluc3RhbmNlb2YgaS5EaWN0KSl7YWRkUGFnZUVycm9yKG5ldyBuLkZvcm1hdEVycm9yKCJQYWdlIGRpY3Rpb25hcnkga2lkIHJlZmVyZW5jZSBwb2ludHMgdG8gd3JvbmcgdHlwZSBvZiBvYmplY3QuIikpO2JyZWFrfWxldCB1PWguZ2V0UmF3KCJUeXBlIik7aWYodSBpbnN0YW5jZW9mIGkuUmVmKXRyeXt1PWF3YWl0IGMuZmV0Y2hBc3luYyh1KX1jYXRjaChlKXthZGRQYWdlRXJyb3IoZSk7YnJlYWt9KDAsaS5pc05hbWUpKHUsIlBhZ2UiKXx8IWguaGFzKCJLaWRzIik/YWRkUGFnZURpY3QoaCxsIGluc3RhbmNlb2YgaS5SZWY/bDpudWxsKTp0LnB1c2goe2N1cnJlbnROb2RlOmgscG9zSW5LaWRzOjB9KTtlLnBvc0luS2lkcysrfXJldHVybiBvfWdldFBhZ2VJbmRleChlKXtjb25zdCB0PXRoaXMucGFnZUluZGV4Q2FjaGUuZ2V0KGUpO2lmKHZvaWQgMCE9PXQpcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0KTtjb25zdCBhPXRoaXMueHJlZjtsZXQgcj0wO2NvbnN0IG5leHQ9dD0+ZnVuY3Rpb24gcGFnZXNCZWZvcmVSZWYodCl7bGV0IHIscz0wO3JldHVybiBhLmZldGNoQXN5bmModCkudGhlbigoZnVuY3Rpb24oYSl7aWYoKDAsaS5pc1JlZnNFcXVhbCkodCxlKSYmISgwLGkuaXNEaWN0KShhLCJQYWdlIikmJiEoYSBpbnN0YW5jZW9mIGkuRGljdCYmIWEuaGFzKCJUeXBlIikmJmEuaGFzKCJDb250ZW50cyIpKSl0aHJvdyBuZXcgbi5Gb3JtYXRFcnJvcigiVGhlIHJlZmVyZW5jZSBkb2VzIG5vdCBwb2ludCB0byBhIC9QYWdlIGRpY3Rpb25hcnkuIik7aWYoIWEpcmV0dXJuIG51bGw7aWYoIShhIGluc3RhbmNlb2YgaS5EaWN0KSl0aHJvdyBuZXcgbi5Gb3JtYXRFcnJvcigiTm9kZSBtdXN0IGJlIGEgZGljdGlvbmFyeS4iKTtyPWEuZ2V0UmF3KCJQYXJlbnQiKTtyZXR1cm4gYS5nZXRBc3luYygiUGFyZW50Iil9KSkudGhlbigoZnVuY3Rpb24oZSl7aWYoIWUpcmV0dXJuIG51bGw7aWYoIShlIGluc3RhbmNlb2YgaS5EaWN0KSl0aHJvdyBuZXcgbi5Gb3JtYXRFcnJvcigiUGFyZW50IG11c3QgYmUgYSBkaWN0aW9uYXJ5LiIpO3JldHVybiBlLmdldEFzeW5jKCJLaWRzIil9KSkudGhlbigoZnVuY3Rpb24oZSl7aWYoIWUpcmV0dXJuIG51bGw7Y29uc3Qgbz1bXTtsZXQgYz0hMTtmb3IobGV0IHI9MCxsPWUubGVuZ3RoO3I8bDtyKyspe2NvbnN0IGw9ZVtyXTtpZighKGwgaW5zdGFuY2VvZiBpLlJlZikpdGhyb3cgbmV3IG4uRm9ybWF0RXJyb3IoIktpZCBtdXN0IGJlIGEgcmVmZXJlbmNlLiIpO2lmKCgwLGkuaXNSZWZzRXF1YWwpKGwsdCkpe2M9ITA7YnJlYWt9by5wdXNoKGEuZmV0Y2hBc3luYyhsKS50aGVuKChmdW5jdGlvbihlKXtpZighKGUgaW5zdGFuY2VvZiBpLkRpY3QpKXRocm93IG5ldyBuLkZvcm1hdEVycm9yKCJLaWQgbm9kZSBtdXN0IGJlIGEgZGljdGlvbmFyeS4iKTtlLmhhcygiQ291bnQiKT9zKz1lLmdldCgiQ291bnQiKTpzKyt9KSkpfWlmKCFjKXRocm93IG5ldyBuLkZvcm1hdEVycm9yKCJLaWQgcmVmZXJlbmNlIG5vdCBmb3VuZCBpbiBwYXJlbnQncyBraWRzLiIpO3JldHVybiBQcm9taXNlLmFsbChvKS50aGVuKChmdW5jdGlvbigpe3JldHVybltzLHJdfSkpfSkpfSh0KS50aGVuKCh0PT57aWYoIXQpe3RoaXMucGFnZUluZGV4Q2FjaGUucHV0KGUscik7cmV0dXJuIHJ9Y29uc3RbYSxuXT10O3IrPWE7cmV0dXJuIG5leHQobil9KSk7cmV0dXJuIG5leHQoZSl9Z2V0IGJhc2VVcmwoKXtjb25zdCBlPXRoaXMuX2NhdERpY3QuZ2V0KCJVUkkiKTtpZihlIGluc3RhbmNlb2YgaS5EaWN0KXtjb25zdCB0PWUuZ2V0KCJCYXNlIik7aWYoInN0cmluZyI9PXR5cGVvZiB0KXtjb25zdCBlPSgwLG4uY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCkodCxudWxsLHt0cnlDb252ZXJ0RW5jb2Rpbmc6ITB9KTtpZihlKXJldHVybigwLG4uc2hhZG93KSh0aGlzLCJiYXNlVXJsIixlLmhyZWYpfX1yZXR1cm4oMCxuLnNoYWRvdykodGhpcywiYmFzZVVybCIsbnVsbCl9c3RhdGljIHBhcnNlRGVzdERpY3Rpb25hcnkoZSl7Y29uc3QgdD1lLmRlc3REaWN0O2lmKCEodCBpbnN0YW5jZW9mIGkuRGljdCkpeygwLG4ud2FybikoInBhcnNlRGVzdERpY3Rpb25hcnk6IGBkZXN0RGljdGAgbXVzdCBiZSBhIGRpY3Rpb25hcnkuIik7cmV0dXJufWNvbnN0IGE9ZS5yZXN1bHRPYmo7aWYoIm9iamVjdCIhPXR5cGVvZiBhKXsoMCxuLndhcm4pKCJwYXJzZURlc3REaWN0aW9uYXJ5OiBgcmVzdWx0T2JqYCBtdXN0IGJlIGFuIG9iamVjdC4iKTtyZXR1cm59Y29uc3Qgcz1lLmRvY0Jhc2VVcmx8fG51bGw7bGV0IGMsbCxoPXQuZ2V0KCJBIik7aWYoIShoIGluc3RhbmNlb2YgaS5EaWN0KSlpZih0LmhhcygiRGVzdCIpKWg9dC5nZXQoIkRlc3QiKTtlbHNle2g9dC5nZXQoIkFBIik7aCBpbnN0YW5jZW9mIGkuRGljdCYmKGguaGFzKCJEIik/aD1oLmdldCgiRCIpOmguaGFzKCJVIikmJihoPWguZ2V0KCJVIikpKX1pZihoIGluc3RhbmNlb2YgaS5EaWN0KXtjb25zdCBlPWguZ2V0KCJTIik7aWYoIShlIGluc3RhbmNlb2YgaS5OYW1lKSl7KDAsbi53YXJuKSgicGFyc2VEZXN0RGljdGlvbmFyeTogSW52YWxpZCB0eXBlIGluIEFjdGlvbiBkaWN0aW9uYXJ5LiIpO3JldHVybn1jb25zdCB0PWUubmFtZTtzd2l0Y2godCl7Y2FzZSJSZXNldEZvcm0iOmNvbnN0IGU9aC5nZXQoIkZsYWdzIikscz0wPT0oMSYoIm51bWJlciI9PXR5cGVvZiBlP2U6MCkpLHU9W10sZD1bXTtmb3IoY29uc3QgZSBvZiBoLmdldCgiRmllbGRzIil8fFtdKWUgaW5zdGFuY2VvZiBpLlJlZj9kLnB1c2goZS50b1N0cmluZygpKToic3RyaW5nIj09dHlwZW9mIGUmJnUucHVzaCgoMCxuLnN0cmluZ1RvUERGU3RyaW5nKShlKSk7YS5yZXNldEZvcm09e2ZpZWxkczp1LHJlZnM6ZCxpbmNsdWRlOnN9O2JyZWFrO2Nhc2UiVVJJIjpjPWguZ2V0KCJVUkkiKTtjIGluc3RhbmNlb2YgaS5OYW1lJiYoYz0iLyIrYy5uYW1lKTticmVhaztjYXNlIkdvVG8iOmw9aC5nZXQoIkQiKTticmVhaztjYXNlIkxhdW5jaCI6Y2FzZSJHb1RvUiI6Y29uc3QgZj1oLmdldCgiRiIpO2YgaW5zdGFuY2VvZiBpLkRpY3Q/Yz1mLmdldCgiRiIpfHxudWxsOiJzdHJpbmciPT10eXBlb2YgZiYmKGM9Zik7bGV0IGc9aC5nZXQoIkQiKTtpZihnKXtnIGluc3RhbmNlb2YgaS5OYW1lJiYoZz1nLm5hbWUpO2lmKCJzdHJpbmciPT10eXBlb2YgYyl7Y29uc3QgZT1jLnNwbGl0KCIjIilbMF07InN0cmluZyI9PXR5cGVvZiBnP2M9ZSsiIyIrZzpBcnJheS5pc0FycmF5KGcpJiYoYz1lKyIjIitKU09OLnN0cmluZ2lmeShnKSl9fWNvbnN0IHA9aC5nZXQoIk5ld1dpbmRvdyIpOyJib29sZWFuIj09dHlwZW9mIHAmJihhLm5ld1dpbmRvdz1wKTticmVhaztjYXNlIk5hbWVkIjpjb25zdCBtPWguZ2V0KCJOIik7bSBpbnN0YW5jZW9mIGkuTmFtZSYmKGEuYWN0aW9uPW0ubmFtZSk7YnJlYWs7Y2FzZSJKYXZhU2NyaXB0Ijpjb25zdCBiPWguZ2V0KCJKUyIpO2xldCB5O2IgaW5zdGFuY2VvZiBvLkJhc2VTdHJlYW0/eT1iLmdldFN0cmluZygpOiJzdHJpbmciPT10eXBlb2YgYiYmKHk9Yik7Y29uc3Qgdz15JiYoMCxyLnJlY292ZXJKc1VSTCkoKDAsbi5zdHJpbmdUb1BERlN0cmluZykoeSkpO2lmKHcpe2M9dy51cmw7YS5uZXdXaW5kb3c9dy5uZXdXaW5kb3c7YnJlYWt9ZGVmYXVsdDppZigiSmF2YVNjcmlwdCI9PT10fHwiU3VibWl0Rm9ybSI9PT10KWJyZWFrOygwLG4ud2FybikoYHBhcnNlRGVzdERpY3Rpb25hcnkgLSB1bnN1cHBvcnRlZCBhY3Rpb246ICIke3R9Ii5gKX19ZWxzZSB0LmhhcygiRGVzdCIpJiYobD10LmdldCgiRGVzdCIpKTtpZigic3RyaW5nIj09dHlwZW9mIGMpe2NvbnN0IGU9KDAsbi5jcmVhdGVWYWxpZEFic29sdXRlVXJsKShjLHMse2FkZERlZmF1bHRQcm90b2NvbDohMCx0cnlDb252ZXJ0RW5jb2Rpbmc6ITB9KTtlJiYoYS51cmw9ZS5ocmVmKTthLnVuc2FmZVVybD1jfWlmKGwpe2wgaW5zdGFuY2VvZiBpLk5hbWUmJihsPWwubmFtZSk7InN0cmluZyI9PXR5cGVvZiBsP2EuZGVzdD0oMCxuLnN0cmluZ1RvUERGU3RyaW5nKShsKTpBcnJheS5pc0FycmF5KGwpJiYoYS5kZXN0PWwpfX19dC5DYXRhbG9nPUNhdGFsb2d9LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5OdW1iZXJUcmVlPXQuTmFtZVRyZWU9dm9pZCAwO3ZhciByPWEoNSksbj1hKDIpO2NsYXNzIE5hbWVPck51bWJlclRyZWV7Y29uc3RydWN0b3IoZSx0LGEpe3RoaXMuY29uc3RydWN0b3I9PT1OYW1lT3JOdW1iZXJUcmVlJiYoMCxuLnVucmVhY2hhYmxlKSgiQ2Fubm90IGluaXRpYWxpemUgTmFtZU9yTnVtYmVyVHJlZS4iKTt0aGlzLnJvb3Q9ZTt0aGlzLnhyZWY9dDt0aGlzLl90eXBlPWF9Z2V0QWxsKCl7Y29uc3QgZT1uZXcgTWFwO2lmKCF0aGlzLnJvb3QpcmV0dXJuIGU7Y29uc3QgdD10aGlzLnhyZWYsYT1uZXcgci5SZWZTZXQ7YS5wdXQodGhpcy5yb290KTtjb25zdCBpPVt0aGlzLnJvb3RdO2Zvcig7aS5sZW5ndGg+MDspe2NvbnN0IHM9dC5mZXRjaElmUmVmKGkuc2hpZnQoKSk7aWYoIShzIGluc3RhbmNlb2Ygci5EaWN0KSljb250aW51ZTtpZihzLmhhcygiS2lkcyIpKXtjb25zdCBlPXMuZ2V0KCJLaWRzIik7aWYoIUFycmF5LmlzQXJyYXkoZSkpY29udGludWU7Zm9yKGNvbnN0IHQgb2YgZSl7aWYoYS5oYXModCkpdGhyb3cgbmV3IG4uRm9ybWF0RXJyb3IoYER1cGxpY2F0ZSBlbnRyeSBpbiAiJHt0aGlzLl90eXBlfSIgdHJlZS5gKTtpLnB1c2godCk7YS5wdXQodCl9Y29udGludWV9Y29uc3Qgbz1zLmdldCh0aGlzLl90eXBlKTtpZihBcnJheS5pc0FycmF5KG8pKWZvcihsZXQgYT0wLHI9by5sZW5ndGg7YTxyO2ErPTIpZS5zZXQodC5mZXRjaElmUmVmKG9bYV0pLHQuZmV0Y2hJZlJlZihvW2ErMV0pKX1yZXR1cm4gZX1nZXQoZSl7aWYoIXRoaXMucm9vdClyZXR1cm4gbnVsbDtjb25zdCB0PXRoaXMueHJlZjtsZXQgYT10LmZldGNoSWZSZWYodGhpcy5yb290KSxyPTA7Zm9yKDthLmhhcygiS2lkcyIpOyl7aWYoKytyPjEwKXsoMCxuLndhcm4pKGBTZWFyY2ggZGVwdGggbGltaXQgcmVhY2hlZCBmb3IgIiR7dGhpcy5fdHlwZX0iIHRyZWUuYCk7cmV0dXJuIG51bGx9Y29uc3QgaT1hLmdldCgiS2lkcyIpO2lmKCFBcnJheS5pc0FycmF5KGkpKXJldHVybiBudWxsO2xldCBzPTAsbz1pLmxlbmd0aC0xO2Zvcig7czw9bzspe2NvbnN0IHI9cytvPj4xLG49dC5mZXRjaElmUmVmKGlbcl0pLGM9bi5nZXQoIkxpbWl0cyIpO2lmKGU8dC5mZXRjaElmUmVmKGNbMF0pKW89ci0xO2Vsc2V7aWYoIShlPnQuZmV0Y2hJZlJlZihjWzFdKSkpe2E9bjticmVha31zPXIrMX19aWYocz5vKXJldHVybiBudWxsfWNvbnN0IGk9YS5nZXQodGhpcy5fdHlwZSk7aWYoQXJyYXkuaXNBcnJheShpKSl7bGV0IGE9MCxyPWkubGVuZ3RoLTI7Zm9yKDthPD1yOyl7Y29uc3Qgbj1hK3I+PjEscz1uKygxJm4pLG89dC5mZXRjaElmUmVmKGlbc10pO2lmKGU8bylyPXMtMjtlbHNle2lmKCEoZT5vKSlyZXR1cm4gdC5mZXRjaElmUmVmKGlbcysxXSk7YT1zKzJ9fX1yZXR1cm4gbnVsbH19dC5OYW1lVHJlZT1jbGFzcyBOYW1lVHJlZSBleHRlbmRzIE5hbWVPck51bWJlclRyZWV7Y29uc3RydWN0b3IoZSx0KXtzdXBlcihlLHQsIk5hbWVzIil9fTt0Lk51bWJlclRyZWU9Y2xhc3MgTnVtYmVyVHJlZSBleHRlbmRzIE5hbWVPck51bWJlclRyZWV7Y29uc3RydWN0b3IoZSx0KXtzdXBlcihlLHQsIk51bXMiKX19fSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuY2xlYXJHbG9iYWxDYWNoZXM9ZnVuY3Rpb24gY2xlYXJHbG9iYWxDYWNoZXMoKXsoMCxyLmNsZWFyUHJpbWl0aXZlQ2FjaGVzKSgpOygwLG4uY2xlYXJVbmljb2RlQ2FjaGVzKSgpfTt2YXIgcj1hKDUpLG49YSg0MCl9LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5GaWxlU3BlYz12b2lkIDA7dmFyIHI9YSgyKSxuPWEoNyksaT1hKDUpO2Z1bmN0aW9uIHBpY2tQbGF0Zm9ybUl0ZW0oZSl7cmV0dXJuIGUuaGFzKCJVRiIpP2UuZ2V0KCJVRiIpOmUuaGFzKCJGIik/ZS5nZXQoIkYiKTplLmhhcygiVW5peCIpP2UuZ2V0KCJVbml4Iik6ZS5oYXMoIk1hYyIpP2UuZ2V0KCJNYWMiKTplLmhhcygiRE9TIik/ZS5nZXQoIkRPUyIpOm51bGx9dC5GaWxlU3BlYz1jbGFzcyBGaWxlU3BlY3tjb25zdHJ1Y3RvcihlLHQpe2lmKGUgaW5zdGFuY2VvZiBpLkRpY3Qpe3RoaXMueHJlZj10O3RoaXMucm9vdD1lO2UuaGFzKCJGUyIpJiYodGhpcy5mcz1lLmdldCgiRlMiKSk7dGhpcy5kZXNjcmlwdGlvbj1lLmhhcygiRGVzYyIpPygwLHIuc3RyaW5nVG9QREZTdHJpbmcpKGUuZ2V0KCJEZXNjIikpOiIiO2UuaGFzKCJSRiIpJiYoMCxyLndhcm4pKCJSZWxhdGVkIGZpbGUgc3BlY2lmaWNhdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQiKTt0aGlzLmNvbnRlbnRBdmFpbGFibGU9ITA7aWYoIWUuaGFzKCJFRiIpKXt0aGlzLmNvbnRlbnRBdmFpbGFibGU9ITE7KDAsci53YXJuKSgiTm9uLWVtYmVkZGVkIGZpbGUgc3BlY2lmaWNhdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQiKX19fWdldCBmaWxlbmFtZSgpe2lmKCF0aGlzLl9maWxlbmFtZSYmdGhpcy5yb290KXtjb25zdCBlPXBpY2tQbGF0Zm9ybUl0ZW0odGhpcy5yb290KXx8InVubmFtZWQiO3RoaXMuX2ZpbGVuYW1lPSgwLHIuc3RyaW5nVG9QREZTdHJpbmcpKGUpLnJlcGxhY2UoL1xcXFwvZywiXFwiKS5yZXBsYWNlKC9cXFwvL2csIi8iKS5yZXBsYWNlKC9cXC9nLCIvIil9cmV0dXJuIHRoaXMuX2ZpbGVuYW1lfWdldCBjb250ZW50KCl7aWYoIXRoaXMuY29udGVudEF2YWlsYWJsZSlyZXR1cm4gbnVsbDshdGhpcy5jb250ZW50UmVmJiZ0aGlzLnJvb3QmJih0aGlzLmNvbnRlbnRSZWY9cGlja1BsYXRmb3JtSXRlbSh0aGlzLnJvb3QuZ2V0KCJFRiIpKSk7bGV0IGU9bnVsbDtpZih0aGlzLmNvbnRlbnRSZWYpe2NvbnN0IHQ9dGhpcy54cmVmLmZldGNoSWZSZWYodGhpcy5jb250ZW50UmVmKTt0IGluc3RhbmNlb2Ygbi5CYXNlU3RyZWFtP2U9dC5nZXRCeXRlcygpOigwLHIud2FybikoIkVtYmVkZGVkIGZpbGUgc3BlY2lmaWNhdGlvbiBwb2ludHMgdG8gbm9uLWV4aXN0aW5nL2ludmFsaWQgY29udGVudCIpfWVsc2UoMCxyLndhcm4pKCJFbWJlZGRlZCBmaWxlIHNwZWNpZmljYXRpb24gZG9lcyBub3QgaGF2ZSBhIGNvbnRlbnQiKTtyZXR1cm4gZX1nZXQgc2VyaWFsaXphYmxlKCl7cmV0dXJue2ZpbGVuYW1lOnRoaXMuZmlsZW5hbWUsY29udGVudDp0aGlzLmNvbnRlbnR9fX19LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5NZXRhZGF0YVBhcnNlcj12b2lkIDA7dmFyIHI9YSg2Nik7dC5NZXRhZGF0YVBhcnNlcj1jbGFzcyBNZXRhZGF0YVBhcnNlcntjb25zdHJ1Y3RvcihlKXtlPXRoaXMuX3JlcGFpcihlKTtjb25zdCB0PW5ldyByLlNpbXBsZVhNTFBhcnNlcih7bG93ZXJDYXNlTmFtZTohMH0pLnBhcnNlRnJvbVN0cmluZyhlKTt0aGlzLl9tZXRhZGF0YU1hcD1uZXcgTWFwO3RoaXMuX2RhdGE9ZTt0JiZ0aGlzLl9wYXJzZSh0KX1fcmVwYWlyKGUpe3JldHVybiBlLnJlcGxhY2UoL15bXjxdKy8sIiIpLnJlcGxhY2UoLz5cXDM3NlxcMzc3KFtePF0rKS9nLChmdW5jdGlvbihlLHQpe2NvbnN0IGE9dC5yZXBsYWNlKC9cXChbMC0zXSkoWzAtN10pKFswLTddKS9nLChmdW5jdGlvbihlLHQsYSxyKXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg2NCp0KzgqYSsxKnIpfSkpLnJlcGxhY2UoLyYoYW1wfGFwb3N8Z3R8bHR8cXVvdCk7L2csKGZ1bmN0aW9uKGUsdCl7c3dpdGNoKHQpe2Nhc2UiYW1wIjpyZXR1cm4iJiI7Y2FzZSJhcG9zIjpyZXR1cm4iJyI7Y2FzZSJndCI6cmV0dXJuIj4iO2Nhc2UibHQiOnJldHVybiI8IjtjYXNlInF1b3QiOnJldHVybiciJ310aHJvdyBuZXcgRXJyb3IoYF9yZXBhaXI6ICR7dH0gaXNuJ3QgZGVmaW5lZC5gKX0pKSxyPVtdO2ZvcihsZXQgZT0wLHQ9YS5sZW5ndGg7ZTx0O2UrPTIpe2NvbnN0IHQ9MjU2KmEuY2hhckNvZGVBdChlKSthLmNoYXJDb2RlQXQoZSsxKTt0Pj0zMiYmdDwxMjcmJjYwIT09dCYmNjIhPT10JiYzOCE9PXQ/ci5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUodCkpOnIucHVzaCgiJiN4IisoNjU1MzYrdCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKSsiOyIpfXJldHVybiI+IityLmpvaW4oIiIpfSkpfV9nZXRTZXF1ZW5jZShlKXtjb25zdCB0PWUubm9kZU5hbWU7cmV0dXJuInJkZjpiYWciIT09dCYmInJkZjpzZXEiIT09dCYmInJkZjphbHQiIT09dD9udWxsOmUuY2hpbGROb2Rlcy5maWx0ZXIoKGU9PiJyZGY6bGkiPT09ZS5ub2RlTmFtZSkpfV9wYXJzZUFycmF5KGUpe2lmKCFlLmhhc0NoaWxkTm9kZXMoKSlyZXR1cm47Y29uc3RbdF09ZS5jaGlsZE5vZGVzLGE9dGhpcy5fZ2V0U2VxdWVuY2UodCl8fFtdO3RoaXMuX21ldGFkYXRhTWFwLnNldChlLm5vZGVOYW1lLGEubWFwKChlPT5lLnRleHRDb250ZW50LnRyaW0oKSkpKX1fcGFyc2UoZSl7bGV0IHQ9ZS5kb2N1bWVudEVsZW1lbnQ7aWYoInJkZjpyZGYiIT09dC5ub2RlTmFtZSl7dD10LmZpcnN0Q2hpbGQ7Zm9yKDt0JiYicmRmOnJkZiIhPT10Lm5vZGVOYW1lOyl0PXQubmV4dFNpYmxpbmd9aWYodCYmInJkZjpyZGYiPT09dC5ub2RlTmFtZSYmdC5oYXNDaGlsZE5vZGVzKCkpZm9yKGNvbnN0IGUgb2YgdC5jaGlsZE5vZGVzKWlmKCJyZGY6ZGVzY3JpcHRpb24iPT09ZS5ub2RlTmFtZSlmb3IoY29uc3QgdCBvZiBlLmNoaWxkTm9kZXMpe2NvbnN0IGU9dC5ub2RlTmFtZTtzd2l0Y2goZSl7Y2FzZSIjdGV4dCI6Y29udGludWU7Y2FzZSJkYzpjcmVhdG9yIjpjYXNlImRjOnN1YmplY3QiOnRoaXMuX3BhcnNlQXJyYXkodCk7Y29udGludWV9dGhpcy5fbWV0YWRhdGFNYXAuc2V0KGUsdC50ZXh0Q29udGVudC50cmltKCkpfX1nZXQgc2VyaWFsaXphYmxlKCl7cmV0dXJue3BhcnNlZERhdGE6dGhpcy5fbWV0YWRhdGFNYXAscmF3RGF0YTp0aGlzLl9kYXRhfX19fSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuU3RydWN0VHJlZVJvb3Q9dC5TdHJ1Y3RUcmVlUGFnZT12b2lkIDA7dmFyIHI9YSg1KSxuPWEoMiksaT1hKDcwKTtjb25zdCBzPSJQQUdFX0NPTlRFTlQiLG89IlNUUkVBTV9DT05URU5UIixjPSJPQkpFQ1QiLGw9IkVMRU1FTlQiO3QuU3RydWN0VHJlZVJvb3Q9Y2xhc3MgU3RydWN0VHJlZVJvb3R7Y29uc3RydWN0b3IoZSl7dGhpcy5kaWN0PWU7dGhpcy5yb2xlTWFwPW5ldyBNYXB9aW5pdCgpe3RoaXMucmVhZFJvbGVNYXAoKX1yZWFkUm9sZU1hcCgpe2NvbnN0IGU9dGhpcy5kaWN0LmdldCgiUm9sZU1hcCIpO2UgaW5zdGFuY2VvZiByLkRpY3QmJmUuZm9yRWFjaCgoKGUsdCk9Pnt0IGluc3RhbmNlb2Ygci5OYW1lJiZ0aGlzLnJvbGVNYXAuc2V0KGUsdC5uYW1lKX0pKX19O2NsYXNzIFN0cnVjdEVsZW1lbnROb2Rle2NvbnN0cnVjdG9yKGUsdCl7dGhpcy50cmVlPWU7dGhpcy5kaWN0PXQ7dGhpcy5raWRzPVtdO3RoaXMucGFyc2VLaWRzKCl9Z2V0IHJvbGUoKXtjb25zdCBlPXRoaXMuZGljdC5nZXQoIlMiKSx0PWUgaW5zdGFuY2VvZiByLk5hbWU/ZS5uYW1lOiIiLHtyb290OmF9PXRoaXMudHJlZTtyZXR1cm4gYS5yb2xlTWFwLmhhcyh0KT9hLnJvbGVNYXAuZ2V0KHQpOnR9cGFyc2VLaWRzKCl7bGV0IGU9bnVsbDtjb25zdCB0PXRoaXMuZGljdC5nZXRSYXcoIlBnIik7dCBpbnN0YW5jZW9mIHIuUmVmJiYoZT10LnRvU3RyaW5nKCkpO2NvbnN0IGE9dGhpcy5kaWN0LmdldCgiSyIpO2lmKEFycmF5LmlzQXJyYXkoYSkpZm9yKGNvbnN0IHQgb2YgYSl7Y29uc3QgYT10aGlzLnBhcnNlS2lkKGUsdCk7YSYmdGhpcy5raWRzLnB1c2goYSl9ZWxzZXtjb25zdCB0PXRoaXMucGFyc2VLaWQoZSxhKTt0JiZ0aGlzLmtpZHMucHVzaCh0KX19cGFyc2VLaWQoZSx0KXtpZihOdW1iZXIuaXNJbnRlZ2VyKHQpKXJldHVybiB0aGlzLnRyZWUucGFnZURpY3Qub2JqSWQhPT1lP251bGw6bmV3IFN0cnVjdEVsZW1lbnQoe3R5cGU6cyxtY2lkOnQscGFnZU9iaklkOmV9KTtsZXQgYT1udWxsO3QgaW5zdGFuY2VvZiByLlJlZj9hPXRoaXMuZGljdC54cmVmLmZldGNoKHQpOnQgaW5zdGFuY2VvZiByLkRpY3QmJihhPXQpO2lmKCFhKXJldHVybiBudWxsO2NvbnN0IG49YS5nZXRSYXcoIlBnIik7biBpbnN0YW5jZW9mIHIuUmVmJiYoZT1uLnRvU3RyaW5nKCkpO2NvbnN0IGk9YS5nZXQoIlR5cGUiKWluc3RhbmNlb2Ygci5OYW1lP2EuZ2V0KCJUeXBlIikubmFtZTpudWxsO3JldHVybiJNQ1IiPT09aT90aGlzLnRyZWUucGFnZURpY3Qub2JqSWQhPT1lP251bGw6bmV3IFN0cnVjdEVsZW1lbnQoe3R5cGU6byxyZWZPYmpJZDphLmdldFJhdygiU3RtIilpbnN0YW5jZW9mIHIuUmVmP2EuZ2V0UmF3KCJTdG0iKS50b1N0cmluZygpOm51bGwscGFnZU9iaklkOmUsbWNpZDphLmdldCgiTUNJRCIpfSk6Ik9CSlIiPT09aT90aGlzLnRyZWUucGFnZURpY3Qub2JqSWQhPT1lP251bGw6bmV3IFN0cnVjdEVsZW1lbnQoe3R5cGU6YyxyZWZPYmpJZDphLmdldFJhdygiT2JqIilpbnN0YW5jZW9mIHIuUmVmP2EuZ2V0UmF3KCJPYmoiKS50b1N0cmluZygpOm51bGwscGFnZU9iaklkOmV9KTpuZXcgU3RydWN0RWxlbWVudCh7dHlwZTpsLGRpY3Q6YX0pfX1jbGFzcyBTdHJ1Y3RFbGVtZW50e2NvbnN0cnVjdG9yKHt0eXBlOmUsZGljdDp0PW51bGwsbWNpZDphPW51bGwscGFnZU9iaklkOnI9bnVsbCxyZWZPYmpJZDpuPW51bGx9KXt0aGlzLnR5cGU9ZTt0aGlzLmRpY3Q9dDt0aGlzLm1jaWQ9YTt0aGlzLnBhZ2VPYmpJZD1yO3RoaXMucmVmT2JqSWQ9bjt0aGlzLnBhcmVudE5vZGU9bnVsbH19dC5TdHJ1Y3RUcmVlUGFnZT1jbGFzcyBTdHJ1Y3RUcmVlUGFnZXtjb25zdHJ1Y3RvcihlLHQpe3RoaXMucm9vdD1lO3RoaXMucm9vdERpY3Q9ZT9lLmRpY3Q6bnVsbDt0aGlzLnBhZ2VEaWN0PXQ7dGhpcy5ub2Rlcz1bXX1wYXJzZSgpe2lmKCF0aGlzLnJvb3R8fCF0aGlzLnJvb3REaWN0KXJldHVybjtjb25zdCBlPXRoaXMucm9vdERpY3QuZ2V0KCJQYXJlbnRUcmVlIik7aWYoIWUpcmV0dXJuO2NvbnN0IHQ9dGhpcy5wYWdlRGljdC5nZXQoIlN0cnVjdFBhcmVudHMiKTtpZighTnVtYmVyLmlzSW50ZWdlcih0KSlyZXR1cm47Y29uc3QgYT1uZXcgaS5OdW1iZXJUcmVlKGUsdGhpcy5yb290RGljdC54cmVmKS5nZXQodCk7aWYoIUFycmF5LmlzQXJyYXkoYSkpcmV0dXJuO2NvbnN0IG49bmV3IE1hcDtmb3IoY29uc3QgZSBvZiBhKWUgaW5zdGFuY2VvZiByLlJlZiYmdGhpcy5hZGROb2RlKHRoaXMucm9vdERpY3QueHJlZi5mZXRjaChlKSxuKX1hZGROb2RlKGUsdCxhPTApe2lmKGE+NDApeygwLG4ud2FybikoIlN0cnVjdFRyZWUgTUFYX0RFUFRIIHJlYWNoZWQuIik7cmV0dXJuIG51bGx9aWYodC5oYXMoZSkpcmV0dXJuIHQuZ2V0KGUpO2NvbnN0IGk9bmV3IFN0cnVjdEVsZW1lbnROb2RlKHRoaXMsZSk7dC5zZXQoZSxpKTtjb25zdCBzPWUuZ2V0KCJQIik7aWYoIXN8fCgwLHIuaXNOYW1lKShzLmdldCgiVHlwZSIpLCJTdHJ1Y3RUcmVlUm9vdCIpKXt0aGlzLmFkZFRvcExldmVsTm9kZShlLGkpfHx0LmRlbGV0ZShlKTtyZXR1cm4gaX1jb25zdCBvPXRoaXMuYWRkTm9kZShzLHQsYSsxKTtpZighbylyZXR1cm4gaTtsZXQgYz0hMTtmb3IoY29uc3QgdCBvZiBvLmtpZHMpaWYodC50eXBlPT09bCYmdC5kaWN0PT09ZSl7dC5wYXJlbnROb2RlPWk7Yz0hMH1jfHx0LmRlbGV0ZShlKTtyZXR1cm4gaX1hZGRUb3BMZXZlbE5vZGUoZSx0KXtjb25zdCBhPXRoaXMucm9vdERpY3QuZ2V0KCJLIik7aWYoIWEpcmV0dXJuITE7aWYoYSBpbnN0YW5jZW9mIHIuRGljdCl7aWYoYS5vYmpJZCE9PWUub2JqSWQpcmV0dXJuITE7dGhpcy5ub2Rlc1swXT10O3JldHVybiEwfWlmKCFBcnJheS5pc0FycmF5KGEpKXJldHVybiEwO2xldCBuPSExO2ZvcihsZXQgcj0wO3I8YS5sZW5ndGg7cisrKXtjb25zdCBpPWFbcl07aWYoaSYmaS50b1N0cmluZygpPT09ZS5vYmpJZCl7dGhpcy5ub2Rlc1tyXT10O249ITB9fXJldHVybiBufWdldCBzZXJpYWxpemFibGUoKXtmdW5jdGlvbiBub2RlVG9TZXJpYWxpemFibGUoZSx0LGE9MCl7aWYoYT40MCl7KDAsbi53YXJuKSgiU3RydWN0VHJlZSB0b28gZGVlcCB0byBiZSBmdWxseSBzZXJpYWxpemVkLiIpO3JldHVybn1jb25zdCByPU9iamVjdC5jcmVhdGUobnVsbCk7ci5yb2xlPWUucm9sZTtyLmNoaWxkcmVuPVtdO3QuY2hpbGRyZW4ucHVzaChyKTtjb25zdCBpPWUuZGljdC5nZXQoIkFsdCIpOyJzdHJpbmciPT10eXBlb2YgaSYmKHIuYWx0PSgwLG4uc3RyaW5nVG9QREZTdHJpbmcpKGkpKTtjb25zdCBoPWUuZGljdC5nZXQoIkxhbmciKTsic3RyaW5nIj09dHlwZW9mIGgmJihyLmxhbmc9KDAsbi5zdHJpbmdUb1BERlN0cmluZykoaCkpO2Zvcihjb25zdCB0IG9mIGUua2lkcyl7Y29uc3QgZT10LnR5cGU9PT1sP3QucGFyZW50Tm9kZTpudWxsO2U/bm9kZVRvU2VyaWFsaXphYmxlKGUscixhKzEpOnQudHlwZT09PXN8fHQudHlwZT09PW8/ci5jaGlsZHJlbi5wdXNoKHt0eXBlOiJjb250ZW50IixpZDpgcGFnZSR7dC5wYWdlT2JqSWR9X21jaWQke3QubWNpZH1gfSk6dC50eXBlPT09YyYmci5jaGlsZHJlbi5wdXNoKHt0eXBlOiJvYmplY3QiLGlkOnQucmVmT2JqSWR9KX19Y29uc3QgZT1PYmplY3QuY3JlYXRlKG51bGwpO2UuY2hpbGRyZW49W107ZS5yb2xlPSJSb290Ijtmb3IoY29uc3QgdCBvZiB0aGlzLm5vZGVzKXQmJm5vZGVUb1NlcmlhbGl6YWJsZSh0LGUpO3JldHVybiBlfX19LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5PYmplY3RMb2FkZXI9dm9pZCAwO3ZhciByPWEoNSksbj1hKDcpLGk9YSg2KSxzPWEoMik7ZnVuY3Rpb24gYWRkQ2hpbGRyZW4oZSx0KXtpZihlIGluc3RhbmNlb2Ygci5EaWN0KWU9ZS5nZXRSYXdWYWx1ZXMoKTtlbHNlIGlmKGUgaW5zdGFuY2VvZiBuLkJhc2VTdHJlYW0pZT1lLmRpY3QuZ2V0UmF3VmFsdWVzKCk7ZWxzZSBpZighQXJyYXkuaXNBcnJheShlKSlyZXR1cm47Zm9yKGNvbnN0IGkgb2YgZSkoKGE9aSlpbnN0YW5jZW9mIHIuUmVmfHxhIGluc3RhbmNlb2Ygci5EaWN0fHxhIGluc3RhbmNlb2Ygbi5CYXNlU3RyZWFtfHxBcnJheS5pc0FycmF5KGEpKSYmdC5wdXNoKGkpO3ZhciBhfXQuT2JqZWN0TG9hZGVyPWNsYXNzIE9iamVjdExvYWRlcntjb25zdHJ1Y3RvcihlLHQsYSl7dGhpcy5kaWN0PWU7dGhpcy5rZXlzPXQ7dGhpcy54cmVmPWE7dGhpcy5yZWZTZXQ9bnVsbH1hc3luYyBsb2FkKCl7aWYodGhpcy54cmVmLnN0cmVhbS5pc0RhdGFMb2FkZWQpcmV0dXJuO2NvbnN0e2tleXM6ZSxkaWN0OnR9PXRoaXM7dGhpcy5yZWZTZXQ9bmV3IHIuUmVmU2V0O2NvbnN0IGE9W107Zm9yKGxldCByPTAsbj1lLmxlbmd0aDtyPG47cisrKXtjb25zdCBuPXQuZ2V0UmF3KGVbcl0pO3ZvaWQgMCE9PW4mJmEucHVzaChuKX1yZXR1cm4gdGhpcy5fd2FsayhhKX1hc3luYyBfd2FsayhlKXtjb25zdCB0PVtdLGE9W107Zm9yKDtlLmxlbmd0aDspe2xldCBvPWUucG9wKCk7aWYobyBpbnN0YW5jZW9mIHIuUmVmKXtpZih0aGlzLnJlZlNldC5oYXMobykpY29udGludWU7dHJ5e3RoaXMucmVmU2V0LnB1dChvKTtvPXRoaXMueHJlZi5mZXRjaChvKX1jYXRjaChlKXtpZighKGUgaW5zdGFuY2VvZiBpLk1pc3NpbmdEYXRhRXhjZXB0aW9uKSl7KDAscy53YXJuKShgT2JqZWN0TG9hZGVyLl93YWxrIC0gcmVxdWVzdGluZyBhbGwgZGF0YTogIiR7ZX0iLmApO3RoaXMucmVmU2V0PW51bGw7Y29uc3R7bWFuYWdlcjp0fT10aGlzLnhyZWYuc3RyZWFtO3JldHVybiB0LnJlcXVlc3RBbGxDaHVua3MoKX10LnB1c2gobyk7YS5wdXNoKHtiZWdpbjplLmJlZ2luLGVuZDplLmVuZH0pfX1pZihvIGluc3RhbmNlb2Ygbi5CYXNlU3RyZWFtKXtjb25zdCBlPW8uZ2V0QmFzZVN0cmVhbXMoKTtpZihlKXtsZXQgcj0hMTtmb3IoY29uc3QgdCBvZiBlKWlmKCF0LmlzRGF0YUxvYWRlZCl7cj0hMDthLnB1c2goe2JlZ2luOnQuc3RhcnQsZW5kOnQuZW5kfSl9ciYmdC5wdXNoKG8pfX1hZGRDaGlsZHJlbihvLGUpfWlmKGEubGVuZ3RoKXthd2FpdCB0aGlzLnhyZWYuc3RyZWFtLm1hbmFnZXIucmVxdWVzdFJhbmdlcyhhKTtmb3IoY29uc3QgZSBvZiB0KWUgaW5zdGFuY2VvZiByLlJlZiYmdGhpcy5yZWZTZXQucmVtb3ZlKGUpO3JldHVybiB0aGlzLl93YWxrKHQpfXRoaXMucmVmU2V0PW51bGx9fX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LlhGQUZhY3Rvcnk9dm9pZCAwO3ZhciByPWEoNzcpLG49YSg4MSksaT1hKDg3KSxzPWEoODUpLG89YSg3OCksYz1hKDIpLGw9YSg4OCksaD1hKDk4KTtjbGFzcyBYRkFGYWN0b3J5e2NvbnN0cnVjdG9yKGUpe3RyeXt0aGlzLnJvb3Q9KG5ldyBsLlhGQVBhcnNlcikucGFyc2UoWEZBRmFjdG9yeS5fY3JlYXRlRG9jdW1lbnQoZSkpO2NvbnN0IHQ9bmV3IG4uQmluZGVyKHRoaXMucm9vdCk7dGhpcy5mb3JtPXQuYmluZCgpO3RoaXMuZGF0YUhhbmRsZXI9bmV3IGkuRGF0YUhhbmRsZXIodGhpcy5yb290LHQuZ2V0RGF0YSgpKTt0aGlzLmZvcm1bci4kZ2xvYmFsRGF0YV0udGVtcGxhdGU9dGhpcy5mb3JtfWNhdGNoKGUpeygwLGMud2FybikoYFhGQSAtIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBwYXJzaW5nIGFuZCBiaW5kaW5nOiAke2V9YCl9fWlzVmFsaWQoKXtyZXR1cm4gdGhpcy5yb290JiZ0aGlzLmZvcm19X2NyZWF0ZVBhZ2VzSGVscGVyKCl7Y29uc3QgZT10aGlzLmZvcm1bci4kdG9QYWdlc10oKTtyZXR1cm4gbmV3IFByb21pc2UoKCh0LGEpPT57Y29uc3QgbmV4dEl0ZXJhdGlvbj0oKT0+e3RyeXtjb25zdCBhPWUubmV4dCgpO2EuZG9uZT90KGEudmFsdWUpOnNldFRpbWVvdXQobmV4dEl0ZXJhdGlvbiwwKX1jYXRjaChlKXthKGUpfX07c2V0VGltZW91dChuZXh0SXRlcmF0aW9uLDApfSkpfWFzeW5jIF9jcmVhdGVQYWdlcygpe3RyeXt0aGlzLnBhZ2VzPWF3YWl0IHRoaXMuX2NyZWF0ZVBhZ2VzSGVscGVyKCk7dGhpcy5kaW1zPXRoaXMucGFnZXMuY2hpbGRyZW4ubWFwKChlPT57Y29uc3R7d2lkdGg6dCxoZWlnaHQ6YX09ZS5hdHRyaWJ1dGVzLnN0eWxlO3JldHVyblswLDAscGFyc2VJbnQodCkscGFyc2VJbnQoYSldfSkpfWNhdGNoKGUpeygwLGMud2FybikoYFhGQSAtIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBsYXlvdXQ6ICR7ZX1gKX19Z2V0Qm91bmRpbmdCb3goZSl7cmV0dXJuIHRoaXMuZGltc1tlXX1hc3luYyBnZXROdW1QYWdlcygpe3RoaXMucGFnZXN8fGF3YWl0IHRoaXMuX2NyZWF0ZVBhZ2VzKCk7cmV0dXJuIHRoaXMuZGltcy5sZW5ndGh9c2V0SW1hZ2VzKGUpe3RoaXMuZm9ybVtyLiRnbG9iYWxEYXRhXS5pbWFnZXM9ZX1zZXRGb250cyhlKXt0aGlzLmZvcm1bci4kZ2xvYmFsRGF0YV0uZm9udEZpbmRlcj1uZXcgcy5Gb250RmluZGVyKGUpO2NvbnN0IHQ9W107Zm9yKGxldCBlIG9mIHRoaXMuZm9ybVtyLiRnbG9iYWxEYXRhXS51c2VkVHlwZWZhY2VzKXtlPSgwLG8uc3RyaXBRdW90ZXMpKGUpO3RoaXMuZm9ybVtyLiRnbG9iYWxEYXRhXS5mb250RmluZGVyLmZpbmQoZSl8fHQucHVzaChlKX1yZXR1cm4gdC5sZW5ndGg+MD90Om51bGx9YXBwZW5kRm9udHMoZSx0KXt0aGlzLmZvcm1bci4kZ2xvYmFsRGF0YV0uZm9udEZpbmRlci5hZGQoZSx0KX1hc3luYyBnZXRQYWdlcygpe3RoaXMucGFnZXN8fGF3YWl0IHRoaXMuX2NyZWF0ZVBhZ2VzKCk7Y29uc3QgZT10aGlzLnBhZ2VzO3RoaXMucGFnZXM9bnVsbDtyZXR1cm4gZX1zZXJpYWxpemVEYXRhKGUpe3JldHVybiB0aGlzLmRhdGFIYW5kbGVyLnNlcmlhbGl6ZShlKX1zdGF0aWMgX2NyZWF0ZURvY3VtZW50KGUpe3JldHVybiBlWyIveGRwOnhkcCJdP09iamVjdC52YWx1ZXMoZSkuam9pbigiIik6ZVsieGRwOnhkcCJdfXN0YXRpYyBnZXRSaWNoVGV4dEFzSHRtbChlKXtpZighZXx8InN0cmluZyIhPXR5cGVvZiBlKXJldHVybiBudWxsO3RyeXtsZXQgdD1uZXcgbC5YRkFQYXJzZXIoaC5YaHRtbE5hbWVzcGFjZSwhMCkucGFyc2UoZSk7aWYoIVsiYm9keSIsInhodG1sIl0uaW5jbHVkZXModFtyLiRub2RlTmFtZV0pKXtjb25zdCBlPWguWGh0bWxOYW1lc3BhY2UuYm9keSh7fSk7ZVtyLiRhcHBlbmRDaGlsZF0odCk7dD1lfWNvbnN0IGE9dFtyLiR0b0hUTUxdKCk7aWYoIWEuc3VjY2VzcylyZXR1cm4gbnVsbDtjb25zdHtodG1sOm59PWEse2F0dHJpYnV0ZXM6aX09bjtpZihpKXtpLmNsYXNzJiYoaS5jbGFzcz1pLmNsYXNzLmZpbHRlcigoZT0+IWUuc3RhcnRzV2l0aCgieGZhIikpKSk7aS5kaXI9ImF1dG8ifXJldHVybntodG1sOm4sc3RyOnRbci4kdGV4dF0oKX19Y2F0Y2goZSl7KDAsYy53YXJuKShgWEZBIC0gYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHBhcnNpbmcgb2YgcmljaCB0ZXh0OiAke2V9YCl9cmV0dXJuIG51bGx9fXQuWEZBRmFjdG9yeT1YRkFGYWN0b3J5fSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuWG1sT2JqZWN0PXQuWEZBT2JqZWN0QXJyYXk9dC5YRkFPYmplY3Q9dC5YRkFBdHRyaWJ1dGU9dC5TdHJpbmdPYmplY3Q9dC5PcHRpb25PYmplY3Q9dC5PcHRpb24xMD10Lk9wdGlvbjAxPXQuSW50ZWdlck9iamVjdD10LkNvbnRlbnRPYmplY3Q9dC4kdWlkPXQuJHRvU3R5bGU9dC4kdG9TdHJpbmc9dC4kdG9QYWdlcz10LiR0b0hUTUw9dC4kdGV4dD10LiR0YWJJbmRleD10LiRzZXRWYWx1ZT10LiRzZXRTZXRBdHRyaWJ1dGVzPXQuJHNldElkPXQuJHNlYXJjaE5vZGU9dC4kcm9vdD10LiRyZXNvbHZlUHJvdG90eXBlcz10LiRyZW1vdmVDaGlsZD10LiRwdXNoUGFyYT10LiRwdXNoR2x5cGhzPXQuJHBvcFBhcmE9dC4kb25UZXh0PXQuJG9uQ2hpbGRDaGVjaz10LiRvbkNoaWxkPXQuJG5zQXR0cmlidXRlcz10LiRub2RlTmFtZT10LiRuYW1lc3BhY2VJZD10LiRpc1VzYWJsZT10LiRpc1RyYW5zcGFyZW50PXQuJGlzVGhlcmVNb3JlV2lkdGg9dC4kaXNTcGxpdHRhYmxlPXQuJGlzTnNBZ25vc3RpYz10LiRpc0Rlc2NlbmRlbnQ9dC4kaXNEYXRhVmFsdWU9dC4kaXNDREFUQVhtbD10LiRpc0JpbmRhYmxlPXQuJGluc2VydEF0PXQuJGluZGV4T2Y9dC4kaWRzPXQuJGhhc1NldHRhYmxlVmFsdWU9dC4kZ2xvYmFsRGF0YT10LiRnZXRUZW1wbGF0ZVJvb3Q9dC4kZ2V0U3ViZm9ybVBhcmVudD10LiRnZXRSZWFsQ2hpbGRyZW5CeU5hbWVJdD10LiRnZXRQYXJlbnQ9dC4kZ2V0TmV4dFBhZ2U9dC4kZ2V0RXh0cmE9dC4kZ2V0RGF0YVZhbHVlPXQuJGdldENvbnRhaW5lZENoaWxkcmVuPXQuJGdldENoaWxkcmVuQnlOYW1lSXQ9dC4kZ2V0Q2hpbGRyZW5CeU5hbWU9dC4kZ2V0Q2hpbGRyZW5CeUNsYXNzPXQuJGdldENoaWxkcmVuPXQuJGdldEF2YWlsYWJsZVNwYWNlPXQuJGdldEF0dHJpYnV0ZXM9dC4kZ2V0QXR0cmlidXRlSXQ9dC4kZmx1c2hIVE1MPXQuJGZpbmFsaXplPXQuJGV4dHJhPXQuJGR1bXA9dC4kZGF0YT10LiRjb250ZW50PXQuJGNvbnN1bWVkPXQuJGNsb25lPXQuJGNsZWFudXA9dC4kY2xlYW5QYWdlPXQuJGNsZWFuPXQuJGNoaWxkcmVuVG9IVE1MPXQuJGFwcGVuZENoaWxkPXQuJGFkZEhUTUw9dC4kYWNjZXB0V2hpdGVzcGFjZT12b2lkIDA7dmFyIHI9YSg3OCksbj1hKDIpLGk9YSg2KSxzPWEoNzkpLG89YSg4MCk7Y29uc3QgYz1TeW1ib2woKTt0LiRhY2NlcHRXaGl0ZXNwYWNlPWM7Y29uc3QgbD1TeW1ib2woKTt0LiRhZGRIVE1MPWw7Y29uc3QgaD1TeW1ib2woKTt0LiRhcHBlbmRDaGlsZD1oO2NvbnN0IHU9U3ltYm9sKCk7dC4kY2hpbGRyZW5Ub0hUTUw9dTtjb25zdCBkPVN5bWJvbCgpO3QuJGNsZWFuPWQ7Y29uc3QgZj1TeW1ib2woKTt0LiRjbGVhblBhZ2U9Zjtjb25zdCBnPVN5bWJvbCgpO3QuJGNsZWFudXA9Zztjb25zdCBwPVN5bWJvbCgpO3QuJGNsb25lPXA7Y29uc3QgbT1TeW1ib2woKTt0LiRjb25zdW1lZD1tO2NvbnN0IGI9U3ltYm9sKCJjb250ZW50Iik7dC4kY29udGVudD1iO2NvbnN0IHk9U3ltYm9sKCJkYXRhIik7dC4kZGF0YT15O2NvbnN0IHc9U3ltYm9sKCk7dC4kZHVtcD13O2NvbnN0IFM9U3ltYm9sKCJleHRyYSIpO3QuJGV4dHJhPVM7Y29uc3QgeD1TeW1ib2woKTt0LiRmaW5hbGl6ZT14O2NvbnN0IGs9U3ltYm9sKCk7dC4kZmx1c2hIVE1MPWs7Y29uc3QgQz1TeW1ib2woKTt0LiRnZXRBdHRyaWJ1dGVJdD1DO2NvbnN0IHY9U3ltYm9sKCk7dC4kZ2V0QXR0cmlidXRlcz12O2NvbnN0IEY9U3ltYm9sKCk7dC4kZ2V0QXZhaWxhYmxlU3BhY2U9Rjtjb25zdCBPPVN5bWJvbCgpO3QuJGdldENoaWxkcmVuQnlDbGFzcz1PO2NvbnN0IFQ9U3ltYm9sKCk7dC4kZ2V0Q2hpbGRyZW5CeU5hbWU9VDtjb25zdCBNPVN5bWJvbCgpO3QuJGdldENoaWxkcmVuQnlOYW1lSXQ9TTtjb25zdCBFPVN5bWJvbCgpO3QuJGdldERhdGFWYWx1ZT1FO2NvbnN0IEQ9U3ltYm9sKCk7dC4kZ2V0RXh0cmE9RDtjb25zdCBOPVN5bWJvbCgpO3QuJGdldFJlYWxDaGlsZHJlbkJ5TmFtZUl0PU47Y29uc3QgUj1TeW1ib2woKTt0LiRnZXRDaGlsZHJlbj1SO2NvbnN0IEw9U3ltYm9sKCk7dC4kZ2V0Q29udGFpbmVkQ2hpbGRyZW49TDtjb25zdCBqPVN5bWJvbCgpO3QuJGdldE5leHRQYWdlPWo7Y29uc3QgJD1TeW1ib2woKTt0LiRnZXRTdWJmb3JtUGFyZW50PSQ7Y29uc3QgXz1TeW1ib2woKTt0LiRnZXRQYXJlbnQ9Xztjb25zdCBVPVN5bWJvbCgpO3QuJGdldFRlbXBsYXRlUm9vdD1VO2NvbnN0IFg9U3ltYm9sKCk7dC4kZ2xvYmFsRGF0YT1YO2NvbnN0IEg9U3ltYm9sKCk7dC4kaGFzU2V0dGFibGVWYWx1ZT1IO2NvbnN0IHE9U3ltYm9sKCk7dC4kaWRzPXE7Y29uc3Qgej1TeW1ib2woKTt0LiRpbmRleE9mPXo7Y29uc3QgVz1TeW1ib2woKTt0LiRpbnNlcnRBdD1XO2NvbnN0IEc9U3ltYm9sKCk7dC4kaXNDREFUQVhtbD1HO2NvbnN0IFY9U3ltYm9sKCk7dC4kaXNCaW5kYWJsZT1WO2NvbnN0IEs9U3ltYm9sKCk7dC4kaXNEYXRhVmFsdWU9Sztjb25zdCBZPVN5bWJvbCgpO3QuJGlzRGVzY2VuZGVudD1ZO2NvbnN0IEo9U3ltYm9sKCk7dC4kaXNOc0Fnbm9zdGljPUo7Y29uc3QgWj1TeW1ib2woKTt0LiRpc1NwbGl0dGFibGU9Wjtjb25zdCBRPVN5bWJvbCgpO3QuJGlzVGhlcmVNb3JlV2lkdGg9UTtjb25zdCBlZT1TeW1ib2woKTt0LiRpc1RyYW5zcGFyZW50PWVlO2NvbnN0IHRlPVN5bWJvbCgpO3QuJGlzVXNhYmxlPXRlO2NvbnN0IGFlPVN5bWJvbCgpLHJlPVN5bWJvbCgibmFtZXNwYWNlSWQiKTt0LiRuYW1lc3BhY2VJZD1yZTtjb25zdCBuZT1TeW1ib2woIm5vZGVOYW1lIik7dC4kbm9kZU5hbWU9bmU7Y29uc3QgaWU9U3ltYm9sKCk7dC4kbnNBdHRyaWJ1dGVzPWllO2NvbnN0IHNlPVN5bWJvbCgpO3QuJG9uQ2hpbGQ9c2U7Y29uc3Qgb2U9U3ltYm9sKCk7dC4kb25DaGlsZENoZWNrPW9lO2NvbnN0IGNlPVN5bWJvbCgpO3QuJG9uVGV4dD1jZTtjb25zdCBsZT1TeW1ib2woKTt0LiRwdXNoR2x5cGhzPWxlO2NvbnN0IGhlPVN5bWJvbCgpO3QuJHBvcFBhcmE9aGU7Y29uc3QgdWU9U3ltYm9sKCk7dC4kcHVzaFBhcmE9dWU7Y29uc3QgZGU9U3ltYm9sKCk7dC4kcmVtb3ZlQ2hpbGQ9ZGU7Y29uc3QgZmU9U3ltYm9sKCJyb290Iik7dC4kcm9vdD1mZTtjb25zdCBnZT1TeW1ib2woKTt0LiRyZXNvbHZlUHJvdG90eXBlcz1nZTtjb25zdCBwZT1TeW1ib2woKTt0LiRzZWFyY2hOb2RlPXBlO2NvbnN0IG1lPVN5bWJvbCgpO3QuJHNldElkPW1lO2NvbnN0IGJlPVN5bWJvbCgpO3QuJHNldFNldEF0dHJpYnV0ZXM9YmU7Y29uc3QgeWU9U3ltYm9sKCk7dC4kc2V0VmFsdWU9eWU7Y29uc3Qgd2U9U3ltYm9sKCk7dC4kdGFiSW5kZXg9d2U7Y29uc3QgU2U9U3ltYm9sKCk7dC4kdGV4dD1TZTtjb25zdCB4ZT1TeW1ib2woKTt0LiR0b1BhZ2VzPXhlO2NvbnN0IEFlPVN5bWJvbCgpO3QuJHRvSFRNTD1BZTtjb25zdCBrZT1TeW1ib2woKTt0LiR0b1N0cmluZz1rZTtjb25zdCBDZT1TeW1ib2woKTt0LiR0b1N0eWxlPUNlO2NvbnN0IHZlPVN5bWJvbCgidWlkIik7dC4kdWlkPXZlO2NvbnN0IEZlPVN5bWJvbCgpLE9lPVN5bWJvbCgpLFRlPVN5bWJvbCgpLEllPVN5bWJvbCgiX2NoaWxkcmVuIiksTWU9U3ltYm9sKCksUGU9U3ltYm9sKCksRWU9U3ltYm9sKCksRGU9U3ltYm9sKCksTmU9U3ltYm9sKCksQmU9U3ltYm9sKCksUmU9U3ltYm9sKCksTGU9U3ltYm9sKCksamU9U3ltYm9sKCksJGU9U3ltYm9sKCJwYXJlbnQiKSxfZT1TeW1ib2woKSxVZT1TeW1ib2woKSxYZT1TeW1ib2woKTtsZXQgSGU9MDtjb25zdCBxZT1zLk5hbWVzcGFjZUlkcy5kYXRhc2V0cy5pZDtjbGFzcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSx0LGE9ITEpe3RoaXNbcmVdPWU7dGhpc1tuZV09dDt0aGlzW1JlXT1hO3RoaXNbJGVdPW51bGw7dGhpc1tJZV09W107dGhpc1t2ZV09YCR7dH0ke0hlKyt9YDt0aGlzW1hdPW51bGx9W3NlXShlKXtpZighdGhpc1tSZV18fCF0aGlzW29lXShlKSlyZXR1cm4hMTtjb25zdCB0PWVbbmVdLGE9dGhpc1t0XTtpZighKGEgaW5zdGFuY2VvZiBYRkFPYmplY3RBcnJheSkpe251bGwhPT1hJiZ0aGlzW2RlXShhKTt0aGlzW3RdPWU7dGhpc1toXShlKTtyZXR1cm4hMH1pZihhLnB1c2goZSkpe3RoaXNbaF0oZSk7cmV0dXJuITB9bGV0IHI9IiI7dGhpcy5pZD9yPWAgKGlkOiAke3RoaXMuaWR9KWA6dGhpcy5uYW1lJiYocj1gIChuYW1lOiAke3RoaXMubmFtZX0gJHt0aGlzLmgudmFsdWV9KWApOygwLG4ud2FybikoYFhGQSAtIG5vZGUgIiR7dGhpc1tuZV19IiR7cn0gaGFzIGFscmVhZHkgZW5vdWdoICIke3R9IiFgKTtyZXR1cm4hMX1bb2VdKGUpe3JldHVybiB0aGlzLmhhc093blByb3BlcnR5KGVbbmVdKSYmZVtyZV09PT10aGlzW3JlXX1bSl0oKXtyZXR1cm4hMX1bY10oKXtyZXR1cm4hMX1bR10oKXtyZXR1cm4hMX1bVl0oKXtyZXR1cm4hMX1baGVdKCl7dGhpcy5wYXJhJiZ0aGlzW1VdKClbU10ucGFyYVN0YWNrLnBvcCgpfVt1ZV0oKXt0aGlzW1VdKClbU10ucGFyYVN0YWNrLnB1c2godGhpcy5wYXJhKX1bbWVdKGUpe3RoaXMuaWQmJnRoaXNbcmVdPT09cy5OYW1lc3BhY2VJZHMudGVtcGxhdGUuaWQmJmUuc2V0KHRoaXMuaWQsdGhpcyl9W1VdKCl7cmV0dXJuIHRoaXNbWF0udGVtcGxhdGV9W1pdKCl7cmV0dXJuITF9W1FdKCl7cmV0dXJuITF9W2hdKGUpe2VbJGVdPXRoaXM7dGhpc1tJZV0ucHVzaChlKTshZVtYXSYmdGhpc1tYXSYmKGVbWF09dGhpc1tYXSl9W2RlXShlKXtjb25zdCB0PXRoaXNbSWVdLmluZGV4T2YoZSk7dGhpc1tJZV0uc3BsaWNlKHQsMSl9W0hdKCl7cmV0dXJuIHRoaXMuaGFzT3duUHJvcGVydHkoInZhbHVlIil9W3llXShlKXt9W2NlXShlKXt9W3hdKCl7fVtkXShlKXtkZWxldGUgdGhpc1tSZV07aWYodGhpc1tnXSl7ZS5jbGVhbih0aGlzW2ddKTtkZWxldGUgdGhpc1tnXX19W3pdKGUpe3JldHVybiB0aGlzW0llXS5pbmRleE9mKGUpfVtXXShlLHQpe3RbJGVdPXRoaXM7dGhpc1tJZV0uc3BsaWNlKGUsMCx0KTshdFtYXSYmdGhpc1tYXSYmKHRbWF09dGhpc1tYXSl9W2VlXSgpe3JldHVybiF0aGlzLm5hbWV9W2FlXSgpe3JldHVybiIifVtTZV0oKXtyZXR1cm4gMD09PXRoaXNbSWVdLmxlbmd0aD90aGlzW2JdOnRoaXNbSWVdLm1hcCgoZT0+ZVtTZV0oKSkpLmpvaW4oIiIpfWdldFtUZV0oKXtjb25zdCBlPU9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTtpZighZS5fYXR0cmlidXRlcyl7Y29uc3QgdD1lLl9hdHRyaWJ1dGVzPW5ldyBTZXQ7Zm9yKGNvbnN0IGUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpe2lmKG51bGw9PT10aGlzW2VdfHx0aGlzW2VdaW5zdGFuY2VvZiBYRkFPYmplY3R8fHRoaXNbZV1pbnN0YW5jZW9mIFhGQU9iamVjdEFycmF5KWJyZWFrO3QuYWRkKGUpfX1yZXR1cm4oMCxuLnNoYWRvdykodGhpcyxUZSxlLl9hdHRyaWJ1dGVzKX1bWV0oZSl7bGV0IHQ9dGhpcztmb3IoO3Q7KXtpZih0PT09ZSlyZXR1cm4hMDt0PXRbX10oKX1yZXR1cm4hMX1bX10oKXtyZXR1cm4gdGhpc1skZV19WyRdKCl7cmV0dXJuIHRoaXNbX10oKX1bUl0oZT1udWxsKXtyZXR1cm4gZT90aGlzW2VdOnRoaXNbSWVdfVt3XSgpe2NvbnN0IGU9T2JqZWN0LmNyZWF0ZShudWxsKTt0aGlzW2JdJiYoZS4kY29udGVudD10aGlzW2JdKTtmb3IoY29uc3QgdCBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSl7Y29uc3QgYT10aGlzW3RdO251bGwhPT1hJiYoYSBpbnN0YW5jZW9mIFhGQU9iamVjdD9lW3RdPWFbd10oKTphIGluc3RhbmNlb2YgWEZBT2JqZWN0QXJyYXk/YS5pc0VtcHR5KCl8fChlW3RdPWEuZHVtcCgpKTplW3RdPWEpfXJldHVybiBlfVtDZV0oKXtyZXR1cm4gbnVsbH1bQWVdKCl7cmV0dXJuIHIuSFRNTFJlc3VsdC5FTVBUWX0qW0xdKCl7Zm9yKGNvbnN0IGUgb2YgdGhpc1tSXSgpKXlpZWxkIGV9KltEZV0oZSx0KXtmb3IoY29uc3QgYSBvZiB0aGlzW0xdKCkpaWYoIWV8fHQ9PT1lLmhhcyhhW25lXSkpe2NvbnN0IGU9dGhpc1tGXSgpLHQ9YVtBZV0oZSk7dC5zdWNjZXNzfHwodGhpc1tTXS5mYWlsaW5nTm9kZT1hKTt5aWVsZCB0fX1ba10oKXtyZXR1cm4gbnVsbH1bbF0oZSx0KXt0aGlzW1NdLmNoaWxkcmVuLnB1c2goZSl9W0ZdKCl7fVt1XSh7ZmlsdGVyOmU9bnVsbCxpbmNsdWRlOnQ9ITB9KXtpZih0aGlzW1NdLmdlbmVyYXRvcil7Y29uc3QgZT10aGlzW0ZdKCksdD10aGlzW1NdLmZhaWxpbmdOb2RlW0FlXShlKTtpZighdC5zdWNjZXNzKXJldHVybiB0O3QuaHRtbCYmdGhpc1tsXSh0Lmh0bWwsdC5iYm94KTtkZWxldGUgdGhpc1tTXS5mYWlsaW5nTm9kZX1lbHNlIHRoaXNbU10uZ2VuZXJhdG9yPXRoaXNbRGVdKGUsdCk7Zm9yKDs7KXtjb25zdCBlPXRoaXNbU10uZ2VuZXJhdG9yLm5leHQoKTtpZihlLmRvbmUpYnJlYWs7Y29uc3QgdD1lLnZhbHVlO2lmKCF0LnN1Y2Nlc3MpcmV0dXJuIHQ7dC5odG1sJiZ0aGlzW2xdKHQuaHRtbCx0LmJib3gpfXRoaXNbU10uZ2VuZXJhdG9yPW51bGw7cmV0dXJuIHIuSFRNTFJlc3VsdC5FTVBUWX1bYmVdKGUpe3RoaXNbVWVdPW5ldyBTZXQoT2JqZWN0LmtleXMoZSkpfVtCZV0oZSl7Y29uc3QgdD10aGlzW1RlXSxhPXRoaXNbVWVdO3JldHVyblsuLi5lXS5maWx0ZXIoKGU9PnQuaGFzKGUpJiYhYS5oYXMoZSkpKX1bZ2VdKGUsdD1uZXcgU2V0KXtmb3IoY29uc3QgYSBvZiB0aGlzW0llXSlhW19lXShlLHQpfVtfZV0oZSx0KXtjb25zdCBhPXRoaXNbTmVdKGUsdCk7YT90aGlzW0ZlXShhLGUsdCk6dGhpc1tnZV0oZSx0KX1bTmVdKGUsdCl7Y29uc3R7dXNlOmEsdXNlaHJlZjpyfT10aGlzO2lmKCFhJiYhcilyZXR1cm4gbnVsbDtsZXQgaT1udWxsLHM9bnVsbCxjPW51bGwsbD1hO2lmKHIpe2w9cjtyLnN0YXJ0c1dpdGgoIiNzb20oIikmJnIuZW5kc1dpdGgoIikiKT9zPXIuc2xpY2UoIiNzb20oIi5sZW5ndGgsci5sZW5ndGgtMSk6ci5zdGFydHNXaXRoKCIuI3NvbSgiKSYmci5lbmRzV2l0aCgiKSIpP3M9ci5zbGljZSgiLiNzb20oIi5sZW5ndGgsci5sZW5ndGgtMSk6ci5zdGFydHNXaXRoKCIjIik/Yz1yLnNsaWNlKDEpOnIuc3RhcnRzV2l0aCgiLiMiKSYmKGM9ci5zbGljZSgyKSl9ZWxzZSBhLnN0YXJ0c1dpdGgoIiMiKT9jPWEuc2xpY2UoMSk6cz1hO3RoaXMudXNlPXRoaXMudXNlaHJlZj0iIjtpZihjKWk9ZS5nZXQoYyk7ZWxzZXtpPSgwLG8uc2VhcmNoTm9kZSkoZS5nZXQoZmUpLHRoaXMscywhMCwhMSk7aSYmKGk9aVswXSl9aWYoIWkpeygwLG4ud2FybikoYFhGQSAtIEludmFsaWQgcHJvdG90eXBlIHJlZmVyZW5jZTogJHtsfS5gKTtyZXR1cm4gbnVsbH1pZihpW25lXSE9PXRoaXNbbmVdKXsoMCxuLndhcm4pKGBYRkEgLSBJbmNvbXBhdGlibGUgcHJvdG90eXBlOiAke2lbbmVdfSAhPT0gJHt0aGlzW25lXX0uYCk7cmV0dXJuIG51bGx9aWYodC5oYXMoaSkpeygwLG4ud2FybikoIlhGQSAtIEN5Y2xlIGRldGVjdGVkIGluIHByb3RvdHlwZXMgdXNlLiIpO3JldHVybiBudWxsfXQuYWRkKGkpO2NvbnN0IGg9aVtOZV0oZSx0KTtoJiZpW0ZlXShoLGUsdCk7aVtnZV0oZSx0KTt0LmRlbGV0ZShpKTtyZXR1cm4gaX1bRmVdKGUsdCxhKXtpZihhLmhhcyhlKSl7KDAsbi53YXJuKSgiWEZBIC0gQ3ljbGUgZGV0ZWN0ZWQgaW4gcHJvdG90eXBlcyB1c2UuIik7cmV0dXJufSF0aGlzW2JdJiZlW2JdJiYodGhpc1tiXT1lW2JdKTtuZXcgU2V0KGEpLmFkZChlKTtmb3IoY29uc3QgdCBvZiB0aGlzW0JlXShlW1VlXSkpe3RoaXNbdF09ZVt0XTt0aGlzW1VlXSYmdGhpc1tVZV0uYWRkKHQpfWZvcihjb25zdCByIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKXtpZih0aGlzW1RlXS5oYXMocikpY29udGludWU7Y29uc3Qgbj10aGlzW3JdLGk9ZVtyXTtpZihuIGluc3RhbmNlb2YgWEZBT2JqZWN0QXJyYXkpe2Zvcihjb25zdCBlIG9mIG5bSWVdKWVbX2VdKHQsYSk7Zm9yKGxldCByPW5bSWVdLmxlbmd0aCxzPWlbSWVdLmxlbmd0aDtyPHM7cisrKXtjb25zdCBpPWVbSWVdW3JdW3BdKCk7aWYoIW4ucHVzaChpKSlicmVhaztpWyRlXT10aGlzO3RoaXNbSWVdLnB1c2goaSk7aVtfZV0odCxhKX19ZWxzZSBpZihudWxsPT09bil7aWYobnVsbCE9PWkpe2NvbnN0IGU9aVtwXSgpO2VbJGVdPXRoaXM7dGhpc1tyXT1lO3RoaXNbSWVdLnB1c2goZSk7ZVtfZV0odCxhKX19ZWxzZXtuW2dlXSh0LGEpO2kmJm5bRmVdKGksdCxhKX19fXN0YXRpY1tNZV0oZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/ZS5tYXAoKGU9PlhGQU9iamVjdFtNZV0oZSkpKToib2JqZWN0Ij09dHlwZW9mIGUmJm51bGwhPT1lP09iamVjdC5hc3NpZ24oe30sZSk6ZX1bcF0oKXtjb25zdCBlPU9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKTtmb3IoY29uc3QgdCBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRoaXMpKXRyeXtlW3RdPXRoaXNbdF19Y2F0Y2goYSl7KDAsbi5zaGFkb3cpKGUsdCx0aGlzW3RdKX1lW3ZlXT1gJHtlW25lXX0ke0hlKyt9YDtlW0llXT1bXTtmb3IoY29uc3QgdCBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSl7aWYodGhpc1tUZV0uaGFzKHQpKXtlW3RdPVhGQU9iamVjdFtNZV0odGhpc1t0XSk7Y29udGludWV9Y29uc3QgYT10aGlzW3RdO2VbdF09YSBpbnN0YW5jZW9mIFhGQU9iamVjdEFycmF5P25ldyBYRkFPYmplY3RBcnJheShhW0xlXSk6bnVsbH1mb3IoY29uc3QgdCBvZiB0aGlzW0llXSl7Y29uc3QgYT10W25lXSxyPXRbcF0oKTtlW0llXS5wdXNoKHIpO3JbJGVdPWU7bnVsbD09PWVbYV0/ZVthXT1yOmVbYV1bSWVdLnB1c2gocil9cmV0dXJuIGV9W1JdKGU9bnVsbCl7cmV0dXJuIGU/dGhpc1tJZV0uZmlsdGVyKCh0PT50W25lXT09PWUpKTp0aGlzW0llXX1bT10oZSl7cmV0dXJuIHRoaXNbZV19W1RdKGUsdCxhPSEwKXtyZXR1cm4gQXJyYXkuZnJvbSh0aGlzW01dKGUsdCxhKSl9KltNXShlLHQsYT0hMCl7aWYoInBhcmVudCIhPT1lKXtmb3IoY29uc3QgYSBvZiB0aGlzW0llXSl7YVtuZV09PT1lJiYoeWllbGQgYSk7YS5uYW1lPT09ZSYmKHlpZWxkIGEpOyh0fHxhW2VlXSgpKSYmKHlpZWxkKmFbTV0oZSx0LCExKSl9YSYmdGhpc1tUZV0uaGFzKGUpJiYoeWllbGQgbmV3IFhGQUF0dHJpYnV0ZSh0aGlzLGUsdGhpc1tlXSkpfWVsc2UgeWllbGQgdGhpc1skZV19fXQuWEZBT2JqZWN0PVhGQU9iamVjdDtjbGFzcyBYRkFPYmplY3RBcnJheXtjb25zdHJ1Y3RvcihlPTEvMCl7dGhpc1tMZV09ZTt0aGlzW0llXT1bXX1wdXNoKGUpe2lmKHRoaXNbSWVdLmxlbmd0aDw9dGhpc1tMZV0pe3RoaXNbSWVdLnB1c2goZSk7cmV0dXJuITB9KDAsbi53YXJuKShgWEZBIC0gbm9kZSAiJHtlW25lXX0iIGFjY2VwdHMgbm8gbW9yZSB0aGFuICR7dGhpc1tMZV19IGNoaWxkcmVuYCk7cmV0dXJuITF9aXNFbXB0eSgpe3JldHVybiAwPT09dGhpc1tJZV0ubGVuZ3RofWR1bXAoKXtyZXR1cm4gMT09PXRoaXNbSWVdLmxlbmd0aD90aGlzW0llXVswXVt3XSgpOnRoaXNbSWVdLm1hcCgoZT0+ZVt3XSgpKSl9W3BdKCl7Y29uc3QgZT1uZXcgWEZBT2JqZWN0QXJyYXkodGhpc1tMZV0pO2VbSWVdPXRoaXNbSWVdLm1hcCgoZT0+ZVtwXSgpKSk7cmV0dXJuIGV9Z2V0IGNoaWxkcmVuKCl7cmV0dXJuIHRoaXNbSWVdfWNsZWFyKCl7dGhpc1tJZV0ubGVuZ3RoPTB9fXQuWEZBT2JqZWN0QXJyYXk9WEZBT2JqZWN0QXJyYXk7Y2xhc3MgWEZBQXR0cmlidXRle2NvbnN0cnVjdG9yKGUsdCxhKXt0aGlzWyRlXT1lO3RoaXNbbmVdPXQ7dGhpc1tiXT1hO3RoaXNbbV09ITE7dGhpc1t2ZV09ImF0dHJpYnV0ZSIrSGUrK31bX10oKXtyZXR1cm4gdGhpc1skZV19W0tdKCl7cmV0dXJuITB9W0VdKCl7cmV0dXJuIHRoaXNbYl0udHJpbSgpfVt5ZV0oZSl7ZT1lLnZhbHVlfHwiIjt0aGlzW2JdPWUudG9TdHJpbmcoKX1bU2VdKCl7cmV0dXJuIHRoaXNbYl19W1ldKGUpe3JldHVybiB0aGlzWyRlXT09PWV8fHRoaXNbJGVdW1ldKGUpfX10LlhGQUF0dHJpYnV0ZT1YRkFBdHRyaWJ1dGU7Y2xhc3MgWG1sT2JqZWN0IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUsdCxhPXt9KXtzdXBlcihlLHQpO3RoaXNbYl09IiI7dGhpc1tQZV09bnVsbDtpZigiI3RleHQiIT09dCl7Y29uc3QgZT1uZXcgTWFwO3RoaXNbT2VdPWU7Zm9yKGNvbnN0W3Qscl1vZiBPYmplY3QuZW50cmllcyhhKSllLnNldCh0LG5ldyBYRkFBdHRyaWJ1dGUodGhpcyx0LHIpKTtpZihhLmhhc093blByb3BlcnR5KGllKSl7Y29uc3QgZT1hW2llXS54ZmEuZGF0YU5vZGU7dm9pZCAwIT09ZSYmKCJkYXRhR3JvdXAiPT09ZT90aGlzW1BlXT0hMToiZGF0YVZhbHVlIj09PWUmJih0aGlzW1BlXT0hMCkpfX10aGlzW21dPSExfVtrZV0oZSl7Y29uc3QgdD10aGlzW25lXTtpZigiI3RleHQiPT09dCl7ZS5wdXNoKCgwLGkuZW5jb2RlVG9YbWxTdHJpbmcpKHRoaXNbYl0pKTtyZXR1cm59Y29uc3QgYT0oMCxuLnV0ZjhTdHJpbmdUb1N0cmluZykodCkscj10aGlzW3JlXT09PXFlPyJ4ZmE6IjoiIjtlLnB1c2goYDwke3J9JHthfWApO2Zvcihjb25zdFt0LGFdb2YgdGhpc1tPZV0uZW50cmllcygpKXtjb25zdCByPSgwLG4udXRmOFN0cmluZ1RvU3RyaW5nKSh0KTtlLnB1c2goYCAke3J9PSIkeygwLGkuZW5jb2RlVG9YbWxTdHJpbmcpKGFbYl0pfSJgKX1udWxsIT09dGhpc1tQZV0mJih0aGlzW1BlXT9lLnB1c2goJyB4ZmE6ZGF0YU5vZGU9ImRhdGFWYWx1ZSInKTplLnB1c2goJyB4ZmE6ZGF0YU5vZGU9ImRhdGFHcm91cCInKSk7aWYodGhpc1tiXXx8MCE9PXRoaXNbSWVdLmxlbmd0aCl7ZS5wdXNoKCI+Iik7aWYodGhpc1tiXSkic3RyaW5nIj09dHlwZW9mIHRoaXNbYl0/ZS5wdXNoKCgwLGkuZW5jb2RlVG9YbWxTdHJpbmcpKHRoaXNbYl0pKTp0aGlzW2JdW2tlXShlKTtlbHNlIGZvcihjb25zdCB0IG9mIHRoaXNbSWVdKXRba2VdKGUpO2UucHVzaChgPC8ke3J9JHthfT5gKX1lbHNlIGUucHVzaCgiLz4iKX1bc2VdKGUpe2lmKHRoaXNbYl0pe2NvbnN0IGU9bmV3IFhtbE9iamVjdCh0aGlzW3JlXSwiI3RleHQiKTt0aGlzW2hdKGUpO2VbYl09dGhpc1tiXTt0aGlzW2JdPSIifXRoaXNbaF0oZSk7cmV0dXJuITB9W2NlXShlKXt0aGlzW2JdKz1lfVt4XSgpe2lmKHRoaXNbYl0mJnRoaXNbSWVdLmxlbmd0aD4wKXtjb25zdCBlPW5ldyBYbWxPYmplY3QodGhpc1tyZV0sIiN0ZXh0Iik7dGhpc1toXShlKTtlW2JdPXRoaXNbYl07ZGVsZXRlIHRoaXNbYl19fVtBZV0oKXtyZXR1cm4iI3RleHQiPT09dGhpc1tuZV0/ci5IVE1MUmVzdWx0LnN1Y2Nlc3Moe25hbWU6IiN0ZXh0Iix2YWx1ZTp0aGlzW2JdfSk6ci5IVE1MUmVzdWx0LkVNUFRZfVtSXShlPW51bGwpe3JldHVybiBlP3RoaXNbSWVdLmZpbHRlcigodD0+dFtuZV09PT1lKSk6dGhpc1tJZV19W3ZdKCl7cmV0dXJuIHRoaXNbT2VdfVtPXShlKXtjb25zdCB0PXRoaXNbT2VdLmdldChlKTtyZXR1cm4gdm9pZCAwIT09dD90OnRoaXNbUl0oZSl9KltNXShlLHQpe2NvbnN0IGE9dGhpc1tPZV0uZ2V0KGUpO2EmJih5aWVsZCBhKTtmb3IoY29uc3QgYSBvZiB0aGlzW0llXSl7YVtuZV09PT1lJiYoeWllbGQgYSk7dCYmKHlpZWxkKmFbTV0oZSx0KSl9fSpbQ10oZSx0KXtjb25zdCBhPXRoaXNbT2VdLmdldChlKTshYXx8dCYmYVttXXx8KHlpZWxkIGEpO2Zvcihjb25zdCBhIG9mIHRoaXNbSWVdKXlpZWxkKmFbQ10oZSx0KX0qW05dKGUsdCxhKXtmb3IoY29uc3QgciBvZiB0aGlzW0llXSl7cltuZV0hPT1lfHxhJiZyW21dfHwoeWllbGQgcik7dCYmKHlpZWxkKnJbTl0oZSx0LGEpKX19W0tdKCl7cmV0dXJuIG51bGw9PT10aGlzW1BlXT8wPT09dGhpc1tJZV0ubGVuZ3RofHx0aGlzW0llXVswXVtyZV09PT1zLk5hbWVzcGFjZUlkcy54aHRtbC5pZDp0aGlzW1BlXX1bRV0oKXtyZXR1cm4gbnVsbD09PXRoaXNbUGVdPzA9PT10aGlzW0llXS5sZW5ndGg/dGhpc1tiXS50cmltKCk6dGhpc1tJZV1bMF1bcmVdPT09cy5OYW1lc3BhY2VJZHMueGh0bWwuaWQ/dGhpc1tJZV1bMF1bU2VdKCkudHJpbSgpOm51bGw6dGhpc1tiXS50cmltKCl9W3llXShlKXtlPWUudmFsdWV8fCIiO3RoaXNbYl09ZS50b1N0cmluZygpfVt3XShlPSExKXtjb25zdCB0PU9iamVjdC5jcmVhdGUobnVsbCk7ZSYmKHQuJG5zPXRoaXNbcmVdKTt0aGlzW2JdJiYodC4kY29udGVudD10aGlzW2JdKTt0LiRuYW1lPXRoaXNbbmVdO3QuY2hpbGRyZW49W107Zm9yKGNvbnN0IGEgb2YgdGhpc1tJZV0pdC5jaGlsZHJlbi5wdXNoKGFbd10oZSkpO3QuYXR0cmlidXRlcz1PYmplY3QuY3JlYXRlKG51bGwpO2Zvcihjb25zdFtlLGFdb2YgdGhpc1tPZV0pdC5hdHRyaWJ1dGVzW2VdPWFbYl07cmV0dXJuIHR9fXQuWG1sT2JqZWN0PVhtbE9iamVjdDtjbGFzcyBDb250ZW50T2JqZWN0IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoZSx0KTt0aGlzW2JdPSIifVtjZV0oZSl7dGhpc1tiXSs9ZX1beF0oKXt9fXQuQ29udGVudE9iamVjdD1Db250ZW50T2JqZWN0O3QuT3B0aW9uT2JqZWN0PWNsYXNzIE9wdGlvbk9iamVjdCBleHRlbmRzIENvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSx0LGEpe3N1cGVyKGUsdCk7dGhpc1tqZV09YX1beF0oKXt0aGlzW2JdPSgwLHIuZ2V0S2V5d29yZCkoe2RhdGE6dGhpc1tiXSxkZWZhdWx0VmFsdWU6dGhpc1tqZV1bMF0sdmFsaWRhdGU6ZT0+dGhpc1tqZV0uaW5jbHVkZXMoZSl9KX1bZF0oZSl7c3VwZXJbZF0oZSk7ZGVsZXRlIHRoaXNbamVdfX07dC5TdHJpbmdPYmplY3Q9Y2xhc3MgU3RyaW5nT2JqZWN0IGV4dGVuZHMgQ29udGVudE9iamVjdHtbeF0oKXt0aGlzW2JdPXRoaXNbYl0udHJpbSgpfX07Y2xhc3MgSW50ZWdlck9iamVjdCBleHRlbmRzIENvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSx0LGEscil7c3VwZXIoZSx0KTt0aGlzW0VlXT1hO3RoaXNbWGVdPXJ9W3hdKCl7dGhpc1tiXT0oMCxyLmdldEludGVnZXIpKHtkYXRhOnRoaXNbYl0sZGVmYXVsdFZhbHVlOnRoaXNbRWVdLHZhbGlkYXRlOnRoaXNbWGVdfSl9W2RdKGUpe3N1cGVyW2RdKGUpO2RlbGV0ZSB0aGlzW0VlXTtkZWxldGUgdGhpc1tYZV19fXQuSW50ZWdlck9iamVjdD1JbnRlZ2VyT2JqZWN0O3QuT3B0aW9uMDE9Y2xhc3MgT3B0aW9uMDEgZXh0ZW5kcyBJbnRlZ2VyT2JqZWN0e2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoZSx0LDAsKGU9PjE9PT1lKSl9fTt0Lk9wdGlvbjEwPWNsYXNzIE9wdGlvbjEwIGV4dGVuZHMgSW50ZWdlck9iamVjdHtjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKGUsdCwxLChlPT4wPT09ZSkpfX19LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5IVE1MUmVzdWx0PXZvaWQgMDt0LmdldEJCb3g9ZnVuY3Rpb24gZ2V0QkJveChlKXtjb25zdCB0PS0xO2lmKCFlKXJldHVybnt4OnQseTp0LHdpZHRoOnQsaGVpZ2h0OnR9O2NvbnN0IGE9ZS50cmltKCkuc3BsaXQoL1xzKixccyovKS5tYXAoKGU9PmdldE1lYXN1cmVtZW50KGUsIi0xIikpKTtpZihhLmxlbmd0aDw0fHxhWzJdPDB8fGFbM108MClyZXR1cm57eDp0LHk6dCx3aWR0aDp0LGhlaWdodDp0fTtjb25zdFtyLG4saSxzXT1hO3JldHVybnt4OnIseTpuLHdpZHRoOmksaGVpZ2h0OnN9fTt0LmdldENvbG9yPWZ1bmN0aW9uIGdldENvbG9yKGUsdD1bMCwwLDBdKXtsZXRbYSxyLG5dPXQ7aWYoIWUpcmV0dXJue3I6YSxnOnIsYjpufTtjb25zdCBpPWUudHJpbSgpLnNwbGl0KC9ccyosXHMqLykubWFwKChlPT5NYXRoLm1pbihNYXRoLm1heCgwLHBhcnNlSW50KGUudHJpbSgpLDEwKSksMjU1KSkpLm1hcCgoZT0+aXNOYU4oZSk/MDplKSk7aWYoaS5sZW5ndGg8MylyZXR1cm57cjphLGc6cixiOm59O1thLHIsbl09aTtyZXR1cm57cjphLGc6cixiOm59fTt0LmdldEZsb2F0PWZ1bmN0aW9uIGdldEZsb2F0KHtkYXRhOmUsZGVmYXVsdFZhbHVlOnQsdmFsaWRhdGU6YX0pe2lmKCFlKXJldHVybiB0O2U9ZS50cmltKCk7Y29uc3Qgcj1wYXJzZUZsb2F0KGUpO2lmKCFpc05hTihyKSYmYShyKSlyZXR1cm4gcjtyZXR1cm4gdH07dC5nZXRJbnRlZ2VyPWZ1bmN0aW9uIGdldEludGVnZXIoe2RhdGE6ZSxkZWZhdWx0VmFsdWU6dCx2YWxpZGF0ZTphfSl7aWYoIWUpcmV0dXJuIHQ7ZT1lLnRyaW0oKTtjb25zdCByPXBhcnNlSW50KGUsMTApO2lmKCFpc05hTihyKSYmYShyKSlyZXR1cm4gcjtyZXR1cm4gdH07dC5nZXRLZXl3b3JkPWdldEtleXdvcmQ7dC5nZXRNZWFzdXJlbWVudD1nZXRNZWFzdXJlbWVudDt0LmdldFJhdGlvPWZ1bmN0aW9uIGdldFJhdGlvKGUpe2lmKCFlKXJldHVybntudW06MSxkZW46MX07Y29uc3QgdD1lLnRyaW0oKS5zcGxpdCgvXHMqOlxzKi8pLm1hcCgoZT0+cGFyc2VGbG9hdChlKSkpLmZpbHRlcigoZT0+IWlzTmFOKGUpKSk7MT09PXQubGVuZ3RoJiZ0LnB1c2goMSk7aWYoMD09PXQubGVuZ3RoKXJldHVybntudW06MSxkZW46MX07Y29uc3RbYSxyXT10O3JldHVybntudW06YSxkZW46cn19O3QuZ2V0UmVsZXZhbnQ9ZnVuY3Rpb24gZ2V0UmVsZXZhbnQoZSl7aWYoIWUpcmV0dXJuW107cmV0dXJuIGUudHJpbSgpLnNwbGl0KC9ccysvKS5tYXAoKGU9Pih7ZXhjbHVkZWQ6Ii0iPT09ZVswXSx2aWV3bmFtZTplLnN1YnN0cmluZygxKX0pKSl9O3QuZ2V0U3RyaW5nT3B0aW9uPWZ1bmN0aW9uIGdldFN0cmluZ09wdGlvbihlLHQpe3JldHVybiBnZXRLZXl3b3JkKHtkYXRhOmUsZGVmYXVsdFZhbHVlOnRbMF0sdmFsaWRhdGU6ZT0+dC5pbmNsdWRlcyhlKX0pfTt0LnN0cmlwUXVvdGVzPWZ1bmN0aW9uIHN0cmlwUXVvdGVzKGUpe2lmKGUuc3RhcnRzV2l0aCgiJyIpfHxlLnN0YXJ0c1dpdGgoJyInKSlyZXR1cm4gZS5zbGljZSgxLGUubGVuZ3RoLTEpO3JldHVybiBlfTt2YXIgcj1hKDIpO2NvbnN0IG49e3B0OmU9PmUsY206ZT0+ZS8yLjU0KjcyLG1tOmU9PmUvMjUuNCo3MixpbjplPT43MiplLHB4OmU9PmV9LGk9LyhbKy1dP1xkK1wuP1xkKikoLiopLztmdW5jdGlvbiBnZXRLZXl3b3JkKHtkYXRhOmUsZGVmYXVsdFZhbHVlOnQsdmFsaWRhdGU6YX0pe3JldHVybiBlJiZhKGU9ZS50cmltKCkpP2U6dH1mdW5jdGlvbiBnZXRNZWFzdXJlbWVudChlLHQ9IjAiKXt0PXR8fCIwIjtpZighZSlyZXR1cm4gZ2V0TWVhc3VyZW1lbnQodCk7Y29uc3QgYT1lLnRyaW0oKS5tYXRjaChpKTtpZighYSlyZXR1cm4gZ2V0TWVhc3VyZW1lbnQodCk7Y29uc3RbLHIsc109YSxvPXBhcnNlRmxvYXQocik7aWYoaXNOYU4obykpcmV0dXJuIGdldE1lYXN1cmVtZW50KHQpO2lmKDA9PT1vKXJldHVybiAwO2NvbnN0IGM9bltzXTtyZXR1cm4gYz9jKG8pOm99Y2xhc3MgSFRNTFJlc3VsdHtzdGF0aWMgZ2V0IEZBSUxVUkUoKXtyZXR1cm4oMCxyLnNoYWRvdykodGhpcywiRkFJTFVSRSIsbmV3IEhUTUxSZXN1bHQoITEsbnVsbCxudWxsLG51bGwpKX1zdGF0aWMgZ2V0IEVNUFRZKCl7cmV0dXJuKDAsci5zaGFkb3cpKHRoaXMsIkVNUFRZIixuZXcgSFRNTFJlc3VsdCghMCxudWxsLG51bGwsbnVsbCkpfWNvbnN0cnVjdG9yKGUsdCxhLHIpe3RoaXMuc3VjY2Vzcz1lO3RoaXMuaHRtbD10O3RoaXMuYmJveD1hO3RoaXMuYnJlYWtOb2RlPXJ9aXNCcmVhaygpe3JldHVybiEhdGhpcy5icmVha05vZGV9c3RhdGljIGJyZWFrTm9kZShlKXtyZXR1cm4gbmV3IEhUTUxSZXN1bHQoITEsbnVsbCxudWxsLGUpfXN0YXRpYyBzdWNjZXNzKGUsdD1udWxsKXtyZXR1cm4gbmV3IEhUTUxSZXN1bHQoITAsZSx0LG51bGwpfX10LkhUTUxSZXN1bHQ9SFRNTFJlc3VsdH0sKGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5OYW1lc3BhY2VJZHM9dC4kYnVpbGRYRkFPYmplY3Q9dm9pZCAwO2NvbnN0IGE9U3ltYm9sKCk7dC4kYnVpbGRYRkFPYmplY3Q9YTt0Lk5hbWVzcGFjZUlkcz17Y29uZmlnOntpZDowLGNoZWNrOmU9PmUuc3RhcnRzV2l0aCgiaHR0cDovL3d3dy54ZmEub3JnL3NjaGVtYS94Y2kvIil9LGNvbm5lY3Rpb25TZXQ6e2lkOjEsY2hlY2s6ZT0+ZS5zdGFydHNXaXRoKCJodHRwOi8vd3d3LnhmYS5vcmcvc2NoZW1hL3hmYS1jb25uZWN0aW9uLXNldC8iKX0sZGF0YXNldHM6e2lkOjIsY2hlY2s6ZT0+ZS5zdGFydHNXaXRoKCJodHRwOi8vd3d3LnhmYS5vcmcvc2NoZW1hL3hmYS1kYXRhLyIpfSxmb3JtOntpZDozLGNoZWNrOmU9PmUuc3RhcnRzV2l0aCgiaHR0cDovL3d3dy54ZmEub3JnL3NjaGVtYS94ZmEtZm9ybS8iKX0sbG9jYWxlU2V0OntpZDo0LGNoZWNrOmU9PmUuc3RhcnRzV2l0aCgiaHR0cDovL3d3dy54ZmEub3JnL3NjaGVtYS94ZmEtbG9jYWxlLXNldC8iKX0scGRmOntpZDo1LGNoZWNrOmU9PiJodHRwOi8vbnMuYWRvYmUuY29tL3hkcC9wZGYvIj09PWV9LHNpZ25hdHVyZTp7aWQ6NixjaGVjazplPT4iaHR0cDovL3d3dy53My5vcmcvMjAwMC8wOS94bWxkc2lnIyI9PT1lfSxzb3VyY2VTZXQ6e2lkOjcsY2hlY2s6ZT0+ZS5zdGFydHNXaXRoKCJodHRwOi8vd3d3LnhmYS5vcmcvc2NoZW1hL3hmYS1zb3VyY2Utc2V0LyIpfSxzdHlsZXNoZWV0OntpZDo4LGNoZWNrOmU9PiJodHRwOi8vd3d3LnczLm9yZy8xOTk5L1hTTC9UcmFuc2Zvcm0iPT09ZX0sdGVtcGxhdGU6e2lkOjksY2hlY2s6ZT0+ZS5zdGFydHNXaXRoKCJodHRwOi8vd3d3LnhmYS5vcmcvc2NoZW1hL3hmYS10ZW1wbGF0ZS8iKX0seGRjOntpZDoxMCxjaGVjazplPT5lLnN0YXJ0c1dpdGgoImh0dHA6Ly93d3cueGZhLm9yZy9zY2hlbWEveGRjLyIpfSx4ZHA6e2lkOjExLGNoZWNrOmU9PiJodHRwOi8vbnMuYWRvYmUuY29tL3hkcC8iPT09ZX0seGZkZjp7aWQ6MTIsY2hlY2s6ZT0+Imh0dHA6Ly9ucy5hZG9iZS5jb20veGZkZi8iPT09ZX0seGh0bWw6e2lkOjEzLGNoZWNrOmU9PiJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj09PWV9LHhtcG1ldGE6e2lkOjE0LGNoZWNrOmU9PiJodHRwOi8vbnMuYWRvYmUuY29tL3htcG1ldGEvIj09PWV9fX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LmNyZWF0ZURhdGFOb2RlPWZ1bmN0aW9uIGNyZWF0ZURhdGFOb2RlKGUsdCxhKXtjb25zdCBuPXBhcnNlRXhwcmVzc2lvbihhKTtpZighbilyZXR1cm4gbnVsbDtpZihuLnNvbWUoKGU9PmUub3BlcmF0b3I9PT1sKSkpcmV0dXJuIG51bGw7Y29uc3Qgcz1mLmdldChuWzBdLm5hbWUpO2xldCBvPTA7aWYocyl7ZT1zKGUsdCk7bz0xfWVsc2UgZT10fHxlO2ZvcihsZXQgdD1uLmxlbmd0aDtvPHQ7bysrKXtjb25zdHtuYW1lOnQsb3BlcmF0b3I6YSxpbmRleDpzfT1uW29dO2lmKCFpc0Zpbml0ZShzKSl7bltvXS5pbmRleD0wO3JldHVybiBjcmVhdGVOb2RlcyhlLG4uc2xpY2UobykpfWxldCB1O3N3aXRjaChhKXtjYXNlIGM6dT1lW3IuJGdldENoaWxkcmVuQnlOYW1lXSh0LCExKTticmVhaztjYXNlIGw6dT1lW3IuJGdldENoaWxkcmVuQnlOYW1lXSh0LCEwKTticmVhaztjYXNlIGg6dT1lW3IuJGdldENoaWxkcmVuQnlDbGFzc10odCk7dT11IGluc3RhbmNlb2Ygci5YRkFPYmplY3RBcnJheT91LmNoaWxkcmVuOlt1XX1pZigwPT09dS5sZW5ndGgpcmV0dXJuIGNyZWF0ZU5vZGVzKGUsbi5zbGljZShvKSk7aWYoIShzPHUubGVuZ3RoKSl7bltvXS5pbmRleD1zLXUubGVuZ3RoO3JldHVybiBjcmVhdGVOb2RlcyhlLG4uc2xpY2UobykpfXtjb25zdCB0PXVbc107aWYoISh0IGluc3RhbmNlb2Ygci5YRkFPYmplY3QpKXsoMCxpLndhcm4pKCJYRkEgLSBDYW5ub3QgY3JlYXRlIGEgbm9kZS4iKTtyZXR1cm4gbnVsbH1lPXR9fXJldHVybiBudWxsfTt0LnNlYXJjaE5vZGU9ZnVuY3Rpb24gc2VhcmNoTm9kZShlLHQsYSxuPSEwLGk9ITApe2NvbnN0IHM9cGFyc2VFeHByZXNzaW9uKGEsbik7aWYoIXMpcmV0dXJuIG51bGw7Y29uc3Qgbz1mLmdldChzWzBdLm5hbWUpO2xldCB1LGQ9MDtpZihvKXt1PSEwO2U9W28oZSx0KV07ZD0xfWVsc2V7dT1udWxsPT09dDtlPVt0fHxlXX1mb3IobGV0IGE9cy5sZW5ndGg7ZDxhO2QrKyl7Y29uc3R7bmFtZTphLGNhY2hlTmFtZTpuLG9wZXJhdG9yOm8saW5kZXg6Zn09c1tkXSxwPVtdO2Zvcihjb25zdCB0IG9mIGUpe2lmKCEodCBpbnN0YW5jZW9mIHIuWEZBT2JqZWN0KSljb250aW51ZTtsZXQgZSxzO2lmKGkpe3M9Zy5nZXQodCk7aWYoIXMpe3M9bmV3IE1hcDtnLnNldCh0LHMpfWU9cy5nZXQobil9aWYoIWUpe3N3aXRjaChvKXtjYXNlIGM6ZT10W3IuJGdldENoaWxkcmVuQnlOYW1lXShhLCExKTticmVhaztjYXNlIGw6ZT10W3IuJGdldENoaWxkcmVuQnlOYW1lXShhLCEwKTticmVhaztjYXNlIGg6ZT10W3IuJGdldENoaWxkcmVuQnlDbGFzc10oYSk7ZT1lIGluc3RhbmNlb2Ygci5YRkFPYmplY3RBcnJheT9lLmNoaWxkcmVuOltlXX1pJiZzLnNldChuLGUpfWUubGVuZ3RoPjAmJnAucHVzaChlKX1pZigwIT09cC5sZW5ndGh8fHV8fDAhPT1kKWU9aXNGaW5pdGUoZik/cC5maWx0ZXIoKGU9PmY8ZS5sZW5ndGgpKS5tYXAoKGU9PmVbZl0pKTpwLmZsYXQoKTtlbHNle2NvbnN0IGE9dFtyLiRnZXRQYXJlbnRdKCk7aWYoISh0PWEpKXJldHVybiBudWxsO2Q9LTE7ZT1bdF19fWlmKDA9PT1lLmxlbmd0aClyZXR1cm4gbnVsbDtyZXR1cm4gZX07dmFyIHI9YSg3Nyksbj1hKDc5KSxpPWEoMik7Y29uc3Qgcz0vXlteLltdKy8sbz0vXlteXF1dKy8sYz0wLGw9MSxoPTIsdT0zLGQ9NCxmPW5ldyBNYXAoW1siJGRhdGEiLChlLHQpPT5lLmRhdGFzZXRzP2UuZGF0YXNldHMuZGF0YTplXSxbIiRyZWNvcmQiLChlLHQpPT4oZS5kYXRhc2V0cz9lLmRhdGFzZXRzLmRhdGE6ZSlbci4kZ2V0Q2hpbGRyZW5dKClbMF1dLFsiJHRlbXBsYXRlIiwoZSx0KT0+ZS50ZW1wbGF0ZV0sWyIkY29ubmVjdGlvblNldCIsKGUsdCk9PmUuY29ubmVjdGlvblNldF0sWyIkZm9ybSIsKGUsdCk9PmUuZm9ybV0sWyIkbGF5b3V0IiwoZSx0KT0+ZS5sYXlvdXRdLFsiJGhvc3QiLChlLHQpPT5lLmhvc3RdLFsiJGRhdGFXaW5kb3ciLChlLHQpPT5lLmRhdGFXaW5kb3ddLFsiJGV2ZW50IiwoZSx0KT0+ZS5ldmVudF0sWyIhIiwoZSx0KT0+ZS5kYXRhc2V0c10sWyIkeGZhIiwoZSx0KT0+ZV0sWyJ4ZmEiLChlLHQpPT5lXSxbIiQiLChlLHQpPT50XV0pLGc9bmV3IFdlYWtNYXAscD1uLk5hbWVzcGFjZUlkcy5kYXRhc2V0cy5pZDtmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb24oZSx0LGE9ITApe2xldCByPWUubWF0Y2gocyk7aWYoIXIpcmV0dXJuIG51bGw7bGV0W25dPXI7Y29uc3QgZj1be25hbWU6bixjYWNoZU5hbWU6Ii4iK24saW5kZXg6MCxqczpudWxsLGZvcm1DYWxjOm51bGwsb3BlcmF0b3I6Y31dO2xldCBnPW4ubGVuZ3RoO2Zvcig7ZzxlLmxlbmd0aDspe2NvbnN0IG09ZztpZigiWyI9PT1lLmNoYXJBdChnKyspKXtyPWUuc2xpY2UoZykubWF0Y2gobyk7aWYoIXIpeygwLGkud2FybikoIlhGQSAtIEludmFsaWQgaW5kZXggaW4gU09NIGV4cHJlc3Npb24iKTtyZXR1cm4gbnVsbH1mLmF0KC0xKS5pbmRleD0iKiI9PT0ocD0ocD1yWzBdKS50cmltKCkpPzEvMDpwYXJzZUludChwLDEwKXx8MDtnKz1yWzBdLmxlbmd0aCsxO2NvbnRpbnVlfWxldCBiO3N3aXRjaChlLmNoYXJBdChnKSl7Y2FzZSIuIjppZighdClyZXR1cm4gbnVsbDtnKys7Yj1sO2JyZWFrO2Nhc2UiIyI6ZysrO2I9aDticmVhaztjYXNlIlsiOmlmKGEpeygwLGkud2FybikoIlhGQSAtIFNPTSBleHByZXNzaW9uIGNvbnRhaW5zIGEgRm9ybUNhbGMgc3ViZXhwcmVzc2lvbiB3aGljaCBpcyBub3Qgc3VwcG9ydGVkIGZvciBub3cuIik7cmV0dXJuIG51bGx9Yj11O2JyZWFrO2Nhc2UiKCI6aWYoYSl7KDAsaS53YXJuKSgiWEZBIC0gU09NIGV4cHJlc3Npb24gY29udGFpbnMgYSBKYXZhU2NyaXB0IHN1YmV4cHJlc3Npb24gd2hpY2ggaXMgbm90IHN1cHBvcnRlZCBmb3Igbm93LiIpO3JldHVybiBudWxsfWI9ZDticmVhaztkZWZhdWx0OmI9Y31yPWUuc2xpY2UoZykubWF0Y2gocyk7aWYoIXIpYnJlYWs7W25dPXI7Zys9bi5sZW5ndGg7Zi5wdXNoKHtuYW1lOm4sY2FjaGVOYW1lOmUuc2xpY2UobSxnKSxvcGVyYXRvcjpiLGluZGV4OjAsanM6bnVsbCxmb3JtQ2FsYzpudWxsfSl9dmFyIHA7cmV0dXJuIGZ9ZnVuY3Rpb24gY3JlYXRlTm9kZXMoZSx0KXtsZXQgYT1udWxsO2Zvcihjb25zdHtuYW1lOm4saW5kZXg6aX1vZiB0KXtmb3IobGV0IHQ9MCxzPWlzRmluaXRlKGkpP2k6MDt0PD1zO3QrKyl7Y29uc3QgdD1lW3IuJG5hbWVzcGFjZUlkXT09PXA/LTE6ZVtyLiRuYW1lc3BhY2VJZF07YT1uZXcgci5YbWxPYmplY3QodCxuKTtlW3IuJGFwcGVuZENoaWxkXShhKX1lPWF9cmV0dXJuIGF9fSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuQmluZGVyPXZvaWQgMDt2YXIgcj1hKDc3KSxuPWEoODIpLGk9YSg4MCkscz1hKDc5KSxvPWEoMik7Y29uc3QgYz1zLk5hbWVzcGFjZUlkcy5kYXRhc2V0cy5pZDtmdW5jdGlvbiBjcmVhdGVUZXh0KGUpe2NvbnN0IHQ9bmV3IG4uVGV4dCh7fSk7dFtyLiRjb250ZW50XT1lO3JldHVybiB0fXQuQmluZGVyPWNsYXNzIEJpbmRlcntjb25zdHJ1Y3RvcihlKXt0aGlzLnJvb3Q9ZTt0aGlzLmRhdGFzZXRzPWUuZGF0YXNldHM7ZS5kYXRhc2V0cyYmZS5kYXRhc2V0cy5kYXRhP3RoaXMuZGF0YT1lLmRhdGFzZXRzLmRhdGE6dGhpcy5kYXRhPW5ldyByLlhtbE9iamVjdChzLk5hbWVzcGFjZUlkcy5kYXRhc2V0cy5pZCwiZGF0YSIpO3RoaXMuZW1wdHlNZXJnZT0wPT09dGhpcy5kYXRhW3IuJGdldENoaWxkcmVuXSgpLmxlbmd0aDt0aGlzLnJvb3QuZm9ybT10aGlzLmZvcm09ZS50ZW1wbGF0ZVtyLiRjbG9uZV0oKX1faXNDb25zdW1lRGF0YSgpe3JldHVybiF0aGlzLmVtcHR5TWVyZ2UmJnRoaXMuX21lcmdlTW9kZX1faXNNYXRjaFRlbXBsYXRlKCl7cmV0dXJuIXRoaXMuX2lzQ29uc3VtZURhdGEoKX1iaW5kKCl7dGhpcy5fYmluZEVsZW1lbnQodGhpcy5mb3JtLHRoaXMuZGF0YSk7cmV0dXJuIHRoaXMuZm9ybX1nZXREYXRhKCl7cmV0dXJuIHRoaXMuZGF0YX1fYmluZFZhbHVlKGUsdCxhKXtlW3IuJGRhdGFdPXQ7aWYoZVtyLiRoYXNTZXR0YWJsZVZhbHVlXSgpKWlmKHRbci4kaXNEYXRhVmFsdWVdKCkpe2NvbnN0IGE9dFtyLiRnZXREYXRhVmFsdWVdKCk7ZVtyLiRzZXRWYWx1ZV0oY3JlYXRlVGV4dChhKSl9ZWxzZSBpZihlIGluc3RhbmNlb2Ygbi5GaWVsZCYmZS51aSYmZS51aS5jaG9pY2VMaXN0JiYibXVsdGlTZWxlY3QiPT09ZS51aS5jaG9pY2VMaXN0Lm9wZW4pe2NvbnN0IGE9dFtyLiRnZXRDaGlsZHJlbl0oKS5tYXAoKGU9PmVbci4kY29udGVudF0udHJpbSgpKSkuam9pbigiXG4iKTtlW3IuJHNldFZhbHVlXShjcmVhdGVUZXh0KGEpKX1lbHNlIHRoaXMuX2lzQ29uc3VtZURhdGEoKSYmKDAsby53YXJuKSgiWEZBIC0gTm9kZXMgaGF2ZW4ndCB0aGUgc2FtZSB0eXBlLiIpO2Vsc2UhdFtyLiRpc0RhdGFWYWx1ZV0oKXx8dGhpcy5faXNNYXRjaFRlbXBsYXRlKCk/dGhpcy5fYmluZEVsZW1lbnQoZSx0KTooMCxvLndhcm4pKCJYRkEgLSBOb2RlcyBoYXZlbid0IHRoZSBzYW1lIHR5cGUuIil9X2ZpbmREYXRhQnlOYW1lVG9Db25zdW1lKGUsdCxhLG4pe2lmKCFlKXJldHVybiBudWxsO2xldCBpLG87Zm9yKGxldCBuPTA7bjwzO24rKyl7aT1hW3IuJGdldFJlYWxDaGlsZHJlbkJ5TmFtZUl0XShlLCExLCEwKTtmb3IoOzspe289aS5uZXh0KCkudmFsdWU7aWYoIW8pYnJlYWs7aWYodD09PW9bci4kaXNEYXRhVmFsdWVdKCkpcmV0dXJuIG99aWYoYVtyLiRuYW1lc3BhY2VJZF09PT1zLk5hbWVzcGFjZUlkcy5kYXRhc2V0cy5pZCYmImRhdGEiPT09YVtyLiRub2RlTmFtZV0pYnJlYWs7YT1hW3IuJGdldFBhcmVudF0oKX1pZighbilyZXR1cm4gbnVsbDtpPXRoaXMuZGF0YVtyLiRnZXRSZWFsQ2hpbGRyZW5CeU5hbWVJdF0oZSwhMCwhMSk7bz1pLm5leHQoKS52YWx1ZTtpZihvKXJldHVybiBvO2k9dGhpcy5kYXRhW3IuJGdldEF0dHJpYnV0ZUl0XShlLCEwKTtvPWkubmV4dCgpLnZhbHVlO3JldHVybiBvJiZvW3IuJGlzRGF0YVZhbHVlXSgpP286bnVsbH1fc2V0UHJvcGVydGllcyhlLHQpe2lmKGUuaGFzT3duUHJvcGVydHkoInNldFByb3BlcnR5IikpZm9yKGNvbnN0e3JlZjphLHRhcmdldDpzLGNvbm5lY3Rpb246Y31vZiBlLnNldFByb3BlcnR5LmNoaWxkcmVuKXtpZihjKWNvbnRpbnVlO2lmKCFhKWNvbnRpbnVlO2NvbnN0IGw9KDAsaS5zZWFyY2hOb2RlKSh0aGlzLnJvb3QsdCxhLCExLCExKTtpZighbCl7KDAsby53YXJuKShgWEZBIC0gSW52YWxpZCByZWZlcmVuY2U6ICR7YX0uYCk7Y29udGludWV9Y29uc3RbaF09bDtpZighaFtyLiRpc0Rlc2NlbmRlbnRdKHRoaXMuZGF0YSkpeygwLG8ud2FybikoIlhGQSAtIEludmFsaWQgbm9kZTogbXVzdCBiZSBhIGRhdGEgbm9kZS4iKTtjb250aW51ZX1jb25zdCB1PSgwLGkuc2VhcmNoTm9kZSkodGhpcy5yb290LGUscywhMSwhMSk7aWYoIXUpeygwLG8ud2FybikoYFhGQSAtIEludmFsaWQgdGFyZ2V0OiAke3N9LmApO2NvbnRpbnVlfWNvbnN0W2RdPXU7aWYoIWRbci4kaXNEZXNjZW5kZW50XShlKSl7KDAsby53YXJuKSgiWEZBIC0gSW52YWxpZCB0YXJnZXQ6IG11c3QgYmUgYSBwcm9wZXJ0eSBvciBzdWJwcm9wZXJ0eS4iKTtjb250aW51ZX1jb25zdCBmPWRbci4kZ2V0UGFyZW50XSgpO2lmKGQgaW5zdGFuY2VvZiBuLlNldFByb3BlcnR5fHxmIGluc3RhbmNlb2Ygbi5TZXRQcm9wZXJ0eSl7KDAsby53YXJuKSgiWEZBIC0gSW52YWxpZCB0YXJnZXQ6IGNhbm5vdCBiZSBhIHNldFByb3BlcnR5IG9yIG9uZSBvZiBpdHMgcHJvcGVydGllcy4iKTtjb250aW51ZX1pZihkIGluc3RhbmNlb2Ygbi5CaW5kSXRlbXN8fGYgaW5zdGFuY2VvZiBuLkJpbmRJdGVtcyl7KDAsby53YXJuKSgiWEZBIC0gSW52YWxpZCB0YXJnZXQ6IGNhbm5vdCBiZSBhIGJpbmRJdGVtcyBvciBvbmUgb2YgaXRzIHByb3BlcnRpZXMuIik7Y29udGludWV9Y29uc3QgZz1oW3IuJHRleHRdKCkscD1kW3IuJG5vZGVOYW1lXTtpZihkIGluc3RhbmNlb2Ygci5YRkFBdHRyaWJ1dGUpe2NvbnN0IGU9T2JqZWN0LmNyZWF0ZShudWxsKTtlW3BdPWc7Y29uc3QgdD1SZWZsZWN0LmNvbnN0cnVjdChPYmplY3QuZ2V0UHJvdG90eXBlT2YoZikuY29uc3RydWN0b3IsW2VdKTtmW3BdPXRbcF19ZWxzZSBpZihkLmhhc093blByb3BlcnR5KHIuJGNvbnRlbnQpKXtkW3IuJGRhdGFdPWg7ZFtyLiRjb250ZW50XT1nO2Rbci4kZmluYWxpemVdKCl9ZWxzZSgwLG8ud2FybikoIlhGQSAtIEludmFsaWQgbm9kZSB0byB1c2UgaW4gc2V0UHJvcGVydHkiKX19X2JpbmRJdGVtcyhlLHQpe2lmKCFlLmhhc093blByb3BlcnR5KCJpdGVtcyIpfHwhZS5oYXNPd25Qcm9wZXJ0eSgiYmluZEl0ZW1zIil8fGUuYmluZEl0ZW1zLmlzRW1wdHkoKSlyZXR1cm47Zm9yKGNvbnN0IHQgb2YgZS5pdGVtcy5jaGlsZHJlbillW3IuJHJlbW92ZUNoaWxkXSh0KTtlLml0ZW1zLmNsZWFyKCk7Y29uc3QgYT1uZXcgbi5JdGVtcyh7fSkscz1uZXcgbi5JdGVtcyh7fSk7ZVtyLiRhcHBlbmRDaGlsZF0oYSk7ZS5pdGVtcy5wdXNoKGEpO2Vbci4kYXBwZW5kQ2hpbGRdKHMpO2UuaXRlbXMucHVzaChzKTtmb3IoY29uc3R7cmVmOm4sbGFiZWxSZWY6Yyx2YWx1ZVJlZjpsLGNvbm5lY3Rpb246aH1vZiBlLmJpbmRJdGVtcy5jaGlsZHJlbil7aWYoaCljb250aW51ZTtpZighbiljb250aW51ZTtjb25zdCBlPSgwLGkuc2VhcmNoTm9kZSkodGhpcy5yb290LHQsbiwhMSwhMSk7aWYoZSlmb3IoY29uc3QgdCBvZiBlKXtpZighdFtyLiRpc0Rlc2NlbmRlbnRdKHRoaXMuZGF0YXNldHMpKXsoMCxvLndhcm4pKGBYRkEgLSBJbnZhbGlkIHJlZiAoJHtufSk6IG11c3QgYmUgYSBkYXRhc2V0cyBjaGlsZC5gKTtjb250aW51ZX1jb25zdCBlPSgwLGkuc2VhcmNoTm9kZSkodGhpcy5yb290LHQsYywhMCwhMSk7aWYoIWUpeygwLG8ud2FybikoYFhGQSAtIEludmFsaWQgbGFiZWw6ICR7Y30uYCk7Y29udGludWV9Y29uc3RbaF09ZTtpZighaFtyLiRpc0Rlc2NlbmRlbnRdKHRoaXMuZGF0YXNldHMpKXsoMCxvLndhcm4pKCJYRkEgLSBJbnZhbGlkIGxhYmVsOiBtdXN0IGJlIGEgZGF0YXNldHMgY2hpbGQuIik7Y29udGludWV9Y29uc3QgdT0oMCxpLnNlYXJjaE5vZGUpKHRoaXMucm9vdCx0LGwsITAsITEpO2lmKCF1KXsoMCxvLndhcm4pKGBYRkEgLSBJbnZhbGlkIHZhbHVlOiAke2x9LmApO2NvbnRpbnVlfWNvbnN0W2RdPXU7aWYoIWRbci4kaXNEZXNjZW5kZW50XSh0aGlzLmRhdGFzZXRzKSl7KDAsby53YXJuKSgiWEZBIC0gSW52YWxpZCB2YWx1ZTogbXVzdCBiZSBhIGRhdGFzZXRzIGNoaWxkLiIpO2NvbnRpbnVlfWNvbnN0IGY9Y3JlYXRlVGV4dChoW3IuJHRleHRdKCkpLGc9Y3JlYXRlVGV4dChkW3IuJHRleHRdKCkpO2Fbci4kYXBwZW5kQ2hpbGRdKGYpO2EudGV4dC5wdXNoKGYpO3Nbci4kYXBwZW5kQ2hpbGRdKGcpO3MudGV4dC5wdXNoKGcpfWVsc2UoMCxvLndhcm4pKGBYRkEgLSBJbnZhbGlkIHJlZmVyZW5jZTogJHtufS5gKX19X2JpbmRPY2N1cnJlbmNlcyhlLHQsYSl7bGV0IG47aWYodC5sZW5ndGg+MSl7bj1lW3IuJGNsb25lXSgpO25bci4kcmVtb3ZlQ2hpbGRdKG4ub2NjdXIpO24ub2NjdXI9bnVsbH10aGlzLl9iaW5kVmFsdWUoZSx0WzBdLGEpO3RoaXMuX3NldFByb3BlcnRpZXMoZSx0WzBdKTt0aGlzLl9iaW5kSXRlbXMoZSx0WzBdKTtpZigxPT09dC5sZW5ndGgpcmV0dXJuO2NvbnN0IGk9ZVtyLiRnZXRQYXJlbnRdKCkscz1lW3IuJG5vZGVOYW1lXSxvPWlbci4kaW5kZXhPZl0oZSk7Zm9yKGxldCBlPTEsYz10Lmxlbmd0aDtlPGM7ZSsrKXtjb25zdCBjPXRbZV0sbD1uW3IuJGNsb25lXSgpO2lbc10ucHVzaChsKTtpW3IuJGluc2VydEF0XShvK2UsbCk7dGhpcy5fYmluZFZhbHVlKGwsYyxhKTt0aGlzLl9zZXRQcm9wZXJ0aWVzKGwsYyk7dGhpcy5fYmluZEl0ZW1zKGwsYyl9fV9jcmVhdGVPY2N1cnJlbmNlcyhlKXtpZighdGhpcy5lbXB0eU1lcmdlKXJldHVybjtjb25zdHtvY2N1cjp0fT1lO2lmKCF0fHx0LmluaXRpYWw8PTEpcmV0dXJuO2NvbnN0IGE9ZVtyLiRnZXRQYXJlbnRdKCksbj1lW3IuJG5vZGVOYW1lXTtpZighKGFbbl1pbnN0YW5jZW9mIHIuWEZBT2JqZWN0QXJyYXkpKXJldHVybjtsZXQgaTtpPWUubmFtZT9hW25dLmNoaWxkcmVuLmZpbHRlcigodD0+dC5uYW1lPT09ZS5uYW1lKSkubGVuZ3RoOmFbbl0uY2hpbGRyZW4ubGVuZ3RoO2NvbnN0IHM9YVtyLiRpbmRleE9mXShlKSsxLG89dC5pbml0aWFsLWk7aWYobyl7Y29uc3QgdD1lW3IuJGNsb25lXSgpO3Rbci4kcmVtb3ZlQ2hpbGRdKHQub2NjdXIpO3Qub2NjdXI9bnVsbDthW25dLnB1c2godCk7YVtyLiRpbnNlcnRBdF0ocyx0KTtmb3IobGV0IGU9MTtlPG87ZSsrKXtjb25zdCBpPXRbci4kY2xvbmVdKCk7YVtuXS5wdXNoKGkpO2Fbci4kaW5zZXJ0QXRdKHMrZSxpKX19fV9nZXRPY2N1ckluZm8oZSl7Y29uc3R7bmFtZTp0LG9jY3VyOmF9PWU7aWYoIWF8fCF0KXJldHVyblsxLDFdO2NvbnN0IHI9LTE9PT1hLm1heD8xLzA6YS5tYXg7cmV0dXJuW2EubWluLHJdfV9zZXRBbmRCaW5kKGUsdCl7dGhpcy5fc2V0UHJvcGVydGllcyhlLHQpO3RoaXMuX2JpbmRJdGVtcyhlLHQpO3RoaXMuX2JpbmRFbGVtZW50KGUsdCl9X2JpbmRFbGVtZW50KGUsdCl7Y29uc3QgYT1bXTt0aGlzLl9jcmVhdGVPY2N1cnJlbmNlcyhlKTtmb3IoY29uc3QgbiBvZiBlW3IuJGdldENoaWxkcmVuXSgpKXtpZihuW3IuJGRhdGFdKWNvbnRpbnVlO2lmKHZvaWQgMD09PXRoaXMuX21lcmdlTW9kZSYmInN1YmZvcm0iPT09bltyLiRub2RlTmFtZV0pe3RoaXMuX21lcmdlTW9kZT0iY29uc3VtZURhdGEiPT09bi5tZXJnZU1vZGU7Y29uc3QgZT10W3IuJGdldENoaWxkcmVuXSgpO2lmKGUubGVuZ3RoPjApdGhpcy5fYmluZE9jY3VycmVuY2VzKG4sW2VbMF1dLG51bGwpO2Vsc2UgaWYodGhpcy5lbXB0eU1lcmdlKXtjb25zdCBlPXRbci4kbmFtZXNwYWNlSWRdPT09Yz8tMTp0W3IuJG5hbWVzcGFjZUlkXSxhPW5bci4kZGF0YV09bmV3IHIuWG1sT2JqZWN0KGUsbi5uYW1lfHwicm9vdCIpO3Rbci4kYXBwZW5kQ2hpbGRdKGEpO3RoaXMuX2JpbmRFbGVtZW50KG4sYSl9Y29udGludWV9aWYoIW5bci4kaXNCaW5kYWJsZV0oKSljb250aW51ZTtsZXQgZT0hMSxzPW51bGwsbD1udWxsLGg9bnVsbDtpZihuLmJpbmQpe3N3aXRjaChuLmJpbmQubWF0Y2gpe2Nhc2Uibm9uZSI6dGhpcy5fc2V0QW5kQmluZChuLHQpO2NvbnRpbnVlO2Nhc2UiZ2xvYmFsIjplPSEwO2JyZWFrO2Nhc2UiZGF0YVJlZiI6aWYoIW4uYmluZC5yZWYpeygwLG8ud2FybikoYFhGQSAtIHJlZiBpcyBlbXB0eSBpbiBub2RlICR7bltyLiRub2RlTmFtZV19LmApO3RoaXMuX3NldEFuZEJpbmQobix0KTtjb250aW51ZX1sPW4uYmluZC5yZWZ9bi5iaW5kLnBpY3R1cmUmJihzPW4uYmluZC5waWN0dXJlW3IuJGNvbnRlbnRdKX1jb25zdFt1LGRdPXRoaXMuX2dldE9jY3VySW5mbyhuKTtpZihsKXtoPSgwLGkuc2VhcmNoTm9kZSkodGhpcy5yb290LHQsbCwhMCwhMSk7aWYobnVsbD09PWgpe2g9KDAsaS5jcmVhdGVEYXRhTm9kZSkodGhpcy5kYXRhLHQsbCk7aWYoIWgpY29udGludWU7dGhpcy5faXNDb25zdW1lRGF0YSgpJiYoaFtyLiRjb25zdW1lZF09ITApO3RoaXMuX3NldEFuZEJpbmQobixoKTtjb250aW51ZX10aGlzLl9pc0NvbnN1bWVEYXRhKCkmJihoPWguZmlsdGVyKChlPT4hZVtyLiRjb25zdW1lZF0pKSk7aC5sZW5ndGg+ZD9oPWguc2xpY2UoMCxkKTowPT09aC5sZW5ndGgmJihoPW51bGwpO2gmJnRoaXMuX2lzQ29uc3VtZURhdGEoKSYmaC5mb3JFYWNoKChlPT57ZVtyLiRjb25zdW1lZF09ITB9KSl9ZWxzZXtpZighbi5uYW1lKXt0aGlzLl9zZXRBbmRCaW5kKG4sdCk7Y29udGludWV9aWYodGhpcy5faXNDb25zdW1lRGF0YSgpKXtjb25zdCBhPVtdO2Zvcig7YS5sZW5ndGg8ZDspe2NvbnN0IGk9dGhpcy5fZmluZERhdGFCeU5hbWVUb0NvbnN1bWUobi5uYW1lLG5bci4kaGFzU2V0dGFibGVWYWx1ZV0oKSx0LGUpO2lmKCFpKWJyZWFrO2lbci4kY29uc3VtZWRdPSEwO2EucHVzaChpKX1oPWEubGVuZ3RoPjA/YTpudWxsfWVsc2V7aD10W3IuJGdldFJlYWxDaGlsZHJlbkJ5TmFtZUl0XShuLm5hbWUsITEsdGhpcy5lbXB0eU1lcmdlKS5uZXh0KCkudmFsdWU7aWYoIWgpe2lmKDA9PT11KXthLnB1c2gobik7Y29udGludWV9Y29uc3QgZT10W3IuJG5hbWVzcGFjZUlkXT09PWM/LTE6dFtyLiRuYW1lc3BhY2VJZF07aD1uW3IuJGRhdGFdPW5ldyByLlhtbE9iamVjdChlLG4ubmFtZSk7dGhpcy5lbXB0eU1lcmdlJiYoaFtyLiRjb25zdW1lZF09ITApO3Rbci4kYXBwZW5kQ2hpbGRdKGgpO3RoaXMuX3NldEFuZEJpbmQobixoKTtjb250aW51ZX10aGlzLmVtcHR5TWVyZ2UmJihoW3IuJGNvbnN1bWVkXT0hMCk7aD1baF19fWg/dGhpcy5fYmluZE9jY3VycmVuY2VzKG4saCxzKTp1PjA/dGhpcy5fc2V0QW5kQmluZChuLHQpOmEucHVzaChuKX1hLmZvckVhY2goKGU9PmVbci4kZ2V0UGFyZW50XSgpW3IuJHJlbW92ZUNoaWxkXShlKSkpfX19LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5WYWx1ZT10LlRleHQ9dC5UZW1wbGF0ZU5hbWVzcGFjZT10LlRlbXBsYXRlPXQuU2V0UHJvcGVydHk9dC5JdGVtcz10LkZpZWxkPXQuQmluZEl0ZW1zPXZvaWQgMDt2YXIgcj1hKDc3KSxuPWEoNzkpLGk9YSg4Mykscz1hKDg0KSxvPWEoNzgpLGM9YSgyKSxsPWEoODUpLGg9YSg2KSx1PWEoODApO2NvbnN0IGQ9bi5OYW1lc3BhY2VJZHMudGVtcGxhdGUuaWQsZj0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLGc9L15IKFxkKykkLyxwPW5ldyBTZXQoWyJpbWFnZS9naWYiLCJpbWFnZS9qcGVnIiwiaW1hZ2UvanBnIiwiaW1hZ2UvcGpwZWciLCJpbWFnZS9wbmciLCJpbWFnZS9hcG5nIiwiaW1hZ2UveC1wbmciLCJpbWFnZS9ibXAiLCJpbWFnZS94LW1zLWJtcCIsImltYWdlL3RpZmYiLCJpbWFnZS90aWYiLCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0iXSksbT1bW1s2Niw3N10sImltYWdlL2JtcCJdLFtbMjU1LDIxNiwyNTVdLCJpbWFnZS9qcGVnIl0sW1s3Myw3Myw0MiwwXSwiaW1hZ2UvdGlmZiJdLFtbNzcsNzcsMCw0Ml0sImltYWdlL3RpZmYiXSxbWzcxLDczLDcwLDU2LDU3LDk3XSwiaW1hZ2UvZ2lmIl0sW1sxMzcsODAsNzgsNzEsMTMsMTAsMjYsMTBdLCJpbWFnZS9wbmciXV07ZnVuY3Rpb24gZ2V0Qm9yZGVyRGltcyhlKXtpZighZXx8IWUuYm9yZGVyKXJldHVybnt3OjAsaDowfTtjb25zdCB0PWUuYm9yZGVyW3IuJGdldEV4dHJhXSgpO3JldHVybiB0P3t3OnQud2lkdGhzWzBdK3Qud2lkdGhzWzJdK3QuaW5zZXRzWzBdK3QuaW5zZXRzWzJdLGg6dC53aWR0aHNbMV0rdC53aWR0aHNbM10rdC5pbnNldHNbMV0rdC5pbnNldHNbM119Ont3OjAsaDowfX1mdW5jdGlvbiBoYXNNYXJnaW4oZSl7cmV0dXJuIGUubWFyZ2luJiYoZS5tYXJnaW4udG9wSW5zZXR8fGUubWFyZ2luLnJpZ2h0SW5zZXR8fGUubWFyZ2luLmJvdHRvbUluc2V0fHxlLm1hcmdpbi5sZWZ0SW5zZXQpfWZ1bmN0aW9uIF9zZXRWYWx1ZShlLHQpe2lmKCFlLnZhbHVlKXtjb25zdCB0PW5ldyBWYWx1ZSh7fSk7ZVtyLiRhcHBlbmRDaGlsZF0odCk7ZS52YWx1ZT10fWUudmFsdWVbci4kc2V0VmFsdWVdKHQpfWZ1bmN0aW9uKmdldENvbnRhaW5lZENoaWxkcmVuKGUpe2Zvcihjb25zdCB0IG9mIGVbci4kZ2V0Q2hpbGRyZW5dKCkpdCBpbnN0YW5jZW9mIFN1YmZvcm1TZXQ/eWllbGQqdFtyLiRnZXRDb250YWluZWRDaGlsZHJlbl0oKTp5aWVsZCB0fWZ1bmN0aW9uIGlzUmVxdWlyZWQoZSl7cmV0dXJuIGUudmFsaWRhdGUmJiJlcnJvciI9PT1lLnZhbGlkYXRlLm51bGxUZXN0fWZ1bmN0aW9uIHNldFRhYkluZGV4KGUpe2Zvcig7ZTspe2lmKCFlLnRyYXZlcnNhbCl7ZVtyLiR0YWJJbmRleF09ZVtyLiRnZXRQYXJlbnRdKClbci4kdGFiSW5kZXhdO3JldHVybn1pZihlW3IuJHRhYkluZGV4XSlyZXR1cm47bGV0IHQ9bnVsbDtmb3IoY29uc3QgYSBvZiBlLnRyYXZlcnNhbFtyLiRnZXRDaGlsZHJlbl0oKSlpZigibmV4dCI9PT1hLm9wZXJhdGlvbil7dD1hO2JyZWFrfWlmKCF0fHwhdC5yZWYpe2Vbci4kdGFiSW5kZXhdPWVbci4kZ2V0UGFyZW50XSgpW3IuJHRhYkluZGV4XTtyZXR1cm59Y29uc3QgYT1lW3IuJGdldFRlbXBsYXRlUm9vdF0oKTtlW3IuJHRhYkluZGV4XT0rK2Fbci4kdGFiSW5kZXhdO2NvbnN0IG49YVtyLiRzZWFyY2hOb2RlXSh0LnJlZixlKTtpZighbilyZXR1cm47ZT1uWzBdfX1mdW5jdGlvbiBhcHBseUFzc2lzdChlLHQpe2NvbnN0IGE9ZS5hc3Npc3Q7aWYoYSl7Y29uc3QgZT1hW3IuJHRvSFRNTF0oKTtlJiYodC50aXRsZT1lKTtjb25zdCBuPWEucm9sZS5tYXRjaChnKTtpZihuKXtjb25zdCBlPSJoZWFkaW5nIixhPW5bMV07dC5yb2xlPWU7dFsiYXJpYS1sZXZlbCJdPWF9fWlmKCJ0YWJsZSI9PT1lLmxheW91dCl0LnJvbGU9InRhYmxlIjtlbHNlIGlmKCJyb3ciPT09ZS5sYXlvdXQpdC5yb2xlPSJyb3ciO2Vsc2V7Y29uc3QgYT1lW3IuJGdldFBhcmVudF0oKTsicm93Ij09PWEubGF5b3V0JiYoYS5hc3Npc3QmJiJUSCI9PT1hLmFzc2lzdC5yb2xlP3Qucm9sZT0iY29sdW1uaGVhZGVyIjp0LnJvbGU9ImNlbGwiKX19ZnVuY3Rpb24gYXJpYUxhYmVsKGUpe2lmKCFlLmFzc2lzdClyZXR1cm4gbnVsbDtjb25zdCB0PWUuYXNzaXN0O3JldHVybiB0LnNwZWFrJiYiIiE9PXQuc3BlYWtbci4kY29udGVudF0/dC5zcGVha1tyLiRjb250ZW50XTp0LnRvb2xUaXA/dC50b29sVGlwW3IuJGNvbnRlbnRdOm51bGx9ZnVuY3Rpb24gdmFsdWVUb0h0bWwoZSl7cmV0dXJuIG8uSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJkaXYiLGF0dHJpYnV0ZXM6e2NsYXNzOlsieGZhUmljaCJdLHN0eWxlOk9iamVjdC5jcmVhdGUobnVsbCl9LGNoaWxkcmVuOlt7bmFtZToic3BhbiIsYXR0cmlidXRlczp7c3R5bGU6T2JqZWN0LmNyZWF0ZShudWxsKX0sdmFsdWU6ZX1dfSl9ZnVuY3Rpb24gc2V0Rmlyc3RVbnNwbGl0dGFibGUoZSl7Y29uc3QgdD1lW3IuJGdldFRlbXBsYXRlUm9vdF0oKTtpZihudWxsPT09dFtyLiRleHRyYV0uZmlyc3RVbnNwbGl0dGFibGUpe3Rbci4kZXh0cmFdLmZpcnN0VW5zcGxpdHRhYmxlPWU7dFtyLiRleHRyYV0ubm9MYXlvdXRGYWlsdXJlPSEwfX1mdW5jdGlvbiB1bnNldEZpcnN0VW5zcGxpdHRhYmxlKGUpe2NvbnN0IHQ9ZVtyLiRnZXRUZW1wbGF0ZVJvb3RdKCk7dFtyLiRleHRyYV0uZmlyc3RVbnNwbGl0dGFibGU9PT1lJiYodFtyLiRleHRyYV0ubm9MYXlvdXRGYWlsdXJlPSExKX1mdW5jdGlvbiBoYW5kbGVCcmVhayhlKXtpZihlW3IuJGV4dHJhXSlyZXR1cm4hMTtlW3IuJGV4dHJhXT1PYmplY3QuY3JlYXRlKG51bGwpO2lmKCJhdXRvIj09PWUudGFyZ2V0VHlwZSlyZXR1cm4hMTtjb25zdCB0PWVbci4kZ2V0VGVtcGxhdGVSb290XSgpO2xldCBhPW51bGw7aWYoZS50YXJnZXQpe2E9dFtyLiRzZWFyY2hOb2RlXShlLnRhcmdldCxlW3IuJGdldFBhcmVudF0oKSk7aWYoIWEpcmV0dXJuITE7YT1hWzBdfWNvbnN0e2N1cnJlbnRQYWdlQXJlYTpuLGN1cnJlbnRDb250ZW50QXJlYTppfT10W3IuJGV4dHJhXTtpZigicGFnZUFyZWEiPT09ZS50YXJnZXRUeXBlKXthIGluc3RhbmNlb2YgUGFnZUFyZWF8fChhPW51bGwpO2lmKGUuc3RhcnROZXcpe2Vbci4kZXh0cmFdLnRhcmdldD1hfHxuO3JldHVybiEwfWlmKGEmJmEhPT1uKXtlW3IuJGV4dHJhXS50YXJnZXQ9YTtyZXR1cm4hMH1yZXR1cm4hMX1hIGluc3RhbmNlb2YgQ29udGVudEFyZWF8fChhPW51bGwpO2NvbnN0IHM9YSYmYVtyLiRnZXRQYXJlbnRdKCk7bGV0IG8sYz1zO2lmKGUuc3RhcnROZXcpaWYoYSl7Y29uc3QgZT1zLmNvbnRlbnRBcmVhLmNoaWxkcmVuLHQ9ZS5pbmRleE9mKGkpLHI9ZS5pbmRleE9mKGEpOy0xIT09dCYmdDxyJiYoYz1udWxsKTtvPXItMX1lbHNlIG89bi5jb250ZW50QXJlYS5jaGlsZHJlbi5pbmRleE9mKGkpO2Vsc2V7aWYoIWF8fGE9PT1pKXJldHVybiExO289cy5jb250ZW50QXJlYS5jaGlsZHJlbi5pbmRleE9mKGEpLTE7Yz1zPT09bj9udWxsOnN9ZVtyLiRleHRyYV0udGFyZ2V0PWM7ZVtyLiRleHRyYV0uaW5kZXg9bztyZXR1cm4hMH1mdW5jdGlvbiBoYW5kbGVPdmVyZmxvdyhlLHQsYSl7Y29uc3Qgbj1lW3IuJGdldFRlbXBsYXRlUm9vdF0oKSxpPW5bci4kZXh0cmFdLm5vTGF5b3V0RmFpbHVyZSxzPXRbci4kZ2V0U3ViZm9ybVBhcmVudF07dFtyLiRnZXRTdWJmb3JtUGFyZW50XT0oKT0+ZTtuW3IuJGV4dHJhXS5ub0xheW91dEZhaWx1cmU9ITA7Y29uc3Qgbz10W3IuJHRvSFRNTF0oYSk7ZVtyLiRhZGRIVE1MXShvLmh0bWwsby5iYm94KTtuW3IuJGV4dHJhXS5ub0xheW91dEZhaWx1cmU9aTt0W3IuJGdldFN1YmZvcm1QYXJlbnRdPXN9Y2xhc3MgQXBwZWFyYW5jZUZpbHRlciBleHRlbmRzIHIuU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImFwcGVhcmFuY2VGaWx0ZXIiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS50eXBlLFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIEFyYyBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImFyYyIsITApO3RoaXMuY2lyY3VsYXI9KDAsby5nZXRJbnRlZ2VyKSh7ZGF0YTplLmNpcmN1bGFyLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy5oYW5kPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLmhhbmQsWyJldmVuIiwibGVmdCIsInJpZ2h0Il0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5zdGFydEFuZ2xlPSgwLG8uZ2V0RmxvYXQpKHtkYXRhOmUuc3RhcnRBbmdsZSxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT4hMH0pO3RoaXMuc3dlZXBBbmdsZT0oMCxvLmdldEZsb2F0KSh7ZGF0YTplLnN3ZWVwQW5nbGUsZGVmYXVsdFZhbHVlOjM2MCx2YWxpZGF0ZTplPT4hMH0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmVkZ2U9bnVsbDt0aGlzLmZpbGw9bnVsbH1bci4kdG9IVE1MXSgpe2NvbnN0IGU9dGhpcy5lZGdlfHxuZXcgRWRnZSh7fSksdD1lW3IuJHRvU3R5bGVdKCksYT1PYmplY3QuY3JlYXRlKG51bGwpO3RoaXMuZmlsbCYmInZpc2libGUiPT09dGhpcy5maWxsLnByZXNlbmNlP09iamVjdC5hc3NpZ24oYSx0aGlzLmZpbGxbci4kdG9TdHlsZV0oKSk6YS5maWxsPSJ0cmFuc3BhcmVudCI7YS5zdHJva2VXaWR0aD0oMCxzLm1lYXN1cmVUb1N0cmluZykoInZpc2libGUiPT09ZS5wcmVzZW5jZT9lLnRoaWNrbmVzczowKTthLnN0cm9rZT10LmNvbG9yO2xldCBuO2NvbnN0IGk9e3htbG5zOmYsc3R5bGU6e3dpZHRoOiIxMDAlIixoZWlnaHQ6IjEwMCUiLG92ZXJmbG93OiJ2aXNpYmxlIn19O2lmKDM2MD09PXRoaXMuc3dlZXBBbmdsZSluPXtuYW1lOiJlbGxpcHNlIixhdHRyaWJ1dGVzOnt4bWxuczpmLGN4OiI1MCUiLGN5OiI1MCUiLHJ4OiI1MCUiLHJ5OiI1MCUiLHN0eWxlOmF9fTtlbHNle2NvbnN0IGU9dGhpcy5zdGFydEFuZ2xlKk1hdGguUEkvMTgwLHQ9dGhpcy5zd2VlcEFuZ2xlKk1hdGguUEkvMTgwLHI9dGhpcy5zd2VlcEFuZ2xlPjE4MD8xOjAsW3MsbyxjLGxdPVs1MCooMStNYXRoLmNvcyhlKSksNTAqKDEtTWF0aC5zaW4oZSkpLDUwKigxK01hdGguY29zKGUrdCkpLDUwKigxLU1hdGguc2luKGUrdCkpXTtuPXtuYW1lOiJwYXRoIixhdHRyaWJ1dGVzOnt4bWxuczpmLGQ6YE0gJHtzfSAke299IEEgNTAgNTAgMCAke3J9IDAgJHtjfSAke2x9YCx2ZWN0b3JFZmZlY3Q6Im5vbi1zY2FsaW5nLXN0cm9rZSIsc3R5bGU6YX19O09iamVjdC5hc3NpZ24oaSx7dmlld0JveDoiMCAwIDEwMCAxMDAiLHByZXNlcnZlQXNwZWN0UmF0aW86Im5vbmUifSl9Y29uc3QgYz17bmFtZToic3ZnIixjaGlsZHJlbjpbbl0sYXR0cmlidXRlczppfTtpZihoYXNNYXJnaW4odGhpc1tyLiRnZXRQYXJlbnRdKClbci4kZ2V0UGFyZW50XSgpKSlyZXR1cm4gby5IVE1MUmVzdWx0LnN1Y2Nlc3Moe25hbWU6ImRpdiIsYXR0cmlidXRlczp7c3R5bGU6e2Rpc3BsYXk6ImlubGluZSIsd2lkdGg6IjEwMCUiLGhlaWdodDoiMTAwJSJ9fSxjaGlsZHJlbjpbY119KTtjLmF0dHJpYnV0ZXMuc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtyZXR1cm4gby5IVE1MUmVzdWx0LnN1Y2Nlc3MoYyl9fWNsYXNzIEFyZWEgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJhcmVhIiwhMCk7dGhpcy5jb2xTcGFuPSgwLG8uZ2V0SW50ZWdlcikoe2RhdGE6ZS5jb2xTcGFuLGRlZmF1bHRWYWx1ZToxLHZhbGlkYXRlOmU9PmU+PTF8fC0xPT09ZX0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy5yZWxldmFudD0oMCxvLmdldFJlbGV2YW50KShlLnJlbGV2YW50KTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy54PSgwLG8uZ2V0TWVhc3VyZW1lbnQpKGUueCwiMHB0Iik7dGhpcy55PSgwLG8uZ2V0TWVhc3VyZW1lbnQpKGUueSwiMHB0Iik7dGhpcy5kZXNjPW51bGw7dGhpcy5leHRyYXM9bnVsbDt0aGlzLmFyZWE9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5kcmF3PW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuZXhPYmplY3Q9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5leGNsR3JvdXA9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5maWVsZD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLnN1YmZvcm09bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5zdWJmb3JtU2V0PW5ldyByLlhGQU9iamVjdEFycmF5fSpbci4kZ2V0Q29udGFpbmVkQ2hpbGRyZW5dKCl7eWllbGQqZ2V0Q29udGFpbmVkQ2hpbGRyZW4odGhpcyl9W3IuJGlzVHJhbnNwYXJlbnRdKCl7cmV0dXJuITB9W3IuJGlzQmluZGFibGVdKCl7cmV0dXJuITB9W3IuJGFkZEhUTUxdKGUsdCl7Y29uc3RbYSxuLGksc109dDt0aGlzW3IuJGV4dHJhXS53aWR0aD1NYXRoLm1heCh0aGlzW3IuJGV4dHJhXS53aWR0aCxhK2kpO3RoaXNbci4kZXh0cmFdLmhlaWdodD1NYXRoLm1heCh0aGlzW3IuJGV4dHJhXS5oZWlnaHQsbitzKTt0aGlzW3IuJGV4dHJhXS5jaGlsZHJlbi5wdXNoKGUpfVtyLiRnZXRBdmFpbGFibGVTcGFjZV0oKXtyZXR1cm4gdGhpc1tyLiRleHRyYV0uYXZhaWxhYmxlU3BhY2V9W3IuJHRvSFRNTF0oZSl7Y29uc3QgdD0oMCxzLnRvU3R5bGUpKHRoaXMsInBvc2l0aW9uIiksYT17c3R5bGU6dCxpZDp0aGlzW3IuJHVpZF0sY2xhc3M6WyJ4ZmFBcmVhIl19OygwLHMuaXNQcmludE9ubHkpKHRoaXMpJiZhLmNsYXNzLnB1c2goInhmYVByaW50T25seSIpO3RoaXMubmFtZSYmKGEueGZhTmFtZT10aGlzLm5hbWUpO2NvbnN0IG49W107dGhpc1tyLiRleHRyYV09e2NoaWxkcmVuOm4sd2lkdGg6MCxoZWlnaHQ6MCxhdmFpbGFibGVTcGFjZTplfTtjb25zdCBpPXRoaXNbci4kY2hpbGRyZW5Ub0hUTUxdKHtmaWx0ZXI6bmV3IFNldChbImFyZWEiLCJkcmF3IiwiZmllbGQiLCJleGNsR3JvdXAiLCJzdWJmb3JtIiwic3ViZm9ybVNldCJdKSxpbmNsdWRlOiEwfSk7aWYoIWkuc3VjY2Vzcyl7aWYoaS5pc0JyZWFrKCkpcmV0dXJuIGk7ZGVsZXRlIHRoaXNbci4kZXh0cmFdO3JldHVybiBvLkhUTUxSZXN1bHQuRkFJTFVSRX10LndpZHRoPSgwLHMubWVhc3VyZVRvU3RyaW5nKSh0aGlzW3IuJGV4dHJhXS53aWR0aCk7dC5oZWlnaHQ9KDAscy5tZWFzdXJlVG9TdHJpbmcpKHRoaXNbci4kZXh0cmFdLmhlaWdodCk7Y29uc3QgYz17bmFtZToiZGl2IixhdHRyaWJ1dGVzOmEsY2hpbGRyZW46bn0sbD1bdGhpcy54LHRoaXMueSx0aGlzW3IuJGV4dHJhXS53aWR0aCx0aGlzW3IuJGV4dHJhXS5oZWlnaHRdO2RlbGV0ZSB0aGlzW3IuJGV4dHJhXTtyZXR1cm4gby5IVE1MUmVzdWx0LnN1Y2Nlc3MoYyxsKX19Y2xhc3MgQXNzaXN0IGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwiYXNzaXN0IiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnJvbGU9ZS5yb2xlfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5zcGVhaz1udWxsO3RoaXMudG9vbFRpcD1udWxsfVtyLiR0b0hUTUxdKCl7cmV0dXJuIHRoaXMudG9vbFRpcCYmdGhpcy50b29sVGlwW3IuJGNvbnRlbnRdP3RoaXMudG9vbFRpcFtyLiRjb250ZW50XTpudWxsfX1jbGFzcyBCYXJjb2RlIGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwiYmFyY29kZSIsITApO3RoaXMuY2hhckVuY29kaW5nPSgwLG8uZ2V0S2V5d29yZCkoe2RhdGE6ZS5jaGFyRW5jb2Rpbmc/ZS5jaGFyRW5jb2RpbmcudG9Mb3dlckNhc2UoKToiIixkZWZhdWx0VmFsdWU6IiIsdmFsaWRhdGU6ZT0+WyJ1dGYtOCIsImJpZy1maXZlIiwiZm9udHNwZWNpZmljIiwiZ2JrIiwiZ2ItMTgwMzAiLCJnYi0yMzEyIiwia3NjLTU2MDEiLCJub25lIiwic2hpZnQtamlzIiwidWNzLTIiLCJ1dGYtMTYiXS5pbmNsdWRlcyhlKXx8ZS5tYXRjaCgvaXNvLTg4NTktXGR7Mn0vKX0pO3RoaXMuY2hlY2tzdW09KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuY2hlY2tzdW0sWyJub25lIiwiMW1vZDEwIiwiMW1vZDEwXzFtb2QxMSIsIjJtb2QxMCIsImF1dG8iXSk7dGhpcy5kYXRhQ29sdW1uQ291bnQ9KDAsby5nZXRJbnRlZ2VyKSh7ZGF0YTplLmRhdGFDb2x1bW5Db3VudCxkZWZhdWx0VmFsdWU6LTEsdmFsaWRhdGU6ZT0+ZT49MH0pO3RoaXMuZGF0YUxlbmd0aD0oMCxvLmdldEludGVnZXIpKHtkYXRhOmUuZGF0YUxlbmd0aCxkZWZhdWx0VmFsdWU6LTEsdmFsaWRhdGU6ZT0+ZT49MH0pO3RoaXMuZGF0YVByZXA9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuZGF0YVByZXAsWyJub25lIiwiZmxhdGVDb21wcmVzcyJdKTt0aGlzLmRhdGFSb3dDb3VudD0oMCxvLmdldEludGVnZXIpKHtkYXRhOmUuZGF0YVJvd0NvdW50LGRlZmF1bHRWYWx1ZTotMSx2YWxpZGF0ZTplPT5lPj0wfSk7dGhpcy5lbmRDaGFyPWUuZW5kQ2hhcnx8IiI7dGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbD0oMCxvLmdldEludGVnZXIpKHtkYXRhOmUuZXJyb3JDb3JyZWN0aW9uTGV2ZWwsZGVmYXVsdFZhbHVlOi0xLHZhbGlkYXRlOmU9PmU+PTAmJmU8PTh9KTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubW9kdWxlSGVpZ2h0PSgwLG8uZ2V0TWVhc3VyZW1lbnQpKGUubW9kdWxlSGVpZ2h0LCI1bW0iKTt0aGlzLm1vZHVsZVdpZHRoPSgwLG8uZ2V0TWVhc3VyZW1lbnQpKGUubW9kdWxlV2lkdGgsIjAuMjVtbSIpO3RoaXMucHJpbnRDaGVja0RpZ2l0PSgwLG8uZ2V0SW50ZWdlcikoe2RhdGE6ZS5wcmludENoZWNrRGlnaXQsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV9KTt0aGlzLnJvd0NvbHVtblJhdGlvPSgwLG8uZ2V0UmF0aW8pKGUucm93Q29sdW1uUmF0aW8pO3RoaXMuc3RhcnRDaGFyPWUuc3RhcnRDaGFyfHwiIjt0aGlzLnRleHRMb2NhdGlvbj0oMCxvLmdldFN0cmluZ09wdGlvbikoZS50ZXh0TG9jYXRpb24sWyJiZWxvdyIsImFib3ZlIiwiYWJvdmVFbWJlZGRlZCIsImJlbG93RW1iZWRkZWQiLCJub25lIl0pO3RoaXMudHJ1bmNhdGU9KDAsby5nZXRJbnRlZ2VyKSh7ZGF0YTplLnRydW5jYXRlLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy50eXBlPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLnR5cGU/ZS50eXBlLnRvTG93ZXJDYXNlKCk6IiIsWyJhenRlYyIsImNvZGFiYXIiLCJjb2RlMm9mNWluZHVzdHJpYWwiLCJjb2RlMm9mNWludGVybGVhdmVkIiwiY29kZTJvZjVtYXRyaXgiLCJjb2RlMm9mNXN0YW5kYXJkIiwiY29kZTNvZjkiLCJjb2RlM29mOWV4dGVuZGVkIiwiY29kZTExIiwiY29kZTQ5IiwiY29kZTkzIiwiY29kZTEyOCIsImNvZGUxMjhhIiwiY29kZTEyOGIiLCJjb2RlMTI4YyIsImNvZGUxMjhzc2NjIiwiZGF0YW1hdHJpeCIsImVhbjgiLCJlYW44YWRkMiIsImVhbjhhZGQ1IiwiZWFuMTMiLCJlYW4xM2FkZDIiLCJlYW4xM2FkZDUiLCJlYW4xM3B3Y2QiLCJmaW0iLCJsb2dtYXJzIiwibWF4aWNvZGUiLCJtc2kiLCJwZGY0MTciLCJwZGY0MTdtYWNybyIsInBsZXNzZXkiLCJwb3N0YXVzY3VzdDIiLCJwb3N0YXVzY3VzdDMiLCJwb3N0YXVzcmVwbHlwYWlkIiwicG9zdGF1c3N0YW5kYXJkIiwicG9zdHVrcm00c2NjIiwicG9zdHVzZHBiYyIsInBvc3R1c2ltYiIsInBvc3R1c3N0YW5kYXJkIiwicG9zdHVzNXppcCIsInFyY29kZSIsInJmaWQiLCJyc3MxNCIsInJzczE0ZXhwYW5kZWQiLCJyc3MxNGxpbWl0ZWQiLCJyc3MxNHN0YWNrZWQiLCJyc3MxNHN0YWNrZWRvbW5pIiwicnNzMTR0cnVuY2F0ZWQiLCJ0ZWxlcGVuIiwidWNjMTI4IiwidWNjMTI4cmFuZG9tIiwidWNjMTI4c3NjYyIsInVwY2EiLCJ1cGNhYWRkMiIsInVwY2FhZGQ1IiwidXBjYXB3Y2QiLCJ1cGNlIiwidXBjZWFkZDIiLCJ1cGNlYWRkNSIsInVwY2VhbjIiLCJ1cGNlYW41IiwidXBzbWF4aWNvZGUiXSk7dGhpcy51cHNNb2RlPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLnVwc01vZGUsWyJ1c0NhcnJpZXIiLCJpbnRlcm5hdGlvbmFsQ2FycmllciIsInNlY3VyZVN5bWJvbCIsInN0YW5kYXJkU3ltYm9sIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLndpZGVOYXJyb3dSYXRpbz0oMCxvLmdldFJhdGlvKShlLndpZGVOYXJyb3dSYXRpbyk7dGhpcy5lbmNyeXB0PW51bGw7dGhpcy5leHRyYXM9bnVsbH19Y2xhc3MgQmluZCBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImJpbmQiLCEwKTt0aGlzLm1hdGNoPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLm1hdGNoLFsib25jZSIsImRhdGFSZWYiLCJnbG9iYWwiLCJub25lIl0pO3RoaXMucmVmPWUucmVmfHwiIjt0aGlzLnBpY3R1cmU9bnVsbH19Y2xhc3MgQmluZEl0ZW1zIGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwiYmluZEl0ZW1zIik7dGhpcy5jb25uZWN0aW9uPWUuY29ubmVjdGlvbnx8IiI7dGhpcy5sYWJlbFJlZj1lLmxhYmVsUmVmfHwiIjt0aGlzLnJlZj1lLnJlZnx8IiI7dGhpcy52YWx1ZVJlZj1lLnZhbHVlUmVmfHwiIn19dC5CaW5kSXRlbXM9QmluZEl0ZW1zO2NsYXNzIEJvb2tlbmQgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJib29rZW5kIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmxlYWRlcj1lLmxlYWRlcnx8IiI7dGhpcy50cmFpbGVyPWUudHJhaWxlcnx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBCb29sZWFuRWxlbWVudCBleHRlbmRzIHIuT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwiYm9vbGVhbiIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifVtyLiR0b0hUTUxdKGUpe3JldHVybiB2YWx1ZVRvSHRtbCgxPT09dGhpc1tyLiRjb250ZW50XT8iMSI6IjAiKX19Y2xhc3MgQm9yZGVyIGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwiYm9yZGVyIiwhMCk7dGhpcy5icmVhaz0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5icmVhayxbImNsb3NlIiwib3BlbiJdKTt0aGlzLmhhbmQ9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuaGFuZCxbImV2ZW4iLCJsZWZ0IiwicmlnaHQiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnByZXNlbmNlPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLnByZXNlbmNlLFsidmlzaWJsZSIsImhpZGRlbiIsImluYWN0aXZlIiwiaW52aXNpYmxlIl0pO3RoaXMucmVsZXZhbnQ9KDAsby5nZXRSZWxldmFudCkoZS5yZWxldmFudCk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuY29ybmVyPW5ldyByLlhGQU9iamVjdEFycmF5KDQpO3RoaXMuZWRnZT1uZXcgci5YRkFPYmplY3RBcnJheSg0KTt0aGlzLmV4dHJhcz1udWxsO3RoaXMuZmlsbD1udWxsO3RoaXMubWFyZ2luPW51bGx9W3IuJGdldEV4dHJhXSgpe2lmKCF0aGlzW3IuJGV4dHJhXSl7Y29uc3QgZT10aGlzLmVkZ2UuY2hpbGRyZW4uc2xpY2UoKTtpZihlLmxlbmd0aDw0KXtjb25zdCB0PWUuYXQoLTEpfHxuZXcgRWRnZSh7fSk7Zm9yKGxldCBhPWUubGVuZ3RoO2E8NDthKyspZS5wdXNoKHQpfWNvbnN0IHQ9ZS5tYXAoKGU9PmUudGhpY2tuZXNzKSksYT1bMCwwLDAsMF07aWYodGhpcy5tYXJnaW4pe2FbMF09dGhpcy5tYXJnaW4udG9wSW5zZXQ7YVsxXT10aGlzLm1hcmdpbi5yaWdodEluc2V0O2FbMl09dGhpcy5tYXJnaW4uYm90dG9tSW5zZXQ7YVszXT10aGlzLm1hcmdpbi5sZWZ0SW5zZXR9dGhpc1tyLiRleHRyYV09e3dpZHRoczp0LGluc2V0czphLGVkZ2VzOmV9fXJldHVybiB0aGlzW3IuJGV4dHJhXX1bci4kdG9TdHlsZV0oKXtjb25zdHtlZGdlczplfT10aGlzW3IuJGdldEV4dHJhXSgpLHQ9ZS5tYXAoKGU9Pntjb25zdCB0PWVbci4kdG9TdHlsZV0oKTt0LmNvbG9yPXQuY29sb3J8fCIjMDAwMDAwIjtyZXR1cm4gdH0pKSxhPU9iamVjdC5jcmVhdGUobnVsbCk7dGhpcy5tYXJnaW4mJk9iamVjdC5hc3NpZ24oYSx0aGlzLm1hcmdpbltyLiR0b1N0eWxlXSgpKTt0aGlzLmZpbGwmJiJ2aXNpYmxlIj09PXRoaXMuZmlsbC5wcmVzZW5jZSYmT2JqZWN0LmFzc2lnbihhLHRoaXMuZmlsbFtyLiR0b1N0eWxlXSgpKTtpZih0aGlzLmNvcm5lci5jaGlsZHJlbi5zb21lKChlPT4wIT09ZS5yYWRpdXMpKSl7Y29uc3QgZT10aGlzLmNvcm5lci5jaGlsZHJlbi5tYXAoKGU9PmVbci4kdG9TdHlsZV0oKSkpO2lmKDI9PT1lLmxlbmd0aHx8Mz09PWUubGVuZ3RoKXtjb25zdCB0PWUuYXQoLTEpO2ZvcihsZXQgYT1lLmxlbmd0aDthPDQ7YSsrKWUucHVzaCh0KX1hLmJvcmRlclJhZGl1cz1lLm1hcCgoZT0+ZS5yYWRpdXMpKS5qb2luKCIgIil9c3dpdGNoKHRoaXMucHJlc2VuY2Upe2Nhc2UiaW52aXNpYmxlIjpjYXNlImhpZGRlbiI6YS5ib3JkZXJTdHlsZT0iIjticmVhaztjYXNlImluYWN0aXZlIjphLmJvcmRlclN0eWxlPSJub25lIjticmVhaztkZWZhdWx0OmEuYm9yZGVyU3R5bGU9dC5tYXAoKGU9PmUuc3R5bGUpKS5qb2luKCIgIil9YS5ib3JkZXJXaWR0aD10Lm1hcCgoZT0+ZS53aWR0aCkpLmpvaW4oIiAiKTthLmJvcmRlckNvbG9yPXQubWFwKChlPT5lLmNvbG9yKSkuam9pbigiICIpO3JldHVybiBhfX1jbGFzcyBCcmVhayBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImJyZWFrIiwhMCk7dGhpcy5hZnRlcj0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5hZnRlcixbImF1dG8iLCJjb250ZW50QXJlYSIsInBhZ2VBcmVhIiwicGFnZUV2ZW4iLCJwYWdlT2RkIl0pO3RoaXMuYWZ0ZXJUYXJnZXQ9ZS5hZnRlclRhcmdldHx8IiI7dGhpcy5iZWZvcmU9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuYmVmb3JlLFsiYXV0byIsImNvbnRlbnRBcmVhIiwicGFnZUFyZWEiLCJwYWdlRXZlbiIsInBhZ2VPZGQiXSk7dGhpcy5iZWZvcmVUYXJnZXQ9ZS5iZWZvcmVUYXJnZXR8fCIiO3RoaXMuYm9va2VuZExlYWRlcj1lLmJvb2tlbmRMZWFkZXJ8fCIiO3RoaXMuYm9va2VuZFRyYWlsZXI9ZS5ib29rZW5kVHJhaWxlcnx8IiI7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm92ZXJmbG93TGVhZGVyPWUub3ZlcmZsb3dMZWFkZXJ8fCIiO3RoaXMub3ZlcmZsb3dUYXJnZXQ9ZS5vdmVyZmxvd1RhcmdldHx8IiI7dGhpcy5vdmVyZmxvd1RyYWlsZXI9ZS5vdmVyZmxvd1RyYWlsZXJ8fCIiO3RoaXMuc3RhcnROZXc9KDAsby5nZXRJbnRlZ2VyKSh7ZGF0YTplLnN0YXJ0TmV3LGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZXh0cmFzPW51bGx9fWNsYXNzIEJyZWFrQWZ0ZXIgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJicmVha0FmdGVyIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmxlYWRlcj1lLmxlYWRlcnx8IiI7dGhpcy5zdGFydE5ldz0oMCxvLmdldEludGVnZXIpKHtkYXRhOmUuc3RhcnROZXcsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV9KTt0aGlzLnRhcmdldD1lLnRhcmdldHx8IiI7dGhpcy50YXJnZXRUeXBlPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLnRhcmdldFR5cGUsWyJhdXRvIiwiY29udGVudEFyZWEiLCJwYWdlQXJlYSJdKTt0aGlzLnRyYWlsZXI9ZS50cmFpbGVyfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5zY3JpcHQ9bnVsbH19Y2xhc3MgQnJlYWtCZWZvcmUgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJicmVha0JlZm9yZSIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5sZWFkZXI9ZS5sZWFkZXJ8fCIiO3RoaXMuc3RhcnROZXc9KDAsby5nZXRJbnRlZ2VyKSh7ZGF0YTplLnN0YXJ0TmV3LGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy50YXJnZXQ9ZS50YXJnZXR8fCIiO3RoaXMudGFyZ2V0VHlwZT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS50YXJnZXRUeXBlLFsiYXV0byIsImNvbnRlbnRBcmVhIiwicGFnZUFyZWEiXSk7dGhpcy50cmFpbGVyPWUudHJhaWxlcnx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuc2NyaXB0PW51bGx9W3IuJHRvSFRNTF0oZSl7dGhpc1tyLiRleHRyYV09e307cmV0dXJuIG8uSFRNTFJlc3VsdC5GQUlMVVJFfX1jbGFzcyBCdXR0b24gZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJidXR0b24iLCEwKTt0aGlzLmhpZ2hsaWdodD0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5oaWdobGlnaHQsWyJpbnZlcnRlZCIsIm5vbmUiLCJvdXRsaW5lIiwicHVzaCJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmV4dHJhcz1udWxsfVtyLiR0b0hUTUxdKGUpe2NvbnN0IHQ9dGhpc1tyLiRnZXRQYXJlbnRdKClbci4kZ2V0UGFyZW50XSgpLGE9e25hbWU6ImJ1dHRvbiIsYXR0cmlidXRlczp7aWQ6dGhpc1tyLiR1aWRdLGNsYXNzOlsieGZhQnV0dG9uIl0sc3R5bGU6e319LGNoaWxkcmVuOltdfTtmb3IoY29uc3QgZSBvZiB0LmV2ZW50LmNoaWxkcmVuKXtpZigiY2xpY2siIT09ZS5hY3Rpdml0eXx8IWUuc2NyaXB0KWNvbnRpbnVlO2NvbnN0IHQ9KDAsaC5yZWNvdmVySnNVUkwpKGUuc2NyaXB0W3IuJGNvbnRlbnRdKTtpZighdCljb250aW51ZTtjb25zdCBuPSgwLHMuZml4VVJMKSh0LnVybCk7biYmYS5jaGlsZHJlbi5wdXNoKHtuYW1lOiJhIixhdHRyaWJ1dGVzOntpZDoibGluayIrdGhpc1tyLiR1aWRdLGhyZWY6bixuZXdXaW5kb3c6dC5uZXdXaW5kb3csY2xhc3M6WyJ4ZmFMaW5rIl0sc3R5bGU6e319LGNoaWxkcmVuOltdfSl9cmV0dXJuIG8uSFRNTFJlc3VsdC5zdWNjZXNzKGEpfX1jbGFzcyBDYWxjdWxhdGUgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJjYWxjdWxhdGUiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMub3ZlcnJpZGU9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUub3ZlcnJpZGUsWyJkaXNhYmxlZCIsImVycm9yIiwiaWdub3JlIiwid2FybmluZyJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbDt0aGlzLm1lc3NhZ2U9bnVsbDt0aGlzLnNjcmlwdD1udWxsfX1jbGFzcyBDYXB0aW9uIGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwiY2FwdGlvbiIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5wbGFjZW1lbnQ9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUucGxhY2VtZW50LFsibGVmdCIsImJvdHRvbSIsImlubGluZSIsInJpZ2h0IiwidG9wIl0pO3RoaXMucHJlc2VuY2U9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUucHJlc2VuY2UsWyJ2aXNpYmxlIiwiaGlkZGVuIiwiaW5hY3RpdmUiLCJpbnZpc2libGUiXSk7dGhpcy5yZXNlcnZlPU1hdGguY2VpbCgoMCxvLmdldE1lYXN1cmVtZW50KShlLnJlc2VydmUpKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbDt0aGlzLmZvbnQ9bnVsbDt0aGlzLm1hcmdpbj1udWxsO3RoaXMucGFyYT1udWxsO3RoaXMudmFsdWU9bnVsbH1bci4kc2V0VmFsdWVdKGUpe19zZXRWYWx1ZSh0aGlzLGUpfVtyLiRnZXRFeHRyYV0oZSl7aWYoIXRoaXNbci4kZXh0cmFdKXtsZXR7d2lkdGg6dCxoZWlnaHQ6YX09ZTtzd2l0Y2godGhpcy5wbGFjZW1lbnQpe2Nhc2UibGVmdCI6Y2FzZSJyaWdodCI6Y2FzZSJpbmxpbmUiOnQ9dGhpcy5yZXNlcnZlPD0wP3Q6dGhpcy5yZXNlcnZlO2JyZWFrO2Nhc2UidG9wIjpjYXNlImJvdHRvbSI6YT10aGlzLnJlc2VydmU8PTA/YTp0aGlzLnJlc2VydmV9dGhpc1tyLiRleHRyYV09KDAscy5sYXlvdXROb2RlKSh0aGlzLHt3aWR0aDp0LGhlaWdodDphfSl9cmV0dXJuIHRoaXNbci4kZXh0cmFdfVtyLiR0b0hUTUxdKGUpe2lmKCF0aGlzLnZhbHVlKXJldHVybiBvLkhUTUxSZXN1bHQuRU1QVFk7dGhpc1tyLiRwdXNoUGFyYV0oKTtjb25zdCB0PXRoaXMudmFsdWVbci4kdG9IVE1MXShlKS5odG1sO2lmKCF0KXt0aGlzW3IuJHBvcFBhcmFdKCk7cmV0dXJuIG8uSFRNTFJlc3VsdC5FTVBUWX1jb25zdCBhPXRoaXMucmVzZXJ2ZTtpZih0aGlzLnJlc2VydmU8PTApe2NvbnN0e3c6dCxoOmF9PXRoaXNbci4kZ2V0RXh0cmFdKGUpO3N3aXRjaCh0aGlzLnBsYWNlbWVudCl7Y2FzZSJsZWZ0IjpjYXNlInJpZ2h0IjpjYXNlImlubGluZSI6dGhpcy5yZXNlcnZlPXQ7YnJlYWs7Y2FzZSJ0b3AiOmNhc2UiYm90dG9tIjp0aGlzLnJlc2VydmU9YX19Y29uc3Qgbj1bXTsic3RyaW5nIj09dHlwZW9mIHQ/bi5wdXNoKHtuYW1lOiIjdGV4dCIsdmFsdWU6dH0pOm4ucHVzaCh0KTtjb25zdCBpPSgwLHMudG9TdHlsZSkodGhpcywiZm9udCIsIm1hcmdpbiIsInZpc2liaWxpdHkiKTtzd2l0Y2godGhpcy5wbGFjZW1lbnQpe2Nhc2UibGVmdCI6Y2FzZSJyaWdodCI6dGhpcy5yZXNlcnZlPjAmJihpLndpZHRoPSgwLHMubWVhc3VyZVRvU3RyaW5nKSh0aGlzLnJlc2VydmUpKTticmVhaztjYXNlInRvcCI6Y2FzZSJib3R0b20iOnRoaXMucmVzZXJ2ZT4wJiYoaS5oZWlnaHQ9KDAscy5tZWFzdXJlVG9TdHJpbmcpKHRoaXMucmVzZXJ2ZSkpfSgwLHMuc2V0UGFyYSkodGhpcyxudWxsLHQpO3RoaXNbci4kcG9wUGFyYV0oKTt0aGlzLnJlc2VydmU9YTtyZXR1cm4gby5IVE1MUmVzdWx0LnN1Y2Nlc3Moe25hbWU6ImRpdiIsYXR0cmlidXRlczp7c3R5bGU6aSxjbGFzczpbInhmYUNhcHRpb24iXX0sY2hpbGRyZW46bn0pfX1jbGFzcyBDZXJ0aWZpY2F0ZSBleHRlbmRzIHIuU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImNlcnRpZmljYXRlIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIENlcnRpZmljYXRlcyBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImNlcnRpZmljYXRlcyIsITApO3RoaXMuY3JlZGVudGlhbFNlcnZlclBvbGljeT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5jcmVkZW50aWFsU2VydmVyUG9saWN5LFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXJsPWUudXJsfHwiIjt0aGlzLnVybFBvbGljeT1lLnVybFBvbGljeXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZW5jcnlwdGlvbj1udWxsO3RoaXMuaXNzdWVycz1udWxsO3RoaXMua2V5VXNhZ2U9bnVsbDt0aGlzLm9pZHM9bnVsbDt0aGlzLnNpZ25pbmc9bnVsbDt0aGlzLnN1YmplY3RETnM9bnVsbH19Y2xhc3MgQ2hlY2tCdXR0b24gZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJjaGVja0J1dHRvbiIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5tYXJrPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLm1hcmssWyJkZWZhdWx0IiwiY2hlY2siLCJjaXJjbGUiLCJjcm9zcyIsImRpYW1vbmQiLCJzcXVhcmUiLCJzdGFyIl0pO3RoaXMuc2hhcGU9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuc2hhcGUsWyJzcXVhcmUiLCJyb3VuZCJdKTt0aGlzLnNpemU9KDAsby5nZXRNZWFzdXJlbWVudCkoZS5zaXplLCIxMHB0Iik7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuYm9yZGVyPW51bGw7dGhpcy5leHRyYXM9bnVsbDt0aGlzLm1hcmdpbj1udWxsfVtyLiR0b0hUTUxdKGUpe2NvbnN0IHQ9KDAscy50b1N0eWxlKSgibWFyZ2luIiksYT0oMCxzLm1lYXN1cmVUb1N0cmluZykodGhpcy5zaXplKTt0LndpZHRoPXQuaGVpZ2h0PWE7bGV0IG4saSxjO2NvbnN0IGw9dGhpc1tyLiRnZXRQYXJlbnRdKClbci4kZ2V0UGFyZW50XSgpLGg9bC5pdGVtcy5jaGlsZHJlbi5sZW5ndGgmJmwuaXRlbXMuY2hpbGRyZW5bMF1bci4kdG9IVE1MXSgpLmh0bWx8fFtdLHU9e29uOih2b2lkIDAhPT1oWzBdP2hbMF06Im9uIikudG9TdHJpbmcoKSxvZmY6KHZvaWQgMCE9PWhbMV0/aFsxXToib2ZmIikudG9TdHJpbmcoKX0sZD0obC52YWx1ZSYmbC52YWx1ZVtyLiR0ZXh0XSgpfHwib2ZmIik9PT11Lm9ufHx2b2lkIDAsZj1sW3IuJGdldFN1YmZvcm1QYXJlbnRdKCksZz1sW3IuJHVpZF07bGV0IHA7aWYoZiBpbnN0YW5jZW9mIEV4Y2xHcm91cCl7Yz1mW3IuJHVpZF07bj0icmFkaW8iO2k9InhmYVJhZGlvIjtwPWZbci4kZGF0YV0mJmZbci4kZGF0YV1bci4kdWlkXXx8ZltyLiR1aWRdfWVsc2V7bj0iY2hlY2tib3giO2k9InhmYUNoZWNrYm94IjtwPWxbci4kZGF0YV0mJmxbci4kZGF0YV1bci4kdWlkXXx8bFtyLiR1aWRdfWNvbnN0IG09e25hbWU6ImlucHV0IixhdHRyaWJ1dGVzOntjbGFzczpbaV0sc3R5bGU6dCxmaWVsZElkOmcsZGF0YUlkOnAsdHlwZTpuLGNoZWNrZWQ6ZCx4ZmFPbjp1Lm9uLHhmYU9mZjp1Lm9mZiwiYXJpYS1sYWJlbCI6YXJpYUxhYmVsKGwpLCJhcmlhLXJlcXVpcmVkIjohMX19O2MmJihtLmF0dHJpYnV0ZXMubmFtZT1jKTtpZihpc1JlcXVpcmVkKGwpKXttLmF0dHJpYnV0ZXNbImFyaWEtcmVxdWlyZWQiXT0hMDttLmF0dHJpYnV0ZXMucmVxdWlyZWQ9ITB9cmV0dXJuIG8uSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJsYWJlbCIsYXR0cmlidXRlczp7Y2xhc3M6WyJ4ZmFMYWJlbCJdfSxjaGlsZHJlbjpbbV19KX19Y2xhc3MgQ2hvaWNlTGlzdCBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImNob2ljZUxpc3QiLCEwKTt0aGlzLmNvbW1pdE9uPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLmNvbW1pdE9uLFsic2VsZWN0IiwiZXhpdCJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMub3Blbj0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5vcGVuLFsidXNlckNvbnRyb2wiLCJhbHdheXMiLCJtdWx0aVNlbGVjdCIsIm9uRW50cnkiXSk7dGhpcy50ZXh0RW50cnk9KDAsby5nZXRJbnRlZ2VyKSh7ZGF0YTplLnRleHRFbnRyeSxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT4xPT09ZX0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmJvcmRlcj1udWxsO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5tYXJnaW49bnVsbH1bci4kdG9IVE1MXShlKXtjb25zdCB0PSgwLHMudG9TdHlsZSkodGhpcywiYm9yZGVyIiwibWFyZ2luIiksYT10aGlzW3IuJGdldFBhcmVudF0oKVtyLiRnZXRQYXJlbnRdKCksbj17Zm9udFNpemU6YGNhbGMoJHthLmZvbnQmJmEuZm9udC5zaXplfHwxMH1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYH0saT1bXTtpZihhLml0ZW1zLmNoaWxkcmVuLmxlbmd0aD4wKXtjb25zdCBlPWEuaXRlbXM7bGV0IHQ9MCxzPTA7aWYoMj09PWUuY2hpbGRyZW4ubGVuZ3RoKXt0PWUuY2hpbGRyZW5bMF0uc2F2ZTtzPTEtdH1jb25zdCBvPWUuY2hpbGRyZW5bdF1bci4kdG9IVE1MXSgpLmh0bWwsYz1lLmNoaWxkcmVuW3NdW3IuJHRvSFRNTF0oKS5odG1sO2xldCBsPSExO2NvbnN0IGg9YS52YWx1ZSYmYS52YWx1ZVtyLiR0ZXh0XSgpfHwiIjtmb3IobGV0IGU9MCx0PW8ubGVuZ3RoO2U8dDtlKyspe2NvbnN0IHQ9e25hbWU6Im9wdGlvbiIsYXR0cmlidXRlczp7dmFsdWU6Y1tlXXx8b1tlXSxzdHlsZTpufSx2YWx1ZTpvW2VdfTtjW2VdPT09aCYmKHQuYXR0cmlidXRlcy5zZWxlY3RlZD1sPSEwKTtpLnB1c2godCl9bHx8aS5zcGxpY2UoMCwwLHtuYW1lOiJvcHRpb24iLGF0dHJpYnV0ZXM6e2hpZGRlbjohMCxzZWxlY3RlZDohMH0sdmFsdWU6IiAifSl9Y29uc3QgYz17Y2xhc3M6WyJ4ZmFTZWxlY3QiXSxmaWVsZElkOmFbci4kdWlkXSxkYXRhSWQ6YVtyLiRkYXRhXSYmYVtyLiRkYXRhXVtyLiR1aWRdfHxhW3IuJHVpZF0sc3R5bGU6dCwiYXJpYS1sYWJlbCI6YXJpYUxhYmVsKGEpLCJhcmlhLXJlcXVpcmVkIjohMX07aWYoaXNSZXF1aXJlZChhKSl7Y1siYXJpYS1yZXF1aXJlZCJdPSEwO2MucmVxdWlyZWQ9ITB9Im11bHRpU2VsZWN0Ij09PXRoaXMub3BlbiYmKGMubXVsdGlwbGU9ITApO3JldHVybiBvLkhUTUxSZXN1bHQuc3VjY2Vzcyh7bmFtZToibGFiZWwiLGF0dHJpYnV0ZXM6e2NsYXNzOlsieGZhTGFiZWwiXX0sY2hpbGRyZW46W3tuYW1lOiJzZWxlY3QiLGNoaWxkcmVuOmksYXR0cmlidXRlczpjfV19KX19Y2xhc3MgQ29sb3IgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJjb2xvciIsITApO3RoaXMuY1NwYWNlPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLmNTcGFjZSxbIlNSR0IiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy52YWx1ZT1lLnZhbHVlPygwLG8uZ2V0Q29sb3IpKGUudmFsdWUpOiIiO3RoaXMuZXh0cmFzPW51bGx9W3IuJGhhc1NldHRhYmxlVmFsdWVdKCl7cmV0dXJuITF9W3IuJHRvU3R5bGVdKCl7cmV0dXJuIHRoaXMudmFsdWU/Yy5VdGlsLm1ha2VIZXhDb2xvcih0aGlzLnZhbHVlLnIsdGhpcy52YWx1ZS5nLHRoaXMudmFsdWUuYik6bnVsbH19Y2xhc3MgQ29tYiBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImNvbWIiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubnVtYmVyT2ZDZWxscz0oMCxvLmdldEludGVnZXIpKHtkYXRhOmUubnVtYmVyT2ZDZWxscyxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT5lPj0wfSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBDb25uZWN0IGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwiY29ubmVjdCIsITApO3RoaXMuY29ubmVjdGlvbj1lLmNvbm5lY3Rpb258fCIiO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5yZWY9ZS5yZWZ8fCIiO3RoaXMudXNhZ2U9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUudXNhZ2UsWyJleHBvcnRBbmRJbXBvcnQiLCJleHBvcnRPbmx5IiwiaW1wb3J0T25seSJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5waWN0dXJlPW51bGx9fWNsYXNzIENvbnRlbnRBcmVhIGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwiY29udGVudEFyZWEiLCEwKTt0aGlzLmg9KDAsby5nZXRNZWFzdXJlbWVudCkoZS5oKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMucmVsZXZhbnQ9KDAsby5nZXRSZWxldmFudCkoZS5yZWxldmFudCk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMudz0oMCxvLmdldE1lYXN1cmVtZW50KShlLncpO3RoaXMueD0oMCxvLmdldE1lYXN1cmVtZW50KShlLngsIjBwdCIpO3RoaXMueT0oMCxvLmdldE1lYXN1cmVtZW50KShlLnksIjBwdCIpO3RoaXMuZGVzYz1udWxsO3RoaXMuZXh0cmFzPW51bGx9W3IuJHRvSFRNTF0oZSl7Y29uc3QgdD17bGVmdDooMCxzLm1lYXN1cmVUb1N0cmluZykodGhpcy54KSx0b3A6KDAscy5tZWFzdXJlVG9TdHJpbmcpKHRoaXMueSksd2lkdGg6KDAscy5tZWFzdXJlVG9TdHJpbmcpKHRoaXMudyksaGVpZ2h0OigwLHMubWVhc3VyZVRvU3RyaW5nKSh0aGlzLmgpfSxhPVsieGZhQ29udGVudGFyZWEiXTsoMCxzLmlzUHJpbnRPbmx5KSh0aGlzKSYmYS5wdXNoKCJ4ZmFQcmludE9ubHkiKTtyZXR1cm4gby5IVE1MUmVzdWx0LnN1Y2Nlc3Moe25hbWU6ImRpdiIsY2hpbGRyZW46W10sYXR0cmlidXRlczp7c3R5bGU6dCxjbGFzczphLGlkOnRoaXNbci4kdWlkXX19KX19Y2xhc3MgQ29ybmVyIGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwiY29ybmVyIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmludmVydGVkPSgwLG8uZ2V0SW50ZWdlcikoe2RhdGE6ZS5pbnZlcnRlZCxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT4xPT09ZX0pO3RoaXMuam9pbj0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5qb2luLFsic3F1YXJlIiwicm91bmQiXSk7dGhpcy5wcmVzZW5jZT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5wcmVzZW5jZSxbInZpc2libGUiLCJoaWRkZW4iLCJpbmFjdGl2ZSIsImludmlzaWJsZSJdKTt0aGlzLnJhZGl1cz0oMCxvLmdldE1lYXN1cmVtZW50KShlLnJhZGl1cyk7dGhpcy5zdHJva2U9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuc3Ryb2tlLFsic29saWQiLCJkYXNoRG90IiwiZGFzaERvdERvdCIsImRhc2hlZCIsImRvdHRlZCIsImVtYm9zc2VkIiwiZXRjaGVkIiwibG93ZXJlZCIsInJhaXNlZCJdKTt0aGlzLnRoaWNrbmVzcz0oMCxvLmdldE1lYXN1cmVtZW50KShlLnRoaWNrbmVzcywiMC41cHQiKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5jb2xvcj1udWxsO3RoaXMuZXh0cmFzPW51bGx9W3IuJHRvU3R5bGVdKCl7Y29uc3QgZT0oMCxzLnRvU3R5bGUpKHRoaXMsInZpc2liaWxpdHkiKTtlLnJhZGl1cz0oMCxzLm1lYXN1cmVUb1N0cmluZykoInNxdWFyZSI9PT10aGlzLmpvaW4/MDp0aGlzLnJhZGl1cyk7cmV0dXJuIGV9fWNsYXNzIERhdGVFbGVtZW50IGV4dGVuZHMgci5Db250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImRhdGUiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn1bci4kZmluYWxpemVdKCl7Y29uc3QgZT10aGlzW3IuJGNvbnRlbnRdLnRyaW0oKTt0aGlzW3IuJGNvbnRlbnRdPWU/bmV3IERhdGUoZSk6bnVsbH1bci4kdG9IVE1MXShlKXtyZXR1cm4gdmFsdWVUb0h0bWwodGhpc1tyLiRjb250ZW50XT90aGlzW3IuJGNvbnRlbnRdLnRvU3RyaW5nKCk6IiIpfX1jbGFzcyBEYXRlVGltZSBleHRlbmRzIHIuQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJkYXRlVGltZSIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifVtyLiRmaW5hbGl6ZV0oKXtjb25zdCBlPXRoaXNbci4kY29udGVudF0udHJpbSgpO3RoaXNbci4kY29udGVudF09ZT9uZXcgRGF0ZShlKTpudWxsfVtyLiR0b0hUTUxdKGUpe3JldHVybiB2YWx1ZVRvSHRtbCh0aGlzW3IuJGNvbnRlbnRdP3RoaXNbci4kY29udGVudF0udG9TdHJpbmcoKToiIil9fWNsYXNzIERhdGVUaW1lRWRpdCBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImRhdGVUaW1lRWRpdCIsITApO3RoaXMuaFNjcm9sbFBvbGljeT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5oU2Nyb2xsUG9saWN5LFsiYXV0byIsIm9mZiIsIm9uIl0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5waWNrZXI9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUucGlja2VyLFsiaG9zdCIsIm5vbmUiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuYm9yZGVyPW51bGw7dGhpcy5jb21iPW51bGw7dGhpcy5leHRyYXM9bnVsbDt0aGlzLm1hcmdpbj1udWxsfVtyLiR0b0hUTUxdKGUpe2NvbnN0IHQ9KDAscy50b1N0eWxlKSh0aGlzLCJib3JkZXIiLCJmb250IiwibWFyZ2luIiksYT10aGlzW3IuJGdldFBhcmVudF0oKVtyLiRnZXRQYXJlbnRdKCksbj17bmFtZToiaW5wdXQiLGF0dHJpYnV0ZXM6e3R5cGU6InRleHQiLGZpZWxkSWQ6YVtyLiR1aWRdLGRhdGFJZDphW3IuJGRhdGFdJiZhW3IuJGRhdGFdW3IuJHVpZF18fGFbci4kdWlkXSxjbGFzczpbInhmYVRleHRmaWVsZCJdLHN0eWxlOnQsImFyaWEtbGFiZWwiOmFyaWFMYWJlbChhKSwiYXJpYS1yZXF1aXJlZCI6ITF9fTtpZihpc1JlcXVpcmVkKGEpKXtuLmF0dHJpYnV0ZXNbImFyaWEtcmVxdWlyZWQiXT0hMDtuLmF0dHJpYnV0ZXMucmVxdWlyZWQ9ITB9cmV0dXJuIG8uSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJsYWJlbCIsYXR0cmlidXRlczp7Y2xhc3M6WyJ4ZmFMYWJlbCJdfSxjaGlsZHJlbjpbbl19KX19Y2xhc3MgRGVjaW1hbCBleHRlbmRzIHIuQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJkZWNpbWFsIik7dGhpcy5mcmFjRGlnaXRzPSgwLG8uZ2V0SW50ZWdlcikoe2RhdGE6ZS5mcmFjRGlnaXRzLGRlZmF1bHRWYWx1ZToyLHZhbGlkYXRlOmU9PiEwfSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmxlYWREaWdpdHM9KDAsby5nZXRJbnRlZ2VyKSh7ZGF0YTplLmxlYWREaWdpdHMsZGVmYXVsdFZhbHVlOi0xLHZhbGlkYXRlOmU9PiEwfSk7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifVtyLiRmaW5hbGl6ZV0oKXtjb25zdCBlPXBhcnNlRmxvYXQodGhpc1tyLiRjb250ZW50XS50cmltKCkpO3RoaXNbci4kY29udGVudF09aXNOYU4oZSk/bnVsbDplfVtyLiR0b0hUTUxdKGUpe3JldHVybiB2YWx1ZVRvSHRtbChudWxsIT09dGhpc1tyLiRjb250ZW50XT90aGlzW3IuJGNvbnRlbnRdLnRvU3RyaW5nKCk6IiIpfX1jbGFzcyBEZWZhdWx0VWkgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJkZWZhdWx0VWkiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmV4dHJhcz1udWxsfX1jbGFzcyBEZXNjIGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwiZGVzYyIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuYm9vbGVhbj1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmRhdGU9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5kYXRlVGltZT1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmRlY2ltYWw9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5leERhdGE9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5mbG9hdD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmltYWdlPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuaW50ZWdlcj1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLnRleHQ9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy50aW1lPW5ldyByLlhGQU9iamVjdEFycmF5fX1jbGFzcyBEaWdlc3RNZXRob2QgZXh0ZW5kcyByLk9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJkaWdlc3RNZXRob2QiLFsiIiwiU0hBMSIsIlNIQTI1NiIsIlNIQTUxMiIsIlJJUEVNRDE2MCJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgRGlnZXN0TWV0aG9kcyBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImRpZ2VzdE1ldGhvZHMiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS50eXBlLFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5kaWdlc3RNZXRob2Q9bmV3IHIuWEZBT2JqZWN0QXJyYXl9fWNsYXNzIERyYXcgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJkcmF3IiwhMCk7dGhpcy5hbmNob3JUeXBlPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLmFuY2hvclR5cGUsWyJ0b3BMZWZ0IiwiYm90dG9tQ2VudGVyIiwiYm90dG9tTGVmdCIsImJvdHRvbVJpZ2h0IiwibWlkZGxlQ2VudGVyIiwibWlkZGxlTGVmdCIsIm1pZGRsZVJpZ2h0IiwidG9wQ2VudGVyIiwidG9wUmlnaHQiXSk7dGhpcy5jb2xTcGFuPSgwLG8uZ2V0SW50ZWdlcikoe2RhdGE6ZS5jb2xTcGFuLGRlZmF1bHRWYWx1ZToxLHZhbGlkYXRlOmU9PmU+PTF8fC0xPT09ZX0pO3RoaXMuaD1lLmg/KDAsby5nZXRNZWFzdXJlbWVudCkoZS5oKToiIjt0aGlzLmhBbGlnbj0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5oQWxpZ24sWyJsZWZ0IiwiY2VudGVyIiwianVzdGlmeSIsImp1c3RpZnlBbGwiLCJyYWRpeCIsInJpZ2h0Il0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5sb2NhbGU9ZS5sb2NhbGV8fCIiO3RoaXMubWF4SD0oMCxvLmdldE1lYXN1cmVtZW50KShlLm1heEgsIjBwdCIpO3RoaXMubWF4Vz0oMCxvLmdldE1lYXN1cmVtZW50KShlLm1heFcsIjBwdCIpO3RoaXMubWluSD0oMCxvLmdldE1lYXN1cmVtZW50KShlLm1pbkgsIjBwdCIpO3RoaXMubWluVz0oMCxvLmdldE1lYXN1cmVtZW50KShlLm1pblcsIjBwdCIpO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMucHJlc2VuY2U9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUucHJlc2VuY2UsWyJ2aXNpYmxlIiwiaGlkZGVuIiwiaW5hY3RpdmUiLCJpbnZpc2libGUiXSk7dGhpcy5yZWxldmFudD0oMCxvLmdldFJlbGV2YW50KShlLnJlbGV2YW50KTt0aGlzLnJvdGF0ZT0oMCxvLmdldEludGVnZXIpKHtkYXRhOmUucm90YXRlLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PmUlOTA9PTB9KTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy53PWUudz8oMCxvLmdldE1lYXN1cmVtZW50KShlLncpOiIiO3RoaXMueD0oMCxvLmdldE1lYXN1cmVtZW50KShlLngsIjBwdCIpO3RoaXMueT0oMCxvLmdldE1lYXN1cmVtZW50KShlLnksIjBwdCIpO3RoaXMuYXNzaXN0PW51bGw7dGhpcy5ib3JkZXI9bnVsbDt0aGlzLmNhcHRpb249bnVsbDt0aGlzLmRlc2M9bnVsbDt0aGlzLmV4dHJhcz1udWxsO3RoaXMuZm9udD1udWxsO3RoaXMua2VlcD1udWxsO3RoaXMubWFyZ2luPW51bGw7dGhpcy5wYXJhPW51bGw7dGhpcy50cmF2ZXJzYWw9bnVsbDt0aGlzLnVpPW51bGw7dGhpcy52YWx1ZT1udWxsO3RoaXMuc2V0UHJvcGVydHk9bmV3IHIuWEZBT2JqZWN0QXJyYXl9W3IuJHNldFZhbHVlXShlKXtfc2V0VmFsdWUodGhpcyxlKX1bci4kdG9IVE1MXShlKXtzZXRUYWJJbmRleCh0aGlzKTtpZigiaGlkZGVuIj09PXRoaXMucHJlc2VuY2V8fCJpbmFjdGl2ZSI9PT10aGlzLnByZXNlbmNlKXJldHVybiBvLkhUTUxSZXN1bHQuRU1QVFk7KDAscy5maXhEaW1lbnNpb25zKSh0aGlzKTt0aGlzW3IuJHB1c2hQYXJhXSgpO2NvbnN0IHQ9dGhpcy53LGE9dGhpcy5oLHt3Om4saDpjLGlzQnJva2VuOmx9PSgwLHMubGF5b3V0Tm9kZSkodGhpcyxlKTtpZihuJiYiIj09PXRoaXMudyl7aWYobCYmdGhpc1tyLiRnZXRTdWJmb3JtUGFyZW50XSgpW3IuJGlzVGhlcmVNb3JlV2lkdGhdKCkpe3RoaXNbci4kcG9wUGFyYV0oKTtyZXR1cm4gby5IVE1MUmVzdWx0LkZBSUxVUkV9dGhpcy53PW59YyYmIiI9PT10aGlzLmgmJih0aGlzLmg9Yyk7c2V0Rmlyc3RVbnNwbGl0dGFibGUodGhpcyk7aWYoISgwLGkuY2hlY2tEaW1lbnNpb25zKSh0aGlzLGUpKXt0aGlzLnc9dDt0aGlzLmg9YTt0aGlzW3IuJHBvcFBhcmFdKCk7cmV0dXJuIG8uSFRNTFJlc3VsdC5GQUlMVVJFfXVuc2V0Rmlyc3RVbnNwbGl0dGFibGUodGhpcyk7Y29uc3QgaD0oMCxzLnRvU3R5bGUpKHRoaXMsImZvbnQiLCJoQWxpZ24iLCJkaW1lbnNpb25zIiwicG9zaXRpb24iLCJwcmVzZW5jZSIsInJvdGF0ZSIsImFuY2hvclR5cGUiLCJib3JkZXIiLCJtYXJnaW4iKTsoMCxzLnNldE1pbk1heERpbWVuc2lvbnMpKHRoaXMsaCk7aWYoaC5tYXJnaW4pe2gucGFkZGluZz1oLm1hcmdpbjtkZWxldGUgaC5tYXJnaW59Y29uc3QgdT1bInhmYURyYXciXTt0aGlzLmZvbnQmJnUucHVzaCgieGZhRm9udCIpOygwLHMuaXNQcmludE9ubHkpKHRoaXMpJiZ1LnB1c2goInhmYVByaW50T25seSIpO2NvbnN0IGQ9e3N0eWxlOmgsaWQ6dGhpc1tyLiR1aWRdLGNsYXNzOnV9O3RoaXMubmFtZSYmKGQueGZhTmFtZT10aGlzLm5hbWUpO2NvbnN0IGY9e25hbWU6ImRpdiIsYXR0cmlidXRlczpkLGNoaWxkcmVuOltdfTthcHBseUFzc2lzdCh0aGlzLGQpO2NvbnN0IGc9KDAscy5jb21wdXRlQmJveCkodGhpcyxmLGUpLHA9dGhpcy52YWx1ZT90aGlzLnZhbHVlW3IuJHRvSFRNTF0oZSkuaHRtbDpudWxsO2lmKG51bGw9PT1wKXt0aGlzLnc9dDt0aGlzLmg9YTt0aGlzW3IuJHBvcFBhcmFdKCk7cmV0dXJuIG8uSFRNTFJlc3VsdC5zdWNjZXNzKCgwLHMuY3JlYXRlV3JhcHBlcikodGhpcyxmKSxnKX1mLmNoaWxkcmVuLnB1c2gocCk7KDAscy5zZXRQYXJhKSh0aGlzLGgscCk7dGhpcy53PXQ7dGhpcy5oPWE7dGhpc1tyLiRwb3BQYXJhXSgpO3JldHVybiBvLkhUTUxSZXN1bHQuc3VjY2VzcygoMCxzLmNyZWF0ZVdyYXBwZXIpKHRoaXMsZiksZyl9fWNsYXNzIEVkZ2UgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJlZGdlIiwhMCk7dGhpcy5jYXA9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuY2FwLFsic3F1YXJlIiwiYnV0dCIsInJvdW5kIl0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5wcmVzZW5jZT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5wcmVzZW5jZSxbInZpc2libGUiLCJoaWRkZW4iLCJpbmFjdGl2ZSIsImludmlzaWJsZSJdKTt0aGlzLnN0cm9rZT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5zdHJva2UsWyJzb2xpZCIsImRhc2hEb3QiLCJkYXNoRG90RG90IiwiZGFzaGVkIiwiZG90dGVkIiwiZW1ib3NzZWQiLCJldGNoZWQiLCJsb3dlcmVkIiwicmFpc2VkIl0pO3RoaXMudGhpY2tuZXNzPSgwLG8uZ2V0TWVhc3VyZW1lbnQpKGUudGhpY2tuZXNzLCIwLjVwdCIpO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmNvbG9yPW51bGw7dGhpcy5leHRyYXM9bnVsbH1bci4kdG9TdHlsZV0oKXtjb25zdCBlPSgwLHMudG9TdHlsZSkodGhpcywidmlzaWJpbGl0eSIpO09iamVjdC5hc3NpZ24oZSx7bGluZWNhcDp0aGlzLmNhcCx3aWR0aDooMCxzLm1lYXN1cmVUb1N0cmluZykodGhpcy50aGlja25lc3MpLGNvbG9yOnRoaXMuY29sb3I/dGhpcy5jb2xvcltyLiR0b1N0eWxlXSgpOiIjMDAwMDAwIixzdHlsZToiIn0pO2lmKCJ2aXNpYmxlIiE9PXRoaXMucHJlc2VuY2UpZS5zdHlsZT0ibm9uZSI7ZWxzZSBzd2l0Y2godGhpcy5zdHJva2Upe2Nhc2Uic29saWQiOmUuc3R5bGU9InNvbGlkIjticmVhaztjYXNlImRhc2hEb3QiOmNhc2UiZGFzaERvdERvdCI6Y2FzZSJkYXNoZWQiOmUuc3R5bGU9ImRhc2hlZCI7YnJlYWs7Y2FzZSJkb3R0ZWQiOmUuc3R5bGU9ImRvdHRlZCI7YnJlYWs7Y2FzZSJlbWJvc3NlZCI6ZS5zdHlsZT0icmlkZ2UiO2JyZWFrO2Nhc2UiZXRjaGVkIjplLnN0eWxlPSJncm9vdmUiO2JyZWFrO2Nhc2UibG93ZXJlZCI6ZS5zdHlsZT0iaW5zZXQiO2JyZWFrO2Nhc2UicmFpc2VkIjplLnN0eWxlPSJvdXRzZXQifXJldHVybiBlfX1jbGFzcyBFbmNvZGluZyBleHRlbmRzIHIuT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImVuY29kaW5nIixbImFkYmUueDUwOS5yc2Ffc2hhMSIsImFkYmUucGtjczcuZGV0YWNoZWQiLCJhZGJlLnBrY3M3LnNoYTEiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIEVuY29kaW5ncyBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImVuY29kaW5ncyIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy50eXBlPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLnR5cGUsWyJvcHRpb25hbCIsInJlcXVpcmVkIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmVuY29kaW5nPW5ldyByLlhGQU9iamVjdEFycmF5fX1jbGFzcyBFbmNyeXB0IGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwiZW5jcnlwdCIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuY2VydGlmaWNhdGU9bnVsbH19Y2xhc3MgRW5jcnlwdERhdGEgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJlbmNyeXB0RGF0YSIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5vcGVyYXRpb249KDAsby5nZXRTdHJpbmdPcHRpb24pKGUub3BlcmF0aW9uLFsiZW5jcnlwdCIsImRlY3J5cHQiXSk7dGhpcy50YXJnZXQ9ZS50YXJnZXR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmZpbHRlcj1udWxsO3RoaXMubWFuaWZlc3Q9bnVsbH19Y2xhc3MgRW5jcnlwdGlvbiBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImVuY3J5cHRpb24iLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS50eXBlLFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5jZXJ0aWZpY2F0ZT1uZXcgci5YRkFPYmplY3RBcnJheX19Y2xhc3MgRW5jcnlwdGlvbk1ldGhvZCBleHRlbmRzIHIuT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImVuY3J5cHRpb25NZXRob2QiLFsiIiwiQUVTMjU2LUNCQyIsIlRSSVBMRURFUy1DQkMiLCJBRVMxMjgtQ0JDIiwiQUVTMTkyLUNCQyJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgRW5jcnlwdGlvbk1ldGhvZHMgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJlbmNyeXB0aW9uTWV0aG9kcyIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy50eXBlPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLnR5cGUsWyJvcHRpb25hbCIsInJlcXVpcmVkIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmVuY3J5cHRpb25NZXRob2Q9bmV3IHIuWEZBT2JqZWN0QXJyYXl9fWNsYXNzIEV2ZW50IGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwiZXZlbnQiLCEwKTt0aGlzLmFjdGl2aXR5PSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLmFjdGl2aXR5LFsiY2xpY2siLCJjaGFuZ2UiLCJkb2NDbG9zZSIsImRvY1JlYWR5IiwiZW50ZXIiLCJleGl0IiwiZnVsbCIsImluZGV4Q2hhbmdlIiwiaW5pdGlhbGl6ZSIsIm1vdXNlRG93biIsIm1vdXNlRW50ZXIiLCJtb3VzZUV4aXQiLCJtb3VzZVVwIiwicG9zdEV4ZWN1dGUiLCJwb3N0T3BlbiIsInBvc3RQcmludCIsInBvc3RTYXZlIiwicG9zdFNpZ24iLCJwb3N0U3VibWl0IiwicHJlRXhlY3V0ZSIsInByZU9wZW4iLCJwcmVQcmludCIsInByZVNhdmUiLCJwcmVTaWduIiwicHJlU3VibWl0IiwicmVhZHkiLCJ2YWxpZGF0aW9uU3RhdGUiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmxpc3Rlbj0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5saXN0ZW4sWyJyZWZPbmx5IiwicmVmQW5kRGVzY2VuZGVudHMiXSk7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy5yZWY9ZS5yZWZ8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmV4dHJhcz1udWxsO3RoaXMuZW5jcnlwdERhdGE9bnVsbDt0aGlzLmV4ZWN1dGU9bnVsbDt0aGlzLnNjcmlwdD1udWxsO3RoaXMuc2lnbkRhdGE9bnVsbDt0aGlzLnN1Ym1pdD1udWxsfX1jbGFzcyBFeERhdGEgZXh0ZW5kcyByLkNvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwiZXhEYXRhIik7dGhpcy5jb250ZW50VHlwZT1lLmNvbnRlbnRUeXBlfHwiIjt0aGlzLmhyZWY9ZS5ocmVmfHwiIjt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubWF4TGVuZ3RoPSgwLG8uZ2V0SW50ZWdlcikoe2RhdGE6ZS5tYXhMZW5ndGgsZGVmYXVsdFZhbHVlOi0xLHZhbGlkYXRlOmU9PmU+PS0xfSk7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy5yaWQ9ZS5yaWR8fCIiO3RoaXMudHJhbnNmZXJFbmNvZGluZz0oMCxvLmdldFN0cmluZ09wdGlvbikoZS50cmFuc2ZlckVuY29kaW5nLFsibm9uZSIsImJhc2U2NCIsInBhY2thZ2UiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifVtyLiRpc0NEQVRBWG1sXSgpe3JldHVybiJ0ZXh0L2h0bWwiPT09dGhpcy5jb250ZW50VHlwZX1bci4kb25DaGlsZF0oZSl7aWYoInRleHQvaHRtbCI9PT10aGlzLmNvbnRlbnRUeXBlJiZlW3IuJG5hbWVzcGFjZUlkXT09PW4uTmFtZXNwYWNlSWRzLnhodG1sLmlkKXt0aGlzW3IuJGNvbnRlbnRdPWU7cmV0dXJuITB9aWYoInRleHQveG1sIj09PXRoaXMuY29udGVudFR5cGUpe3RoaXNbci4kY29udGVudF09ZTtyZXR1cm4hMH1yZXR1cm4hMX1bci4kdG9IVE1MXShlKXtyZXR1cm4idGV4dC9odG1sIj09PXRoaXMuY29udGVudFR5cGUmJnRoaXNbci4kY29udGVudF0/dGhpc1tyLiRjb250ZW50XVtyLiR0b0hUTUxdKGUpOm8uSFRNTFJlc3VsdC5FTVBUWX19Y2xhc3MgRXhPYmplY3QgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJleE9iamVjdCIsITApO3RoaXMuYXJjaGl2ZT1lLmFyY2hpdmV8fCIiO3RoaXMuY2xhc3NJZD1lLmNsYXNzSWR8fCIiO3RoaXMuY29kZUJhc2U9ZS5jb2RlQmFzZXx8IiI7dGhpcy5jb2RlVHlwZT1lLmNvZGVUeXBlfHwiIjt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmV4dHJhcz1udWxsO3RoaXMuYm9vbGVhbj1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmRhdGU9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5kYXRlVGltZT1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmRlY2ltYWw9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5leERhdGE9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5leE9iamVjdD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmZsb2F0PW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuaW1hZ2U9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5pbnRlZ2VyPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMudGV4dD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLnRpbWU9bmV3IHIuWEZBT2JqZWN0QXJyYXl9fWNsYXNzIEV4Y2xHcm91cCBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImV4Y2xHcm91cCIsITApO3RoaXMuYWNjZXNzPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLmFjY2VzcyxbIm9wZW4iLCJub25JbnRlcmFjdGl2ZSIsInByb3RlY3RlZCIsInJlYWRPbmx5Il0pO3RoaXMuYWNjZXNzS2V5PWUuYWNjZXNzS2V5fHwiIjt0aGlzLmFuY2hvclR5cGU9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuYW5jaG9yVHlwZSxbInRvcExlZnQiLCJib3R0b21DZW50ZXIiLCJib3R0b21MZWZ0IiwiYm90dG9tUmlnaHQiLCJtaWRkbGVDZW50ZXIiLCJtaWRkbGVMZWZ0IiwibWlkZGxlUmlnaHQiLCJ0b3BDZW50ZXIiLCJ0b3BSaWdodCJdKTt0aGlzLmNvbFNwYW49KDAsby5nZXRJbnRlZ2VyKSh7ZGF0YTplLmNvbFNwYW4sZGVmYXVsdFZhbHVlOjEsdmFsaWRhdGU6ZT0+ZT49MXx8LTE9PT1lfSk7dGhpcy5oPWUuaD8oMCxvLmdldE1lYXN1cmVtZW50KShlLmgpOiIiO3RoaXMuaEFsaWduPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLmhBbGlnbixbImxlZnQiLCJjZW50ZXIiLCJqdXN0aWZ5IiwianVzdGlmeUFsbCIsInJhZGl4IiwicmlnaHQiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmxheW91dD0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5sYXlvdXQsWyJwb3NpdGlvbiIsImxyLXRiIiwicmwtcm93IiwicmwtdGIiLCJyb3ciLCJ0YWJsZSIsInRiIl0pO3RoaXMubWF4SD0oMCxvLmdldE1lYXN1cmVtZW50KShlLm1heEgsIjBwdCIpO3RoaXMubWF4Vz0oMCxvLmdldE1lYXN1cmVtZW50KShlLm1heFcsIjBwdCIpO3RoaXMubWluSD0oMCxvLmdldE1lYXN1cmVtZW50KShlLm1pbkgsIjBwdCIpO3RoaXMubWluVz0oMCxvLmdldE1lYXN1cmVtZW50KShlLm1pblcsIjBwdCIpO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMucHJlc2VuY2U9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUucHJlc2VuY2UsWyJ2aXNpYmxlIiwiaGlkZGVuIiwiaW5hY3RpdmUiLCJpbnZpc2libGUiXSk7dGhpcy5yZWxldmFudD0oMCxvLmdldFJlbGV2YW50KShlLnJlbGV2YW50KTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy53PWUudz8oMCxvLmdldE1lYXN1cmVtZW50KShlLncpOiIiO3RoaXMueD0oMCxvLmdldE1lYXN1cmVtZW50KShlLngsIjBwdCIpO3RoaXMueT0oMCxvLmdldE1lYXN1cmVtZW50KShlLnksIjBwdCIpO3RoaXMuYXNzaXN0PW51bGw7dGhpcy5iaW5kPW51bGw7dGhpcy5ib3JkZXI9bnVsbDt0aGlzLmNhbGN1bGF0ZT1udWxsO3RoaXMuY2FwdGlvbj1udWxsO3RoaXMuZGVzYz1udWxsO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5tYXJnaW49bnVsbDt0aGlzLnBhcmE9bnVsbDt0aGlzLnRyYXZlcnNhbD1udWxsO3RoaXMudmFsaWRhdGU9bnVsbDt0aGlzLmNvbm5lY3Q9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5ldmVudD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmZpZWxkPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuc2V0UHJvcGVydHk9bmV3IHIuWEZBT2JqZWN0QXJyYXl9W3IuJGlzQmluZGFibGVdKCl7cmV0dXJuITB9W3IuJGhhc1NldHRhYmxlVmFsdWVdKCl7cmV0dXJuITB9W3IuJHNldFZhbHVlXShlKXtmb3IoY29uc3QgdCBvZiB0aGlzLmZpZWxkLmNoaWxkcmVuKXtpZighdC52YWx1ZSl7Y29uc3QgZT1uZXcgVmFsdWUoe30pO3Rbci4kYXBwZW5kQ2hpbGRdKGUpO3QudmFsdWU9ZX10LnZhbHVlW3IuJHNldFZhbHVlXShlKX19W3IuJGlzVGhlcmVNb3JlV2lkdGhdKCl7cmV0dXJuIHRoaXMubGF5b3V0LmVuZHNXaXRoKCItdGIiKSYmMD09PXRoaXNbci4kZXh0cmFdLmF0dGVtcHQmJnRoaXNbci4kZXh0cmFdLm51bWJlckluTGluZT4wfHx0aGlzW3IuJGdldFBhcmVudF0oKVtyLiRpc1RoZXJlTW9yZVdpZHRoXSgpfVtyLiRpc1NwbGl0dGFibGVdKCl7Y29uc3QgZT10aGlzW3IuJGdldFN1YmZvcm1QYXJlbnRdKCk7aWYoIWVbci4kaXNTcGxpdHRhYmxlXSgpKXJldHVybiExO2lmKHZvaWQgMCE9PXRoaXNbci4kZXh0cmFdLl9pc1NwbGl0dGFibGUpcmV0dXJuIHRoaXNbci4kZXh0cmFdLl9pc1NwbGl0dGFibGU7aWYoInBvc2l0aW9uIj09PXRoaXMubGF5b3V0fHx0aGlzLmxheW91dC5pbmNsdWRlcygicm93Iikpe3RoaXNbci4kZXh0cmFdLl9pc1NwbGl0dGFibGU9ITE7cmV0dXJuITF9aWYoZS5sYXlvdXQmJmUubGF5b3V0LmVuZHNXaXRoKCItdGIiKSYmMCE9PWVbci4kZXh0cmFdLm51bWJlckluTGluZSlyZXR1cm4hMTt0aGlzW3IuJGV4dHJhXS5faXNTcGxpdHRhYmxlPSEwO3JldHVybiEwfVtyLiRmbHVzaEhUTUxdKCl7cmV0dXJuKDAsaS5mbHVzaEhUTUwpKHRoaXMpfVtyLiRhZGRIVE1MXShlLHQpeygwLGkuYWRkSFRNTCkodGhpcyxlLHQpfVtyLiRnZXRBdmFpbGFibGVTcGFjZV0oKXtyZXR1cm4oMCxpLmdldEF2YWlsYWJsZVNwYWNlKSh0aGlzKX1bci4kdG9IVE1MXShlKXtzZXRUYWJJbmRleCh0aGlzKTtpZigiaGlkZGVuIj09PXRoaXMucHJlc2VuY2V8fCJpbmFjdGl2ZSI9PT10aGlzLnByZXNlbmNlfHwwPT09dGhpcy5ofHwwPT09dGhpcy53KXJldHVybiBvLkhUTUxSZXN1bHQuRU1QVFk7KDAscy5maXhEaW1lbnNpb25zKSh0aGlzKTtjb25zdCB0PVtdLGE9e2lkOnRoaXNbci4kdWlkXSxjbGFzczpbXX07KDAscy5zZXRBY2Nlc3MpKHRoaXMsYS5jbGFzcyk7dGhpc1tyLiRleHRyYV18fCh0aGlzW3IuJGV4dHJhXT1PYmplY3QuY3JlYXRlKG51bGwpKTtPYmplY3QuYXNzaWduKHRoaXNbci4kZXh0cmFdLHtjaGlsZHJlbjp0LGF0dHJpYnV0ZXM6YSxhdHRlbXB0OjAsbGluZTpudWxsLG51bWJlckluTGluZTowLGF2YWlsYWJsZVNwYWNlOnt3aWR0aDpNYXRoLm1pbih0aGlzLnd8fDEvMCxlLndpZHRoKSxoZWlnaHQ6TWF0aC5taW4odGhpcy5ofHwxLzAsZS5oZWlnaHQpfSx3aWR0aDowLGhlaWdodDowLHByZXZIZWlnaHQ6MCxjdXJyZW50V2lkdGg6MH0pO2NvbnN0IG49dGhpc1tyLiRpc1NwbGl0dGFibGVdKCk7bnx8c2V0Rmlyc3RVbnNwbGl0dGFibGUodGhpcyk7aWYoISgwLGkuY2hlY2tEaW1lbnNpb25zKSh0aGlzLGUpKXJldHVybiBvLkhUTUxSZXN1bHQuRkFJTFVSRTtjb25zdCBjPW5ldyBTZXQoWyJmaWVsZCJdKTtpZih0aGlzLmxheW91dC5pbmNsdWRlcygicm93Iikpe2NvbnN0IGU9dGhpc1tyLiRnZXRTdWJmb3JtUGFyZW50XSgpLmNvbHVtbldpZHRocztpZihBcnJheS5pc0FycmF5KGUpJiZlLmxlbmd0aD4wKXt0aGlzW3IuJGV4dHJhXS5jb2x1bW5XaWR0aHM9ZTt0aGlzW3IuJGV4dHJhXS5jdXJyZW50Q29sdW1uPTB9fWNvbnN0IGw9KDAscy50b1N0eWxlKSh0aGlzLCJhbmNob3JUeXBlIiwiZGltZW5zaW9ucyIsInBvc2l0aW9uIiwicHJlc2VuY2UiLCJib3JkZXIiLCJtYXJnaW4iLCJoQWxpZ24iKSxoPVsieGZhRXhjbGdyb3VwIl0sdT0oMCxzLmxheW91dENsYXNzKSh0aGlzKTt1JiZoLnB1c2godSk7KDAscy5pc1ByaW50T25seSkodGhpcykmJmgucHVzaCgieGZhUHJpbnRPbmx5Iik7YS5zdHlsZT1sO2EuY2xhc3M9aDt0aGlzLm5hbWUmJihhLnhmYU5hbWU9dGhpcy5uYW1lKTt0aGlzW3IuJHB1c2hQYXJhXSgpO2NvbnN0IGQ9ImxyLXRiIj09PXRoaXMubGF5b3V0fHwicmwtdGIiPT09dGhpcy5sYXlvdXQsZj1kPzI6MTtmb3IoO3RoaXNbci4kZXh0cmFdLmF0dGVtcHQ8Zjt0aGlzW3IuJGV4dHJhXS5hdHRlbXB0Kyspe2QmJjE9PT10aGlzW3IuJGV4dHJhXS5hdHRlbXB0JiYodGhpc1tyLiRleHRyYV0ubnVtYmVySW5MaW5lPTApO2NvbnN0IGU9dGhpc1tyLiRjaGlsZHJlblRvSFRNTF0oe2ZpbHRlcjpjLGluY2x1ZGU6ITB9KTtpZihlLnN1Y2Nlc3MpYnJlYWs7aWYoZS5pc0JyZWFrKCkpe3RoaXNbci4kcG9wUGFyYV0oKTtyZXR1cm4gZX1pZihkJiYwPT09dGhpc1tyLiRleHRyYV0uYXR0ZW1wdCYmMD09PXRoaXNbci4kZXh0cmFdLm51bWJlckluTGluZSYmIXRoaXNbci4kZ2V0VGVtcGxhdGVSb290XSgpW3IuJGV4dHJhXS5ub0xheW91dEZhaWx1cmUpe3RoaXNbci4kZXh0cmFdLmF0dGVtcHQ9ZjticmVha319dGhpc1tyLiRwb3BQYXJhXSgpO258fHVuc2V0Rmlyc3RVbnNwbGl0dGFibGUodGhpcyk7aWYodGhpc1tyLiRleHRyYV0uYXR0ZW1wdD09PWYpe258fGRlbGV0ZSB0aGlzW3IuJGV4dHJhXTtyZXR1cm4gby5IVE1MUmVzdWx0LkZBSUxVUkV9bGV0IGc9MCxwPTA7aWYodGhpcy5tYXJnaW4pe2c9dGhpcy5tYXJnaW4ubGVmdEluc2V0K3RoaXMubWFyZ2luLnJpZ2h0SW5zZXQ7cD10aGlzLm1hcmdpbi50b3BJbnNldCt0aGlzLm1hcmdpbi5ib3R0b21JbnNldH1jb25zdCBtPU1hdGgubWF4KHRoaXNbci4kZXh0cmFdLndpZHRoK2csdGhpcy53fHwwKSxiPU1hdGgubWF4KHRoaXNbci4kZXh0cmFdLmhlaWdodCtwLHRoaXMuaHx8MCkseT1bdGhpcy54LHRoaXMueSxtLGJdOyIiPT09dGhpcy53JiYobC53aWR0aD0oMCxzLm1lYXN1cmVUb1N0cmluZykobSkpOyIiPT09dGhpcy5oJiYobC5oZWlnaHQ9KDAscy5tZWFzdXJlVG9TdHJpbmcpKGIpKTtjb25zdCB3PXtuYW1lOiJkaXYiLGF0dHJpYnV0ZXM6YSxjaGlsZHJlbjp0fTthcHBseUFzc2lzdCh0aGlzLGEpO2RlbGV0ZSB0aGlzW3IuJGV4dHJhXTtyZXR1cm4gby5IVE1MUmVzdWx0LnN1Y2Nlc3MoKDAscy5jcmVhdGVXcmFwcGVyKSh0aGlzLHcpLHkpfX1jbGFzcyBFeGVjdXRlIGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwiZXhlY3V0ZSIpO3RoaXMuY29ubmVjdGlvbj1lLmNvbm5lY3Rpb258fCIiO3RoaXMuZXhlY3V0ZVR5cGU9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuZXhlY3V0ZVR5cGUsWyJpbXBvcnQiLCJyZW1lcmdlIl0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5ydW5BdD0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5ydW5BdCxbImNsaWVudCIsImJvdGgiLCJzZXJ2ZXIiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBFeHRyYXMgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJleHRyYXMiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmJvb2xlYW49bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5kYXRlPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuZGF0ZVRpbWU9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5kZWNpbWFsPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuZXhEYXRhPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuZXh0cmFzPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuZmxvYXQ9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5pbWFnZT1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmludGVnZXI9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy50ZXh0PW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMudGltZT1uZXcgci5YRkFPYmplY3RBcnJheX19Y2xhc3MgRmllbGQgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJmaWVsZCIsITApO3RoaXMuYWNjZXNzPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLmFjY2VzcyxbIm9wZW4iLCJub25JbnRlcmFjdGl2ZSIsInByb3RlY3RlZCIsInJlYWRPbmx5Il0pO3RoaXMuYWNjZXNzS2V5PWUuYWNjZXNzS2V5fHwiIjt0aGlzLmFuY2hvclR5cGU9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuYW5jaG9yVHlwZSxbInRvcExlZnQiLCJib3R0b21DZW50ZXIiLCJib3R0b21MZWZ0IiwiYm90dG9tUmlnaHQiLCJtaWRkbGVDZW50ZXIiLCJtaWRkbGVMZWZ0IiwibWlkZGxlUmlnaHQiLCJ0b3BDZW50ZXIiLCJ0b3BSaWdodCJdKTt0aGlzLmNvbFNwYW49KDAsby5nZXRJbnRlZ2VyKSh7ZGF0YTplLmNvbFNwYW4sZGVmYXVsdFZhbHVlOjEsdmFsaWRhdGU6ZT0+ZT49MXx8LTE9PT1lfSk7dGhpcy5oPWUuaD8oMCxvLmdldE1lYXN1cmVtZW50KShlLmgpOiIiO3RoaXMuaEFsaWduPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLmhBbGlnbixbImxlZnQiLCJjZW50ZXIiLCJqdXN0aWZ5IiwianVzdGlmeUFsbCIsInJhZGl4IiwicmlnaHQiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmxvY2FsZT1lLmxvY2FsZXx8IiI7dGhpcy5tYXhIPSgwLG8uZ2V0TWVhc3VyZW1lbnQpKGUubWF4SCwiMHB0Iik7dGhpcy5tYXhXPSgwLG8uZ2V0TWVhc3VyZW1lbnQpKGUubWF4VywiMHB0Iik7dGhpcy5taW5IPSgwLG8uZ2V0TWVhc3VyZW1lbnQpKGUubWluSCwiMHB0Iik7dGhpcy5taW5XPSgwLG8uZ2V0TWVhc3VyZW1lbnQpKGUubWluVywiMHB0Iik7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy5wcmVzZW5jZT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5wcmVzZW5jZSxbInZpc2libGUiLCJoaWRkZW4iLCJpbmFjdGl2ZSIsImludmlzaWJsZSJdKTt0aGlzLnJlbGV2YW50PSgwLG8uZ2V0UmVsZXZhbnQpKGUucmVsZXZhbnQpO3RoaXMucm90YXRlPSgwLG8uZ2V0SW50ZWdlcikoe2RhdGE6ZS5yb3RhdGUsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+ZSU5MD09MH0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLnc9ZS53PygwLG8uZ2V0TWVhc3VyZW1lbnQpKGUudyk6IiI7dGhpcy54PSgwLG8uZ2V0TWVhc3VyZW1lbnQpKGUueCwiMHB0Iik7dGhpcy55PSgwLG8uZ2V0TWVhc3VyZW1lbnQpKGUueSwiMHB0Iik7dGhpcy5hc3Npc3Q9bnVsbDt0aGlzLmJpbmQ9bnVsbDt0aGlzLmJvcmRlcj1udWxsO3RoaXMuY2FsY3VsYXRlPW51bGw7dGhpcy5jYXB0aW9uPW51bGw7dGhpcy5kZXNjPW51bGw7dGhpcy5leHRyYXM9bnVsbDt0aGlzLmZvbnQ9bnVsbDt0aGlzLmZvcm1hdD1udWxsO3RoaXMuaXRlbXM9bmV3IHIuWEZBT2JqZWN0QXJyYXkoMik7dGhpcy5rZWVwPW51bGw7dGhpcy5tYXJnaW49bnVsbDt0aGlzLnBhcmE9bnVsbDt0aGlzLnRyYXZlcnNhbD1udWxsO3RoaXMudWk9bnVsbDt0aGlzLnZhbGlkYXRlPW51bGw7dGhpcy52YWx1ZT1udWxsO3RoaXMuYmluZEl0ZW1zPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuY29ubmVjdD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmV2ZW50PW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuc2V0UHJvcGVydHk9bmV3IHIuWEZBT2JqZWN0QXJyYXl9W3IuJGlzQmluZGFibGVdKCl7cmV0dXJuITB9W3IuJHNldFZhbHVlXShlKXtfc2V0VmFsdWUodGhpcyxlKX1bci4kdG9IVE1MXShlKXtzZXRUYWJJbmRleCh0aGlzKTtpZighdGhpcy51aSl7dGhpcy51aT1uZXcgVWkoe30pO3RoaXMudWlbci4kZ2xvYmFsRGF0YV09dGhpc1tyLiRnbG9iYWxEYXRhXTt0aGlzW3IuJGFwcGVuZENoaWxkXSh0aGlzLnVpKTtsZXQgZTtzd2l0Y2godGhpcy5pdGVtcy5jaGlsZHJlbi5sZW5ndGgpe2Nhc2UgMDplPW5ldyBUZXh0RWRpdCh7fSk7dGhpcy51aS50ZXh0RWRpdD1lO2JyZWFrO2Nhc2UgMTplPW5ldyBDaGVja0J1dHRvbih7fSk7dGhpcy51aS5jaGVja0J1dHRvbj1lO2JyZWFrO2Nhc2UgMjplPW5ldyBDaG9pY2VMaXN0KHt9KTt0aGlzLnVpLmNob2ljZUxpc3Q9ZX10aGlzLnVpW3IuJGFwcGVuZENoaWxkXShlKX1pZighdGhpcy51aXx8ImhpZGRlbiI9PT10aGlzLnByZXNlbmNlfHwiaW5hY3RpdmUiPT09dGhpcy5wcmVzZW5jZXx8MD09PXRoaXMuaHx8MD09PXRoaXMudylyZXR1cm4gby5IVE1MUmVzdWx0LkVNUFRZO3RoaXMuY2FwdGlvbiYmZGVsZXRlIHRoaXMuY2FwdGlvbltyLiRleHRyYV07dGhpc1tyLiRwdXNoUGFyYV0oKTtjb25zdCB0PXRoaXMuY2FwdGlvbj90aGlzLmNhcHRpb25bci4kdG9IVE1MXShlKS5odG1sOm51bGwsYT10aGlzLncsbj10aGlzLmg7bGV0IGM9MCxoPTA7aWYodGhpcy5tYXJnaW4pe2M9dGhpcy5tYXJnaW4ubGVmdEluc2V0K3RoaXMubWFyZ2luLnJpZ2h0SW5zZXQ7aD10aGlzLm1hcmdpbi50b3BJbnNldCt0aGlzLm1hcmdpbi5ib3R0b21JbnNldH1sZXQgdT1udWxsO2lmKCIiPT09dGhpcy53fHwiIj09PXRoaXMuaCl7bGV0IHQ9bnVsbCxhPW51bGwsbj0wLGk9MDtpZih0aGlzLnVpLmNoZWNrQnV0dG9uKW49aT10aGlzLnVpLmNoZWNrQnV0dG9uLnNpemU7ZWxzZXtjb25zdHt3OnQsaDphfT0oMCxzLmxheW91dE5vZGUpKHRoaXMsZSk7aWYobnVsbCE9PXQpe249dDtpPWF9ZWxzZSBpPSgwLGwuZ2V0TWV0cmljcykodGhpcy5mb250LCEwKS5saW5lTm9HYXB9dT1nZXRCb3JkZXJEaW1zKHRoaXMudWlbci4kZ2V0RXh0cmFdKCkpO24rPXUudztpKz11Lmg7aWYodGhpcy5jYXB0aW9uKXtjb25zdHt3OnMsaDpjLGlzQnJva2VuOmx9PXRoaXMuY2FwdGlvbltyLiRnZXRFeHRyYV0oZSk7aWYobCYmdGhpc1tyLiRnZXRTdWJmb3JtUGFyZW50XSgpW3IuJGlzVGhlcmVNb3JlV2lkdGhdKCkpe3RoaXNbci4kcG9wUGFyYV0oKTtyZXR1cm4gby5IVE1MUmVzdWx0LkZBSUxVUkV9dD1zO2E9Yztzd2l0Y2godGhpcy5jYXB0aW9uLnBsYWNlbWVudCl7Y2FzZSJsZWZ0IjpjYXNlInJpZ2h0IjpjYXNlImlubGluZSI6dCs9bjticmVhaztjYXNlInRvcCI6Y2FzZSJib3R0b20iOmErPWl9fWVsc2V7dD1uO2E9aX1pZih0JiYiIj09PXRoaXMudyl7dCs9Yzt0aGlzLnc9TWF0aC5taW4odGhpcy5tYXhXPD0wPzEvMDp0aGlzLm1heFcsdGhpcy5taW5XKzE8dD90OnRoaXMubWluVyl9aWYoYSYmIiI9PT10aGlzLmgpe2ErPWg7dGhpcy5oPU1hdGgubWluKHRoaXMubWF4SDw9MD8xLzA6dGhpcy5tYXhILHRoaXMubWluSCsxPGE/YTp0aGlzLm1pbkgpfX10aGlzW3IuJHBvcFBhcmFdKCk7KDAscy5maXhEaW1lbnNpb25zKSh0aGlzKTtzZXRGaXJzdFVuc3BsaXR0YWJsZSh0aGlzKTtpZighKDAsaS5jaGVja0RpbWVuc2lvbnMpKHRoaXMsZSkpe3RoaXMudz1hO3RoaXMuaD1uO3RoaXNbci4kcG9wUGFyYV0oKTtyZXR1cm4gby5IVE1MUmVzdWx0LkZBSUxVUkV9dW5zZXRGaXJzdFVuc3BsaXR0YWJsZSh0aGlzKTtjb25zdCBkPSgwLHMudG9TdHlsZSkodGhpcywiZm9udCIsImRpbWVuc2lvbnMiLCJwb3NpdGlvbiIsInJvdGF0ZSIsImFuY2hvclR5cGUiLCJwcmVzZW5jZSIsIm1hcmdpbiIsImhBbGlnbiIpOygwLHMuc2V0TWluTWF4RGltZW5zaW9ucykodGhpcyxkKTtjb25zdCBmPVsieGZhRmllbGQiXTt0aGlzLmZvbnQmJmYucHVzaCgieGZhRm9udCIpOygwLHMuaXNQcmludE9ubHkpKHRoaXMpJiZmLnB1c2goInhmYVByaW50T25seSIpO2NvbnN0IGc9e3N0eWxlOmQsaWQ6dGhpc1tyLiR1aWRdLGNsYXNzOmZ9O2lmKGQubWFyZ2luKXtkLnBhZGRpbmc9ZC5tYXJnaW47ZGVsZXRlIGQubWFyZ2lufSgwLHMuc2V0QWNjZXNzKSh0aGlzLGYpO3RoaXMubmFtZSYmKGcueGZhTmFtZT10aGlzLm5hbWUpO2NvbnN0IHA9W10sbT17bmFtZToiZGl2IixhdHRyaWJ1dGVzOmcsY2hpbGRyZW46cH07YXBwbHlBc3Npc3QodGhpcyxnKTtjb25zdCBiPXRoaXMuYm9yZGVyP3RoaXMuYm9yZGVyW3IuJHRvU3R5bGVdKCk6bnVsbCx5PSgwLHMuY29tcHV0ZUJib3gpKHRoaXMsbSxlKSx3PXRoaXMudWlbci4kdG9IVE1MXSgpLmh0bWw7aWYoIXcpe09iamVjdC5hc3NpZ24oZCxiKTtyZXR1cm4gby5IVE1MUmVzdWx0LnN1Y2Nlc3MoKDAscy5jcmVhdGVXcmFwcGVyKSh0aGlzLG0pLHkpfXRoaXNbci4kdGFiSW5kZXhdJiYody5jaGlsZHJlbiYmdy5jaGlsZHJlblswXT93LmNoaWxkcmVuWzBdLmF0dHJpYnV0ZXMudGFiaW5kZXg9dGhpc1tyLiR0YWJJbmRleF06dy5hdHRyaWJ1dGVzLnRhYmluZGV4PXRoaXNbci4kdGFiSW5kZXhdKTt3LmF0dHJpYnV0ZXMuc3R5bGV8fCh3LmF0dHJpYnV0ZXMuc3R5bGU9T2JqZWN0LmNyZWF0ZShudWxsKSk7bGV0IFM9bnVsbDtpZih0aGlzLnVpLmJ1dHRvbil7MT09PXcuY2hpbGRyZW4ubGVuZ3RoJiYoW1NdPXcuY2hpbGRyZW4uc3BsaWNlKDAsMSkpO09iamVjdC5hc3NpZ24ody5hdHRyaWJ1dGVzLnN0eWxlLGIpfWVsc2UgT2JqZWN0LmFzc2lnbihkLGIpO3AucHVzaCh3KTtpZih0aGlzLnZhbHVlKWlmKHRoaXMudWkuaW1hZ2VFZGl0KXcuY2hpbGRyZW4ucHVzaCh0aGlzLnZhbHVlW3IuJHRvSFRNTF0oKS5odG1sKTtlbHNlIGlmKCF0aGlzLnVpLmJ1dHRvbil7bGV0IGU9IiI7aWYodGhpcy52YWx1ZS5leERhdGEpZT10aGlzLnZhbHVlLmV4RGF0YVtyLiR0ZXh0XSgpO2Vsc2UgaWYodGhpcy52YWx1ZS50ZXh0KWU9dGhpcy52YWx1ZS50ZXh0W3IuJGdldEV4dHJhXSgpO2Vsc2V7Y29uc3QgdD10aGlzLnZhbHVlW3IuJHRvSFRNTF0oKS5odG1sO251bGwhPT10JiYoZT10LmNoaWxkcmVuWzBdLnZhbHVlKX10aGlzLnVpLnRleHRFZGl0JiZ0aGlzLnZhbHVlLnRleHQmJnRoaXMudmFsdWUudGV4dC5tYXhDaGFycyYmKHcuY2hpbGRyZW5bMF0uYXR0cmlidXRlcy5tYXhMZW5ndGg9dGhpcy52YWx1ZS50ZXh0Lm1heENoYXJzKTtpZihlKXtpZih0aGlzLnVpLm51bWVyaWNFZGl0KXtlPXBhcnNlRmxvYXQoZSk7ZT1pc05hTihlKT8iIjplLnRvU3RyaW5nKCl9InRleHRhcmVhIj09PXcuY2hpbGRyZW5bMF0ubmFtZT93LmNoaWxkcmVuWzBdLmF0dHJpYnV0ZXMudGV4dENvbnRlbnQ9ZTp3LmNoaWxkcmVuWzBdLmF0dHJpYnV0ZXMudmFsdWU9ZX19aWYoIXRoaXMudWkuaW1hZ2VFZGl0JiZ3LmNoaWxkcmVuJiZ3LmNoaWxkcmVuWzBdJiZ0aGlzLmgpe3U9dXx8Z2V0Qm9yZGVyRGltcyh0aGlzLnVpW3IuJGdldEV4dHJhXSgpKTtsZXQgdD0wO2lmKHRoaXMuY2FwdGlvbiYmWyJ0b3AiLCJib3R0b20iXS5pbmNsdWRlcyh0aGlzLmNhcHRpb24ucGxhY2VtZW50KSl7dD10aGlzLmNhcHRpb24ucmVzZXJ2ZTt0PD0wJiYodD10aGlzLmNhcHRpb25bci4kZ2V0RXh0cmFdKGUpLmgpO2NvbnN0IGE9dGhpcy5oLXQtaC11Lmg7dy5jaGlsZHJlblswXS5hdHRyaWJ1dGVzLnN0eWxlLmhlaWdodD0oMCxzLm1lYXN1cmVUb1N0cmluZykoYSl9ZWxzZSB3LmNoaWxkcmVuWzBdLmF0dHJpYnV0ZXMuc3R5bGUuaGVpZ2h0PSIxMDAlIn1TJiZ3LmNoaWxkcmVuLnB1c2goUyk7aWYoIXQpe3cuYXR0cmlidXRlcy5jbGFzcyYmdy5hdHRyaWJ1dGVzLmNsYXNzLnB1c2goInhmYUxlZnQiKTt0aGlzLnc9YTt0aGlzLmg9bjtyZXR1cm4gby5IVE1MUmVzdWx0LnN1Y2Nlc3MoKDAscy5jcmVhdGVXcmFwcGVyKSh0aGlzLG0pLHkpfWlmKHRoaXMudWkuYnV0dG9uKXtkLnBhZGRpbmcmJmRlbGV0ZSBkLnBhZGRpbmc7ImRpdiI9PT10Lm5hbWUmJih0Lm5hbWU9InNwYW4iKTt3LmNoaWxkcmVuLnB1c2godCk7cmV0dXJuIG8uSFRNTFJlc3VsdC5zdWNjZXNzKG0seSl9dGhpcy51aS5jaGVja0J1dHRvbiYmKHQuYXR0cmlidXRlcy5jbGFzc1swXT0ieGZhQ2FwdGlvbkZvckNoZWNrQnV0dG9uIik7dy5hdHRyaWJ1dGVzLmNsYXNzfHwody5hdHRyaWJ1dGVzLmNsYXNzPVtdKTt3LmNoaWxkcmVuLnNwbGljZSgwLDAsdCk7c3dpdGNoKHRoaXMuY2FwdGlvbi5wbGFjZW1lbnQpe2Nhc2UibGVmdCI6Y2FzZSJpbmxpbmUiOncuYXR0cmlidXRlcy5jbGFzcy5wdXNoKCJ4ZmFMZWZ0Iik7YnJlYWs7Y2FzZSJyaWdodCI6dy5hdHRyaWJ1dGVzLmNsYXNzLnB1c2goInhmYVJpZ2h0Iik7YnJlYWs7Y2FzZSJ0b3AiOncuYXR0cmlidXRlcy5jbGFzcy5wdXNoKCJ4ZmFUb3AiKTticmVhaztjYXNlImJvdHRvbSI6dy5hdHRyaWJ1dGVzLmNsYXNzLnB1c2goInhmYUJvdHRvbSIpfXRoaXMudz1hO3RoaXMuaD1uO3JldHVybiBvLkhUTUxSZXN1bHQuc3VjY2VzcygoMCxzLmNyZWF0ZVdyYXBwZXIpKHRoaXMsbSkseSl9fXQuRmllbGQ9RmllbGQ7Y2xhc3MgRmlsbCBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImZpbGwiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMucHJlc2VuY2U9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUucHJlc2VuY2UsWyJ2aXNpYmxlIiwiaGlkZGVuIiwiaW5hY3RpdmUiLCJpbnZpc2libGUiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuY29sb3I9bnVsbDt0aGlzLmV4dHJhcz1udWxsO3RoaXMubGluZWFyPW51bGw7dGhpcy5wYXR0ZXJuPW51bGw7dGhpcy5yYWRpYWw9bnVsbDt0aGlzLnNvbGlkPW51bGw7dGhpcy5zdGlwcGxlPW51bGx9W3IuJHRvU3R5bGVdKCl7Y29uc3QgZT10aGlzW3IuJGdldFBhcmVudF0oKSx0PWVbci4kZ2V0UGFyZW50XSgpW3IuJGdldFBhcmVudF0oKSxhPU9iamVjdC5jcmVhdGUobnVsbCk7bGV0IG49ImNvbG9yIixpPW47aWYoZSBpbnN0YW5jZW9mIEJvcmRlcil7bj0iYmFja2dyb3VuZC1jb2xvciI7aT0iYmFja2dyb3VuZCI7dCBpbnN0YW5jZW9mIFVpJiYoYS5iYWNrZ3JvdW5kQ29sb3I9IndoaXRlIil9aWYoZSBpbnN0YW5jZW9mIFJlY3RhbmdsZXx8ZSBpbnN0YW5jZW9mIEFyYyl7bj1pPSJmaWxsIjthLmZpbGw9IndoaXRlIn1mb3IoY29uc3QgZSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSl7aWYoImV4dHJhcyI9PT1lfHwiY29sb3IiPT09ZSljb250aW51ZTtjb25zdCB0PXRoaXNbZV07aWYoISh0IGluc3RhbmNlb2Ygci5YRkFPYmplY3QpKWNvbnRpbnVlO2NvbnN0IHM9dFtyLiR0b1N0eWxlXSh0aGlzLmNvbG9yKTtzJiYoYVtzLnN0YXJ0c1dpdGgoIiMiKT9uOmldPXMpO3JldHVybiBhfWlmKHRoaXMuY29sb3ImJnRoaXMuY29sb3IudmFsdWUpe2NvbnN0IGU9dGhpcy5jb2xvcltyLiR0b1N0eWxlXSgpO2FbZS5zdGFydHNXaXRoKCIjIik/bjppXT1lfXJldHVybiBhfX1jbGFzcyBGaWx0ZXIgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJmaWx0ZXIiLCEwKTt0aGlzLmFkZFJldm9jYXRpb25JbmZvPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLmFkZFJldm9jYXRpb25JbmZvLFsiIiwicmVxdWlyZWQiLCJvcHRpb25hbCIsIm5vbmUiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy52ZXJzaW9uPSgwLG8uZ2V0SW50ZWdlcikoe2RhdGE6dGhpcy52ZXJzaW9uLGRlZmF1bHRWYWx1ZTo1LHZhbGlkYXRlOmU9PmU+PTEmJmU8PTV9KTt0aGlzLmFwcGVhcmFuY2VGaWx0ZXI9bnVsbDt0aGlzLmNlcnRpZmljYXRlcz1udWxsO3RoaXMuZGlnZXN0TWV0aG9kcz1udWxsO3RoaXMuZW5jb2RpbmdzPW51bGw7dGhpcy5lbmNyeXB0aW9uTWV0aG9kcz1udWxsO3RoaXMuaGFuZGxlcj1udWxsO3RoaXMubG9ja0RvY3VtZW50PW51bGw7dGhpcy5tZHA9bnVsbDt0aGlzLnJlYXNvbnM9bnVsbDt0aGlzLnRpbWVTdGFtcD1udWxsfX1jbGFzcyBGbG9hdCBleHRlbmRzIHIuQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJmbG9hdCIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifVtyLiRmaW5hbGl6ZV0oKXtjb25zdCBlPXBhcnNlRmxvYXQodGhpc1tyLiRjb250ZW50XS50cmltKCkpO3RoaXNbci4kY29udGVudF09aXNOYU4oZSk/bnVsbDplfVtyLiR0b0hUTUxdKGUpe3JldHVybiB2YWx1ZVRvSHRtbChudWxsIT09dGhpc1tyLiRjb250ZW50XT90aGlzW3IuJGNvbnRlbnRdLnRvU3RyaW5nKCk6IiIpfX1jbGFzcyBGb250IGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwiZm9udCIsITApO3RoaXMuYmFzZWxpbmVTaGlmdD0oMCxvLmdldE1lYXN1cmVtZW50KShlLmJhc2VsaW5lU2hpZnQpO3RoaXMuZm9udEhvcml6b250YWxTY2FsZT0oMCxvLmdldEZsb2F0KSh7ZGF0YTplLmZvbnRIb3Jpem9udGFsU2NhbGUsZGVmYXVsdFZhbHVlOjEwMCx2YWxpZGF0ZTplPT5lPj0wfSk7dGhpcy5mb250VmVydGljYWxTY2FsZT0oMCxvLmdldEZsb2F0KSh7ZGF0YTplLmZvbnRWZXJ0aWNhbFNjYWxlLGRlZmF1bHRWYWx1ZToxMDAsdmFsaWRhdGU6ZT0+ZT49MH0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5rZXJuaW5nTW9kZT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5rZXJuaW5nTW9kZSxbIm5vbmUiLCJwYWlyIl0pO3RoaXMubGV0dGVyU3BhY2luZz0oMCxvLmdldE1lYXN1cmVtZW50KShlLmxldHRlclNwYWNpbmcsIjAiKTt0aGlzLmxpbmVUaHJvdWdoPSgwLG8uZ2V0SW50ZWdlcikoe2RhdGE6ZS5saW5lVGhyb3VnaCxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT4xPT09ZXx8Mj09PWV9KTt0aGlzLmxpbmVUaHJvdWdoUGVyaW9kPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLmxpbmVUaHJvdWdoUGVyaW9kLFsiYWxsIiwid29yZCJdKTt0aGlzLm92ZXJsaW5lPSgwLG8uZ2V0SW50ZWdlcikoe2RhdGE6ZS5vdmVybGluZSxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT4xPT09ZXx8Mj09PWV9KTt0aGlzLm92ZXJsaW5lUGVyaW9kPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLm92ZXJsaW5lUGVyaW9kLFsiYWxsIiwid29yZCJdKTt0aGlzLnBvc3R1cmU9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUucG9zdHVyZSxbIm5vcm1hbCIsIml0YWxpYyJdKTt0aGlzLnNpemU9KDAsby5nZXRNZWFzdXJlbWVudCkoZS5zaXplLCIxMHB0Iik7dGhpcy50eXBlZmFjZT1lLnR5cGVmYWNlfHwiQ291cmllciI7dGhpcy51bmRlcmxpbmU9KDAsby5nZXRJbnRlZ2VyKSh7ZGF0YTplLnVuZGVybGluZSxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT4xPT09ZXx8Mj09PWV9KTt0aGlzLnVuZGVybGluZVBlcmlvZD0oMCxvLmdldFN0cmluZ09wdGlvbikoZS51bmRlcmxpbmVQZXJpb2QsWyJhbGwiLCJ3b3JkIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLndlaWdodD0oMCxvLmdldFN0cmluZ09wdGlvbikoZS53ZWlnaHQsWyJub3JtYWwiLCJib2xkIl0pO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5maWxsPW51bGx9W3IuJGNsZWFuXShlKXtzdXBlcltyLiRjbGVhbl0oZSk7dGhpc1tyLiRnbG9iYWxEYXRhXS51c2VkVHlwZWZhY2VzLmFkZCh0aGlzLnR5cGVmYWNlKX1bci4kdG9TdHlsZV0oKXtjb25zdCBlPSgwLHMudG9TdHlsZSkodGhpcywiZmlsbCIpLHQ9ZS5jb2xvcjtpZih0KWlmKCIjMDAwMDAwIj09PXQpZGVsZXRlIGUuY29sb3I7ZWxzZSBpZighdC5zdGFydHNXaXRoKCIjIikpe2UuYmFja2dyb3VuZD10O2UuYmFja2dyb3VuZENsaXA9InRleHQiO2UuY29sb3I9InRyYW5zcGFyZW50In10aGlzLmJhc2VsaW5lU2hpZnQmJihlLnZlcnRpY2FsQWxpZ249KDAscy5tZWFzdXJlVG9TdHJpbmcpKHRoaXMuYmFzZWxpbmVTaGlmdCkpO2UuZm9udEtlcm5pbmc9Im5vbmUiPT09dGhpcy5rZXJuaW5nTW9kZT8ibm9uZSI6Im5vcm1hbCI7ZS5sZXR0ZXJTcGFjaW5nPSgwLHMubWVhc3VyZVRvU3RyaW5nKSh0aGlzLmxldHRlclNwYWNpbmcpO2lmKDAhPT10aGlzLmxpbmVUaHJvdWdoKXtlLnRleHREZWNvcmF0aW9uPSJsaW5lLXRocm91Z2giOzI9PT10aGlzLmxpbmVUaHJvdWdoJiYoZS50ZXh0RGVjb3JhdGlvblN0eWxlPSJkb3VibGUiKX1pZigwIT09dGhpcy5vdmVybGluZSl7ZS50ZXh0RGVjb3JhdGlvbj0ib3ZlcmxpbmUiOzI9PT10aGlzLm92ZXJsaW5lJiYoZS50ZXh0RGVjb3JhdGlvblN0eWxlPSJkb3VibGUiKX1lLmZvbnRTdHlsZT10aGlzLnBvc3R1cmU7ZS5mb250U2l6ZT0oMCxzLm1lYXN1cmVUb1N0cmluZykoLjk5KnRoaXMuc2l6ZSk7KDAscy5zZXRGb250RmFtaWx5KSh0aGlzLHRoaXMsdGhpc1tyLiRnbG9iYWxEYXRhXS5mb250RmluZGVyLGUpO2lmKDAhPT10aGlzLnVuZGVybGluZSl7ZS50ZXh0RGVjb3JhdGlvbj0idW5kZXJsaW5lIjsyPT09dGhpcy51bmRlcmxpbmUmJihlLnRleHREZWNvcmF0aW9uU3R5bGU9ImRvdWJsZSIpfWUuZm9udFdlaWdodD10aGlzLndlaWdodDtyZXR1cm4gZX19Y2xhc3MgRm9ybWF0IGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwiZm9ybWF0IiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbDt0aGlzLnBpY3R1cmU9bnVsbH19Y2xhc3MgSGFuZGxlciBleHRlbmRzIHIuU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImhhbmRsZXIiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS50eXBlLFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIEh5cGhlbmF0aW9uIGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwiaHlwaGVuYXRpb24iKTt0aGlzLmV4Y2x1ZGVBbGxDYXBzPSgwLG8uZ2V0SW50ZWdlcikoe2RhdGE6ZS5leGNsdWRlQWxsQ2FwcyxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT4xPT09ZX0pO3RoaXMuZXhjbHVkZUluaXRpYWxDYXA9KDAsby5nZXRJbnRlZ2VyKSh7ZGF0YTplLmV4Y2x1ZGVJbml0aWFsQ2FwLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy5oeXBoZW5hdGU9KDAsby5nZXRJbnRlZ2VyKSh7ZGF0YTplLmh5cGhlbmF0ZSxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT4xPT09ZX0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5wdXNoQ2hhcmFjdGVyQ291bnQ9KDAsby5nZXRJbnRlZ2VyKSh7ZGF0YTplLnB1c2hDaGFyYWN0ZXJDb3VudCxkZWZhdWx0VmFsdWU6Myx2YWxpZGF0ZTplPT5lPj0wfSk7dGhpcy5yZW1haW5DaGFyYWN0ZXJDb3VudD0oMCxvLmdldEludGVnZXIpKHtkYXRhOmUucmVtYWluQ2hhcmFjdGVyQ291bnQsZGVmYXVsdFZhbHVlOjMsdmFsaWRhdGU6ZT0+ZT49MH0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLndvcmRDaGFyYWN0ZXJDb3VudD0oMCxvLmdldEludGVnZXIpKHtkYXRhOmUud29yZENoYXJhY3RlckNvdW50LGRlZmF1bHRWYWx1ZTo3LHZhbGlkYXRlOmU9PmU+PTB9KX19Y2xhc3MgSW1hZ2UgZXh0ZW5kcyByLlN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJpbWFnZSIpO3RoaXMuYXNwZWN0PSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLmFzcGVjdCxbImZpdCIsImFjdHVhbCIsImhlaWdodCIsIm5vbmUiLCJ3aWR0aCJdKTt0aGlzLmNvbnRlbnRUeXBlPWUuY29udGVudFR5cGV8fCIiO3RoaXMuaHJlZj1lLmhyZWZ8fCIiO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy50cmFuc2ZlckVuY29kaW5nPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLnRyYW5zZmVyRW5jb2RpbmcsWyJiYXNlNjQiLCJub25lIiwicGFja2FnZSJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9W3IuJHRvSFRNTF0oKXtpZih0aGlzLmNvbnRlbnRUeXBlJiYhcC5oYXModGhpcy5jb250ZW50VHlwZS50b0xvd2VyQ2FzZSgpKSlyZXR1cm4gby5IVE1MUmVzdWx0LkVNUFRZO2xldCBlPXRoaXNbci4kZ2xvYmFsRGF0YV0uaW1hZ2VzJiZ0aGlzW3IuJGdsb2JhbERhdGFdLmltYWdlcy5nZXQodGhpcy5ocmVmKTtpZighZSYmKHRoaXMuaHJlZnx8IXRoaXNbci4kY29udGVudF0pKXJldHVybiBvLkhUTUxSZXN1bHQuRU1QVFk7ZXx8ImJhc2U2NCIhPT10aGlzLnRyYW5zZmVyRW5jb2Rpbmd8fChlPSgwLGMuc3RyaW5nVG9CeXRlcykoYXRvYih0aGlzW3IuJGNvbnRlbnRdKSkpO2lmKCFlKXJldHVybiBvLkhUTUxSZXN1bHQuRU1QVFk7aWYoIXRoaXMuY29udGVudFR5cGUpe2Zvcihjb25zdFt0LGFdb2YgbSlpZihlLmxlbmd0aD50Lmxlbmd0aCYmdC5ldmVyeSgoKHQsYSk9PnQ9PT1lW2FdKSkpe3RoaXMuY29udGVudFR5cGU9YTticmVha31pZighdGhpcy5jb250ZW50VHlwZSlyZXR1cm4gby5IVE1MUmVzdWx0LkVNUFRZfWNvbnN0IHQ9bmV3IEJsb2IoW2VdLHt0eXBlOnRoaXMuY29udGVudFR5cGV9KTtsZXQgYTtzd2l0Y2godGhpcy5hc3BlY3Qpe2Nhc2UiZml0IjpjYXNlImFjdHVhbCI6YnJlYWs7Y2FzZSJoZWlnaHQiOmE9e2hlaWdodDoiMTAwJSIsb2JqZWN0Rml0OiJmaWxsIn07YnJlYWs7Y2FzZSJub25lIjphPXt3aWR0aDoiMTAwJSIsaGVpZ2h0OiIxMDAlIixvYmplY3RGaXQ6ImZpbGwifTticmVhaztjYXNlIndpZHRoIjphPXt3aWR0aDoiMTAwJSIsb2JqZWN0Rml0OiJmaWxsIn19Y29uc3Qgbj10aGlzW3IuJGdldFBhcmVudF0oKTtyZXR1cm4gby5IVE1MUmVzdWx0LnN1Y2Nlc3Moe25hbWU6ImltZyIsYXR0cmlidXRlczp7Y2xhc3M6WyJ4ZmFJbWFnZSJdLHN0eWxlOmEsc3JjOlVSTC5jcmVhdGVPYmplY3RVUkwodCksYWx0Om4/YXJpYUxhYmVsKG5bci4kZ2V0UGFyZW50XSgpKTpudWxsfX0pfX1jbGFzcyBJbWFnZUVkaXQgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJpbWFnZUVkaXQiLCEwKTt0aGlzLmRhdGE9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuZGF0YSxbImxpbmsiLCJlbWJlZCJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmJvcmRlcj1udWxsO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5tYXJnaW49bnVsbH1bci4kdG9IVE1MXShlKXtyZXR1cm4iZW1iZWQiPT09dGhpcy5kYXRhP28uSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJkaXYiLGNoaWxkcmVuOltdLGF0dHJpYnV0ZXM6e319KTpvLkhUTUxSZXN1bHQuRU1QVFl9fWNsYXNzIEludGVnZXIgZXh0ZW5kcyByLkNvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwiaW50ZWdlciIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifVtyLiRmaW5hbGl6ZV0oKXtjb25zdCBlPXBhcnNlSW50KHRoaXNbci4kY29udGVudF0udHJpbSgpLDEwKTt0aGlzW3IuJGNvbnRlbnRdPWlzTmFOKGUpP251bGw6ZX1bci4kdG9IVE1MXShlKXtyZXR1cm4gdmFsdWVUb0h0bWwobnVsbCE9PXRoaXNbci4kY29udGVudF0/dGhpc1tyLiRjb250ZW50XS50b1N0cmluZygpOiIiKX19Y2xhc3MgSXNzdWVycyBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImlzc3VlcnMiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS50eXBlLFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5jZXJ0aWZpY2F0ZT1uZXcgci5YRkFPYmplY3RBcnJheX19Y2xhc3MgSXRlbXMgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJpdGVtcyIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy5wcmVzZW5jZT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5wcmVzZW5jZSxbInZpc2libGUiLCJoaWRkZW4iLCJpbmFjdGl2ZSIsImludmlzaWJsZSJdKTt0aGlzLnJlZj1lLnJlZnx8IiI7dGhpcy5zYXZlPSgwLG8uZ2V0SW50ZWdlcikoe2RhdGE6ZS5zYXZlLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuYm9vbGVhbj1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmRhdGU9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5kYXRlVGltZT1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmRlY2ltYWw9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5leERhdGE9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5mbG9hdD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmltYWdlPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuaW50ZWdlcj1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLnRleHQ9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy50aW1lPW5ldyByLlhGQU9iamVjdEFycmF5fVtyLiR0b0hUTUxdKCl7Y29uc3QgZT1bXTtmb3IoY29uc3QgdCBvZiB0aGlzW3IuJGdldENoaWxkcmVuXSgpKWUucHVzaCh0W3IuJHRleHRdKCkpO3JldHVybiBvLkhUTUxSZXN1bHQuc3VjY2VzcyhlKX19dC5JdGVtcz1JdGVtcztjbGFzcyBLZWVwIGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwia2VlcCIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7Y29uc3QgdD1bIm5vbmUiLCJjb250ZW50QXJlYSIsInBhZ2VBcmVhIl07dGhpcy5pbnRhY3Q9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuaW50YWN0LHQpO3RoaXMubmV4dD0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5uZXh0LHQpO3RoaXMucHJldmlvdXM9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUucHJldmlvdXMsdCk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZXh0cmFzPW51bGx9fWNsYXNzIEtleVVzYWdlIGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwia2V5VXNhZ2UiKTtjb25zdCB0PVsiIiwieWVzIiwibm8iXTt0aGlzLmNybFNpZ249KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuY3JsU2lnbix0KTt0aGlzLmRhdGFFbmNpcGhlcm1lbnQ9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuZGF0YUVuY2lwaGVybWVudCx0KTt0aGlzLmRlY2lwaGVyT25seT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5kZWNpcGhlck9ubHksdCk7dGhpcy5kaWdpdGFsU2lnbmF0dXJlPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLmRpZ2l0YWxTaWduYXR1cmUsdCk7dGhpcy5lbmNpcGhlck9ubHk9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuZW5jaXBoZXJPbmx5LHQpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5rZXlBZ3JlZW1lbnQ9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUua2V5QWdyZWVtZW50LHQpO3RoaXMua2V5Q2VydFNpZ249KDAsby5nZXRTdHJpbmdPcHRpb24pKGUua2V5Q2VydFNpZ24sdCk7dGhpcy5rZXlFbmNpcGhlcm1lbnQ9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUua2V5RW5jaXBoZXJtZW50LHQpO3RoaXMubm9uUmVwdWRpYXRpb249KDAsby5nZXRTdHJpbmdPcHRpb24pKGUubm9uUmVwdWRpYXRpb24sdCk7dGhpcy50eXBlPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLnR5cGUsWyJvcHRpb25hbCIsInJlcXVpcmVkIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgTGluZSBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImxpbmUiLCEwKTt0aGlzLmhhbmQ9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuaGFuZCxbImV2ZW4iLCJsZWZ0IiwicmlnaHQiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnNsb3BlPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLnNsb3BlLFsiXFwiLCIvIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmVkZ2U9bnVsbH1bci4kdG9IVE1MXSgpe2NvbnN0IGU9dGhpc1tyLiRnZXRQYXJlbnRdKClbci4kZ2V0UGFyZW50XSgpLHQ9dGhpcy5lZGdlfHxuZXcgRWRnZSh7fSksYT10W3IuJHRvU3R5bGVdKCksbj1PYmplY3QuY3JlYXRlKG51bGwpLGk9InZpc2libGUiPT09dC5wcmVzZW5jZT90LnRoaWNrbmVzczowO24uc3Ryb2tlV2lkdGg9KDAscy5tZWFzdXJlVG9TdHJpbmcpKGkpO24uc3Ryb2tlPWEuY29sb3I7bGV0IGMsbCxoLHUsZD0iMTAwJSIsZz0iMTAwJSI7aWYoZS53PD1pKXtbYyxsLGgsdV09WyI1MCUiLDAsIjUwJSIsIjEwMCUiXTtkPW4uc3Ryb2tlV2lkdGh9ZWxzZSBpZihlLmg8PWkpe1tjLGwsaCx1XT1bMCwiNTAlIiwiMTAwJSIsIjUwJSJdO2c9bi5zdHJva2VXaWR0aH1lbHNlIlxcIj09PXRoaXMuc2xvcGU/W2MsbCxoLHVdPVswLDAsIjEwMCUiLCIxMDAlIl06W2MsbCxoLHVdPVswLCIxMDAlIiwiMTAwJSIsMF07Y29uc3QgcD17bmFtZToic3ZnIixjaGlsZHJlbjpbe25hbWU6ImxpbmUiLGF0dHJpYnV0ZXM6e3htbG5zOmYseDE6Yyx5MTpsLHgyOmgseTI6dSxzdHlsZTpufX1dLGF0dHJpYnV0ZXM6e3htbG5zOmYsd2lkdGg6ZCxoZWlnaHQ6ZyxzdHlsZTp7b3ZlcmZsb3c6InZpc2libGUifX19O2lmKGhhc01hcmdpbihlKSlyZXR1cm4gby5IVE1MUmVzdWx0LnN1Y2Nlc3Moe25hbWU6ImRpdiIsYXR0cmlidXRlczp7c3R5bGU6e2Rpc3BsYXk6ImlubGluZSIsd2lkdGg6IjEwMCUiLGhlaWdodDoiMTAwJSJ9fSxjaGlsZHJlbjpbcF19KTtwLmF0dHJpYnV0ZXMuc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtyZXR1cm4gby5IVE1MUmVzdWx0LnN1Y2Nlc3MocCl9fWNsYXNzIExpbmVhciBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsImxpbmVhciIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy50eXBlPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLnR5cGUsWyJ0b1JpZ2h0IiwidG9Cb3R0b20iLCJ0b0xlZnQiLCJ0b1RvcCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5jb2xvcj1udWxsO3RoaXMuZXh0cmFzPW51bGx9W3IuJHRvU3R5bGVdKGUpe2U9ZT9lW3IuJHRvU3R5bGVdKCk6IiNGRkZGRkYiO3JldHVybmBsaW5lYXItZ3JhZGllbnQoJHt0aGlzLnR5cGUucmVwbGFjZSgvKFtSQkxUXSkvLCIgJDEiKS50b0xvd2VyQ2FzZSgpfSwgJHtlfSwgJHt0aGlzLmNvbG9yP3RoaXMuY29sb3Jbci4kdG9TdHlsZV0oKToiIzAwMDAwMCJ9KWB9fWNsYXNzIExvY2tEb2N1bWVudCBleHRlbmRzIHIuQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJsb2NrRG9jdW1lbnQiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS50eXBlLFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9W3IuJGZpbmFsaXplXSgpe3RoaXNbci4kY29udGVudF09KDAsby5nZXRTdHJpbmdPcHRpb24pKHRoaXNbci4kY29udGVudF0sWyJhdXRvIiwiMCIsIjEiXSl9fWNsYXNzIE1hbmlmZXN0IGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwibWFuaWZlc3QiLCEwKTt0aGlzLmFjdGlvbj0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5hY3Rpb24sWyJpbmNsdWRlIiwiYWxsIiwiZXhjbHVkZSJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmV4dHJhcz1udWxsO3RoaXMucmVmPW5ldyByLlhGQU9iamVjdEFycmF5fX1jbGFzcyBNYXJnaW4gZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJtYXJnaW4iLCEwKTt0aGlzLmJvdHRvbUluc2V0PSgwLG8uZ2V0TWVhc3VyZW1lbnQpKGUuYm90dG9tSW5zZXQsIjAiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubGVmdEluc2V0PSgwLG8uZ2V0TWVhc3VyZW1lbnQpKGUubGVmdEluc2V0LCIwIik7dGhpcy5yaWdodEluc2V0PSgwLG8uZ2V0TWVhc3VyZW1lbnQpKGUucmlnaHRJbnNldCwiMCIpO3RoaXMudG9wSW5zZXQ9KDAsby5nZXRNZWFzdXJlbWVudCkoZS50b3BJbnNldCwiMCIpO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmV4dHJhcz1udWxsfVtyLiR0b1N0eWxlXSgpe3JldHVybnttYXJnaW46KDAscy5tZWFzdXJlVG9TdHJpbmcpKHRoaXMudG9wSW5zZXQpKyIgIisoMCxzLm1lYXN1cmVUb1N0cmluZykodGhpcy5yaWdodEluc2V0KSsiICIrKDAscy5tZWFzdXJlVG9TdHJpbmcpKHRoaXMuYm90dG9tSW5zZXQpKyIgIisoMCxzLm1lYXN1cmVUb1N0cmluZykodGhpcy5sZWZ0SW5zZXQpfX19Y2xhc3MgTWRwIGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwibWRwIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnBlcm1pc3Npb25zPSgwLG8uZ2V0SW50ZWdlcikoe2RhdGE6ZS5wZXJtaXNzaW9ucyxkZWZhdWx0VmFsdWU6Mix2YWxpZGF0ZTplPT4xPT09ZXx8Mz09PWV9KTt0aGlzLnNpZ25hdHVyZVR5cGU9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuc2lnbmF0dXJlVHlwZSxbImZpbGxlciIsImF1dGhvciJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIE1lZGl1bSBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsIm1lZGl1bSIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5pbWFnaW5nQkJveD0oMCxvLmdldEJCb3gpKGUuaW1hZ2luZ0JCb3gpO3RoaXMubG9uZz0oMCxvLmdldE1lYXN1cmVtZW50KShlLmxvbmcpO3RoaXMub3JpZW50YXRpb249KDAsby5nZXRTdHJpbmdPcHRpb24pKGUub3JpZW50YXRpb24sWyJwb3J0cmFpdCIsImxhbmRzY2FwZSJdKTt0aGlzLnNob3J0PSgwLG8uZ2V0TWVhc3VyZW1lbnQpKGUuc2hvcnQpO3RoaXMuc3RvY2s9ZS5zdG9ja3x8IiI7dGhpcy50cmF5SW49KDAsby5nZXRTdHJpbmdPcHRpb24pKGUudHJheUluLFsiYXV0byIsImRlbGVnYXRlIiwicGFnZUZyb250Il0pO3RoaXMudHJheU91dD0oMCxvLmdldFN0cmluZ09wdGlvbikoZS50cmF5T3V0LFsiYXV0byIsImRlbGVnYXRlIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgTWVzc2FnZSBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsIm1lc3NhZ2UiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLnRleHQ9bmV3IHIuWEZBT2JqZWN0QXJyYXl9fWNsYXNzIE51bWVyaWNFZGl0IGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwibnVtZXJpY0VkaXQiLCEwKTt0aGlzLmhTY3JvbGxQb2xpY3k9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuaFNjcm9sbFBvbGljeSxbImF1dG8iLCJvZmYiLCJvbiJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmJvcmRlcj1udWxsO3RoaXMuY29tYj1udWxsO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5tYXJnaW49bnVsbH1bci4kdG9IVE1MXShlKXtjb25zdCB0PSgwLHMudG9TdHlsZSkodGhpcywiYm9yZGVyIiwiZm9udCIsIm1hcmdpbiIpLGE9dGhpc1tyLiRnZXRQYXJlbnRdKClbci4kZ2V0UGFyZW50XSgpLG49e25hbWU6ImlucHV0IixhdHRyaWJ1dGVzOnt0eXBlOiJ0ZXh0IixmaWVsZElkOmFbci4kdWlkXSxkYXRhSWQ6YVtyLiRkYXRhXSYmYVtyLiRkYXRhXVtyLiR1aWRdfHxhW3IuJHVpZF0sY2xhc3M6WyJ4ZmFUZXh0ZmllbGQiXSxzdHlsZTp0LCJhcmlhLWxhYmVsIjphcmlhTGFiZWwoYSksImFyaWEtcmVxdWlyZWQiOiExfX07aWYoaXNSZXF1aXJlZChhKSl7bi5hdHRyaWJ1dGVzWyJhcmlhLXJlcXVpcmVkIl09ITA7bi5hdHRyaWJ1dGVzLnJlcXVpcmVkPSEwfXJldHVybiBvLkhUTUxSZXN1bHQuc3VjY2Vzcyh7bmFtZToibGFiZWwiLGF0dHJpYnV0ZXM6e2NsYXNzOlsieGZhTGFiZWwiXX0sY2hpbGRyZW46W25dfSl9fWNsYXNzIE9jY3VyIGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwib2NjdXIiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMuaW5pdGlhbD0iIiE9PWUuaW5pdGlhbD8oMCxvLmdldEludGVnZXIpKHtkYXRhOmUuaW5pdGlhbCxkZWZhdWx0VmFsdWU6IiIsdmFsaWRhdGU6ZT0+ITB9KToiIjt0aGlzLm1heD0iIiE9PWUubWF4PygwLG8uZ2V0SW50ZWdlcikoe2RhdGE6ZS5tYXgsZGVmYXVsdFZhbHVlOjEsdmFsaWRhdGU6ZT0+ITB9KToiIjt0aGlzLm1pbj0iIiE9PWUubWluPygwLG8uZ2V0SW50ZWdlcikoe2RhdGE6ZS5taW4sZGVmYXVsdFZhbHVlOjEsdmFsaWRhdGU6ZT0+ITB9KToiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbH1bci4kY2xlYW5dKCl7Y29uc3QgZT10aGlzW3IuJGdldFBhcmVudF0oKSx0PXRoaXMubWluOyIiPT09dGhpcy5taW4mJih0aGlzLm1pbj1lIGluc3RhbmNlb2YgUGFnZUFyZWF8fGUgaW5zdGFuY2VvZiBQYWdlU2V0PzA6MSk7IiI9PT10aGlzLm1heCYmKHRoaXMubWF4PSIiPT09dD9lIGluc3RhbmNlb2YgUGFnZUFyZWF8fGUgaW5zdGFuY2VvZiBQYWdlU2V0Py0xOjE6dGhpcy5taW4pOy0xIT09dGhpcy5tYXgmJnRoaXMubWF4PHRoaXMubWluJiYodGhpcy5tYXg9dGhpcy5taW4pOyIiPT09dGhpcy5pbml0aWFsJiYodGhpcy5pbml0aWFsPWUgaW5zdGFuY2VvZiBUZW1wbGF0ZT8xOnRoaXMubWluKX19Y2xhc3MgT2lkIGV4dGVuZHMgci5TdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwib2lkIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIE9pZHMgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJvaWRzIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnR5cGU9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUudHlwZSxbIm9wdGlvbmFsIiwicmVxdWlyZWQiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMub2lkPW5ldyByLlhGQU9iamVjdEFycmF5fX1jbGFzcyBPdmVyZmxvdyBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsIm92ZXJmbG93Iik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmxlYWRlcj1lLmxlYWRlcnx8IiI7dGhpcy50YXJnZXQ9ZS50YXJnZXR8fCIiO3RoaXMudHJhaWxlcj1lLnRyYWlsZXJ8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn1bci4kZ2V0RXh0cmFdKCl7aWYoIXRoaXNbci4kZXh0cmFdKXtjb25zdCBlPXRoaXNbci4kZ2V0UGFyZW50XSgpLHQ9dGhpc1tyLiRnZXRUZW1wbGF0ZVJvb3RdKCksYT10W3IuJHNlYXJjaE5vZGVdKHRoaXMudGFyZ2V0LGUpLG49dFtyLiRzZWFyY2hOb2RlXSh0aGlzLmxlYWRlcixlKSxpPXRbci4kc2VhcmNoTm9kZV0odGhpcy50cmFpbGVyLGUpO3RoaXNbci4kZXh0cmFdPXt0YXJnZXQ6YSYmYVswXXx8bnVsbCxsZWFkZXI6biYmblswXXx8bnVsbCx0cmFpbGVyOmkmJmlbMF18fG51bGwsYWRkTGVhZGVyOiExLGFkZFRyYWlsZXI6ITF9fXJldHVybiB0aGlzW3IuJGV4dHJhXX19Y2xhc3MgUGFnZUFyZWEgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJwYWdlQXJlYSIsITApO3RoaXMuYmxhbmtPck5vdEJsYW5rPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLmJsYW5rT3JOb3RCbGFuayxbImFueSIsImJsYW5rIiwibm90QmxhbmsiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmluaXRpYWxOdW1iZXI9KDAsby5nZXRJbnRlZ2VyKSh7ZGF0YTplLmluaXRpYWxOdW1iZXIsZGVmYXVsdFZhbHVlOjEsdmFsaWRhdGU6ZT0+ITB9KTt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLm51bWJlcmVkPSgwLG8uZ2V0SW50ZWdlcikoe2RhdGE6ZS5udW1iZXJlZCxkZWZhdWx0VmFsdWU6MSx2YWxpZGF0ZTplPT4hMH0pO3RoaXMub2RkT3JFdmVuPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLm9kZE9yRXZlbixbImFueSIsImV2ZW4iLCJvZGQiXSk7dGhpcy5wYWdlUG9zaXRpb249KDAsby5nZXRTdHJpbmdPcHRpb24pKGUucGFnZVBvc2l0aW9uLFsiYW55IiwiZmlyc3QiLCJsYXN0Iiwib25seSIsInJlc3QiXSk7dGhpcy5yZWxldmFudD0oMCxvLmdldFJlbGV2YW50KShlLnJlbGV2YW50KTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5kZXNjPW51bGw7dGhpcy5leHRyYXM9bnVsbDt0aGlzLm1lZGl1bT1udWxsO3RoaXMub2NjdXI9bnVsbDt0aGlzLmFyZWE9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5jb250ZW50QXJlYT1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmRyYXc9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5leGNsR3JvdXA9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5maWVsZD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLnN1YmZvcm09bmV3IHIuWEZBT2JqZWN0QXJyYXl9W3IuJGlzVXNhYmxlXSgpe2lmKCF0aGlzW3IuJGV4dHJhXSl7dGhpc1tyLiRleHRyYV09e251bWJlck9mVXNlOjB9O3JldHVybiEwfXJldHVybiF0aGlzLm9jY3VyfHwtMT09PXRoaXMub2NjdXIubWF4fHx0aGlzW3IuJGV4dHJhXS5udW1iZXJPZlVzZTx0aGlzLm9jY3VyLm1heH1bci4kY2xlYW5QYWdlXSgpe2RlbGV0ZSB0aGlzW3IuJGV4dHJhXX1bci4kZ2V0TmV4dFBhZ2VdKCl7dGhpc1tyLiRleHRyYV18fCh0aGlzW3IuJGV4dHJhXT17bnVtYmVyT2ZVc2U6MH0pO2NvbnN0IGU9dGhpc1tyLiRnZXRQYXJlbnRdKCk7aWYoIm9yZGVyZWRPY2N1cnJlbmNlIj09PWUucmVsYXRpb24mJnRoaXNbci4kaXNVc2FibGVdKCkpe3RoaXNbci4kZXh0cmFdLm51bWJlck9mVXNlKz0xO3JldHVybiB0aGlzfXJldHVybiBlW3IuJGdldE5leHRQYWdlXSgpfVtyLiRnZXRBdmFpbGFibGVTcGFjZV0oKXtyZXR1cm4gdGhpc1tyLiRleHRyYV0uc3BhY2V8fHt3aWR0aDowLGhlaWdodDowfX1bci4kdG9IVE1MXSgpe3RoaXNbci4kZXh0cmFdfHwodGhpc1tyLiRleHRyYV09e251bWJlck9mVXNlOjF9KTtjb25zdCBlPVtdO3RoaXNbci4kZXh0cmFdLmNoaWxkcmVuPWU7Y29uc3QgdD1PYmplY3QuY3JlYXRlKG51bGwpO2lmKHRoaXMubWVkaXVtJiZ0aGlzLm1lZGl1bS5zaG9ydCYmdGhpcy5tZWRpdW0ubG9uZyl7dC53aWR0aD0oMCxzLm1lYXN1cmVUb1N0cmluZykodGhpcy5tZWRpdW0uc2hvcnQpO3QuaGVpZ2h0PSgwLHMubWVhc3VyZVRvU3RyaW5nKSh0aGlzLm1lZGl1bS5sb25nKTt0aGlzW3IuJGV4dHJhXS5zcGFjZT17d2lkdGg6dGhpcy5tZWRpdW0uc2hvcnQsaGVpZ2h0OnRoaXMubWVkaXVtLmxvbmd9O2lmKCJsYW5kc2NhcGUiPT09dGhpcy5tZWRpdW0ub3JpZW50YXRpb24pe2NvbnN0IGU9dC53aWR0aDt0LndpZHRoPXQuaGVpZ2h0O3QuaGVpZ2h0PWU7dGhpc1tyLiRleHRyYV0uc3BhY2U9e3dpZHRoOnRoaXMubWVkaXVtLmxvbmcsaGVpZ2h0OnRoaXMubWVkaXVtLnNob3J0fX19ZWxzZSgwLGMud2FybikoIlhGQSAtIE5vIG1lZGl1bSBzcGVjaWZpZWQgaW4gcGFnZUFyZWE6IHBsZWFzZSBmaWxlIGEgYnVnLiIpO3RoaXNbci4kY2hpbGRyZW5Ub0hUTUxdKHtmaWx0ZXI6bmV3IFNldChbImFyZWEiLCJkcmF3IiwiZmllbGQiLCJzdWJmb3JtIl0pLGluY2x1ZGU6ITB9KTt0aGlzW3IuJGNoaWxkcmVuVG9IVE1MXSh7ZmlsdGVyOm5ldyBTZXQoWyJjb250ZW50QXJlYSJdKSxpbmNsdWRlOiEwfSk7cmV0dXJuIG8uSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJkaXYiLGNoaWxkcmVuOmUsYXR0cmlidXRlczp7Y2xhc3M6WyJ4ZmFQYWdlIl0saWQ6dGhpc1tyLiR1aWRdLHN0eWxlOnQseGZhTmFtZTp0aGlzLm5hbWV9fSl9fWNsYXNzIFBhZ2VTZXQgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJwYWdlU2V0IiwhMCk7dGhpcy5kdXBsZXhJbXBvc2l0aW9uPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLmR1cGxleEltcG9zaXRpb24sWyJsb25nRWRnZSIsInNob3J0RWRnZSJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMucmVsYXRpb249KDAsby5nZXRTdHJpbmdPcHRpb24pKGUucmVsYXRpb24sWyJvcmRlcmVkT2NjdXJyZW5jZSIsImR1cGxleFBhZ2luYXRlZCIsInNpbXBsZXhQYWdpbmF0ZWQiXSk7dGhpcy5yZWxldmFudD0oMCxvLmdldFJlbGV2YW50KShlLnJlbGV2YW50KTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbDt0aGlzLm9jY3VyPW51bGw7dGhpcy5wYWdlQXJlYT1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLnBhZ2VTZXQ9bmV3IHIuWEZBT2JqZWN0QXJyYXl9W3IuJGNsZWFuUGFnZV0oKXtmb3IoY29uc3QgZSBvZiB0aGlzLnBhZ2VBcmVhLmNoaWxkcmVuKWVbci4kY2xlYW5QYWdlXSgpO2Zvcihjb25zdCBlIG9mIHRoaXMucGFnZVNldC5jaGlsZHJlbillW3IuJGNsZWFuUGFnZV0oKX1bci4kaXNVc2FibGVdKCl7cmV0dXJuIXRoaXMub2NjdXJ8fC0xPT09dGhpcy5vY2N1ci5tYXh8fHRoaXNbci4kZXh0cmFdLm51bWJlck9mVXNlPHRoaXMub2NjdXIubWF4fVtyLiRnZXROZXh0UGFnZV0oKXt0aGlzW3IuJGV4dHJhXXx8KHRoaXNbci4kZXh0cmFdPXtudW1iZXJPZlVzZToxLHBhZ2VJbmRleDotMSxwYWdlU2V0SW5kZXg6LTF9KTtpZigib3JkZXJlZE9jY3VycmVuY2UiPT09dGhpcy5yZWxhdGlvbil7aWYodGhpc1tyLiRleHRyYV0ucGFnZUluZGV4KzE8dGhpcy5wYWdlQXJlYS5jaGlsZHJlbi5sZW5ndGgpe3RoaXNbci4kZXh0cmFdLnBhZ2VJbmRleCs9MTtyZXR1cm4gdGhpcy5wYWdlQXJlYS5jaGlsZHJlblt0aGlzW3IuJGV4dHJhXS5wYWdlSW5kZXhdW3IuJGdldE5leHRQYWdlXSgpfWlmKHRoaXNbci4kZXh0cmFdLnBhZ2VTZXRJbmRleCsxPHRoaXMucGFnZVNldC5jaGlsZHJlbi5sZW5ndGgpe3RoaXNbci4kZXh0cmFdLnBhZ2VTZXRJbmRleCs9MTtyZXR1cm4gdGhpcy5wYWdlU2V0LmNoaWxkcmVuW3RoaXNbci4kZXh0cmFdLnBhZ2VTZXRJbmRleF1bci4kZ2V0TmV4dFBhZ2VdKCl9aWYodGhpc1tyLiRpc1VzYWJsZV0oKSl7dGhpc1tyLiRleHRyYV0ubnVtYmVyT2ZVc2UrPTE7dGhpc1tyLiRleHRyYV0ucGFnZUluZGV4PS0xO3RoaXNbci4kZXh0cmFdLnBhZ2VTZXRJbmRleD0tMTtyZXR1cm4gdGhpc1tyLiRnZXROZXh0UGFnZV0oKX1jb25zdCBlPXRoaXNbci4kZ2V0UGFyZW50XSgpO2lmKGUgaW5zdGFuY2VvZiBQYWdlU2V0KXJldHVybiBlW3IuJGdldE5leHRQYWdlXSgpO3RoaXNbci4kY2xlYW5QYWdlXSgpO3JldHVybiB0aGlzW3IuJGdldE5leHRQYWdlXSgpfWNvbnN0IGU9dGhpc1tyLiRnZXRUZW1wbGF0ZVJvb3RdKClbci4kZXh0cmFdLnBhZ2VOdW1iZXIsdD1lJTI9PTA/ImV2ZW4iOiJvZGQiLGE9MD09PWU/ImZpcnN0IjoicmVzdCI7bGV0IG49dGhpcy5wYWdlQXJlYS5jaGlsZHJlbi5maW5kKChlPT5lLm9kZE9yRXZlbj09PXQmJmUucGFnZVBvc2l0aW9uPT09YSkpO2lmKG4pcmV0dXJuIG47bj10aGlzLnBhZ2VBcmVhLmNoaWxkcmVuLmZpbmQoKGU9PiJhbnkiPT09ZS5vZGRPckV2ZW4mJmUucGFnZVBvc2l0aW9uPT09YSkpO2lmKG4pcmV0dXJuIG47bj10aGlzLnBhZ2VBcmVhLmNoaWxkcmVuLmZpbmQoKGU9PiJhbnkiPT09ZS5vZGRPckV2ZW4mJiJhbnkiPT09ZS5wYWdlUG9zaXRpb24pKTtyZXR1cm4gbnx8dGhpcy5wYWdlQXJlYS5jaGlsZHJlblswXX19Y2xhc3MgUGFyYSBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsInBhcmEiLCEwKTt0aGlzLmhBbGlnbj0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5oQWxpZ24sWyJsZWZ0IiwiY2VudGVyIiwianVzdGlmeSIsImp1c3RpZnlBbGwiLCJyYWRpeCIsInJpZ2h0Il0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5saW5lSGVpZ2h0PWUubGluZUhlaWdodD8oMCxvLmdldE1lYXN1cmVtZW50KShlLmxpbmVIZWlnaHQsIjBwdCIpOiIiO3RoaXMubWFyZ2luTGVmdD1lLm1hcmdpbkxlZnQ/KDAsby5nZXRNZWFzdXJlbWVudCkoZS5tYXJnaW5MZWZ0LCIwcHQiKToiIjt0aGlzLm1hcmdpblJpZ2h0PWUubWFyZ2luUmlnaHQ/KDAsby5nZXRNZWFzdXJlbWVudCkoZS5tYXJnaW5SaWdodCwiMHB0Iik6IiI7dGhpcy5vcnBoYW5zPSgwLG8uZ2V0SW50ZWdlcikoe2RhdGE6ZS5vcnBoYW5zLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PmU+PTB9KTt0aGlzLnByZXNlcnZlPWUucHJlc2VydmV8fCIiO3RoaXMucmFkaXhPZmZzZXQ9ZS5yYWRpeE9mZnNldD8oMCxvLmdldE1lYXN1cmVtZW50KShlLnJhZGl4T2Zmc2V0LCIwcHQiKToiIjt0aGlzLnNwYWNlQWJvdmU9ZS5zcGFjZUFib3ZlPygwLG8uZ2V0TWVhc3VyZW1lbnQpKGUuc3BhY2VBYm92ZSwiMHB0Iik6IiI7dGhpcy5zcGFjZUJlbG93PWUuc3BhY2VCZWxvdz8oMCxvLmdldE1lYXN1cmVtZW50KShlLnNwYWNlQmVsb3csIjBwdCIpOiIiO3RoaXMudGFiRGVmYXVsdD1lLnRhYkRlZmF1bHQ/KDAsby5nZXRNZWFzdXJlbWVudCkodGhpcy50YWJEZWZhdWx0KToiIjt0aGlzLnRhYlN0b3BzPShlLnRhYlN0b3BzfHwiIikudHJpbSgpLnNwbGl0KC9ccysvKS5tYXAoKChlLHQpPT50JTI9PTE/KDAsby5nZXRNZWFzdXJlbWVudCkoZSk6ZSkpO3RoaXMudGV4dEluZGVudD1lLnRleHRJbmRlbnQ/KDAsby5nZXRNZWFzdXJlbWVudCkoZS50ZXh0SW5kZW50LCIwcHQiKToiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy52QWxpZ249KDAsby5nZXRTdHJpbmdPcHRpb24pKGUudkFsaWduLFsidG9wIiwiYm90dG9tIiwibWlkZGxlIl0pO3RoaXMud2lkb3dzPSgwLG8uZ2V0SW50ZWdlcikoe2RhdGE6ZS53aWRvd3MsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+ZT49MH0pO3RoaXMuaHlwaGVuYXRpb249bnVsbH1bci4kdG9TdHlsZV0oKXtjb25zdCBlPSgwLHMudG9TdHlsZSkodGhpcywiaEFsaWduIik7IiIhPT10aGlzLm1hcmdpbkxlZnQmJihlLnBhZGRpbmdMZWZ0PSgwLHMubWVhc3VyZVRvU3RyaW5nKSh0aGlzLm1hcmdpbkxlZnQpKTsiIiE9PXRoaXMubWFyZ2luUmlnaHQmJihlLnBhZGRpbmdpZ2h0PSgwLHMubWVhc3VyZVRvU3RyaW5nKSh0aGlzLm1hcmdpblJpZ2h0KSk7IiIhPT10aGlzLnNwYWNlQWJvdmUmJihlLnBhZGRpbmdUb3A9KDAscy5tZWFzdXJlVG9TdHJpbmcpKHRoaXMuc3BhY2VBYm92ZSkpOyIiIT09dGhpcy5zcGFjZUJlbG93JiYoZS5wYWRkaW5nQm90dG9tPSgwLHMubWVhc3VyZVRvU3RyaW5nKSh0aGlzLnNwYWNlQmVsb3cpKTtpZigiIiE9PXRoaXMudGV4dEluZGVudCl7ZS50ZXh0SW5kZW50PSgwLHMubWVhc3VyZVRvU3RyaW5nKSh0aGlzLnRleHRJbmRlbnQpOygwLHMuZml4VGV4dEluZGVudCkoZSl9dGhpcy5saW5lSGVpZ2h0PjAmJihlLmxpbmVIZWlnaHQ9KDAscy5tZWFzdXJlVG9TdHJpbmcpKHRoaXMubGluZUhlaWdodCkpOyIiIT09dGhpcy50YWJEZWZhdWx0JiYoZS50YWJTaXplPSgwLHMubWVhc3VyZVRvU3RyaW5nKSh0aGlzLnRhYkRlZmF1bHQpKTt0aGlzLnRhYlN0b3BzLmxlbmd0aDt0aGlzLmh5cGhlbmF0YXRpb24mJk9iamVjdC5hc3NpZ24oZSx0aGlzLmh5cGhlbmF0YXRpb25bci4kdG9TdHlsZV0oKSk7cmV0dXJuIGV9fWNsYXNzIFBhc3N3b3JkRWRpdCBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsInBhc3N3b3JkRWRpdCIsITApO3RoaXMuaFNjcm9sbFBvbGljeT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5oU2Nyb2xsUG9saWN5LFsiYXV0byIsIm9mZiIsIm9uIl0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5wYXNzd29yZENoYXI9ZS5wYXNzd29yZENoYXJ8fCIqIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5ib3JkZXI9bnVsbDt0aGlzLmV4dHJhcz1udWxsO3RoaXMubWFyZ2luPW51bGx9fWNsYXNzIFBhdHRlcm4gZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJwYXR0ZXJuIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnR5cGU9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUudHlwZSxbImNyb3NzSGF0Y2giLCJjcm9zc0RpYWdvbmFsIiwiZGlhZ29uYWxMZWZ0IiwiZGlhZ29uYWxSaWdodCIsImhvcml6b250YWwiLCJ2ZXJ0aWNhbCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5jb2xvcj1udWxsO3RoaXMuZXh0cmFzPW51bGx9W3IuJHRvU3R5bGVdKGUpe2U9ZT9lW3IuJHRvU3R5bGVdKCk6IiNGRkZGRkYiO2NvbnN0IHQ9dGhpcy5jb2xvcj90aGlzLmNvbG9yW3IuJHRvU3R5bGVdKCk6IiMwMDAwMDAiLGE9InJlcGVhdGluZy1saW5lYXItZ3JhZGllbnQiLG49YCR7ZX0sJHtlfSA1cHgsJHt0fSA1cHgsJHt0fSAxMHB4YDtzd2l0Y2godGhpcy50eXBlKXtjYXNlImNyb3NzSGF0Y2giOnJldHVybmAke2F9KHRvIHRvcCwke259KSAke2F9KHRvIHJpZ2h0LCR7bn0pYDtjYXNlImNyb3NzRGlhZ29uYWwiOnJldHVybmAke2F9KDQ1ZGVnLCR7bn0pICR7YX0oLTQ1ZGVnLCR7bn0pYDtjYXNlImRpYWdvbmFsTGVmdCI6cmV0dXJuYCR7YX0oNDVkZWcsJHtufSlgO2Nhc2UiZGlhZ29uYWxSaWdodCI6cmV0dXJuYCR7YX0oLTQ1ZGVnLCR7bn0pYDtjYXNlImhvcml6b250YWwiOnJldHVybmAke2F9KHRvIHRvcCwke259KWA7Y2FzZSJ2ZXJ0aWNhbCI6cmV0dXJuYCR7YX0odG8gcmlnaHQsJHtufSlgfXJldHVybiIifX1jbGFzcyBQaWN0dXJlIGV4dGVuZHMgci5TdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwicGljdHVyZSIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBQcm90byBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsInByb3RvIiwhMCk7dGhpcy5hcHBlYXJhbmNlRmlsdGVyPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuYXJjPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuYXJlYT1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmFzc2lzdD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmJhcmNvZGU9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5iaW5kSXRlbXM9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5ib29rZW5kPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuYm9vbGVhbj1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmJvcmRlcj1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmJyZWFrPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuYnJlYWtBZnRlcj1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmJyZWFrQmVmb3JlPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuYnV0dG9uPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuY2FsY3VsYXRlPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuY2FwdGlvbj1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmNlcnRpZmljYXRlPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuY2VydGlmaWNhdGVzPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuY2hlY2tCdXR0b249bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5jaG9pY2VMaXN0PW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuY29sb3I9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5jb21iPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuY29ubmVjdD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmNvbnRlbnRBcmVhPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuY29ybmVyPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuZGF0ZT1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmRhdGVUaW1lPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuZGF0ZVRpbWVFZGl0PW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuZGVjaW1hbD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmRlZmF1bHRVaT1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmRlc2M9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5kaWdlc3RNZXRob2Q9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5kaWdlc3RNZXRob2RzPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuZHJhdz1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmVkZ2U9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5lbmNvZGluZz1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmVuY29kaW5ncz1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmVuY3J5cHQ9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5lbmNyeXB0RGF0YT1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmVuY3J5cHRpb249bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5lbmNyeXB0aW9uTWV0aG9kPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuZW5jcnlwdGlvbk1ldGhvZHM9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5ldmVudD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmV4RGF0YT1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmV4T2JqZWN0PW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuZXhjbEdyb3VwPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuZXhlY3V0ZT1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmV4dHJhcz1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmZpZWxkPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuZmlsbD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmZpbHRlcj1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmZsb2F0PW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuZm9udD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmZvcm1hdD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmhhbmRsZXI9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5oeXBoZW5hdGlvbj1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmltYWdlPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuaW1hZ2VFZGl0PW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuaW50ZWdlcj1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmlzc3VlcnM9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5pdGVtcz1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmtlZXA9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5rZXlVc2FnZT1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmxpbmU9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5saW5lYXI9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5sb2NrRG9jdW1lbnQ9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5tYW5pZmVzdD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLm1hcmdpbj1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLm1kcD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLm1lZGl1bT1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLm1lc3NhZ2U9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5udW1lcmljRWRpdD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLm9jY3VyPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMub2lkPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMub2lkcz1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLm92ZXJmbG93PW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMucGFnZUFyZWE9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5wYWdlU2V0PW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMucGFyYT1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLnBhc3N3b3JkRWRpdD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLnBhdHRlcm49bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5waWN0dXJlPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMucmFkaWFsPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMucmVhc29uPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMucmVhc29ucz1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLnJlY3RhbmdsZT1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLnJlZj1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLnNjcmlwdD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLnNldFByb3BlcnR5PW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuc2lnbkRhdGE9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5zaWduYXR1cmU9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5zaWduaW5nPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuc29saWQ9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5zcGVhaz1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLnN0aXBwbGU9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5zdWJmb3JtPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuc3ViZm9ybVNldD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLnN1YmplY3RETj1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLnN1YmplY3RETnM9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5zdWJtaXQ9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy50ZXh0PW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMudGV4dEVkaXQ9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy50aW1lPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMudGltZVN0YW1wPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMudG9vbFRpcD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLnRyYXZlcnNhbD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLnRyYXZlcnNlPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMudWk9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy52YWxpZGF0ZT1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLnZhbHVlPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMudmFyaWFibGVzPW5ldyByLlhGQU9iamVjdEFycmF5fX1jbGFzcyBSYWRpYWwgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJyYWRpYWwiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS50eXBlLFsidG9FZGdlIiwidG9DZW50ZXIiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuY29sb3I9bnVsbDt0aGlzLmV4dHJhcz1udWxsfVtyLiR0b1N0eWxlXShlKXtlPWU/ZVtyLiR0b1N0eWxlXSgpOiIjRkZGRkZGIjtjb25zdCB0PXRoaXMuY29sb3I/dGhpcy5jb2xvcltyLiR0b1N0eWxlXSgpOiIjMDAwMDAwIjtyZXR1cm5gcmFkaWFsLWdyYWRpZW50KGNpcmNsZSBhdCBjZW50ZXIsICR7InRvRWRnZSI9PT10aGlzLnR5cGU/YCR7ZX0sJHt0fWA6YCR7dH0sJHtlfWB9KWB9fWNsYXNzIFJlYXNvbiBleHRlbmRzIHIuU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsInJlYXNvbiIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBSZWFzb25zIGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwicmVhc29ucyIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy50eXBlPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLnR5cGUsWyJvcHRpb25hbCIsInJlcXVpcmVkIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLnJlYXNvbj1uZXcgci5YRkFPYmplY3RBcnJheX19Y2xhc3MgUmVjdGFuZ2xlIGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwicmVjdGFuZ2xlIiwhMCk7dGhpcy5oYW5kPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLmhhbmQsWyJldmVuIiwibGVmdCIsInJpZ2h0Il0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuY29ybmVyPW5ldyByLlhGQU9iamVjdEFycmF5KDQpO3RoaXMuZWRnZT1uZXcgci5YRkFPYmplY3RBcnJheSg0KTt0aGlzLmZpbGw9bnVsbH1bci4kdG9IVE1MXSgpe2NvbnN0IGU9dGhpcy5lZGdlLmNoaWxkcmVuLmxlbmd0aD90aGlzLmVkZ2UuY2hpbGRyZW5bMF06bmV3IEVkZ2Uoe30pLHQ9ZVtyLiR0b1N0eWxlXSgpLGE9T2JqZWN0LmNyZWF0ZShudWxsKTt0aGlzLmZpbGwmJiJ2aXNpYmxlIj09PXRoaXMuZmlsbC5wcmVzZW5jZT9PYmplY3QuYXNzaWduKGEsdGhpcy5maWxsW3IuJHRvU3R5bGVdKCkpOmEuZmlsbD0idHJhbnNwYXJlbnQiO2Euc3Ryb2tlV2lkdGg9KDAscy5tZWFzdXJlVG9TdHJpbmcpKCJ2aXNpYmxlIj09PWUucHJlc2VuY2U/ZS50aGlja25lc3M6MCk7YS5zdHJva2U9dC5jb2xvcjtjb25zdCBuPSh0aGlzLmNvcm5lci5jaGlsZHJlbi5sZW5ndGg/dGhpcy5jb3JuZXIuY2hpbGRyZW5bMF06bmV3IENvcm5lcih7fSkpW3IuJHRvU3R5bGVdKCksaT17bmFtZToic3ZnIixjaGlsZHJlbjpbe25hbWU6InJlY3QiLGF0dHJpYnV0ZXM6e3htbG5zOmYsd2lkdGg6IjEwMCUiLGhlaWdodDoiMTAwJSIseDowLHk6MCxyeDpuLnJhZGl1cyxyeTpuLnJhZGl1cyxzdHlsZTphfX1dLGF0dHJpYnV0ZXM6e3htbG5zOmYsc3R5bGU6e292ZXJmbG93OiJ2aXNpYmxlIn0sd2lkdGg6IjEwMCUiLGhlaWdodDoiMTAwJSJ9fTtpZihoYXNNYXJnaW4odGhpc1tyLiRnZXRQYXJlbnRdKClbci4kZ2V0UGFyZW50XSgpKSlyZXR1cm4gby5IVE1MUmVzdWx0LnN1Y2Nlc3Moe25hbWU6ImRpdiIsYXR0cmlidXRlczp7c3R5bGU6e2Rpc3BsYXk6ImlubGluZSIsd2lkdGg6IjEwMCUiLGhlaWdodDoiMTAwJSJ9fSxjaGlsZHJlbjpbaV19KTtpLmF0dHJpYnV0ZXMuc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtyZXR1cm4gby5IVE1MUmVzdWx0LnN1Y2Nlc3MoaSl9fWNsYXNzIFJlZkVsZW1lbnQgZXh0ZW5kcyByLlN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJyZWYiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgU2NyaXB0IGV4dGVuZHMgci5TdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwic2NyaXB0Iik7dGhpcy5iaW5kaW5nPWUuYmluZGluZ3x8IiI7dGhpcy5jb250ZW50VHlwZT1lLmNvbnRlbnRUeXBlfHwiIjt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMucnVuQXQ9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUucnVuQXQsWyJjbGllbnQiLCJib3RoIiwic2VydmVyIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgU2V0UHJvcGVydHkgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJzZXRQcm9wZXJ0eSIpO3RoaXMuY29ubmVjdGlvbj1lLmNvbm5lY3Rpb258fCIiO3RoaXMucmVmPWUucmVmfHwiIjt0aGlzLnRhcmdldD1lLnRhcmdldHx8IiJ9fXQuU2V0UHJvcGVydHk9U2V0UHJvcGVydHk7Y2xhc3MgU2lnbkRhdGEgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJzaWduRGF0YSIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5vcGVyYXRpb249KDAsby5nZXRTdHJpbmdPcHRpb24pKGUub3BlcmF0aW9uLFsic2lnbiIsImNsZWFyIiwidmVyaWZ5Il0pO3RoaXMucmVmPWUucmVmfHwiIjt0aGlzLnRhcmdldD1lLnRhcmdldHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZmlsdGVyPW51bGw7dGhpcy5tYW5pZmVzdD1udWxsfX1jbGFzcyBTaWduYXR1cmUgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJzaWduYXR1cmUiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS50eXBlLFsiUERGMS4zIiwiUERGMS42Il0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmJvcmRlcj1udWxsO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5maWx0ZXI9bnVsbDt0aGlzLm1hbmlmZXN0PW51bGw7dGhpcy5tYXJnaW49bnVsbH19Y2xhc3MgU2lnbmluZyBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsInNpZ25pbmciLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS50eXBlLFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5jZXJ0aWZpY2F0ZT1uZXcgci5YRkFPYmplY3RBcnJheX19Y2xhc3MgU29saWQgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJzb2xpZCIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZXh0cmFzPW51bGx9W3IuJHRvU3R5bGVdKGUpe3JldHVybiBlP2Vbci4kdG9TdHlsZV0oKToiI0ZGRkZGRiJ9fWNsYXNzIFNwZWFrIGV4dGVuZHMgci5TdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwic3BlYWsiKTt0aGlzLmRpc2FibGU9KDAsby5nZXRJbnRlZ2VyKSh7ZGF0YTplLmRpc2FibGUsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV9KTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMucHJpb3JpdHk9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUucHJpb3JpdHksWyJjdXN0b20iLCJjYXB0aW9uIiwibmFtZSIsInRvb2xUaXAiXSk7dGhpcy5yaWQ9ZS5yaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgU3RpcHBsZSBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsInN0aXBwbGUiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMucmF0ZT0oMCxvLmdldEludGVnZXIpKHtkYXRhOmUucmF0ZSxkZWZhdWx0VmFsdWU6NTAsdmFsaWRhdGU6ZT0+ZT49MCYmZTw9MTAwfSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuY29sb3I9bnVsbDt0aGlzLmV4dHJhcz1udWxsfVtyLiR0b1N0eWxlXShlKXtjb25zdCB0PXRoaXMucmF0ZS8xMDA7cmV0dXJuIGMuVXRpbC5tYWtlSGV4Q29sb3IoTWF0aC5yb3VuZChlLnZhbHVlLnIqKDEtdCkrdGhpcy52YWx1ZS5yKnQpLE1hdGgucm91bmQoZS52YWx1ZS5nKigxLXQpK3RoaXMudmFsdWUuZyp0KSxNYXRoLnJvdW5kKGUudmFsdWUuYiooMS10KSt0aGlzLnZhbHVlLmIqdCkpfX1jbGFzcyBTdWJmb3JtIGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwic3ViZm9ybSIsITApO3RoaXMuYWNjZXNzPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLmFjY2VzcyxbIm9wZW4iLCJub25JbnRlcmFjdGl2ZSIsInByb3RlY3RlZCIsInJlYWRPbmx5Il0pO3RoaXMuYWxsb3dNYWNybz0oMCxvLmdldEludGVnZXIpKHtkYXRhOmUuYWxsb3dNYWNybyxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT4xPT09ZX0pO3RoaXMuYW5jaG9yVHlwZT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5hbmNob3JUeXBlLFsidG9wTGVmdCIsImJvdHRvbUNlbnRlciIsImJvdHRvbUxlZnQiLCJib3R0b21SaWdodCIsIm1pZGRsZUNlbnRlciIsIm1pZGRsZUxlZnQiLCJtaWRkbGVSaWdodCIsInRvcENlbnRlciIsInRvcFJpZ2h0Il0pO3RoaXMuY29sU3Bhbj0oMCxvLmdldEludGVnZXIpKHtkYXRhOmUuY29sU3BhbixkZWZhdWx0VmFsdWU6MSx2YWxpZGF0ZTplPT5lPj0xfHwtMT09PWV9KTt0aGlzLmNvbHVtbldpZHRocz0oZS5jb2x1bW5XaWR0aHN8fCIiKS50cmltKCkuc3BsaXQoL1xzKy8pLm1hcCgoZT0+Ii0xIj09PWU/LTE6KDAsby5nZXRNZWFzdXJlbWVudCkoZSkpKTt0aGlzLmg9ZS5oPygwLG8uZ2V0TWVhc3VyZW1lbnQpKGUuaCk6IiI7dGhpcy5oQWxpZ249KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuaEFsaWduLFsibGVmdCIsImNlbnRlciIsImp1c3RpZnkiLCJqdXN0aWZ5QWxsIiwicmFkaXgiLCJyaWdodCJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubGF5b3V0PSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLmxheW91dCxbInBvc2l0aW9uIiwibHItdGIiLCJybC1yb3ciLCJybC10YiIsInJvdyIsInRhYmxlIiwidGIiXSk7dGhpcy5sb2NhbGU9ZS5sb2NhbGV8fCIiO3RoaXMubWF4SD0oMCxvLmdldE1lYXN1cmVtZW50KShlLm1heEgsIjBwdCIpO3RoaXMubWF4Vz0oMCxvLmdldE1lYXN1cmVtZW50KShlLm1heFcsIjBwdCIpO3RoaXMubWVyZ2VNb2RlPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLm1lcmdlTW9kZSxbImNvbnN1bWVEYXRhIiwibWF0Y2hUZW1wbGF0ZSJdKTt0aGlzLm1pbkg9KDAsby5nZXRNZWFzdXJlbWVudCkoZS5taW5ILCIwcHQiKTt0aGlzLm1pblc9KDAsby5nZXRNZWFzdXJlbWVudCkoZS5taW5XLCIwcHQiKTt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnByZXNlbmNlPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLnByZXNlbmNlLFsidmlzaWJsZSIsImhpZGRlbiIsImluYWN0aXZlIiwiaW52aXNpYmxlIl0pO3RoaXMucmVsZXZhbnQ9KDAsby5nZXRSZWxldmFudCkoZS5yZWxldmFudCk7dGhpcy5yZXN0b3JlU3RhdGU9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUucmVzdG9yZVN0YXRlLFsibWFudWFsIiwiYXV0byJdKTt0aGlzLnNjb3BlPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLnNjb3BlLFsibmFtZSIsIm5vbmUiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMudz1lLnc/KDAsby5nZXRNZWFzdXJlbWVudCkoZS53KToiIjt0aGlzLng9KDAsby5nZXRNZWFzdXJlbWVudCkoZS54LCIwcHQiKTt0aGlzLnk9KDAsby5nZXRNZWFzdXJlbWVudCkoZS55LCIwcHQiKTt0aGlzLmFzc2lzdD1udWxsO3RoaXMuYmluZD1udWxsO3RoaXMuYm9va2VuZD1udWxsO3RoaXMuYm9yZGVyPW51bGw7dGhpcy5icmVhaz1udWxsO3RoaXMuY2FsY3VsYXRlPW51bGw7dGhpcy5kZXNjPW51bGw7dGhpcy5leHRyYXM9bnVsbDt0aGlzLmtlZXA9bnVsbDt0aGlzLm1hcmdpbj1udWxsO3RoaXMub2NjdXI9bnVsbDt0aGlzLm92ZXJmbG93PW51bGw7dGhpcy5wYWdlU2V0PW51bGw7dGhpcy5wYXJhPW51bGw7dGhpcy50cmF2ZXJzYWw9bnVsbDt0aGlzLnZhbGlkYXRlPW51bGw7dGhpcy52YXJpYWJsZXM9bnVsbDt0aGlzLmFyZWE9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5icmVha0FmdGVyPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuYnJlYWtCZWZvcmU9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5jb25uZWN0PW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuZHJhdz1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmV2ZW50PW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuZXhPYmplY3Q9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5leGNsR3JvdXA9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5maWVsZD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLnByb3RvPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuc2V0UHJvcGVydHk9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5zdWJmb3JtPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuc3ViZm9ybVNldD1uZXcgci5YRkFPYmplY3RBcnJheX1bci4kZ2V0U3ViZm9ybVBhcmVudF0oKXtjb25zdCBlPXRoaXNbci4kZ2V0UGFyZW50XSgpO3JldHVybiBlIGluc3RhbmNlb2YgU3ViZm9ybVNldD9lW3IuJGdldFN1YmZvcm1QYXJlbnRdKCk6ZX1bci4kaXNCaW5kYWJsZV0oKXtyZXR1cm4hMH1bci4kaXNUaGVyZU1vcmVXaWR0aF0oKXtyZXR1cm4gdGhpcy5sYXlvdXQuZW5kc1dpdGgoIi10YiIpJiYwPT09dGhpc1tyLiRleHRyYV0uYXR0ZW1wdCYmdGhpc1tyLiRleHRyYV0ubnVtYmVySW5MaW5lPjB8fHRoaXNbci4kZ2V0UGFyZW50XSgpW3IuJGlzVGhlcmVNb3JlV2lkdGhdKCl9KltyLiRnZXRDb250YWluZWRDaGlsZHJlbl0oKXt5aWVsZCpnZXRDb250YWluZWRDaGlsZHJlbih0aGlzKX1bci4kZmx1c2hIVE1MXSgpe3JldHVybigwLGkuZmx1c2hIVE1MKSh0aGlzKX1bci4kYWRkSFRNTF0oZSx0KXsoMCxpLmFkZEhUTUwpKHRoaXMsZSx0KX1bci4kZ2V0QXZhaWxhYmxlU3BhY2VdKCl7cmV0dXJuKDAsaS5nZXRBdmFpbGFibGVTcGFjZSkodGhpcyl9W3IuJGlzU3BsaXR0YWJsZV0oKXtjb25zdCBlPXRoaXNbci4kZ2V0U3ViZm9ybVBhcmVudF0oKTtpZighZVtyLiRpc1NwbGl0dGFibGVdKCkpcmV0dXJuITE7aWYodm9pZCAwIT09dGhpc1tyLiRleHRyYV0uX2lzU3BsaXR0YWJsZSlyZXR1cm4gdGhpc1tyLiRleHRyYV0uX2lzU3BsaXR0YWJsZTtpZigicG9zaXRpb24iPT09dGhpcy5sYXlvdXR8fHRoaXMubGF5b3V0LmluY2x1ZGVzKCJyb3ciKSl7dGhpc1tyLiRleHRyYV0uX2lzU3BsaXR0YWJsZT0hMTtyZXR1cm4hMX1pZih0aGlzLmtlZXAmJiJub25lIiE9PXRoaXMua2VlcC5pbnRhY3Qpe3RoaXNbci4kZXh0cmFdLl9pc1NwbGl0dGFibGU9ITE7cmV0dXJuITF9aWYoZS5sYXlvdXQmJmUubGF5b3V0LmVuZHNXaXRoKCItdGIiKSYmMCE9PWVbci4kZXh0cmFdLm51bWJlckluTGluZSlyZXR1cm4hMTt0aGlzW3IuJGV4dHJhXS5faXNTcGxpdHRhYmxlPSEwO3JldHVybiEwfVtyLiR0b0hUTUxdKGUpe3NldFRhYkluZGV4KHRoaXMpO2lmKHRoaXMuYnJlYWspe2lmKCJhdXRvIiE9PXRoaXMuYnJlYWsuYWZ0ZXJ8fCIiIT09dGhpcy5icmVhay5hZnRlclRhcmdldCl7Y29uc3QgZT1uZXcgQnJlYWtBZnRlcih7dGFyZ2V0VHlwZTp0aGlzLmJyZWFrLmFmdGVyLHRhcmdldDp0aGlzLmJyZWFrLmFmdGVyVGFyZ2V0LHN0YXJ0TmV3OnRoaXMuYnJlYWsuc3RhcnROZXcudG9TdHJpbmcoKX0pO2Vbci4kZ2xvYmFsRGF0YV09dGhpc1tyLiRnbG9iYWxEYXRhXTt0aGlzW3IuJGFwcGVuZENoaWxkXShlKTt0aGlzLmJyZWFrQWZ0ZXIucHVzaChlKX1pZigiYXV0byIhPT10aGlzLmJyZWFrLmJlZm9yZXx8IiIhPT10aGlzLmJyZWFrLmJlZm9yZVRhcmdldCl7Y29uc3QgZT1uZXcgQnJlYWtCZWZvcmUoe3RhcmdldFR5cGU6dGhpcy5icmVhay5iZWZvcmUsdGFyZ2V0OnRoaXMuYnJlYWsuYmVmb3JlVGFyZ2V0LHN0YXJ0TmV3OnRoaXMuYnJlYWsuc3RhcnROZXcudG9TdHJpbmcoKX0pO2Vbci4kZ2xvYmFsRGF0YV09dGhpc1tyLiRnbG9iYWxEYXRhXTt0aGlzW3IuJGFwcGVuZENoaWxkXShlKTt0aGlzLmJyZWFrQmVmb3JlLnB1c2goZSl9aWYoIiIhPT10aGlzLmJyZWFrLm92ZXJmbG93VGFyZ2V0KXtjb25zdCBlPW5ldyBPdmVyZmxvdyh7dGFyZ2V0OnRoaXMuYnJlYWsub3ZlcmZsb3dUYXJnZXQsbGVhZGVyOnRoaXMuYnJlYWsub3ZlcmZsb3dMZWFkZXIsdHJhaWxlcjp0aGlzLmJyZWFrLm92ZXJmbG93VHJhaWxlcn0pO2Vbci4kZ2xvYmFsRGF0YV09dGhpc1tyLiRnbG9iYWxEYXRhXTt0aGlzW3IuJGFwcGVuZENoaWxkXShlKTt0aGlzLm92ZXJmbG93LnB1c2goZSl9dGhpc1tyLiRyZW1vdmVDaGlsZF0odGhpcy5icmVhayk7dGhpcy5icmVhaz1udWxsfWlmKCJoaWRkZW4iPT09dGhpcy5wcmVzZW5jZXx8ImluYWN0aXZlIj09PXRoaXMucHJlc2VuY2UpcmV0dXJuIG8uSFRNTFJlc3VsdC5FTVBUWTsodGhpcy5icmVha0JlZm9yZS5jaGlsZHJlbi5sZW5ndGg+MXx8dGhpcy5icmVha0FmdGVyLmNoaWxkcmVuLmxlbmd0aD4xKSYmKDAsYy53YXJuKSgiWEZBIC0gU2V2ZXJhbCBicmVha0JlZm9yZSBvciBicmVha0FmdGVyIGluIHN1YmZvcm1zOiBwbGVhc2UgZmlsZSBhIGJ1Zy4iKTtpZih0aGlzLmJyZWFrQmVmb3JlLmNoaWxkcmVuLmxlbmd0aD49MSl7Y29uc3QgZT10aGlzLmJyZWFrQmVmb3JlLmNoaWxkcmVuWzBdO2lmKGhhbmRsZUJyZWFrKGUpKXJldHVybiBvLkhUTUxSZXN1bHQuYnJlYWtOb2RlKGUpfWlmKHRoaXNbci4kZXh0cmFdJiZ0aGlzW3IuJGV4dHJhXS5hZnRlckJyZWFrQWZ0ZXIpcmV0dXJuIG8uSFRNTFJlc3VsdC5FTVBUWTsoMCxzLmZpeERpbWVuc2lvbnMpKHRoaXMpO2NvbnN0IHQ9W10sYT17aWQ6dGhpc1tyLiR1aWRdLGNsYXNzOltdfTsoMCxzLnNldEFjY2VzcykodGhpcyxhLmNsYXNzKTt0aGlzW3IuJGV4dHJhXXx8KHRoaXNbci4kZXh0cmFdPU9iamVjdC5jcmVhdGUobnVsbCkpO09iamVjdC5hc3NpZ24odGhpc1tyLiRleHRyYV0se2NoaWxkcmVuOnQsbGluZTpudWxsLGF0dHJpYnV0ZXM6YSxhdHRlbXB0OjAsbnVtYmVySW5MaW5lOjAsYXZhaWxhYmxlU3BhY2U6e3dpZHRoOk1hdGgubWluKHRoaXMud3x8MS8wLGUud2lkdGgpLGhlaWdodDpNYXRoLm1pbih0aGlzLmh8fDEvMCxlLmhlaWdodCl9LHdpZHRoOjAsaGVpZ2h0OjAscHJldkhlaWdodDowLGN1cnJlbnRXaWR0aDowfSk7Y29uc3Qgbj10aGlzW3IuJGdldFRlbXBsYXRlUm9vdF0oKSxsPW5bci4kZXh0cmFdLm5vTGF5b3V0RmFpbHVyZSxoPXRoaXNbci4kaXNTcGxpdHRhYmxlXSgpO2h8fHNldEZpcnN0VW5zcGxpdHRhYmxlKHRoaXMpO2lmKCEoMCxpLmNoZWNrRGltZW5zaW9ucykodGhpcyxlKSlyZXR1cm4gby5IVE1MUmVzdWx0LkZBSUxVUkU7Y29uc3QgdT1uZXcgU2V0KFsiYXJlYSIsImRyYXciLCJleGNsR3JvdXAiLCJmaWVsZCIsInN1YmZvcm0iLCJzdWJmb3JtU2V0Il0pO2lmKHRoaXMubGF5b3V0LmluY2x1ZGVzKCJyb3ciKSl7Y29uc3QgZT10aGlzW3IuJGdldFN1YmZvcm1QYXJlbnRdKCkuY29sdW1uV2lkdGhzO2lmKEFycmF5LmlzQXJyYXkoZSkmJmUubGVuZ3RoPjApe3RoaXNbci4kZXh0cmFdLmNvbHVtbldpZHRocz1lO3RoaXNbci4kZXh0cmFdLmN1cnJlbnRDb2x1bW49MH19Y29uc3QgZD0oMCxzLnRvU3R5bGUpKHRoaXMsImFuY2hvclR5cGUiLCJkaW1lbnNpb25zIiwicG9zaXRpb24iLCJwcmVzZW5jZSIsImJvcmRlciIsIm1hcmdpbiIsImhBbGlnbiIpLGY9WyJ4ZmFTdWJmb3JtIl0sZz0oMCxzLmxheW91dENsYXNzKSh0aGlzKTtnJiZmLnB1c2goZyk7YS5zdHlsZT1kO2EuY2xhc3M9Zjt0aGlzLm5hbWUmJihhLnhmYU5hbWU9dGhpcy5uYW1lKTtpZih0aGlzLm92ZXJmbG93KXtjb25zdCB0PXRoaXMub3ZlcmZsb3dbci4kZ2V0RXh0cmFdKCk7aWYodC5hZGRMZWFkZXIpe3QuYWRkTGVhZGVyPSExO2hhbmRsZU92ZXJmbG93KHRoaXMsdC5sZWFkZXIsZSl9fXRoaXNbci4kcHVzaFBhcmFdKCk7Y29uc3QgcD0ibHItdGIiPT09dGhpcy5sYXlvdXR8fCJybC10YiI9PT10aGlzLmxheW91dCxtPXA/MjoxO2Zvcig7dGhpc1tyLiRleHRyYV0uYXR0ZW1wdDxtO3RoaXNbci4kZXh0cmFdLmF0dGVtcHQrKyl7cCYmMT09PXRoaXNbci4kZXh0cmFdLmF0dGVtcHQmJih0aGlzW3IuJGV4dHJhXS5udW1iZXJJbkxpbmU9MCk7Y29uc3QgZT10aGlzW3IuJGNoaWxkcmVuVG9IVE1MXSh7ZmlsdGVyOnUsaW5jbHVkZTohMH0pO2lmKGUuc3VjY2VzcylicmVhaztpZihlLmlzQnJlYWsoKSl7dGhpc1tyLiRwb3BQYXJhXSgpO3JldHVybiBlfWlmKHAmJjA9PT10aGlzW3IuJGV4dHJhXS5hdHRlbXB0JiYwPT09dGhpc1tyLiRleHRyYV0ubnVtYmVySW5MaW5lJiYhbltyLiRleHRyYV0ubm9MYXlvdXRGYWlsdXJlKXt0aGlzW3IuJGV4dHJhXS5hdHRlbXB0PW07YnJlYWt9fXRoaXNbci4kcG9wUGFyYV0oKTtofHx1bnNldEZpcnN0VW5zcGxpdHRhYmxlKHRoaXMpO25bci4kZXh0cmFdLm5vTGF5b3V0RmFpbHVyZT1sO2lmKHRoaXNbci4kZXh0cmFdLmF0dGVtcHQ9PT1tKXt0aGlzLm92ZXJmbG93JiYodGhpc1tyLiRnZXRUZW1wbGF0ZVJvb3RdKClbci4kZXh0cmFdLm92ZXJmbG93Tm9kZT10aGlzLm92ZXJmbG93KTtofHxkZWxldGUgdGhpc1tyLiRleHRyYV07cmV0dXJuIG8uSFRNTFJlc3VsdC5GQUlMVVJFfWlmKHRoaXMub3ZlcmZsb3cpe2NvbnN0IHQ9dGhpcy5vdmVyZmxvd1tyLiRnZXRFeHRyYV0oKTtpZih0LmFkZFRyYWlsZXIpe3QuYWRkVHJhaWxlcj0hMTtoYW5kbGVPdmVyZmxvdyh0aGlzLHQudHJhaWxlcixlKX19bGV0IGI9MCx5PTA7aWYodGhpcy5tYXJnaW4pe2I9dGhpcy5tYXJnaW4ubGVmdEluc2V0K3RoaXMubWFyZ2luLnJpZ2h0SW5zZXQ7eT10aGlzLm1hcmdpbi50b3BJbnNldCt0aGlzLm1hcmdpbi5ib3R0b21JbnNldH1jb25zdCB3PU1hdGgubWF4KHRoaXNbci4kZXh0cmFdLndpZHRoK2IsdGhpcy53fHwwKSxTPU1hdGgubWF4KHRoaXNbci4kZXh0cmFdLmhlaWdodCt5LHRoaXMuaHx8MCkseD1bdGhpcy54LHRoaXMueSx3LFNdOyIiPT09dGhpcy53JiYoZC53aWR0aD0oMCxzLm1lYXN1cmVUb1N0cmluZykodykpOyIiPT09dGhpcy5oJiYoZC5oZWlnaHQ9KDAscy5tZWFzdXJlVG9TdHJpbmcpKFMpKTtpZigoIjBweCI9PT1kLndpZHRofHwiMHB4Ij09PWQuaGVpZ2h0KSYmMD09PXQubGVuZ3RoKXJldHVybiBvLkhUTUxSZXN1bHQuRU1QVFk7Y29uc3Qgaz17bmFtZToiZGl2IixhdHRyaWJ1dGVzOmEsY2hpbGRyZW46dH07YXBwbHlBc3Npc3QodGhpcyxhKTtjb25zdCBDPW8uSFRNTFJlc3VsdC5zdWNjZXNzKCgwLHMuY3JlYXRlV3JhcHBlcikodGhpcyxrKSx4KTtpZih0aGlzLmJyZWFrQWZ0ZXIuY2hpbGRyZW4ubGVuZ3RoPj0xKXtjb25zdCBlPXRoaXMuYnJlYWtBZnRlci5jaGlsZHJlblswXTtpZihoYW5kbGVCcmVhayhlKSl7dGhpc1tyLiRleHRyYV0uYWZ0ZXJCcmVha0FmdGVyPUM7cmV0dXJuIG8uSFRNTFJlc3VsdC5icmVha05vZGUoZSl9fWRlbGV0ZSB0aGlzW3IuJGV4dHJhXTtyZXR1cm4gQ319Y2xhc3MgU3ViZm9ybVNldCBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsInN1YmZvcm1TZXQiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMucmVsYXRpb249KDAsby5nZXRTdHJpbmdPcHRpb24pKGUucmVsYXRpb24sWyJvcmRlcmVkIiwiY2hvaWNlIiwidW5vcmRlcmVkIl0pO3RoaXMucmVsZXZhbnQ9KDAsby5nZXRSZWxldmFudCkoZS5yZWxldmFudCk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuYm9va2VuZD1udWxsO3RoaXMuYnJlYWs9bnVsbDt0aGlzLmRlc2M9bnVsbDt0aGlzLmV4dHJhcz1udWxsO3RoaXMub2NjdXI9bnVsbDt0aGlzLm92ZXJmbG93PW51bGw7dGhpcy5icmVha0FmdGVyPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuYnJlYWtCZWZvcmU9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5zdWJmb3JtPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuc3ViZm9ybVNldD1uZXcgci5YRkFPYmplY3RBcnJheX0qW3IuJGdldENvbnRhaW5lZENoaWxkcmVuXSgpe3lpZWxkKmdldENvbnRhaW5lZENoaWxkcmVuKHRoaXMpfVtyLiRnZXRTdWJmb3JtUGFyZW50XSgpe2xldCBlPXRoaXNbci4kZ2V0UGFyZW50XSgpO2Zvcig7IShlIGluc3RhbmNlb2YgU3ViZm9ybSk7KWU9ZVtyLiRnZXRQYXJlbnRdKCk7cmV0dXJuIGV9W3IuJGlzQmluZGFibGVdKCl7cmV0dXJuITB9fWNsYXNzIFN1YmplY3RETiBleHRlbmRzIHIuQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJzdWJqZWN0RE4iKTt0aGlzLmRlbGltaXRlcj1lLmRlbGltaXRlcnx8IiwiO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifVtyLiRmaW5hbGl6ZV0oKXt0aGlzW3IuJGNvbnRlbnRdPW5ldyBNYXAodGhpc1tyLiRjb250ZW50XS5zcGxpdCh0aGlzLmRlbGltaXRlcikubWFwKChlPT57KGU9ZS5zcGxpdCgiPSIsMikpWzBdPWVbMF0udHJpbSgpO3JldHVybiBlfSkpKX19Y2xhc3MgU3ViamVjdEROcyBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsInN1YmplY3RETnMiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT0oMCxvLmdldFN0cmluZ09wdGlvbikoZS50eXBlLFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5zdWJqZWN0RE49bmV3IHIuWEZBT2JqZWN0QXJyYXl9fWNsYXNzIFN1Ym1pdCBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsInN1Ym1pdCIsITApO3RoaXMuZW1iZWRQREY9KDAsby5nZXRJbnRlZ2VyKSh7ZGF0YTplLmVtYmVkUERGLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy5mb3JtYXQ9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuZm9ybWF0LFsieGRwIiwiZm9ybWRhdGEiLCJwZGYiLCJ1cmxlbmNvZGVkIiwieGZkIiwieG1sIl0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy50YXJnZXQ9ZS50YXJnZXR8fCIiO3RoaXMudGV4dEVuY29kaW5nPSgwLG8uZ2V0S2V5d29yZCkoe2RhdGE6ZS50ZXh0RW5jb2Rpbmc/ZS50ZXh0RW5jb2RpbmcudG9Mb3dlckNhc2UoKToiIixkZWZhdWx0VmFsdWU6IiIsdmFsaWRhdGU6ZT0+WyJ1dGYtOCIsImJpZy1maXZlIiwiZm9udHNwZWNpZmljIiwiZ2JrIiwiZ2ItMTgwMzAiLCJnYi0yMzEyIiwia3NjLTU2MDEiLCJub25lIiwic2hpZnQtamlzIiwidWNzLTIiLCJ1dGYtMTYiXS5pbmNsdWRlcyhlKXx8ZS5tYXRjaCgvaXNvLTg4NTktXGR7Mn0vKX0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLnhkcENvbnRlbnQ9ZS54ZHBDb250ZW50fHwiIjt0aGlzLmVuY3J5cHQ9bnVsbDt0aGlzLmVuY3J5cHREYXRhPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuc2lnbkRhdGE9bmV3IHIuWEZBT2JqZWN0QXJyYXl9fWNsYXNzIFRlbXBsYXRlIGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwidGVtcGxhdGUiLCEwKTt0aGlzLmJhc2VQcm9maWxlPSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLmJhc2VQcm9maWxlLFsiZnVsbCIsImludGVyYWN0aXZlRm9ybXMiXSk7dGhpcy5leHRyYXM9bnVsbDt0aGlzLnN1YmZvcm09bmV3IHIuWEZBT2JqZWN0QXJyYXl9W3IuJGZpbmFsaXplXSgpezA9PT10aGlzLnN1YmZvcm0uY2hpbGRyZW4ubGVuZ3RoJiYoMCxjLndhcm4pKCJYRkEgLSBObyBzdWJmb3JtcyBpbiB0ZW1wbGF0ZSBub2RlLiIpO3RoaXMuc3ViZm9ybS5jaGlsZHJlbi5sZW5ndGg+PTImJigwLGMud2FybikoIlhGQSAtIFNldmVyYWwgc3ViZm9ybXMgaW4gdGVtcGxhdGUgbm9kZTogcGxlYXNlIGZpbGUgYSBidWcuIik7dGhpc1tyLiR0YWJJbmRleF09NWUzfVtyLiRpc1NwbGl0dGFibGVdKCl7cmV0dXJuITB9W3IuJHNlYXJjaE5vZGVdKGUsdCl7cmV0dXJuIGUuc3RhcnRzV2l0aCgiIyIpP1t0aGlzW3IuJGlkc10uZ2V0KGUuc2xpY2UoMSkpXTooMCx1LnNlYXJjaE5vZGUpKHRoaXMsdCxlLCEwLCEwKX0qW3IuJHRvUGFnZXNdKCl7aWYoIXRoaXMuc3ViZm9ybS5jaGlsZHJlbi5sZW5ndGgpcmV0dXJuIG8uSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJkaXYiLGNoaWxkcmVuOltdfSk7dGhpc1tyLiRleHRyYV09e292ZXJmbG93Tm9kZTpudWxsLGZpcnN0VW5zcGxpdHRhYmxlOm51bGwsY3VycmVudENvbnRlbnRBcmVhOm51bGwsY3VycmVudFBhZ2VBcmVhOm51bGwsbm9MYXlvdXRGYWlsdXJlOiExLHBhZ2VOdW1iZXI6MSxwYWdlUG9zaXRpb246ImZpcnN0IixvZGRPckV2ZW46Im9kZCIsYmxhbmtPck5vdEJsYW5rOiJub25CbGFuayIscGFyYVN0YWNrOltdfTtjb25zdCBlPXRoaXMuc3ViZm9ybS5jaGlsZHJlblswXTtlLnBhZ2VTZXRbci4kY2xlYW5QYWdlXSgpO2NvbnN0IHQ9ZS5wYWdlU2V0LnBhZ2VBcmVhLmNoaWxkcmVuLGE9e25hbWU6ImRpdiIsY2hpbGRyZW46W119O2xldCBuPW51bGwsaT1udWxsLHM9bnVsbDtpZihlLmJyZWFrQmVmb3JlLmNoaWxkcmVuLmxlbmd0aD49MSl7aT1lLmJyZWFrQmVmb3JlLmNoaWxkcmVuWzBdO3M9aS50YXJnZXR9ZWxzZSBpZihlLnN1YmZvcm0uY2hpbGRyZW4ubGVuZ3RoPj0xJiZlLnN1YmZvcm0uY2hpbGRyZW5bMF0uYnJlYWtCZWZvcmUuY2hpbGRyZW4ubGVuZ3RoPj0xKXtpPWUuc3ViZm9ybS5jaGlsZHJlblswXS5icmVha0JlZm9yZS5jaGlsZHJlblswXTtzPWkudGFyZ2V0fWVsc2UgaWYoZS5icmVhayYmZS5icmVhay5iZWZvcmVUYXJnZXQpe2k9ZS5icmVhaztzPWkuYmVmb3JlVGFyZ2V0fWVsc2UgaWYoZS5zdWJmb3JtLmNoaWxkcmVuLmxlbmd0aD49MSYmZS5zdWJmb3JtLmNoaWxkcmVuWzBdLmJyZWFrJiZlLnN1YmZvcm0uY2hpbGRyZW5bMF0uYnJlYWsuYmVmb3JlVGFyZ2V0KXtpPWUuc3ViZm9ybS5jaGlsZHJlblswXS5icmVhaztzPWkuYmVmb3JlVGFyZ2V0fWlmKGkpe2NvbnN0IGU9dGhpc1tyLiRzZWFyY2hOb2RlXShzLGlbci4kZ2V0UGFyZW50XSgpKTtpZihlIGluc3RhbmNlb2YgUGFnZUFyZWEpe249ZTtpW3IuJGV4dHJhXT17fX19bnx8KG49dFswXSk7bltyLiRleHRyYV09e251bWJlck9mVXNlOjF9O2NvbnN0IGw9bltyLiRnZXRQYXJlbnRdKCk7bFtyLiRleHRyYV09e251bWJlck9mVXNlOjEscGFnZUluZGV4OmwucGFnZUFyZWEuY2hpbGRyZW4uaW5kZXhPZihuKSxwYWdlU2V0SW5kZXg6MH07bGV0IGgsdT1udWxsLGQ9bnVsbCxmPSEwLGc9MCxwPTA7Zm9yKDs7KXtpZihmKWc9MDtlbHNle2EuY2hpbGRyZW4ucG9wKCk7aWYoMz09KytnKXsoMCxjLndhcm4pKCJYRkEgLSBTb21ldGhpbmcgZ29lcyB3cm9uZzogcGxlYXNlIGZpbGUgYSBidWcuIik7cmV0dXJuIGF9fWg9bnVsbDt0aGlzW3IuJGV4dHJhXS5jdXJyZW50UGFnZUFyZWE9bjtjb25zdCB0PW5bci4kdG9IVE1MXSgpLmh0bWw7YS5jaGlsZHJlbi5wdXNoKHQpO2lmKHUpe3RoaXNbci4kZXh0cmFdLm5vTGF5b3V0RmFpbHVyZT0hMDt0LmNoaWxkcmVuLnB1c2godVtyLiR0b0hUTUxdKG5bci4kZXh0cmFdLnNwYWNlKS5odG1sKTt1PW51bGx9aWYoZCl7dGhpc1tyLiRleHRyYV0ubm9MYXlvdXRGYWlsdXJlPSEwO3QuY2hpbGRyZW4ucHVzaChkW3IuJHRvSFRNTF0obltyLiRleHRyYV0uc3BhY2UpLmh0bWwpO2Q9bnVsbH1jb25zdCBpPW4uY29udGVudEFyZWEuY2hpbGRyZW4scz10LmNoaWxkcmVuLmZpbHRlcigoZT0+ZS5hdHRyaWJ1dGVzLmNsYXNzLmluY2x1ZGVzKCJ4ZmFDb250ZW50YXJlYSIpKSk7Zj0hMTt0aGlzW3IuJGV4dHJhXS5maXJzdFVuc3BsaXR0YWJsZT1udWxsO3RoaXNbci4kZXh0cmFdLm5vTGF5b3V0RmFpbHVyZT0hMTtjb25zdCBmbHVzaD10PT57Y29uc3QgYT1lW3IuJGZsdXNoSFRNTF0oKTtpZihhKXtmPWZ8fGEuY2hpbGRyZW4mJjAhPT1hLmNoaWxkcmVuLmxlbmd0aDtzW3RdLmNoaWxkcmVuLnB1c2goYSl9fTtmb3IobGV0IHQ9cCxuPWkubGVuZ3RoO3Q8bjt0Kyspe2NvbnN0IG49dGhpc1tyLiRleHRyYV0uY3VycmVudENvbnRlbnRBcmVhPWlbdF0sbz17d2lkdGg6bi53LGhlaWdodDpuLmh9O3A9MDtpZih1KXtzW3RdLmNoaWxkcmVuLnB1c2godVtyLiR0b0hUTUxdKG8pLmh0bWwpO3U9bnVsbH1pZihkKXtzW3RdLmNoaWxkcmVuLnB1c2goZFtyLiR0b0hUTUxdKG8pLmh0bWwpO2Q9bnVsbH1jb25zdCBjPWVbci4kdG9IVE1MXShvKTtpZihjLnN1Y2Nlc3Mpe2lmKGMuaHRtbCl7Zj1mfHxjLmh0bWwuY2hpbGRyZW4mJjAhPT1jLmh0bWwuY2hpbGRyZW4ubGVuZ3RoO3NbdF0uY2hpbGRyZW4ucHVzaChjLmh0bWwpfWVsc2UhZiYmYS5jaGlsZHJlbi5sZW5ndGg+MSYmYS5jaGlsZHJlbi5wb3AoKTtyZXR1cm4gYX1pZihjLmlzQnJlYWsoKSl7Y29uc3QgZT1jLmJyZWFrTm9kZTtmbHVzaCh0KTtpZigiYXV0byI9PT1lLnRhcmdldFR5cGUpY29udGludWU7aWYoZS5sZWFkZXIpe3U9dGhpc1tyLiRzZWFyY2hOb2RlXShlLmxlYWRlcixlW3IuJGdldFBhcmVudF0oKSk7dT11P3VbMF06bnVsbH1pZihlLnRyYWlsZXIpe2Q9dGhpc1tyLiRzZWFyY2hOb2RlXShlLnRyYWlsZXIsZVtyLiRnZXRQYXJlbnRdKCkpO2Q9ZD9kWzBdOm51bGx9aWYoInBhZ2VBcmVhIj09PWUudGFyZ2V0VHlwZSl7aD1lW3IuJGV4dHJhXS50YXJnZXQ7dD0xLzB9ZWxzZSBpZihlW3IuJGV4dHJhXS50YXJnZXQpe2g9ZVtyLiRleHRyYV0udGFyZ2V0O3A9ZVtyLiRleHRyYV0uaW5kZXgrMTt0PTEvMH1lbHNlIHQ9ZVtyLiRleHRyYV0uaW5kZXh9ZWxzZSBpZih0aGlzW3IuJGV4dHJhXS5vdmVyZmxvd05vZGUpe2NvbnN0IGU9dGhpc1tyLiRleHRyYV0ub3ZlcmZsb3dOb2RlO3RoaXNbci4kZXh0cmFdLm92ZXJmbG93Tm9kZT1udWxsO2NvbnN0IGE9ZVtyLiRnZXRFeHRyYV0oKSxuPWEudGFyZ2V0O2EuYWRkTGVhZGVyPW51bGwhPT1hLmxlYWRlcjthLmFkZFRyYWlsZXI9bnVsbCE9PWEudHJhaWxlcjtmbHVzaCh0KTtjb25zdCBzPXQ7dD0xLzA7aWYobiBpbnN0YW5jZW9mIFBhZ2VBcmVhKWg9bjtlbHNlIGlmKG4gaW5zdGFuY2VvZiBDb250ZW50QXJlYSl7Y29uc3QgZT1pLmluZGV4T2Yobik7aWYoLTEhPT1lKWU+cz90PWUtMTpwPWU7ZWxzZXtoPW5bci4kZ2V0UGFyZW50XSgpO3A9aC5jb250ZW50QXJlYS5jaGlsZHJlbi5pbmRleE9mKG4pfX19ZWxzZSBmbHVzaCh0KX10aGlzW3IuJGV4dHJhXS5wYWdlTnVtYmVyKz0xO2gmJihoW3IuJGlzVXNhYmxlXSgpP2hbci4kZXh0cmFdLm51bWJlck9mVXNlKz0xOmg9bnVsbCk7bj1ofHxuW3IuJGdldE5leHRQYWdlXSgpO3lpZWxkIG51bGx9fX10LlRlbXBsYXRlPVRlbXBsYXRlO2NsYXNzIFRleHQgZXh0ZW5kcyByLkNvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwidGV4dCIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5tYXhDaGFycz0oMCxvLmdldEludGVnZXIpKHtkYXRhOmUubWF4Q2hhcnMsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+ZT49MH0pO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMucmlkPWUucmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9W3IuJGFjY2VwdFdoaXRlc3BhY2VdKCl7cmV0dXJuITB9W3IuJG9uQ2hpbGRdKGUpe2lmKGVbci4kbmFtZXNwYWNlSWRdPT09bi5OYW1lc3BhY2VJZHMueGh0bWwuaWQpe3RoaXNbci4kY29udGVudF09ZTtyZXR1cm4hMH0oMCxjLndhcm4pKGBYRkEgLSBJbnZhbGlkIGNvbnRlbnQgaW4gVGV4dDogJHtlW3IuJG5vZGVOYW1lXX0uYCk7cmV0dXJuITF9W3IuJG9uVGV4dF0oZSl7dGhpc1tyLiRjb250ZW50XWluc3RhbmNlb2Ygci5YRkFPYmplY3R8fHN1cGVyW3IuJG9uVGV4dF0oZSl9W3IuJGZpbmFsaXplXSgpeyJzdHJpbmciPT10eXBlb2YgdGhpc1tyLiRjb250ZW50XSYmKHRoaXNbci4kY29udGVudF09dGhpc1tyLiRjb250ZW50XS5yZXBsYWNlKC9cclxuL2csIlxuIikpfVtyLiRnZXRFeHRyYV0oKXtyZXR1cm4ic3RyaW5nIj09dHlwZW9mIHRoaXNbci4kY29udGVudF0/dGhpc1tyLiRjb250ZW50XS5zcGxpdCgvW1x1MjAyOVx1MjAyOFxuXS8pLnJlZHVjZSgoKGUsdCk9Pnt0JiZlLnB1c2godCk7cmV0dXJuIGV9KSxbXSkuam9pbigiXG4iKTp0aGlzW3IuJGNvbnRlbnRdW3IuJHRleHRdKCl9W3IuJHRvSFRNTF0oZSl7aWYoInN0cmluZyI9PXR5cGVvZiB0aGlzW3IuJGNvbnRlbnRdKXtjb25zdCBlPXZhbHVlVG9IdG1sKHRoaXNbci4kY29udGVudF0pLmh0bWw7aWYodGhpc1tyLiRjb250ZW50XS5pbmNsdWRlcygiXHUyMDI5Iikpe2UubmFtZT0iZGl2IjtlLmNoaWxkcmVuPVtdO3RoaXNbci4kY29udGVudF0uc3BsaXQoIlx1MjAyOSIpLm1hcCgoZT0+ZS5zcGxpdCgvW1x1MjAyOFxuXS8pLnJlZHVjZSgoKGUsdCk9PntlLnB1c2goe25hbWU6InNwYW4iLHZhbHVlOnR9LHtuYW1lOiJiciJ9KTtyZXR1cm4gZX0pLFtdKSkpLmZvckVhY2goKHQ9PntlLmNoaWxkcmVuLnB1c2goe25hbWU6InAiLGNoaWxkcmVuOnR9KX0pKX1lbHNlIGlmKC9bXHUyMDI4XG5dLy50ZXN0KHRoaXNbci4kY29udGVudF0pKXtlLm5hbWU9ImRpdiI7ZS5jaGlsZHJlbj1bXTt0aGlzW3IuJGNvbnRlbnRdLnNwbGl0KC9bXHUyMDI4XG5dLykuZm9yRWFjaCgodD0+e2UuY2hpbGRyZW4ucHVzaCh7bmFtZToic3BhbiIsdmFsdWU6dH0se25hbWU6ImJyIn0pfSkpfXJldHVybiBvLkhUTUxSZXN1bHQuc3VjY2VzcyhlKX1yZXR1cm4gdGhpc1tyLiRjb250ZW50XVtyLiR0b0hUTUxdKGUpfX10LlRleHQ9VGV4dDtjbGFzcyBUZXh0RWRpdCBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsInRleHRFZGl0IiwhMCk7dGhpcy5hbGxvd1JpY2hUZXh0PSgwLG8uZ2V0SW50ZWdlcikoe2RhdGE6ZS5hbGxvd1JpY2hUZXh0LGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy5oU2Nyb2xsUG9saWN5PSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLmhTY3JvbGxQb2xpY3ksWyJhdXRvIiwib2ZmIiwib24iXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm11bHRpTGluZT0oMCxvLmdldEludGVnZXIpKHtkYXRhOmUubXVsdGlMaW5lLGRlZmF1bHRWYWx1ZToiIix2YWxpZGF0ZTplPT4wPT09ZXx8MT09PWV9KTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy52U2Nyb2xsUG9saWN5PSgwLG8uZ2V0U3RyaW5nT3B0aW9uKShlLnZTY3JvbGxQb2xpY3ksWyJhdXRvIiwib2ZmIiwib24iXSk7dGhpcy5ib3JkZXI9bnVsbDt0aGlzLmNvbWI9bnVsbDt0aGlzLmV4dHJhcz1udWxsO3RoaXMubWFyZ2luPW51bGx9W3IuJHRvSFRNTF0oZSl7Y29uc3QgdD0oMCxzLnRvU3R5bGUpKHRoaXMsImJvcmRlciIsImZvbnQiLCJtYXJnaW4iKTtsZXQgYTtjb25zdCBuPXRoaXNbci4kZ2V0UGFyZW50XSgpW3IuJGdldFBhcmVudF0oKTsiIj09PXRoaXMubXVsdGlMaW5lJiYodGhpcy5tdWx0aUxpbmU9biBpbnN0YW5jZW9mIERyYXc/MTowKTthPTE9PT10aGlzLm11bHRpTGluZT97bmFtZToidGV4dGFyZWEiLGF0dHJpYnV0ZXM6e2RhdGFJZDpuW3IuJGRhdGFdJiZuW3IuJGRhdGFdW3IuJHVpZF18fG5bci4kdWlkXSxmaWVsZElkOm5bci4kdWlkXSxjbGFzczpbInhmYVRleHRmaWVsZCJdLHN0eWxlOnQsImFyaWEtbGFiZWwiOmFyaWFMYWJlbChuKSwiYXJpYS1yZXF1aXJlZCI6ITF9fTp7bmFtZToiaW5wdXQiLGF0dHJpYnV0ZXM6e3R5cGU6InRleHQiLGRhdGFJZDpuW3IuJGRhdGFdJiZuW3IuJGRhdGFdW3IuJHVpZF18fG5bci4kdWlkXSxmaWVsZElkOm5bci4kdWlkXSxjbGFzczpbInhmYVRleHRmaWVsZCJdLHN0eWxlOnQsImFyaWEtbGFiZWwiOmFyaWFMYWJlbChuKSwiYXJpYS1yZXF1aXJlZCI6ITF9fTtpZihpc1JlcXVpcmVkKG4pKXthLmF0dHJpYnV0ZXNbImFyaWEtcmVxdWlyZWQiXT0hMDthLmF0dHJpYnV0ZXMucmVxdWlyZWQ9ITB9cmV0dXJuIG8uSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJsYWJlbCIsYXR0cmlidXRlczp7Y2xhc3M6WyJ4ZmFMYWJlbCJdfSxjaGlsZHJlbjpbYV19KX19Y2xhc3MgVGltZSBleHRlbmRzIHIuU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsInRpbWUiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn1bci4kZmluYWxpemVdKCl7Y29uc3QgZT10aGlzW3IuJGNvbnRlbnRdLnRyaW0oKTt0aGlzW3IuJGNvbnRlbnRdPWU/bmV3IERhdGUoZSk6bnVsbH1bci4kdG9IVE1MXShlKXtyZXR1cm4gdmFsdWVUb0h0bWwodGhpc1tyLiRjb250ZW50XT90aGlzW3IuJGNvbnRlbnRdLnRvU3RyaW5nKCk6IiIpfX1jbGFzcyBUaW1lU3RhbXAgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJ0aW1lU3RhbXAiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMuc2VydmVyPWUuc2VydmVyfHwiIjt0aGlzLnR5cGU9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUudHlwZSxbIm9wdGlvbmFsIiwicmVxdWlyZWQiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBUb29sVGlwIGV4dGVuZHMgci5TdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwidG9vbFRpcCIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5yaWQ9ZS5yaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgVHJhdmVyc2FsIGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwidHJhdmVyc2FsIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbDt0aGlzLnRyYXZlcnNlPW5ldyByLlhGQU9iamVjdEFycmF5fX1jbGFzcyBUcmF2ZXJzZSBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsInRyYXZlcnNlIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm9wZXJhdGlvbj0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5vcGVyYXRpb24sWyJuZXh0IiwiYmFjayIsImRvd24iLCJmaXJzdCIsImxlZnQiLCJyaWdodCIsInVwIl0pO3RoaXMucmVmPWUucmVmfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbDt0aGlzLnNjcmlwdD1udWxsfWdldCBuYW1lKCl7cmV0dXJuIHRoaXMub3BlcmF0aW9ufVtyLiRpc1RyYW5zcGFyZW50XSgpe3JldHVybiExfX1jbGFzcyBVaSBleHRlbmRzIHIuWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGQsInVpIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbDt0aGlzLnBpY3R1cmU9bnVsbDt0aGlzLmJhcmNvZGU9bnVsbDt0aGlzLmJ1dHRvbj1udWxsO3RoaXMuY2hlY2tCdXR0b249bnVsbDt0aGlzLmNob2ljZUxpc3Q9bnVsbDt0aGlzLmRhdGVUaW1lRWRpdD1udWxsO3RoaXMuZGVmYXVsdFVpPW51bGw7dGhpcy5pbWFnZUVkaXQ9bnVsbDt0aGlzLm51bWVyaWNFZGl0PW51bGw7dGhpcy5wYXNzd29yZEVkaXQ9bnVsbDt0aGlzLnNpZ25hdHVyZT1udWxsO3RoaXMudGV4dEVkaXQ9bnVsbH1bci4kZ2V0RXh0cmFdKCl7aWYodm9pZCAwPT09dGhpc1tyLiRleHRyYV0pe2Zvcihjb25zdCBlIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKXtpZigiZXh0cmFzIj09PWV8fCJwaWN0dXJlIj09PWUpY29udGludWU7Y29uc3QgdD10aGlzW2VdO2lmKHQgaW5zdGFuY2VvZiByLlhGQU9iamVjdCl7dGhpc1tyLiRleHRyYV09dDtyZXR1cm4gdH19dGhpc1tyLiRleHRyYV09bnVsbH1yZXR1cm4gdGhpc1tyLiRleHRyYV19W3IuJHRvSFRNTF0oZSl7Y29uc3QgdD10aGlzW3IuJGdldEV4dHJhXSgpO3JldHVybiB0P3Rbci4kdG9IVE1MXShlKTpvLkhUTUxSZXN1bHQuRU1QVFl9fWNsYXNzIFZhbGlkYXRlIGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwidmFsaWRhdGUiLCEwKTt0aGlzLmZvcm1hdFRlc3Q9KDAsby5nZXRTdHJpbmdPcHRpb24pKGUuZm9ybWF0VGVzdCxbIndhcm5pbmciLCJkaXNhYmxlZCIsImVycm9yIl0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5udWxsVGVzdD0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5udWxsVGVzdCxbImRpc2FibGVkIiwiZXJyb3IiLCJ3YXJuaW5nIl0pO3RoaXMuc2NyaXB0VGVzdD0oMCxvLmdldFN0cmluZ09wdGlvbikoZS5zY3JpcHRUZXN0LFsiZXJyb3IiLCJkaXNhYmxlZCIsIndhcm5pbmciXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5tZXNzYWdlPW51bGw7dGhpcy5waWN0dXJlPW51bGw7dGhpcy5zY3JpcHQ9bnVsbH19Y2xhc3MgVmFsdWUgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihkLCJ2YWx1ZSIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5vdmVycmlkZT0oMCxvLmdldEludGVnZXIpKHtkYXRhOmUub3ZlcnJpZGUsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV9KTt0aGlzLnJlbGV2YW50PSgwLG8uZ2V0UmVsZXZhbnQpKGUucmVsZXZhbnQpO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmFyYz1udWxsO3RoaXMuYm9vbGVhbj1udWxsO3RoaXMuZGF0ZT1udWxsO3RoaXMuZGF0ZVRpbWU9bnVsbDt0aGlzLmRlY2ltYWw9bnVsbDt0aGlzLmV4RGF0YT1udWxsO3RoaXMuZmxvYXQ9bnVsbDt0aGlzLmltYWdlPW51bGw7dGhpcy5pbnRlZ2VyPW51bGw7dGhpcy5saW5lPW51bGw7dGhpcy5yZWN0YW5nbGU9bnVsbDt0aGlzLnRleHQ9bnVsbDt0aGlzLnRpbWU9bnVsbH1bci4kc2V0VmFsdWVdKGUpe2NvbnN0IHQ9dGhpc1tyLiRnZXRQYXJlbnRdKCk7aWYodCBpbnN0YW5jZW9mIEZpZWxkJiZ0LnVpJiZ0LnVpLmltYWdlRWRpdCl7aWYoIXRoaXMuaW1hZ2Upe3RoaXMuaW1hZ2U9bmV3IEltYWdlKHt9KTt0aGlzW3IuJGFwcGVuZENoaWxkXSh0aGlzLmltYWdlKX10aGlzLmltYWdlW3IuJGNvbnRlbnRdPWVbci4kY29udGVudF07cmV0dXJufWNvbnN0IGE9ZVtyLiRub2RlTmFtZV07aWYobnVsbD09PXRoaXNbYV0pe2Zvcihjb25zdCBlIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKXtjb25zdCB0PXRoaXNbZV07aWYodCBpbnN0YW5jZW9mIHIuWEZBT2JqZWN0KXt0aGlzW2VdPW51bGw7dGhpc1tyLiRyZW1vdmVDaGlsZF0odCl9fXRoaXNbZVtyLiRub2RlTmFtZV1dPWU7dGhpc1tyLiRhcHBlbmRDaGlsZF0oZSl9ZWxzZSB0aGlzW2FdW3IuJGNvbnRlbnRdPWVbci4kY29udGVudF19W3IuJHRleHRdKCl7aWYodGhpcy5leERhdGEpcmV0dXJuInN0cmluZyI9PXR5cGVvZiB0aGlzLmV4RGF0YVtyLiRjb250ZW50XT90aGlzLmV4RGF0YVtyLiRjb250ZW50XS50cmltKCk6dGhpcy5leERhdGFbci4kY29udGVudF1bci4kdGV4dF0oKS50cmltKCk7Zm9yKGNvbnN0IGUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpe2lmKCJpbWFnZSI9PT1lKWNvbnRpbnVlO2NvbnN0IHQ9dGhpc1tlXTtpZih0IGluc3RhbmNlb2Ygci5YRkFPYmplY3QpcmV0dXJuKHRbci4kY29udGVudF18fCIiKS50b1N0cmluZygpLnRyaW0oKX1yZXR1cm4gbnVsbH1bci4kdG9IVE1MXShlKXtmb3IoY29uc3QgdCBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSl7Y29uc3QgYT10aGlzW3RdO2lmKGEgaW5zdGFuY2VvZiByLlhGQU9iamVjdClyZXR1cm4gYVtyLiR0b0hUTUxdKGUpfXJldHVybiBvLkhUTUxSZXN1bHQuRU1QVFl9fXQuVmFsdWU9VmFsdWU7Y2xhc3MgVmFyaWFibGVzIGV4dGVuZHMgci5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZCwidmFyaWFibGVzIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5ib29sZWFuPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuZGF0ZT1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmRhdGVUaW1lPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuZGVjaW1hbD1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmV4RGF0YT1uZXcgci5YRkFPYmplY3RBcnJheTt0aGlzLmZsb2F0PW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMuaW1hZ2U9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5pbnRlZ2VyPW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMubWFuaWZlc3Q9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy5zY3JpcHQ9bmV3IHIuWEZBT2JqZWN0QXJyYXk7dGhpcy50ZXh0PW5ldyByLlhGQU9iamVjdEFycmF5O3RoaXMudGltZT1uZXcgci5YRkFPYmplY3RBcnJheX1bci4kaXNUcmFuc3BhcmVudF0oKXtyZXR1cm4hMH19Y2xhc3MgVGVtcGxhdGVOYW1lc3BhY2V7c3RhdGljW24uJGJ1aWxkWEZBT2JqZWN0XShlLHQpe2lmKFRlbXBsYXRlTmFtZXNwYWNlLmhhc093blByb3BlcnR5KGUpKXtjb25zdCBhPVRlbXBsYXRlTmFtZXNwYWNlW2VdKHQpO2Fbci4kc2V0U2V0QXR0cmlidXRlc10odCk7cmV0dXJuIGF9fXN0YXRpYyBhcHBlYXJhbmNlRmlsdGVyKGUpe3JldHVybiBuZXcgQXBwZWFyYW5jZUZpbHRlcihlKX1zdGF0aWMgYXJjKGUpe3JldHVybiBuZXcgQXJjKGUpfXN0YXRpYyBhcmVhKGUpe3JldHVybiBuZXcgQXJlYShlKX1zdGF0aWMgYXNzaXN0KGUpe3JldHVybiBuZXcgQXNzaXN0KGUpfXN0YXRpYyBiYXJjb2RlKGUpe3JldHVybiBuZXcgQmFyY29kZShlKX1zdGF0aWMgYmluZChlKXtyZXR1cm4gbmV3IEJpbmQoZSl9c3RhdGljIGJpbmRJdGVtcyhlKXtyZXR1cm4gbmV3IEJpbmRJdGVtcyhlKX1zdGF0aWMgYm9va2VuZChlKXtyZXR1cm4gbmV3IEJvb2tlbmQoZSl9c3RhdGljIGJvb2xlYW4oZSl7cmV0dXJuIG5ldyBCb29sZWFuRWxlbWVudChlKX1zdGF0aWMgYm9yZGVyKGUpe3JldHVybiBuZXcgQm9yZGVyKGUpfXN0YXRpYyBicmVhayhlKXtyZXR1cm4gbmV3IEJyZWFrKGUpfXN0YXRpYyBicmVha0FmdGVyKGUpe3JldHVybiBuZXcgQnJlYWtBZnRlcihlKX1zdGF0aWMgYnJlYWtCZWZvcmUoZSl7cmV0dXJuIG5ldyBCcmVha0JlZm9yZShlKX1zdGF0aWMgYnV0dG9uKGUpe3JldHVybiBuZXcgQnV0dG9uKGUpfXN0YXRpYyBjYWxjdWxhdGUoZSl7cmV0dXJuIG5ldyBDYWxjdWxhdGUoZSl9c3RhdGljIGNhcHRpb24oZSl7cmV0dXJuIG5ldyBDYXB0aW9uKGUpfXN0YXRpYyBjZXJ0aWZpY2F0ZShlKXtyZXR1cm4gbmV3IENlcnRpZmljYXRlKGUpfXN0YXRpYyBjZXJ0aWZpY2F0ZXMoZSl7cmV0dXJuIG5ldyBDZXJ0aWZpY2F0ZXMoZSl9c3RhdGljIGNoZWNrQnV0dG9uKGUpe3JldHVybiBuZXcgQ2hlY2tCdXR0b24oZSl9c3RhdGljIGNob2ljZUxpc3QoZSl7cmV0dXJuIG5ldyBDaG9pY2VMaXN0KGUpfXN0YXRpYyBjb2xvcihlKXtyZXR1cm4gbmV3IENvbG9yKGUpfXN0YXRpYyBjb21iKGUpe3JldHVybiBuZXcgQ29tYihlKX1zdGF0aWMgY29ubmVjdChlKXtyZXR1cm4gbmV3IENvbm5lY3QoZSl9c3RhdGljIGNvbnRlbnRBcmVhKGUpe3JldHVybiBuZXcgQ29udGVudEFyZWEoZSl9c3RhdGljIGNvcm5lcihlKXtyZXR1cm4gbmV3IENvcm5lcihlKX1zdGF0aWMgZGF0ZShlKXtyZXR1cm4gbmV3IERhdGVFbGVtZW50KGUpfXN0YXRpYyBkYXRlVGltZShlKXtyZXR1cm4gbmV3IERhdGVUaW1lKGUpfXN0YXRpYyBkYXRlVGltZUVkaXQoZSl7cmV0dXJuIG5ldyBEYXRlVGltZUVkaXQoZSl9c3RhdGljIGRlY2ltYWwoZSl7cmV0dXJuIG5ldyBEZWNpbWFsKGUpfXN0YXRpYyBkZWZhdWx0VWkoZSl7cmV0dXJuIG5ldyBEZWZhdWx0VWkoZSl9c3RhdGljIGRlc2MoZSl7cmV0dXJuIG5ldyBEZXNjKGUpfXN0YXRpYyBkaWdlc3RNZXRob2QoZSl7cmV0dXJuIG5ldyBEaWdlc3RNZXRob2QoZSl9c3RhdGljIGRpZ2VzdE1ldGhvZHMoZSl7cmV0dXJuIG5ldyBEaWdlc3RNZXRob2RzKGUpfXN0YXRpYyBkcmF3KGUpe3JldHVybiBuZXcgRHJhdyhlKX1zdGF0aWMgZWRnZShlKXtyZXR1cm4gbmV3IEVkZ2UoZSl9c3RhdGljIGVuY29kaW5nKGUpe3JldHVybiBuZXcgRW5jb2RpbmcoZSl9c3RhdGljIGVuY29kaW5ncyhlKXtyZXR1cm4gbmV3IEVuY29kaW5ncyhlKX1zdGF0aWMgZW5jcnlwdChlKXtyZXR1cm4gbmV3IEVuY3J5cHQoZSl9c3RhdGljIGVuY3J5cHREYXRhKGUpe3JldHVybiBuZXcgRW5jcnlwdERhdGEoZSl9c3RhdGljIGVuY3J5cHRpb24oZSl7cmV0dXJuIG5ldyBFbmNyeXB0aW9uKGUpfXN0YXRpYyBlbmNyeXB0aW9uTWV0aG9kKGUpe3JldHVybiBuZXcgRW5jcnlwdGlvbk1ldGhvZChlKX1zdGF0aWMgZW5jcnlwdGlvbk1ldGhvZHMoZSl7cmV0dXJuIG5ldyBFbmNyeXB0aW9uTWV0aG9kcyhlKX1zdGF0aWMgZXZlbnQoZSl7cmV0dXJuIG5ldyBFdmVudChlKX1zdGF0aWMgZXhEYXRhKGUpe3JldHVybiBuZXcgRXhEYXRhKGUpfXN0YXRpYyBleE9iamVjdChlKXtyZXR1cm4gbmV3IEV4T2JqZWN0KGUpfXN0YXRpYyBleGNsR3JvdXAoZSl7cmV0dXJuIG5ldyBFeGNsR3JvdXAoZSl9c3RhdGljIGV4ZWN1dGUoZSl7cmV0dXJuIG5ldyBFeGVjdXRlKGUpfXN0YXRpYyBleHRyYXMoZSl7cmV0dXJuIG5ldyBFeHRyYXMoZSl9c3RhdGljIGZpZWxkKGUpe3JldHVybiBuZXcgRmllbGQoZSl9c3RhdGljIGZpbGwoZSl7cmV0dXJuIG5ldyBGaWxsKGUpfXN0YXRpYyBmaWx0ZXIoZSl7cmV0dXJuIG5ldyBGaWx0ZXIoZSl9c3RhdGljIGZsb2F0KGUpe3JldHVybiBuZXcgRmxvYXQoZSl9c3RhdGljIGZvbnQoZSl7cmV0dXJuIG5ldyBGb250KGUpfXN0YXRpYyBmb3JtYXQoZSl7cmV0dXJuIG5ldyBGb3JtYXQoZSl9c3RhdGljIGhhbmRsZXIoZSl7cmV0dXJuIG5ldyBIYW5kbGVyKGUpfXN0YXRpYyBoeXBoZW5hdGlvbihlKXtyZXR1cm4gbmV3IEh5cGhlbmF0aW9uKGUpfXN0YXRpYyBpbWFnZShlKXtyZXR1cm4gbmV3IEltYWdlKGUpfXN0YXRpYyBpbWFnZUVkaXQoZSl7cmV0dXJuIG5ldyBJbWFnZUVkaXQoZSl9c3RhdGljIGludGVnZXIoZSl7cmV0dXJuIG5ldyBJbnRlZ2VyKGUpfXN0YXRpYyBpc3N1ZXJzKGUpe3JldHVybiBuZXcgSXNzdWVycyhlKX1zdGF0aWMgaXRlbXMoZSl7cmV0dXJuIG5ldyBJdGVtcyhlKX1zdGF0aWMga2VlcChlKXtyZXR1cm4gbmV3IEtlZXAoZSl9c3RhdGljIGtleVVzYWdlKGUpe3JldHVybiBuZXcgS2V5VXNhZ2UoZSl9c3RhdGljIGxpbmUoZSl7cmV0dXJuIG5ldyBMaW5lKGUpfXN0YXRpYyBsaW5lYXIoZSl7cmV0dXJuIG5ldyBMaW5lYXIoZSl9c3RhdGljIGxvY2tEb2N1bWVudChlKXtyZXR1cm4gbmV3IExvY2tEb2N1bWVudChlKX1zdGF0aWMgbWFuaWZlc3QoZSl7cmV0dXJuIG5ldyBNYW5pZmVzdChlKX1zdGF0aWMgbWFyZ2luKGUpe3JldHVybiBuZXcgTWFyZ2luKGUpfXN0YXRpYyBtZHAoZSl7cmV0dXJuIG5ldyBNZHAoZSl9c3RhdGljIG1lZGl1bShlKXtyZXR1cm4gbmV3IE1lZGl1bShlKX1zdGF0aWMgbWVzc2FnZShlKXtyZXR1cm4gbmV3IE1lc3NhZ2UoZSl9c3RhdGljIG51bWVyaWNFZGl0KGUpe3JldHVybiBuZXcgTnVtZXJpY0VkaXQoZSl9c3RhdGljIG9jY3VyKGUpe3JldHVybiBuZXcgT2NjdXIoZSl9c3RhdGljIG9pZChlKXtyZXR1cm4gbmV3IE9pZChlKX1zdGF0aWMgb2lkcyhlKXtyZXR1cm4gbmV3IE9pZHMoZSl9c3RhdGljIG92ZXJmbG93KGUpe3JldHVybiBuZXcgT3ZlcmZsb3coZSl9c3RhdGljIHBhZ2VBcmVhKGUpe3JldHVybiBuZXcgUGFnZUFyZWEoZSl9c3RhdGljIHBhZ2VTZXQoZSl7cmV0dXJuIG5ldyBQYWdlU2V0KGUpfXN0YXRpYyBwYXJhKGUpe3JldHVybiBuZXcgUGFyYShlKX1zdGF0aWMgcGFzc3dvcmRFZGl0KGUpe3JldHVybiBuZXcgUGFzc3dvcmRFZGl0KGUpfXN0YXRpYyBwYXR0ZXJuKGUpe3JldHVybiBuZXcgUGF0dGVybihlKX1zdGF0aWMgcGljdHVyZShlKXtyZXR1cm4gbmV3IFBpY3R1cmUoZSl9c3RhdGljIHByb3RvKGUpe3JldHVybiBuZXcgUHJvdG8oZSl9c3RhdGljIHJhZGlhbChlKXtyZXR1cm4gbmV3IFJhZGlhbChlKX1zdGF0aWMgcmVhc29uKGUpe3JldHVybiBuZXcgUmVhc29uKGUpfXN0YXRpYyByZWFzb25zKGUpe3JldHVybiBuZXcgUmVhc29ucyhlKX1zdGF0aWMgcmVjdGFuZ2xlKGUpe3JldHVybiBuZXcgUmVjdGFuZ2xlKGUpfXN0YXRpYyByZWYoZSl7cmV0dXJuIG5ldyBSZWZFbGVtZW50KGUpfXN0YXRpYyBzY3JpcHQoZSl7cmV0dXJuIG5ldyBTY3JpcHQoZSl9c3RhdGljIHNldFByb3BlcnR5KGUpe3JldHVybiBuZXcgU2V0UHJvcGVydHkoZSl9c3RhdGljIHNpZ25EYXRhKGUpe3JldHVybiBuZXcgU2lnbkRhdGEoZSl9c3RhdGljIHNpZ25hdHVyZShlKXtyZXR1cm4gbmV3IFNpZ25hdHVyZShlKX1zdGF0aWMgc2lnbmluZyhlKXtyZXR1cm4gbmV3IFNpZ25pbmcoZSl9c3RhdGljIHNvbGlkKGUpe3JldHVybiBuZXcgU29saWQoZSl9c3RhdGljIHNwZWFrKGUpe3JldHVybiBuZXcgU3BlYWsoZSl9c3RhdGljIHN0aXBwbGUoZSl7cmV0dXJuIG5ldyBTdGlwcGxlKGUpfXN0YXRpYyBzdWJmb3JtKGUpe3JldHVybiBuZXcgU3ViZm9ybShlKX1zdGF0aWMgc3ViZm9ybVNldChlKXtyZXR1cm4gbmV3IFN1YmZvcm1TZXQoZSl9c3RhdGljIHN1YmplY3RETihlKXtyZXR1cm4gbmV3IFN1YmplY3RETihlKX1zdGF0aWMgc3ViamVjdEROcyhlKXtyZXR1cm4gbmV3IFN1YmplY3RETnMoZSl9c3RhdGljIHN1Ym1pdChlKXtyZXR1cm4gbmV3IFN1Ym1pdChlKX1zdGF0aWMgdGVtcGxhdGUoZSl7cmV0dXJuIG5ldyBUZW1wbGF0ZShlKX1zdGF0aWMgdGV4dChlKXtyZXR1cm4gbmV3IFRleHQoZSl9c3RhdGljIHRleHRFZGl0KGUpe3JldHVybiBuZXcgVGV4dEVkaXQoZSl9c3RhdGljIHRpbWUoZSl7cmV0dXJuIG5ldyBUaW1lKGUpfXN0YXRpYyB0aW1lU3RhbXAoZSl7cmV0dXJuIG5ldyBUaW1lU3RhbXAoZSl9c3RhdGljIHRvb2xUaXAoZSl7cmV0dXJuIG5ldyBUb29sVGlwKGUpfXN0YXRpYyB0cmF2ZXJzYWwoZSl7cmV0dXJuIG5ldyBUcmF2ZXJzYWwoZSl9c3RhdGljIHRyYXZlcnNlKGUpe3JldHVybiBuZXcgVHJhdmVyc2UoZSl9c3RhdGljIHVpKGUpe3JldHVybiBuZXcgVWkoZSl9c3RhdGljIHZhbGlkYXRlKGUpe3JldHVybiBuZXcgVmFsaWRhdGUoZSl9c3RhdGljIHZhbHVlKGUpe3JldHVybiBuZXcgVmFsdWUoZSl9c3RhdGljIHZhcmlhYmxlcyhlKXtyZXR1cm4gbmV3IFZhcmlhYmxlcyhlKX19dC5UZW1wbGF0ZU5hbWVzcGFjZT1UZW1wbGF0ZU5hbWVzcGFjZX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LmFkZEhUTUw9ZnVuY3Rpb24gYWRkSFRNTChlLHQsYSl7Y29uc3QgaT1lW3IuJGV4dHJhXSxzPWkuYXZhaWxhYmxlU3BhY2UsW28sYyxsLGhdPWE7c3dpdGNoKGUubGF5b3V0KXtjYXNlInBvc2l0aW9uIjppLndpZHRoPU1hdGgubWF4KGkud2lkdGgsbytsKTtpLmhlaWdodD1NYXRoLm1heChpLmhlaWdodCxjK2gpO2kuY2hpbGRyZW4ucHVzaCh0KTticmVhaztjYXNlImxyLXRiIjpjYXNlInJsLXRiIjppZighaS5saW5lfHwxPT09aS5hdHRlbXB0KXtpLmxpbmU9Y3JlYXRlTGluZShlLFtdKTtpLmNoaWxkcmVuLnB1c2goaS5saW5lKTtpLm51bWJlckluTGluZT0wfWkubnVtYmVySW5MaW5lKz0xO2kubGluZS5jaGlsZHJlbi5wdXNoKHQpO2lmKDA9PT1pLmF0dGVtcHQpe2kuY3VycmVudFdpZHRoKz1sO2kuaGVpZ2h0PU1hdGgubWF4KGkuaGVpZ2h0LGkucHJldkhlaWdodCtoKX1lbHNle2kuY3VycmVudFdpZHRoPWw7aS5wcmV2SGVpZ2h0PWkuaGVpZ2h0O2kuaGVpZ2h0Kz1oO2kuYXR0ZW1wdD0wfWkud2lkdGg9TWF0aC5tYXgoaS53aWR0aCxpLmN1cnJlbnRXaWR0aCk7YnJlYWs7Y2FzZSJybC1yb3ciOmNhc2Uicm93Ijp7aS5jaGlsZHJlbi5wdXNoKHQpO2kud2lkdGgrPWw7aS5oZWlnaHQ9TWF0aC5tYXgoaS5oZWlnaHQsaCk7Y29uc3QgZT0oMCxuLm1lYXN1cmVUb1N0cmluZykoaS5oZWlnaHQpO2Zvcihjb25zdCB0IG9mIGkuY2hpbGRyZW4pdC5hdHRyaWJ1dGVzLnN0eWxlLmhlaWdodD1lO2JyZWFrfWNhc2UidGFibGUiOmNhc2UidGIiOmkud2lkdGg9TWF0aC5taW4ocy53aWR0aCxNYXRoLm1heChpLndpZHRoLGwpKTtpLmhlaWdodCs9aDtpLmNoaWxkcmVuLnB1c2godCl9fTt0LmNoZWNrRGltZW5zaW9ucz1mdW5jdGlvbiBjaGVja0RpbWVuc2lvbnMoZSx0KXtpZihudWxsPT09ZVtyLiRnZXRUZW1wbGF0ZVJvb3RdKClbci4kZXh0cmFdLmZpcnN0VW5zcGxpdHRhYmxlKXJldHVybiEwO2lmKDA9PT1lLnd8fDA9PT1lLmgpcmV0dXJuITA7Y29uc3QgYT1lW3IuJGdldFN1YmZvcm1QYXJlbnRdKCksbj1hW3IuJGV4dHJhXSYmYVtyLiRleHRyYV0uYXR0ZW1wdHx8MCxbLGkscyxvXT1mdW5jdGlvbiBnZXRUcmFuc2Zvcm1lZEJCb3goZSl7bGV0IHQsYSxyPSIiPT09ZS53P05hTjplLncsbj0iIj09PWUuaD9OYU46ZS5oLFtpLHNdPVswLDBdO3N3aXRjaChlLmFuY2hvclR5cGV8fCIiKXtjYXNlImJvdHRvbUNlbnRlciI6W2ksc109W3IvMixuXTticmVhaztjYXNlImJvdHRvbUxlZnQiOltpLHNdPVswLG5dO2JyZWFrO2Nhc2UiYm90dG9tUmlnaHQiOltpLHNdPVtyLG5dO2JyZWFrO2Nhc2UibWlkZGxlQ2VudGVyIjpbaSxzXT1bci8yLG4vMl07YnJlYWs7Y2FzZSJtaWRkbGVMZWZ0IjpbaSxzXT1bMCxuLzJdO2JyZWFrO2Nhc2UibWlkZGxlUmlnaHQiOltpLHNdPVtyLG4vMl07YnJlYWs7Y2FzZSJ0b3BDZW50ZXIiOltpLHNdPVtyLzIsMF07YnJlYWs7Y2FzZSJ0b3BSaWdodCI6W2ksc109W3IsMF19c3dpdGNoKGUucm90YXRlfHwwKXtjYXNlIDA6W3QsYV09Wy1pLC1zXTticmVhaztjYXNlIDkwOlt0LGFdPVstcyxpXTtbcixuXT1bbiwtcl07YnJlYWs7Y2FzZSAxODA6W3QsYV09W2ksc107W3Isbl09Wy1yLC1uXTticmVhaztjYXNlIDI3MDpbdCxhXT1bcywtaV07W3Isbl09Wy1uLHJdfXJldHVybltlLngrdCtNYXRoLm1pbigwLHIpLGUueSthK01hdGgubWluKDAsbiksTWF0aC5hYnMociksTWF0aC5hYnMobildfShlKTtzd2l0Y2goYS5sYXlvdXQpe2Nhc2UibHItdGIiOmNhc2UicmwtdGIiOnJldHVybiAwPT09bj9lW3IuJGdldFRlbXBsYXRlUm9vdF0oKVtyLiRleHRyYV0ubm9MYXlvdXRGYWlsdXJlPyIiIT09ZS53P01hdGgucm91bmQocy10LndpZHRoKTw9Mjp0LndpZHRoPjI6ISgiIiE9PWUuaCYmTWF0aC5yb3VuZChvLXQuaGVpZ2h0KT4yKSYmKCIiIT09ZS53P01hdGgucm91bmQocy10LndpZHRoKTw9Mnx8MD09PWFbci4kZXh0cmFdLm51bWJlckluTGluZSYmdC5oZWlnaHQ+Mjp0LndpZHRoPjIpOiEhZVtyLiRnZXRUZW1wbGF0ZVJvb3RdKClbci4kZXh0cmFdLm5vTGF5b3V0RmFpbHVyZXx8ISgiIiE9PWUuaCYmTWF0aC5yb3VuZChvLXQuaGVpZ2h0KT4yKSYmKCgiIj09PWUud3x8TWF0aC5yb3VuZChzLXQud2lkdGgpPD0yfHwhYVtyLiRpc1RoZXJlTW9yZVdpZHRoXSgpKSYmdC5oZWlnaHQ+Mik7Y2FzZSJ0YWJsZSI6Y2FzZSJ0YiI6cmV0dXJuISFlW3IuJGdldFRlbXBsYXRlUm9vdF0oKVtyLiRleHRyYV0ubm9MYXlvdXRGYWlsdXJlfHwoIiI9PT1lLmh8fGVbci4kaXNTcGxpdHRhYmxlXSgpPygiIj09PWUud3x8TWF0aC5yb3VuZChzLXQud2lkdGgpPD0yfHwhYVtyLiRpc1RoZXJlTW9yZVdpZHRoXSgpKSYmdC5oZWlnaHQ+MjpNYXRoLnJvdW5kKG8tdC5oZWlnaHQpPD0yKTtjYXNlInBvc2l0aW9uIjppZihlW3IuJGdldFRlbXBsYXRlUm9vdF0oKVtyLiRleHRyYV0ubm9MYXlvdXRGYWlsdXJlKXJldHVybiEwO2lmKCIiPT09ZS5ofHxNYXRoLnJvdW5kKG8raS10LmhlaWdodCk8PTIpcmV0dXJuITA7Y29uc3QgYz1lW3IuJGdldFRlbXBsYXRlUm9vdF0oKVtyLiRleHRyYV0uY3VycmVudENvbnRlbnRBcmVhO3JldHVybiBvK2k+Yy5oO2Nhc2Uicmwtcm93IjpjYXNlInJvdyI6cmV0dXJuISFlW3IuJGdldFRlbXBsYXRlUm9vdF0oKVtyLiRleHRyYV0ubm9MYXlvdXRGYWlsdXJlfHwoIiI9PT1lLmh8fE1hdGgucm91bmQoby10LmhlaWdodCk8PTIpO2RlZmF1bHQ6cmV0dXJuITB9fTt0LmZsdXNoSFRNTD1mdW5jdGlvbiBmbHVzaEhUTUwoZSl7aWYoIWVbci4kZXh0cmFdKXJldHVybiBudWxsO2NvbnN0IHQ9e25hbWU6ImRpdiIsYXR0cmlidXRlczplW3IuJGV4dHJhXS5hdHRyaWJ1dGVzLGNoaWxkcmVuOmVbci4kZXh0cmFdLmNoaWxkcmVufTtpZihlW3IuJGV4dHJhXS5mYWlsaW5nTm9kZSl7Y29uc3QgYT1lW3IuJGV4dHJhXS5mYWlsaW5nTm9kZVtyLiRmbHVzaEhUTUxdKCk7YSYmKGUubGF5b3V0LmVuZHNXaXRoKCItdGIiKT90LmNoaWxkcmVuLnB1c2goY3JlYXRlTGluZShlLFthXSkpOnQuY2hpbGRyZW4ucHVzaChhKSl9aWYoMD09PXQuY2hpbGRyZW4ubGVuZ3RoKXJldHVybiBudWxsO3JldHVybiB0fTt0LmdldEF2YWlsYWJsZVNwYWNlPWZ1bmN0aW9uIGdldEF2YWlsYWJsZVNwYWNlKGUpe2NvbnN0IHQ9ZVtyLiRleHRyYV0uYXZhaWxhYmxlU3BhY2UsYT1lLm1hcmdpbj9lLm1hcmdpbi50b3BJbnNldCtlLm1hcmdpbi5ib3R0b21JbnNldDowLG49ZS5tYXJnaW4/ZS5tYXJnaW4ubGVmdEluc2V0K2UubWFyZ2luLnJpZ2h0SW5zZXQ6MDtzd2l0Y2goZS5sYXlvdXQpe2Nhc2UibHItdGIiOmNhc2UicmwtdGIiOnJldHVybiAwPT09ZVtyLiRleHRyYV0uYXR0ZW1wdD97d2lkdGg6dC53aWR0aC1uLWVbci4kZXh0cmFdLmN1cnJlbnRXaWR0aCxoZWlnaHQ6dC5oZWlnaHQtYS1lW3IuJGV4dHJhXS5wcmV2SGVpZ2h0fTp7d2lkdGg6dC53aWR0aC1uLGhlaWdodDp0LmhlaWdodC1hLWVbci4kZXh0cmFdLmhlaWdodH07Y2FzZSJybC1yb3ciOmNhc2Uicm93IjpyZXR1cm57d2lkdGg6ZVtyLiRleHRyYV0uY29sdW1uV2lkdGhzLnNsaWNlKGVbci4kZXh0cmFdLmN1cnJlbnRDb2x1bW4pLnJlZHVjZSgoKGUsdCk9PmUrdCkpLGhlaWdodDp0LmhlaWdodC1ufTtjYXNlInRhYmxlIjpjYXNlInRiIjpyZXR1cm57d2lkdGg6dC53aWR0aC1uLGhlaWdodDp0LmhlaWdodC1hLWVbci4kZXh0cmFdLmhlaWdodH07ZGVmYXVsdDpyZXR1cm4gdH19O3ZhciByPWEoNzcpLG49YSg4NCk7ZnVuY3Rpb24gY3JlYXRlTGluZShlLHQpe3JldHVybntuYW1lOiJkaXYiLGF0dHJpYnV0ZXM6e2NsYXNzOlsibHItdGIiPT09ZS5sYXlvdXQ/InhmYUxyIjoieGZhUmwiXX0sY2hpbGRyZW46dH19fSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuY29tcHV0ZUJib3g9ZnVuY3Rpb24gY29tcHV0ZUJib3goZSx0LGEpe2xldCBuO2lmKCIiIT09ZS53JiYiIiE9PWUuaCluPVtlLngsZS55LGUudyxlLmhdO2Vsc2V7aWYoIWEpcmV0dXJuIG51bGw7bGV0IGk9ZS53O2lmKCIiPT09aSl7aWYoMD09PWUubWF4Vyl7Y29uc3QgdD1lW3IuJGdldFN1YmZvcm1QYXJlbnRdKCk7aT0icG9zaXRpb24iPT09dC5sYXlvdXQmJiIiIT09dC53PzA6ZS5taW5XfWVsc2UgaT1NYXRoLm1pbihlLm1heFcsYS53aWR0aCk7dC5hdHRyaWJ1dGVzLnN0eWxlLndpZHRoPW1lYXN1cmVUb1N0cmluZyhpKX1sZXQgcz1lLmg7aWYoIiI9PT1zKXtpZigwPT09ZS5tYXhIKXtjb25zdCB0PWVbci4kZ2V0U3ViZm9ybVBhcmVudF0oKTtzPSJwb3NpdGlvbiI9PT10LmxheW91dCYmIiIhPT10Lmg/MDplLm1pbkh9ZWxzZSBzPU1hdGgubWluKGUubWF4SCxhLmhlaWdodCk7dC5hdHRyaWJ1dGVzLnN0eWxlLmhlaWdodD1tZWFzdXJlVG9TdHJpbmcocyl9bj1bZS54LGUueSxpLHNdfXJldHVybiBufTt0LmNyZWF0ZVdyYXBwZXI9ZnVuY3Rpb24gY3JlYXRlV3JhcHBlcihlLHQpe2NvbnN0e2F0dHJpYnV0ZXM6YX09dCx7c3R5bGU6bn09YSxpPXtuYW1lOiJkaXYiLGF0dHJpYnV0ZXM6e2NsYXNzOlsieGZhV3JhcHBlciJdLHN0eWxlOk9iamVjdC5jcmVhdGUobnVsbCl9LGNoaWxkcmVuOltdfTthLmNsYXNzLnB1c2goInhmYVdyYXBwZWQiKTtpZihlLmJvcmRlcil7Y29uc3R7d2lkdGhzOmEsaW5zZXRzOnN9PWUuYm9yZGVyW3IuJGV4dHJhXTtsZXQgbyxjLGw9c1swXSxoPXNbM107Y29uc3QgdT1zWzBdK3NbMl0sZD1zWzFdK3NbM107c3dpdGNoKGUuYm9yZGVyLmhhbmQpe2Nhc2UiZXZlbiI6bC09YVswXS8yO2gtPWFbM10vMjtvPWBjYWxjKDEwMCUgKyAkeyhhWzFdK2FbM10pLzItZH1weClgO2M9YGNhbGMoMTAwJSArICR7KGFbMF0rYVsyXSkvMi11fXB4KWA7YnJlYWs7Y2FzZSJsZWZ0IjpsLT1hWzBdO2gtPWFbM107bz1gY2FsYygxMDAlICsgJHthWzFdK2FbM10tZH1weClgO2M9YGNhbGMoMTAwJSArICR7YVswXSthWzJdLXV9cHgpYDticmVhaztjYXNlInJpZ2h0IjpvPWQ/YGNhbGMoMTAwJSAtICR7ZH1weClgOiIxMDAlIjtjPXU/YGNhbGMoMTAwJSAtICR7dX1weClgOiIxMDAlIn1jb25zdCBmPVsieGZhQm9yZGVyIl07aXNQcmludE9ubHkoZS5ib3JkZXIpJiZmLnB1c2goInhmYVByaW50T25seSIpO2NvbnN0IGc9e25hbWU6ImRpdiIsYXR0cmlidXRlczp7Y2xhc3M6ZixzdHlsZTp7dG9wOmAke2x9cHhgLGxlZnQ6YCR7aH1weGAsd2lkdGg6byxoZWlnaHQ6Y319LGNoaWxkcmVuOltdfTtmb3IoY29uc3QgZSBvZlsiYm9yZGVyIiwiYm9yZGVyV2lkdGgiLCJib3JkZXJDb2xvciIsImJvcmRlclJhZGl1cyIsImJvcmRlclN0eWxlIl0paWYodm9pZCAwIT09bltlXSl7Zy5hdHRyaWJ1dGVzLnN0eWxlW2VdPW5bZV07ZGVsZXRlIG5bZV19aS5jaGlsZHJlbi5wdXNoKGcsdCl9ZWxzZSBpLmNoaWxkcmVuLnB1c2godCk7Zm9yKGNvbnN0IGUgb2ZbImJhY2tncm91bmQiLCJiYWNrZ3JvdW5kQ2xpcCIsInRvcCIsImxlZnQiLCJ3aWR0aCIsImhlaWdodCIsIm1pbldpZHRoIiwibWluSGVpZ2h0IiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJ0cmFuc2Zvcm0iLCJ0cmFuc2Zvcm1PcmlnaW4iLCJ2aXNpYmlsaXR5Il0paWYodm9pZCAwIT09bltlXSl7aS5hdHRyaWJ1dGVzLnN0eWxlW2VdPW5bZV07ZGVsZXRlIG5bZV19ImFic29sdXRlIj09PW4ucG9zaXRpb24/aS5hdHRyaWJ1dGVzLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI6aS5hdHRyaWJ1dGVzLnN0eWxlLnBvc2l0aW9uPSJyZWxhdGl2ZSI7ZGVsZXRlIG4ucG9zaXRpb247aWYobi5hbGlnblNlbGYpe2kuYXR0cmlidXRlcy5zdHlsZS5hbGlnblNlbGY9bi5hbGlnblNlbGY7ZGVsZXRlIG4uYWxpZ25TZWxmfXJldHVybiBpfTt0LmZpeERpbWVuc2lvbnM9ZnVuY3Rpb24gZml4RGltZW5zaW9ucyhlKXtjb25zdCB0PWVbci4kZ2V0U3ViZm9ybVBhcmVudF0oKTtpZih0LmxheW91dCYmdC5sYXlvdXQuaW5jbHVkZXMoInJvdyIpKXtjb25zdCBhPXRbci4kZXh0cmFdLG49ZS5jb2xTcGFuO2xldCBpO2k9LTE9PT1uP2EuY29sdW1uV2lkdGhzLnNsaWNlKGEuY3VycmVudENvbHVtbikucmVkdWNlKCgoZSx0KT0+ZSt0KSwwKTphLmNvbHVtbldpZHRocy5zbGljZShhLmN1cnJlbnRDb2x1bW4sYS5jdXJyZW50Q29sdW1uK24pLnJlZHVjZSgoKGUsdCk9PmUrdCksMCk7aXNOYU4oaSl8fChlLnc9aSl9dC5sYXlvdXQmJiJwb3NpdGlvbiIhPT10LmxheW91dCYmKGUueD1lLnk9MCk7InRhYmxlIj09PWUubGF5b3V0JiYiIj09PWUudyYmQXJyYXkuaXNBcnJheShlLmNvbHVtbldpZHRocykmJihlLnc9ZS5jb2x1bW5XaWR0aHMucmVkdWNlKCgoZSx0KT0+ZSt0KSwwKSl9O3QuZml4VGV4dEluZGVudD1mdW5jdGlvbiBmaXhUZXh0SW5kZW50KGUpe2NvbnN0IHQ9KDAsaS5nZXRNZWFzdXJlbWVudCkoZS50ZXh0SW5kZW50LCIwcHgiKTtpZih0Pj0wKXJldHVybjtjb25zdCBhPSJwYWRkaW5nIisoImxlZnQiPT0oInJpZ2h0Ij09PWUudGV4dEFsaWduPyJyaWdodCI6ImxlZnQiKT8iTGVmdCI6IlJpZ2h0Iikscj0oMCxpLmdldE1lYXN1cmVtZW50KShlW2FdLCIwcHgiKTtlW2FdPXItdCsicHgifTt0LmZpeFVSTD1mdW5jdGlvbiBmaXhVUkwoZSl7Y29uc3QgdD0oMCxuLmNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwpKGUsbnVsbCx7YWRkRGVmYXVsdFByb3RvY29sOiEwLHRyeUNvbnZlcnRFbmNvZGluZzohMH0pO3JldHVybiB0P3QuaHJlZjpudWxsfTt0LmlzUHJpbnRPbmx5PWlzUHJpbnRPbmx5O3QubGF5b3V0Q2xhc3M9ZnVuY3Rpb24gbGF5b3V0Q2xhc3MoZSl7c3dpdGNoKGUubGF5b3V0KXtjYXNlInBvc2l0aW9uIjpkZWZhdWx0OnJldHVybiJ4ZmFQb3NpdGlvbiI7Y2FzZSJsci10YiI6cmV0dXJuInhmYUxyVGIiO2Nhc2Uicmwtcm93IjpyZXR1cm4ieGZhUmxSb3ciO2Nhc2UicmwtdGIiOnJldHVybiJ4ZmFSbFRiIjtjYXNlInJvdyI6cmV0dXJuInhmYVJvdyI7Y2FzZSJ0YWJsZSI6cmV0dXJuInhmYVRhYmxlIjtjYXNlInRiIjpyZXR1cm4ieGZhVGIifX07dC5sYXlvdXROb2RlPWZ1bmN0aW9uIGxheW91dE5vZGUoZSx0KXtsZXQgYT1udWxsLG49bnVsbCxpPSExO2lmKCghZS53fHwhZS5oKSYmZS52YWx1ZSl7bGV0IHM9MCxvPTA7aWYoZS5tYXJnaW4pe3M9ZS5tYXJnaW4ubGVmdEluc2V0K2UubWFyZ2luLnJpZ2h0SW5zZXQ7bz1lLm1hcmdpbi50b3BJbnNldCtlLm1hcmdpbi5ib3R0b21JbnNldH1sZXQgYz1udWxsLGw9bnVsbDtpZihlLnBhcmEpe2w9T2JqZWN0LmNyZWF0ZShudWxsKTtjPSIiPT09ZS5wYXJhLmxpbmVIZWlnaHQ/bnVsbDplLnBhcmEubGluZUhlaWdodDtsLnRvcD0iIj09PWUucGFyYS5zcGFjZUFib3ZlPzA6ZS5wYXJhLnNwYWNlQWJvdmU7bC5ib3R0b209IiI9PT1lLnBhcmEuc3BhY2VCZWxvdz8wOmUucGFyYS5zcGFjZUJlbG93O2wubGVmdD0iIj09PWUucGFyYS5tYXJnaW5MZWZ0PzA6ZS5wYXJhLm1hcmdpbkxlZnQ7bC5yaWdodD0iIj09PWUucGFyYS5tYXJnaW5SaWdodD8wOmUucGFyYS5tYXJnaW5SaWdodH1sZXQgaD1lLmZvbnQ7aWYoIWgpe2NvbnN0IHQ9ZVtyLiRnZXRUZW1wbGF0ZVJvb3RdKCk7bGV0IGE9ZVtyLiRnZXRQYXJlbnRdKCk7Zm9yKDthJiZhIT09dDspe2lmKGEuZm9udCl7aD1hLmZvbnQ7YnJlYWt9YT1hW3IuJGdldFBhcmVudF0oKX19Y29uc3QgdT0oZS53fHx0LndpZHRoKS1zLGQ9ZVtyLiRnbG9iYWxEYXRhXS5mb250RmluZGVyO2lmKGUudmFsdWUuZXhEYXRhJiZlLnZhbHVlLmV4RGF0YVtyLiRjb250ZW50XSYmInRleHQvaHRtbCI9PT1lLnZhbHVlLmV4RGF0YS5jb250ZW50VHlwZSl7Y29uc3QgdD1sYXlvdXRUZXh0KGUudmFsdWUuZXhEYXRhW3IuJGNvbnRlbnRdLGgsbCxjLGQsdSk7bj10LndpZHRoO2E9dC5oZWlnaHQ7aT10LmlzQnJva2VufWVsc2V7Y29uc3QgdD1lLnZhbHVlW3IuJHRleHRdKCk7aWYodCl7Y29uc3QgZT1sYXlvdXRUZXh0KHQsaCxsLGMsZCx1KTtuPWUud2lkdGg7YT1lLmhlaWdodDtpPWUuaXNCcm9rZW59fW51bGw9PT1ufHxlLnd8fChuKz1zKTtudWxsPT09YXx8ZS5ofHwoYSs9byl9cmV0dXJue3c6bixoOmEsaXNCcm9rZW46aX19O3QubWVhc3VyZVRvU3RyaW5nPW1lYXN1cmVUb1N0cmluZzt0LnNldEFjY2Vzcz1mdW5jdGlvbiBzZXRBY2Nlc3MoZSx0KXtzd2l0Y2goZS5hY2Nlc3Mpe2Nhc2Uibm9uSW50ZXJhY3RpdmUiOnQucHVzaCgieGZhTm9uSW50ZXJhY3RpdmUiKTticmVhaztjYXNlInJlYWRPbmx5Ijp0LnB1c2goInhmYVJlYWRPbmx5Iik7YnJlYWs7Y2FzZSJwcm90ZWN0ZWQiOnQucHVzaCgieGZhRGlzYWJsZWQiKX19O3Quc2V0Rm9udEZhbWlseT1mdW5jdGlvbiBzZXRGb250RmFtaWx5KGUsdCxhLHIpe2lmKCFhKXtkZWxldGUgci5mb250RmFtaWx5O3JldHVybn1jb25zdCBuPSgwLGkuc3RyaXBRdW90ZXMpKGUudHlwZWZhY2UpO3IuZm9udEZhbWlseT1gIiR7bn0iYDtjb25zdCBvPWEuZmluZChuKTtpZihvKXtjb25zdHtmb250RmFtaWx5OmF9PW8ucmVndWxhci5jc3NGb250SW5mbzthIT09biYmKHIuZm9udEZhbWlseT1gIiR7YX0iYCk7Y29uc3QgaT1nZXRDdXJyZW50UGFyYSh0KTtpZihpJiYiIiE9PWkubGluZUhlaWdodClyZXR1cm47aWYoci5saW5lSGVpZ2h0KXJldHVybjtjb25zdCBjPSgwLHMuc2VsZWN0Rm9udCkoZSxvKTtjJiYoci5saW5lSGVpZ2h0PU1hdGgubWF4KDEuMixjLmxpbmVIZWlnaHQpKX19O3Quc2V0TWluTWF4RGltZW5zaW9ucz1mdW5jdGlvbiBzZXRNaW5NYXhEaW1lbnNpb25zKGUsdCl7aWYoInBvc2l0aW9uIj09PWVbci4kZ2V0U3ViZm9ybVBhcmVudF0oKS5sYXlvdXQpe2UubWluVz4wJiYodC5taW5XaWR0aD1tZWFzdXJlVG9TdHJpbmcoZS5taW5XKSk7ZS5tYXhXPjAmJih0Lm1heFdpZHRoPW1lYXN1cmVUb1N0cmluZyhlLm1heFcpKTtlLm1pbkg+MCYmKHQubWluSGVpZ2h0PW1lYXN1cmVUb1N0cmluZyhlLm1pbkgpKTtlLm1heEg+MCYmKHQubWF4SGVpZ2h0PW1lYXN1cmVUb1N0cmluZyhlLm1heEgpKX19O3Quc2V0UGFyYT1mdW5jdGlvbiBzZXRQYXJhKGUsdCxhKXtpZihhLmF0dHJpYnV0ZXMuY2xhc3MmJmEuYXR0cmlidXRlcy5jbGFzcy5pbmNsdWRlcygieGZhUmljaCIpKXtpZih0KXsiIj09PWUuaCYmKHQuaGVpZ2h0PSJhdXRvIik7IiI9PT1lLncmJih0LndpZHRoPSJhdXRvIil9Y29uc3Qgbj1nZXRDdXJyZW50UGFyYShlKTtpZihuKXtjb25zdCBlPWEuYXR0cmlidXRlcy5zdHlsZTtlLmRpc3BsYXk9ImZsZXgiO2UuZmxleERpcmVjdGlvbj0iY29sdW1uIjtzd2l0Y2gobi52QWxpZ24pe2Nhc2UidG9wIjplLmp1c3RpZnlDb250ZW50PSJzdGFydCI7YnJlYWs7Y2FzZSJib3R0b20iOmUuanVzdGlmeUNvbnRlbnQ9ImVuZCI7YnJlYWs7Y2FzZSJtaWRkbGUiOmUuanVzdGlmeUNvbnRlbnQ9ImNlbnRlciJ9Y29uc3QgdD1uW3IuJHRvU3R5bGVdKCk7Zm9yKGNvbnN0W2Escl1vZiBPYmplY3QuZW50cmllcyh0KSlhIGluIGV8fChlW2FdPXIpfX19O3QudG9TdHlsZT1mdW5jdGlvbiB0b1N0eWxlKGUsLi4udCl7Y29uc3QgYT1PYmplY3QuY3JlYXRlKG51bGwpO2Zvcihjb25zdCBpIG9mIHQpe2NvbnN0IHQ9ZVtpXTtpZihudWxsIT09dClpZihjLmhhc093blByb3BlcnR5KGkpKWNbaV0oZSxhKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiByLlhGQU9iamVjdCl7Y29uc3QgZT10W3IuJHRvU3R5bGVdKCk7ZT9PYmplY3QuYXNzaWduKGEsZSk6KDAsbi53YXJuKShgKERFQlVHKSAtIFhGQSAtIHN0eWxlIGZvciAke2l9IG5vdCBpbXBsZW1lbnRlZCB5ZXRgKX19cmV0dXJuIGF9O3ZhciByPWEoNzcpLG49YSgyKSxpPWEoNzgpLHM9YSg4NSksbz1hKDg2KTtmdW5jdGlvbiBtZWFzdXJlVG9TdHJpbmcoZSl7cmV0dXJuInN0cmluZyI9PXR5cGVvZiBlPyIwcHgiOk51bWJlci5pc0ludGVnZXIoZSk/YCR7ZX1weGA6YCR7ZS50b0ZpeGVkKDIpfXB4YH1jb25zdCBjPXthbmNob3JUeXBlKGUsdCl7Y29uc3QgYT1lW3IuJGdldFN1YmZvcm1QYXJlbnRdKCk7aWYoYSYmKCFhLmxheW91dHx8InBvc2l0aW9uIj09PWEubGF5b3V0KSl7InRyYW5zZm9ybSJpbiB0fHwodC50cmFuc2Zvcm09IiIpO3N3aXRjaChlLmFuY2hvclR5cGUpe2Nhc2UiYm90dG9tQ2VudGVyIjp0LnRyYW5zZm9ybSs9InRyYW5zbGF0ZSgtNTAlLCAtMTAwJSkiO2JyZWFrO2Nhc2UiYm90dG9tTGVmdCI6dC50cmFuc2Zvcm0rPSJ0cmFuc2xhdGUoMCwtMTAwJSkiO2JyZWFrO2Nhc2UiYm90dG9tUmlnaHQiOnQudHJhbnNmb3JtKz0idHJhbnNsYXRlKC0xMDAlLC0xMDAlKSI7YnJlYWs7Y2FzZSJtaWRkbGVDZW50ZXIiOnQudHJhbnNmb3JtKz0idHJhbnNsYXRlKC01MCUsLTUwJSkiO2JyZWFrO2Nhc2UibWlkZGxlTGVmdCI6dC50cmFuc2Zvcm0rPSJ0cmFuc2xhdGUoMCwtNTAlKSI7YnJlYWs7Y2FzZSJtaWRkbGVSaWdodCI6dC50cmFuc2Zvcm0rPSJ0cmFuc2xhdGUoLTEwMCUsLTUwJSkiO2JyZWFrO2Nhc2UidG9wQ2VudGVyIjp0LnRyYW5zZm9ybSs9InRyYW5zbGF0ZSgtNTAlLDApIjticmVhaztjYXNlInRvcFJpZ2h0Ijp0LnRyYW5zZm9ybSs9InRyYW5zbGF0ZSgtMTAwJSwwKSJ9fX0sZGltZW5zaW9ucyhlLHQpe2NvbnN0IGE9ZVtyLiRnZXRTdWJmb3JtUGFyZW50XSgpO2xldCBuPWUudztjb25zdCBpPWUuaDtpZihhLmxheW91dCYmYS5sYXlvdXQuaW5jbHVkZXMoInJvdyIpKXtjb25zdCB0PWFbci4kZXh0cmFdLGk9ZS5jb2xTcGFuO2xldCBzO2lmKC0xPT09aSl7cz10LmNvbHVtbldpZHRocy5zbGljZSh0LmN1cnJlbnRDb2x1bW4pLnJlZHVjZSgoKGUsdCk9PmUrdCksMCk7dC5jdXJyZW50Q29sdW1uPTB9ZWxzZXtzPXQuY29sdW1uV2lkdGhzLnNsaWNlKHQuY3VycmVudENvbHVtbix0LmN1cnJlbnRDb2x1bW4raSkucmVkdWNlKCgoZSx0KT0+ZSt0KSwwKTt0LmN1cnJlbnRDb2x1bW49KHQuY3VycmVudENvbHVtbitlLmNvbFNwYW4pJXQuY29sdW1uV2lkdGhzLmxlbmd0aH1pc05hTihzKXx8KG49ZS53PXMpfXQud2lkdGg9IiIhPT1uP21lYXN1cmVUb1N0cmluZyhuKToiYXV0byI7dC5oZWlnaHQ9IiIhPT1pP21lYXN1cmVUb1N0cmluZyhpKToiYXV0byJ9LHBvc2l0aW9uKGUsdCl7Y29uc3QgYT1lW3IuJGdldFN1YmZvcm1QYXJlbnRdKCk7aWYoIWF8fCFhLmxheW91dHx8InBvc2l0aW9uIj09PWEubGF5b3V0KXt0LnBvc2l0aW9uPSJhYnNvbHV0ZSI7dC5sZWZ0PW1lYXN1cmVUb1N0cmluZyhlLngpO3QudG9wPW1lYXN1cmVUb1N0cmluZyhlLnkpfX0scm90YXRlKGUsdCl7aWYoZS5yb3RhdGUpeyJ0cmFuc2Zvcm0iaW4gdHx8KHQudHJhbnNmb3JtPSIiKTt0LnRyYW5zZm9ybSs9YHJvdGF0ZSgtJHtlLnJvdGF0ZX1kZWcpYDt0LnRyYW5zZm9ybU9yaWdpbj0idG9wIGxlZnQifX0scHJlc2VuY2UoZSx0KXtzd2l0Y2goZS5wcmVzZW5jZSl7Y2FzZSJpbnZpc2libGUiOnQudmlzaWJpbGl0eT0iaGlkZGVuIjticmVhaztjYXNlImhpZGRlbiI6Y2FzZSJpbmFjdGl2ZSI6dC5kaXNwbGF5PSJub25lIn19LGhBbGlnbihlLHQpe2lmKCJwYXJhIj09PWVbci4kbm9kZU5hbWVdKXN3aXRjaChlLmhBbGlnbil7Y2FzZSJqdXN0aWZ5QWxsIjp0LnRleHRBbGlnbj0ianVzdGlmeS1hbGwiO2JyZWFrO2Nhc2UicmFkaXgiOnQudGV4dEFsaWduPSJsZWZ0IjticmVhaztkZWZhdWx0OnQudGV4dEFsaWduPWUuaEFsaWdufWVsc2Ugc3dpdGNoKGUuaEFsaWduKXtjYXNlImxlZnQiOnQuYWxpZ25TZWxmPSJzdGFydCI7YnJlYWs7Y2FzZSJjZW50ZXIiOnQuYWxpZ25TZWxmPSJjZW50ZXIiO2JyZWFrO2Nhc2UicmlnaHQiOnQuYWxpZ25TZWxmPSJlbmQifX0sbWFyZ2luKGUsdCl7ZS5tYXJnaW4mJih0Lm1hcmdpbj1lLm1hcmdpbltyLiR0b1N0eWxlXSgpLm1hcmdpbil9fTtmdW5jdGlvbiBsYXlvdXRUZXh0KGUsdCxhLG4saSxzKXtjb25zdCBjPW5ldyBvLlRleHRNZWFzdXJlKHQsYSxuLGkpOyJzdHJpbmciPT10eXBlb2YgZT9jLmFkZFN0cmluZyhlKTplW3IuJHB1c2hHbHlwaHNdKGMpO3JldHVybiBjLmNvbXB1dGUocyl9ZnVuY3Rpb24gaXNQcmludE9ubHkoZSl7cmV0dXJuIGUucmVsZXZhbnQubGVuZ3RoPjAmJiFlLnJlbGV2YW50WzBdLmV4Y2x1ZGVkJiYicHJpbnQiPT09ZS5yZWxldmFudFswXS52aWV3bmFtZX1mdW5jdGlvbiBnZXRDdXJyZW50UGFyYShlKXtjb25zdCB0PWVbci4kZ2V0VGVtcGxhdGVSb290XSgpW3IuJGV4dHJhXS5wYXJhU3RhY2s7cmV0dXJuIHQubGVuZ3RoP3QuYXQoLTEpOm51bGx9fSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuRm9udEZpbmRlcj12b2lkIDA7dC5nZXRNZXRyaWNzPWZ1bmN0aW9uIGdldE1ldHJpY3MoZSx0PSExKXtsZXQgYT1udWxsO2lmKGUpe2NvbnN0IHQ9KDAsbi5zdHJpcFF1b3RlcykoZS50eXBlZmFjZSksaT1lW3IuJGdsb2JhbERhdGFdLmZvbnRGaW5kZXIuZmluZCh0KTthPXNlbGVjdEZvbnQoZSxpKX1pZighYSlyZXR1cm57bGluZUhlaWdodDoxMixsaW5lR2FwOjIsbGluZU5vR2FwOjEwfTtjb25zdCBpPWUuc2l6ZXx8MTAscz1hLmxpbmVIZWlnaHQ/TWF0aC5tYXgodD8wOjEuMixhLmxpbmVIZWlnaHQpOjEuMixvPXZvaWQgMD09PWEubGluZUdhcD8uMjphLmxpbmVHYXA7cmV0dXJue2xpbmVIZWlnaHQ6cyppLGxpbmVHYXA6byppLGxpbmVOb0dhcDpNYXRoLm1heCgxLHMtbykqaX19O3Quc2VsZWN0Rm9udD1zZWxlY3RGb250O3ZhciByPWEoNzcpLG49YSg3OCksaT1hKDIpO3QuRm9udEZpbmRlcj1jbGFzcyBGb250RmluZGVye2NvbnN0cnVjdG9yKGUpe3RoaXMuZm9udHM9bmV3IE1hcDt0aGlzLmNhY2hlPW5ldyBNYXA7dGhpcy53YXJuZWQ9bmV3IFNldDt0aGlzLmRlZmF1bHRGb250PW51bGw7dGhpcy5hZGQoZSl9YWRkKGUsdD1udWxsKXtmb3IoY29uc3QgdCBvZiBlKXRoaXMuYWRkUGRmRm9udCh0KTtmb3IoY29uc3QgZSBvZiB0aGlzLmZvbnRzLnZhbHVlcygpKWUucmVndWxhcnx8KGUucmVndWxhcj1lLml0YWxpY3x8ZS5ib2xkfHxlLmJvbGRpdGFsaWMpO2lmKCF0fHwwPT09dC5zaXplKXJldHVybjtjb25zdCBhPXRoaXMuZm9udHMuZ2V0KCJQZGZKUy1GYWxsYmFjay1QZGZKUy1YRkEiKTtmb3IoY29uc3QgZSBvZiB0KXRoaXMuZm9udHMuc2V0KGUsYSl9YWRkUGRmRm9udChlKXtjb25zdCB0PWUuY3NzRm9udEluZm8sYT10LmZvbnRGYW1pbHk7bGV0IHI9dGhpcy5mb250cy5nZXQoYSk7aWYoIXIpe3I9T2JqZWN0LmNyZWF0ZShudWxsKTt0aGlzLmZvbnRzLnNldChhLHIpO3RoaXMuZGVmYXVsdEZvbnR8fCh0aGlzLmRlZmF1bHRGb250PXIpfWxldCBuPSIiO2NvbnN0IGk9cGFyc2VGbG9hdCh0LmZvbnRXZWlnaHQpOzAhPT1wYXJzZUZsb2F0KHQuaXRhbGljQW5nbGUpP249aT49NzAwPyJib2xkaXRhbGljIjoiaXRhbGljIjppPj03MDAmJihuPSJib2xkIik7aWYoIW4peyhlLm5hbWUuaW5jbHVkZXMoIkJvbGQiKXx8ZS5wc05hbWUmJmUucHNOYW1lLmluY2x1ZGVzKCJCb2xkIikpJiYobj0iYm9sZCIpOyhlLm5hbWUuaW5jbHVkZXMoIkl0YWxpYyIpfHxlLm5hbWUuZW5kc1dpdGgoIkl0Iil8fGUucHNOYW1lJiYoZS5wc05hbWUuaW5jbHVkZXMoIkl0YWxpYyIpfHxlLnBzTmFtZS5lbmRzV2l0aCgiSXQiKSkpJiYobis9Iml0YWxpYyIpfW58fChuPSJyZWd1bGFyIik7cltuXT1lfWdldERlZmF1bHQoKXtyZXR1cm4gdGhpcy5kZWZhdWx0Rm9udH1maW5kKGUsdD0hMCl7bGV0IGE9dGhpcy5mb250cy5nZXQoZSl8fHRoaXMuY2FjaGUuZ2V0KGUpO2lmKGEpcmV0dXJuIGE7Y29uc3Qgcj0vLHwtfF98IHxib2xkaXRhbGljfGJvbGR8aXRhbGljfHJlZ3VsYXJ8aXQvZ2k7bGV0IG49ZS5yZXBsYWNlKHIsIiIpO2E9dGhpcy5mb250cy5nZXQobik7aWYoYSl7dGhpcy5jYWNoZS5zZXQoZSxhKTtyZXR1cm4gYX1uPW4udG9Mb3dlckNhc2UoKTtjb25zdCBzPVtdO2Zvcihjb25zdFtlLHRdb2YgdGhpcy5mb250cy5lbnRyaWVzKCkpZS5yZXBsYWNlKHIsIiIpLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChuKSYmcy5wdXNoKHQpO2lmKDA9PT1zLmxlbmd0aClmb3IoY29uc3RbLGVdb2YgdGhpcy5mb250cy5lbnRyaWVzKCkpZS5yZWd1bGFyLm5hbWUmJmUucmVndWxhci5uYW1lLnJlcGxhY2UociwiIikudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKG4pJiZzLnB1c2goZSk7aWYoMD09PXMubGVuZ3RoKXtuPW4ucmVwbGFjZSgvcHNtdHxtdC9naSwiIik7Zm9yKGNvbnN0W2UsdF1vZiB0aGlzLmZvbnRzLmVudHJpZXMoKSllLnJlcGxhY2UociwiIikudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKG4pJiZzLnB1c2godCl9aWYoMD09PXMubGVuZ3RoKWZvcihjb25zdCBlIG9mIHRoaXMuZm9udHMudmFsdWVzKCkpZS5yZWd1bGFyLm5hbWUmJmUucmVndWxhci5uYW1lLnJlcGxhY2UociwiIikudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKG4pJiZzLnB1c2goZSk7aWYocy5sZW5ndGg+PTEpezEhPT1zLmxlbmd0aCYmdCYmKDAsaS53YXJuKShgWEZBIC0gVG9vIG1hbnkgY2hvaWNlcyB0byBndWVzcyB0aGUgY29ycmVjdCBmb250OiAke2V9YCk7dGhpcy5jYWNoZS5zZXQoZSxzWzBdKTtyZXR1cm4gc1swXX1pZih0JiYhdGhpcy53YXJuZWQuaGFzKGUpKXt0aGlzLndhcm5lZC5hZGQoZSk7KDAsaS53YXJuKShgWEZBIC0gQ2Fubm90IGZpbmQgdGhlIGZvbnQ6ICR7ZX1gKX1yZXR1cm4gbnVsbH19O2Z1bmN0aW9uIHNlbGVjdEZvbnQoZSx0KXtyZXR1cm4iaXRhbGljIj09PWUucG9zdHVyZT8iYm9sZCI9PT1lLndlaWdodD90LmJvbGRpdGFsaWM6dC5pdGFsaWM6ImJvbGQiPT09ZS53ZWlnaHQ/dC5ib2xkOnQucmVndWxhcn19LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5UZXh0TWVhc3VyZT12b2lkIDA7dmFyIHI9YSg4NSk7Y2xhc3MgRm9udEluZm97Y29uc3RydWN0b3IoZSx0LGEsbil7dGhpcy5saW5lSGVpZ2h0PWE7dGhpcy5wYXJhTWFyZ2luPXR8fHt0b3A6MCxib3R0b206MCxsZWZ0OjAscmlnaHQ6MH07aWYoIWUpe1t0aGlzLnBkZkZvbnQsdGhpcy54ZmFGb250XT10aGlzLmRlZmF1bHRGb250KG4pO3JldHVybn10aGlzLnhmYUZvbnQ9e3R5cGVmYWNlOmUudHlwZWZhY2UscG9zdHVyZTplLnBvc3R1cmUsd2VpZ2h0OmUud2VpZ2h0LHNpemU6ZS5zaXplLGxldHRlclNwYWNpbmc6ZS5sZXR0ZXJTcGFjaW5nfTtjb25zdCBpPW4uZmluZChlLnR5cGVmYWNlKTtpZihpKXt0aGlzLnBkZkZvbnQ9KDAsci5zZWxlY3RGb250KShlLGkpO3RoaXMucGRmRm9udHx8KFt0aGlzLnBkZkZvbnQsdGhpcy54ZmFGb250XT10aGlzLmRlZmF1bHRGb250KG4pKX1lbHNlW3RoaXMucGRmRm9udCx0aGlzLnhmYUZvbnRdPXRoaXMuZGVmYXVsdEZvbnQobil9ZGVmYXVsdEZvbnQoZSl7Y29uc3QgdD1lLmZpbmQoIkhlbHZldGljYSIsITEpfHxlLmZpbmQoIk15cmlhZCBQcm8iLCExKXx8ZS5maW5kKCJBcmlhbCIsITEpfHxlLmdldERlZmF1bHQoKTtpZih0JiZ0LnJlZ3VsYXIpe2NvbnN0IGU9dC5yZWd1bGFyO3JldHVybltlLHt0eXBlZmFjZTplLmNzc0ZvbnRJbmZvLmZvbnRGYW1pbHkscG9zdHVyZToibm9ybWFsIix3ZWlnaHQ6Im5vcm1hbCIsc2l6ZToxMCxsZXR0ZXJTcGFjaW5nOjB9XX1yZXR1cm5bbnVsbCx7dHlwZWZhY2U6IkNvdXJpZXIiLHBvc3R1cmU6Im5vcm1hbCIsd2VpZ2h0OiJub3JtYWwiLHNpemU6MTAsbGV0dGVyU3BhY2luZzowfV19fWNsYXNzIEZvbnRTZWxlY3Rvcntjb25zdHJ1Y3RvcihlLHQsYSxyKXt0aGlzLmZvbnRGaW5kZXI9cjt0aGlzLnN0YWNrPVtuZXcgRm9udEluZm8oZSx0LGEscildfXB1c2hEYXRhKGUsdCxhKXtjb25zdCByPXRoaXMuc3RhY2suYXQoLTEpO2Zvcihjb25zdCB0IG9mWyJ0eXBlZmFjZSIsInBvc3R1cmUiLCJ3ZWlnaHQiLCJzaXplIiwibGV0dGVyU3BhY2luZyJdKWVbdF18fChlW3RdPXIueGZhRm9udFt0XSk7Zm9yKGNvbnN0IGUgb2ZbInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCJdKWlzTmFOKHRbZV0pJiYodFtlXT1yLnBhcmFNYXJnaW5bZV0pO2NvbnN0IG49bmV3IEZvbnRJbmZvKGUsdCxhfHxyLmxpbmVIZWlnaHQsdGhpcy5mb250RmluZGVyKTtuLnBkZkZvbnR8fChuLnBkZkZvbnQ9ci5wZGZGb250KTt0aGlzLnN0YWNrLnB1c2gobil9cG9wRm9udCgpe3RoaXMuc3RhY2sucG9wKCl9dG9wRm9udCgpe3JldHVybiB0aGlzLnN0YWNrLmF0KC0xKX19dC5UZXh0TWVhc3VyZT1jbGFzcyBUZXh0TWVhc3VyZXtjb25zdHJ1Y3RvcihlLHQsYSxyKXt0aGlzLmdseXBocz1bXTt0aGlzLmZvbnRTZWxlY3Rvcj1uZXcgRm9udFNlbGVjdG9yKGUsdCxhLHIpO3RoaXMuZXh0cmFIZWlnaHQ9MH1wdXNoRGF0YShlLHQsYSl7dGhpcy5mb250U2VsZWN0b3IucHVzaERhdGEoZSx0LGEpfXBvcEZvbnQoZSl7cmV0dXJuIHRoaXMuZm9udFNlbGVjdG9yLnBvcEZvbnQoKX1hZGRQYXJhKCl7Y29uc3QgZT10aGlzLmZvbnRTZWxlY3Rvci50b3BGb250KCk7dGhpcy5leHRyYUhlaWdodCs9ZS5wYXJhTWFyZ2luLnRvcCtlLnBhcmFNYXJnaW4uYm90dG9tfWFkZFN0cmluZyhlKXtpZighZSlyZXR1cm47Y29uc3QgdD10aGlzLmZvbnRTZWxlY3Rvci50b3BGb250KCksYT10LnhmYUZvbnQuc2l6ZTtpZih0LnBkZkZvbnQpe2NvbnN0IHI9dC54ZmFGb250LmxldHRlclNwYWNpbmcsbj10LnBkZkZvbnQsaT1uLmxpbmVIZWlnaHR8fDEuMixzPXQubGluZUhlaWdodHx8TWF0aC5tYXgoMS4yLGkpKmEsbz1pLSh2b2lkIDA9PT1uLmxpbmVHYXA/LjI6bi5saW5lR2FwKSxjPU1hdGgubWF4KDEsbykqYSxsPWEvMWUzLGg9bi5kZWZhdWx0V2lkdGh8fG4uY2hhcnNUb0dseXBocygiICIpWzBdLndpZHRoO2Zvcihjb25zdCB0IG9mIGUuc3BsaXQoL1tcdTIwMjlcbl0vKSl7Y29uc3QgZT1uLmVuY29kZVN0cmluZyh0KS5qb2luKCIiKSxhPW4uY2hhcnNUb0dseXBocyhlKTtmb3IoY29uc3QgZSBvZiBhKXtjb25zdCB0PWUud2lkdGh8fGg7dGhpcy5nbHlwaHMucHVzaChbdCpsK3IscyxjLGUudW5pY29kZSwhMV0pfXRoaXMuZ2x5cGhzLnB1c2goWzAsMCwwLCJcbiIsITBdKX10aGlzLmdseXBocy5wb3AoKX1lbHNle2Zvcihjb25zdCB0IG9mIGUuc3BsaXQoL1tcdTIwMjlcbl0vKSl7Zm9yKGNvbnN0IGUgb2YgdC5zcGxpdCgiIikpdGhpcy5nbHlwaHMucHVzaChbYSwxLjIqYSxhLGUsITFdKTt0aGlzLmdseXBocy5wdXNoKFswLDAsMCwiXG4iLCEwXSl9dGhpcy5nbHlwaHMucG9wKCl9fWNvbXB1dGUoZSl7bGV0IHQ9LTEsYT0wLHI9MCxuPTAsaT0wLHM9MCxvPSExLGM9ITA7Zm9yKGxldCBsPTAsaD10aGlzLmdseXBocy5sZW5ndGg7bDxoO2wrKyl7Y29uc3RbaCx1LGQsZixnXT10aGlzLmdseXBoc1tsXSxwPSIgIj09PWYsbT1jP2Q6dTtpZihnKXtyPU1hdGgubWF4KHIsaSk7aT0wO24rPXM7cz1tO3Q9LTE7YT0wO2M9ITF9ZWxzZSBpZihwKWlmKGkraD5lKXtyPU1hdGgubWF4KHIsaSk7aT0wO24rPXM7cz1tO3Q9LTE7YT0wO289ITA7Yz0hMX1lbHNle3M9TWF0aC5tYXgobSxzKTthPWk7aSs9aDt0PWx9ZWxzZSBpZihpK2g+ZSl7bis9cztzPW07aWYoLTEhPT10KXtsPXQ7cj1NYXRoLm1heChyLGEpO2k9MDt0PS0xO2E9MH1lbHNle3I9TWF0aC5tYXgocixpKTtpPWh9bz0hMDtjPSExfWVsc2V7aSs9aDtzPU1hdGgubWF4KG0scyl9fXI9TWF0aC5tYXgocixpKTtuKz1zK3RoaXMuZXh0cmFIZWlnaHQ7cmV0dXJue3dpZHRoOjEuMDIqcixoZWlnaHQ6bixpc0Jyb2tlbjpvfX19fSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuRGF0YUhhbmRsZXI9dm9pZCAwO3ZhciByPWEoNzcpO3QuRGF0YUhhbmRsZXI9Y2xhc3MgRGF0YUhhbmRsZXJ7Y29uc3RydWN0b3IoZSx0KXt0aGlzLmRhdGE9dDt0aGlzLmRhdGFzZXQ9ZS5kYXRhc2V0c3x8bnVsbH1zZXJpYWxpemUoZSl7Y29uc3QgdD1bWy0xLHRoaXMuZGF0YVtyLiRnZXRDaGlsZHJlbl0oKV1dO2Zvcig7dC5sZW5ndGg+MDspe2NvbnN0IGE9dC5hdCgtMSksW24saV09YTtpZihuKzE9PT1pLmxlbmd0aCl7dC5wb3AoKTtjb250aW51ZX1jb25zdCBzPWlbKythWzBdXSxvPWUuZ2V0KHNbci4kdWlkXSk7aWYobylzW3IuJHNldFZhbHVlXShvKTtlbHNle2NvbnN0IHQ9c1tyLiRnZXRBdHRyaWJ1dGVzXSgpO2Zvcihjb25zdCBhIG9mIHQudmFsdWVzKCkpe2NvbnN0IHQ9ZS5nZXQoYVtyLiR1aWRdKTtpZih0KXthW3IuJHNldFZhbHVlXSh0KTticmVha319fWNvbnN0IGM9c1tyLiRnZXRDaGlsZHJlbl0oKTtjLmxlbmd0aD4wJiZ0LnB1c2goWy0xLGNdKX1jb25zdCBhPVsnPHhmYTpkYXRhc2V0cyB4bWxuczp4ZmE9Imh0dHA6Ly93d3cueGZhLm9yZy9zY2hlbWEveGZhLWRhdGEvMS4wLyI+J107aWYodGhpcy5kYXRhc2V0KWZvcihjb25zdCBlIG9mIHRoaXMuZGF0YXNldFtyLiRnZXRDaGlsZHJlbl0oKSkiZGF0YSIhPT1lW3IuJG5vZGVOYW1lXSYmZVtyLiR0b1N0cmluZ10oYSk7dGhpcy5kYXRhW3IuJHRvU3RyaW5nXShhKTthLnB1c2goIjwveGZhOmRhdGFzZXRzPiIpO3JldHVybiBhLmpvaW4oIiIpfX19LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5YRkFQYXJzZXI9dm9pZCAwO3ZhciByPWEoNzcpLG49YSg2NiksaT1hKDg5KSxzPWEoMik7Y2xhc3MgWEZBUGFyc2VyIGV4dGVuZHMgbi5YTUxQYXJzZXJCYXNle2NvbnN0cnVjdG9yKGU9bnVsbCx0PSExKXtzdXBlcigpO3RoaXMuX2J1aWxkZXI9bmV3IGkuQnVpbGRlcihlKTt0aGlzLl9zdGFjaz1bXTt0aGlzLl9nbG9iYWxEYXRhPXt1c2VkVHlwZWZhY2VzOm5ldyBTZXR9O3RoaXMuX2lkcz1uZXcgTWFwO3RoaXMuX2N1cnJlbnQ9dGhpcy5fYnVpbGRlci5idWlsZFJvb3QodGhpcy5faWRzKTt0aGlzLl9lcnJvckNvZGU9bi5YTUxQYXJzZXJFcnJvckNvZGUuTm9FcnJvcjt0aGlzLl93aGl0ZVJlZ2V4PS9eXHMrJC87dGhpcy5fbmJzcHM9L1x4YTArL2c7dGhpcy5fcmljaFRleHQ9dH1wYXJzZShlKXt0aGlzLnBhcnNlWG1sKGUpO2lmKHRoaXMuX2Vycm9yQ29kZT09PW4uWE1MUGFyc2VyRXJyb3JDb2RlLk5vRXJyb3Ipe3RoaXMuX2N1cnJlbnRbci4kZmluYWxpemVdKCk7cmV0dXJuIHRoaXMuX2N1cnJlbnQuZWxlbWVudH19b25UZXh0KGUpe2U9ZS5yZXBsYWNlKHRoaXMuX25ic3BzLChlPT5lLnNsaWNlKDEpKyIgIikpO3RoaXMuX3JpY2hUZXh0fHx0aGlzLl9jdXJyZW50W3IuJGFjY2VwdFdoaXRlc3BhY2VdKCk/dGhpcy5fY3VycmVudFtyLiRvblRleHRdKGUsdGhpcy5fcmljaFRleHQpOnRoaXMuX3doaXRlUmVnZXgudGVzdChlKXx8dGhpcy5fY3VycmVudFtyLiRvblRleHRdKGUudHJpbSgpKX1vbkNkYXRhKGUpe3RoaXMuX2N1cnJlbnRbci4kb25UZXh0XShlKX1fbWtBdHRyaWJ1dGVzKGUsdCl7bGV0IGE9bnVsbCxuPW51bGw7Y29uc3QgaT1PYmplY3QuY3JlYXRlKHt9KTtmb3IoY29uc3R7bmFtZTpvLHZhbHVlOmN9b2YgZSlpZigieG1sbnMiPT09bylhPygwLHMud2FybikoYFhGQSAtIG11bHRpcGxlIG5hbWVzcGFjZSBkZWZpbml0aW9uIGluIDwke3R9PmApOmE9YztlbHNlIGlmKG8uc3RhcnRzV2l0aCgieG1sbnM6Iikpe2NvbnN0IGU9by5zdWJzdHJpbmcoInhtbG5zOiIubGVuZ3RoKTtufHwobj1bXSk7bi5wdXNoKHtwcmVmaXg6ZSx2YWx1ZTpjfSl9ZWxzZXtjb25zdCBlPW8uaW5kZXhPZigiOiIpO2lmKC0xPT09ZSlpW29dPWM7ZWxzZXtsZXQgdD1pW3IuJG5zQXR0cmlidXRlc107dHx8KHQ9aVtyLiRuc0F0dHJpYnV0ZXNdPU9iamVjdC5jcmVhdGUobnVsbCkpO2NvbnN0W2Esbl09W28uc2xpY2UoMCxlKSxvLnNsaWNlKGUrMSldO2xldCBzPXRbYV07c3x8KHM9dFthXT1PYmplY3QuY3JlYXRlKG51bGwpKTtzW25dPWN9fXJldHVyblthLG4saV19X2dldE5hbWVBbmRQcmVmaXgoZSx0KXtjb25zdCBhPWUuaW5kZXhPZigiOiIpO3JldHVybi0xPT09YT9bZSxudWxsXTpbZS5zdWJzdHJpbmcoYSsxKSx0PyIiOmUuc3Vic3RyaW5nKDAsYSldfW9uQmVnaW5FbGVtZW50KGUsdCxhKXtjb25zdFtuLGksc109dGhpcy5fbWtBdHRyaWJ1dGVzKHQsZSksW28sY109dGhpcy5fZ2V0TmFtZUFuZFByZWZpeChlLHRoaXMuX2J1aWxkZXIuaXNOc0Fnbm9zdGljKCkpLGw9dGhpcy5fYnVpbGRlci5idWlsZCh7bnNQcmVmaXg6YyxuYW1lOm8sYXR0cmlidXRlczpzLG5hbWVzcGFjZTpuLHByZWZpeGVzOml9KTtsW3IuJGdsb2JhbERhdGFdPXRoaXMuX2dsb2JhbERhdGE7aWYoYSl7bFtyLiRmaW5hbGl6ZV0oKTt0aGlzLl9jdXJyZW50W3IuJG9uQ2hpbGRdKGwpJiZsW3IuJHNldElkXSh0aGlzLl9pZHMpO2xbci4kY2xlYW5dKHRoaXMuX2J1aWxkZXIpfWVsc2V7dGhpcy5fc3RhY2sucHVzaCh0aGlzLl9jdXJyZW50KTt0aGlzLl9jdXJyZW50PWx9fW9uRW5kRWxlbWVudChlKXtjb25zdCB0PXRoaXMuX2N1cnJlbnQ7aWYodFtyLiRpc0NEQVRBWG1sXSgpJiYic3RyaW5nIj09dHlwZW9mIHRbci4kY29udGVudF0pe2NvbnN0IGU9bmV3IFhGQVBhcnNlcjtlLl9nbG9iYWxEYXRhPXRoaXMuX2dsb2JhbERhdGE7Y29uc3QgYT1lLnBhcnNlKHRbci4kY29udGVudF0pO3Rbci4kY29udGVudF09bnVsbDt0W3IuJG9uQ2hpbGRdKGEpfXRbci4kZmluYWxpemVdKCk7dGhpcy5fY3VycmVudD10aGlzLl9zdGFjay5wb3AoKTt0aGlzLl9jdXJyZW50W3IuJG9uQ2hpbGRdKHQpJiZ0W3IuJHNldElkXSh0aGlzLl9pZHMpO3Rbci4kY2xlYW5dKHRoaXMuX2J1aWxkZXIpfW9uRXJyb3IoZSl7dGhpcy5fZXJyb3JDb2RlPWV9fXQuWEZBUGFyc2VyPVhGQVBhcnNlcn0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LkJ1aWxkZXI9dm9pZCAwO3ZhciByPWEoNzkpLG49YSg3NyksaT1hKDkwKSxzPWEoODIpLG89YSg5OSksYz1hKDIpO2NsYXNzIFJvb3QgZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcigtMSwicm9vdCIsT2JqZWN0LmNyZWF0ZShudWxsKSk7dGhpcy5lbGVtZW50PW51bGw7dGhpc1tuLiRpZHNdPWV9W24uJG9uQ2hpbGRdKGUpe3RoaXMuZWxlbWVudD1lO3JldHVybiEwfVtuLiRmaW5hbGl6ZV0oKXtzdXBlcltuLiRmaW5hbGl6ZV0oKTtpZih0aGlzLmVsZW1lbnQudGVtcGxhdGUgaW5zdGFuY2VvZiBzLlRlbXBsYXRlKXt0aGlzW24uJGlkc10uc2V0KG4uJHJvb3QsdGhpcy5lbGVtZW50KTt0aGlzLmVsZW1lbnQudGVtcGxhdGVbbi4kcmVzb2x2ZVByb3RvdHlwZXNdKHRoaXNbbi4kaWRzXSk7dGhpcy5lbGVtZW50LnRlbXBsYXRlW24uJGlkc109dGhpc1tuLiRpZHNdfX19Y2xhc3MgRW1wdHkgZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC0xLCIiLE9iamVjdC5jcmVhdGUobnVsbCkpfVtuLiRvbkNoaWxkXShlKXtyZXR1cm4hMX19dC5CdWlsZGVyPWNsYXNzIEJ1aWxkZXJ7Y29uc3RydWN0b3IoZT1udWxsKXt0aGlzLl9uYW1lc3BhY2VTdGFjaz1bXTt0aGlzLl9uc0Fnbm9zdGljTGV2ZWw9MDt0aGlzLl9uYW1lc3BhY2VQcmVmaXhlcz1uZXcgTWFwO3RoaXMuX25hbWVzcGFjZXM9bmV3IE1hcDt0aGlzLl9uZXh0TnNJZD1NYXRoLm1heCguLi5PYmplY3QudmFsdWVzKHIuTmFtZXNwYWNlSWRzKS5tYXAoKCh7aWQ6ZX0pPT5lKSkpO3RoaXMuX2N1cnJlbnROYW1lc3BhY2U9ZXx8bmV3IG8uVW5rbm93bk5hbWVzcGFjZSgrK3RoaXMuX25leHROc0lkKX1idWlsZFJvb3QoZSl7cmV0dXJuIG5ldyBSb290KGUpfWJ1aWxkKHtuc1ByZWZpeDplLG5hbWU6dCxhdHRyaWJ1dGVzOmEsbmFtZXNwYWNlOnMscHJlZml4ZXM6b30pe2NvbnN0IGM9bnVsbCE9PXM7aWYoYyl7dGhpcy5fbmFtZXNwYWNlU3RhY2sucHVzaCh0aGlzLl9jdXJyZW50TmFtZXNwYWNlKTt0aGlzLl9jdXJyZW50TmFtZXNwYWNlPXRoaXMuX3NlYXJjaE5hbWVzcGFjZShzKX1vJiZ0aGlzLl9hZGROYW1lc3BhY2VQcmVmaXgobyk7aWYoYS5oYXNPd25Qcm9wZXJ0eShuLiRuc0F0dHJpYnV0ZXMpKXtjb25zdCBlPWkuTmFtZXNwYWNlU2V0VXAuZGF0YXNldHMsdD1hW24uJG5zQXR0cmlidXRlc107bGV0IHI9bnVsbDtmb3IoY29uc3RbYSxuXW9mIE9iamVjdC5lbnRyaWVzKHQpKXtpZih0aGlzLl9nZXROYW1lc3BhY2VUb1VzZShhKT09PWUpe3I9e3hmYTpufTticmVha319cj9hW24uJG5zQXR0cmlidXRlc109cjpkZWxldGUgYVtuLiRuc0F0dHJpYnV0ZXNdfWNvbnN0IGw9dGhpcy5fZ2V0TmFtZXNwYWNlVG9Vc2UoZSksaD1sJiZsW3IuJGJ1aWxkWEZBT2JqZWN0XSh0LGEpfHxuZXcgRW1wdHk7aFtuLiRpc05zQWdub3N0aWNdKCkmJnRoaXMuX25zQWdub3N0aWNMZXZlbCsrOyhjfHxvfHxoW24uJGlzTnNBZ25vc3RpY10oKSkmJihoW24uJGNsZWFudXBdPXtoYXNOYW1lc3BhY2U6YyxwcmVmaXhlczpvLG5zQWdub3N0aWM6aFtuLiRpc05zQWdub3N0aWNdKCl9KTtyZXR1cm4gaH1pc05zQWdub3N0aWMoKXtyZXR1cm4gdGhpcy5fbnNBZ25vc3RpY0xldmVsPjB9X3NlYXJjaE5hbWVzcGFjZShlKXtsZXQgdD10aGlzLl9uYW1lc3BhY2VzLmdldChlKTtpZih0KXJldHVybiB0O2Zvcihjb25zdFthLHtjaGVjazpufV1vZiBPYmplY3QuZW50cmllcyhyLk5hbWVzcGFjZUlkcykpaWYobihlKSl7dD1pLk5hbWVzcGFjZVNldFVwW2FdO2lmKHQpe3RoaXMuX25hbWVzcGFjZXMuc2V0KGUsdCk7cmV0dXJuIHR9YnJlYWt9dD1uZXcgby5Vbmtub3duTmFtZXNwYWNlKCsrdGhpcy5fbmV4dE5zSWQpO3RoaXMuX25hbWVzcGFjZXMuc2V0KGUsdCk7cmV0dXJuIHR9X2FkZE5hbWVzcGFjZVByZWZpeChlKXtmb3IoY29uc3R7cHJlZml4OnQsdmFsdWU6YX1vZiBlKXtjb25zdCBlPXRoaXMuX3NlYXJjaE5hbWVzcGFjZShhKTtsZXQgcj10aGlzLl9uYW1lc3BhY2VQcmVmaXhlcy5nZXQodCk7aWYoIXIpe3I9W107dGhpcy5fbmFtZXNwYWNlUHJlZml4ZXMuc2V0KHQscil9ci5wdXNoKGUpfX1fZ2V0TmFtZXNwYWNlVG9Vc2UoZSl7aWYoIWUpcmV0dXJuIHRoaXMuX2N1cnJlbnROYW1lc3BhY2U7Y29uc3QgdD10aGlzLl9uYW1lc3BhY2VQcmVmaXhlcy5nZXQoZSk7aWYodCYmdC5sZW5ndGg+MClyZXR1cm4gdC5hdCgtMSk7KDAsYy53YXJuKShgVW5rbm93biBuYW1lc3BhY2UgcHJlZml4OiAke2V9LmApO3JldHVybiBudWxsfWNsZWFuKGUpe2NvbnN0e2hhc05hbWVzcGFjZTp0LHByZWZpeGVzOmEsbnNBZ25vc3RpYzpyfT1lO3QmJih0aGlzLl9jdXJyZW50TmFtZXNwYWNlPXRoaXMuX25hbWVzcGFjZVN0YWNrLnBvcCgpKTthJiZhLmZvckVhY2goKCh7cHJlZml4OmV9KT0+e3RoaXMuX25hbWVzcGFjZVByZWZpeGVzLmdldChlKS5wb3AoKX0pKTtyJiZ0aGlzLl9uc0Fnbm9zdGljTGV2ZWwtLX19fSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuTmFtZXNwYWNlU2V0VXA9dm9pZCAwO3ZhciByPWEoOTEpLG49YSg5MiksaT1hKDkzKSxzPWEoOTQpLG89YSg5NSksYz1hKDk2KSxsPWEoODIpLGg9YSg5NyksdT1hKDk4KTtjb25zdCBkPXtjb25maWc6ci5Db25maWdOYW1lc3BhY2UsY29ubmVjdGlvbjpuLkNvbm5lY3Rpb25TZXROYW1lc3BhY2UsZGF0YXNldHM6aS5EYXRhc2V0c05hbWVzcGFjZSxsb2NhbGVTZXQ6cy5Mb2NhbGVTZXROYW1lc3BhY2Usc2lnbmF0dXJlOm8uU2lnbmF0dXJlTmFtZXNwYWNlLHN0eWxlc2hlZXQ6Yy5TdHlsZXNoZWV0TmFtZXNwYWNlLHRlbXBsYXRlOmwuVGVtcGxhdGVOYW1lc3BhY2UseGRwOmguWGRwTmFtZXNwYWNlLHhodG1sOnUuWGh0bWxOYW1lc3BhY2V9O3QuTmFtZXNwYWNlU2V0VXA9ZH0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LkNvbmZpZ05hbWVzcGFjZT12b2lkIDA7dmFyIHI9YSg3OSksbj1hKDc3KSxpPWEoNzgpLHM9YSgyKTtjb25zdCBvPXIuTmFtZXNwYWNlSWRzLmNvbmZpZy5pZDtjbGFzcyBBY3JvYmF0IGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywiYWNyb2JhdCIsITApO3RoaXMuYWNyb2JhdDc9bnVsbDt0aGlzLmF1dG9TYXZlPW51bGw7dGhpcy5jb21tb249bnVsbDt0aGlzLnZhbGlkYXRlPW51bGw7dGhpcy52YWxpZGF0ZUFwcHJvdmFsU2lnbmF0dXJlcz1udWxsO3RoaXMuc3VibWl0VXJsPW5ldyBuLlhGQU9iamVjdEFycmF5fX1jbGFzcyBBY3JvYmF0NyBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sImFjcm9iYXQ3IiwhMCk7dGhpcy5keW5hbWljUmVuZGVyPW51bGx9fWNsYXNzIEFEQkVfSlNDb25zb2xlIGV4dGVuZHMgbi5PcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywiQURCRV9KU0NvbnNvbGUiLFsiZGVsZWdhdGUiLCJFbmFibGUiLCJEaXNhYmxlIl0pfX1jbGFzcyBBREJFX0pTRGVidWdnZXIgZXh0ZW5kcyBuLk9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJBREJFX0pTRGVidWdnZXIiLFsiZGVsZWdhdGUiLCJFbmFibGUiLCJEaXNhYmxlIl0pfX1jbGFzcyBBZGRTaWxlbnRQcmludCBleHRlbmRzIG4uT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIobywiYWRkU2lsZW50UHJpbnQiKX19Y2xhc3MgQWRkVmlld2VyUHJlZmVyZW5jZXMgZXh0ZW5kcyBuLk9wdGlvbjAxe2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sImFkZFZpZXdlclByZWZlcmVuY2VzIil9fWNsYXNzIEFkanVzdERhdGEgZXh0ZW5kcyBuLk9wdGlvbjEwe2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sImFkanVzdERhdGEiKX19Y2xhc3MgQWRvYmVFeHRlbnNpb25MZXZlbCBleHRlbmRzIG4uSW50ZWdlck9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJhZG9iZUV4dGVuc2lvbkxldmVsIiwwLChlPT5lPj0xJiZlPD04KSl9fWNsYXNzIEFnZW50IGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywiYWdlbnQiLCEwKTt0aGlzLm5hbWU9ZS5uYW1lP2UubmFtZS50cmltKCk6IiI7dGhpcy5jb21tb249bmV3IG4uWEZBT2JqZWN0QXJyYXl9fWNsYXNzIEFsd2F5c0VtYmVkIGV4dGVuZHMgbi5Db250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sImFsd2F5c0VtYmVkIil9fWNsYXNzIEFtZCBleHRlbmRzIG4uU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sImFtZCIpfX1jbGFzcyBBcmVhIGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywiYXJlYSIpO3RoaXMubGV2ZWw9KDAsaS5nZXRJbnRlZ2VyKSh7ZGF0YTplLmxldmVsLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PmU+PTEmJmU8PTN9KTt0aGlzLm5hbWU9KDAsaS5nZXRTdHJpbmdPcHRpb24pKGUubmFtZSxbIiIsImJhcmNvZGUiLCJjb3JlaW5pdCIsImRldmljZURyaXZlciIsImZvbnQiLCJnZW5lcmFsIiwibGF5b3V0IiwibWVyZ2UiLCJzY3JpcHQiLCJzaWduYXR1cmUiLCJzb3VyY2VTZXQiLCJ0ZW1wbGF0ZUNhY2hlIl0pfX1jbGFzcyBBdHRyaWJ1dGVzIGV4dGVuZHMgbi5PcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywiYXR0cmlidXRlcyIsWyJwcmVzZXJ2ZSIsImRlbGVnYXRlIiwiaWdub3JlIl0pfX1jbGFzcyBBdXRvU2F2ZSBleHRlbmRzIG4uT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sImF1dG9TYXZlIixbImRpc2FibGVkIiwiZW5hYmxlZCJdKX19Y2xhc3MgQmFzZSBleHRlbmRzIG4uU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sImJhc2UiKX19Y2xhc3MgQmF0Y2hPdXRwdXQgZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJiYXRjaE91dHB1dCIpO3RoaXMuZm9ybWF0PSgwLGkuZ2V0U3RyaW5nT3B0aW9uKShlLmZvcm1hdCxbIm5vbmUiLCJjb25jYXQiLCJ6aXAiLCJ6aXBDb21wcmVzcyJdKX19Y2xhc3MgQmVoYXZpb3JPdmVycmlkZSBleHRlbmRzIG4uQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJiZWhhdmlvck92ZXJyaWRlIil9W24uJGZpbmFsaXplXSgpe3RoaXNbbi4kY29udGVudF09bmV3IE1hcCh0aGlzW24uJGNvbnRlbnRdLnRyaW0oKS5zcGxpdCgvXHMrLykuZmlsdGVyKChlPT5lLmluY2x1ZGVzKCI6IikpKS5tYXAoKGU9PmUuc3BsaXQoIjoiLDIpKSkpfX1jbGFzcyBDYWNoZSBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sImNhY2hlIiwhMCk7dGhpcy50ZW1wbGF0ZUNhY2hlPW51bGx9fWNsYXNzIENoYW5nZSBleHRlbmRzIG4uT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIobywiY2hhbmdlIil9fWNsYXNzIENvbW1vbiBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sImNvbW1vbiIsITApO3RoaXMuZGF0YT1udWxsO3RoaXMubG9jYWxlPW51bGw7dGhpcy5sb2NhbGVTZXQ9bnVsbDt0aGlzLm1lc3NhZ2luZz1udWxsO3RoaXMuc3VwcHJlc3NCYW5uZXI9bnVsbDt0aGlzLnRlbXBsYXRlPW51bGw7dGhpcy52YWxpZGF0aW9uTWVzc2FnaW5nPW51bGw7dGhpcy52ZXJzaW9uQ29udHJvbD1udWxsO3RoaXMubG9nPW5ldyBuLlhGQU9iamVjdEFycmF5fX1jbGFzcyBDb21wcmVzcyBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sImNvbXByZXNzIik7dGhpcy5zY29wZT0oMCxpLmdldFN0cmluZ09wdGlvbikoZS5zY29wZSxbImltYWdlT25seSIsImRvY3VtZW50Il0pfX1jbGFzcyBDb21wcmVzc0xvZ2ljYWxTdHJ1Y3R1cmUgZXh0ZW5kcyBuLk9wdGlvbjAxe2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sImNvbXByZXNzTG9naWNhbFN0cnVjdHVyZSIpfX1jbGFzcyBDb21wcmVzc09iamVjdFN0cmVhbSBleHRlbmRzIG4uT3B0aW9uMTB7Y29uc3RydWN0b3IoZSl7c3VwZXIobywiY29tcHJlc3NPYmplY3RTdHJlYW0iKX19Y2xhc3MgQ29tcHJlc3Npb24gZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJjb21wcmVzc2lvbiIsITApO3RoaXMuY29tcHJlc3NMb2dpY2FsU3RydWN0dXJlPW51bGw7dGhpcy5jb21wcmVzc09iamVjdFN0cmVhbT1udWxsO3RoaXMubGV2ZWw9bnVsbDt0aGlzLnR5cGU9bnVsbH19Y2xhc3MgQ29uZmlnIGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywiY29uZmlnIiwhMCk7dGhpcy5hY3JvYmF0PW51bGw7dGhpcy5wcmVzZW50PW51bGw7dGhpcy50cmFjZT1udWxsO3RoaXMuYWdlbnQ9bmV3IG4uWEZBT2JqZWN0QXJyYXl9fWNsYXNzIENvbmZvcm1hbmNlIGV4dGVuZHMgbi5PcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywiY29uZm9ybWFuY2UiLFsiQSIsIkIiXSl9fWNsYXNzIENvbnRlbnRDb3B5IGV4dGVuZHMgbi5PcHRpb24wMXtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJjb250ZW50Q29weSIpfX1jbGFzcyBDb3BpZXMgZXh0ZW5kcyBuLkludGVnZXJPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywiY29waWVzIiwxLChlPT5lPj0xKSl9fWNsYXNzIENyZWF0b3IgZXh0ZW5kcyBuLlN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJjcmVhdG9yIil9fWNsYXNzIEN1cnJlbnRQYWdlIGV4dGVuZHMgbi5JbnRlZ2VyT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sImN1cnJlbnRQYWdlIiwwLChlPT5lPj0wKSl9fWNsYXNzIERhdGEgZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJkYXRhIiwhMCk7dGhpcy5hZGp1c3REYXRhPW51bGw7dGhpcy5hdHRyaWJ1dGVzPW51bGw7dGhpcy5pbmNyZW1lbnRhbExvYWQ9bnVsbDt0aGlzLm91dHB1dFhTTD1udWxsO3RoaXMucmFuZ2U9bnVsbDt0aGlzLnJlY29yZD1udWxsO3RoaXMuc3RhcnROb2RlPW51bGw7dGhpcy51cmk9bnVsbDt0aGlzLndpbmRvdz1udWxsO3RoaXMueHNsPW51bGw7dGhpcy5leGNsdWRlTlM9bmV3IG4uWEZBT2JqZWN0QXJyYXk7dGhpcy50cmFuc2Zvcm09bmV3IG4uWEZBT2JqZWN0QXJyYXl9fWNsYXNzIERlYnVnIGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywiZGVidWciLCEwKTt0aGlzLnVyaT1udWxsfX1jbGFzcyBEZWZhdWx0VHlwZWZhY2UgZXh0ZW5kcyBuLkNvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywiZGVmYXVsdFR5cGVmYWNlIik7dGhpcy53cml0aW5nU2NyaXB0PSgwLGkuZ2V0U3RyaW5nT3B0aW9uKShlLndyaXRpbmdTY3JpcHQsWyIqIiwiQXJhYmljIiwiQ3lyaWxsaWMiLCJFYXN0RXVyb3BlYW5Sb21hbiIsIkdyZWVrIiwiSGVicmV3IiwiSmFwYW5lc2UiLCJLb3JlYW4iLCJSb21hbiIsIlNpbXBsaWZpZWRDaGluZXNlIiwiVGhhaSIsIlRyYWRpdGlvbmFsQ2hpbmVzZSIsIlZpZXRuYW1lc2UiXSl9fWNsYXNzIERlc3RpbmF0aW9uIGV4dGVuZHMgbi5PcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywiZGVzdGluYXRpb24iLFsicGRmIiwicGNsIiwicHMiLCJ3ZWJDbGllbnQiLCJ6cGwiXSl9fWNsYXNzIERvY3VtZW50QXNzZW1ibHkgZXh0ZW5kcyBuLk9wdGlvbjAxe2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sImRvY3VtZW50QXNzZW1ibHkiKX19Y2xhc3MgRHJpdmVyIGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywiZHJpdmVyIiwhMCk7dGhpcy5uYW1lPWUubmFtZT9lLm5hbWUudHJpbSgpOiIiO3RoaXMuZm9udEluZm89bnVsbDt0aGlzLnhkYz1udWxsfX1jbGFzcyBEdXBsZXhPcHRpb24gZXh0ZW5kcyBuLk9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJkdXBsZXhPcHRpb24iLFsic2ltcGxleCIsImR1cGxleEZsaXBMb25nRWRnZSIsImR1cGxleEZsaXBTaG9ydEVkZ2UiXSl9fWNsYXNzIER5bmFtaWNSZW5kZXIgZXh0ZW5kcyBuLk9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJkeW5hbWljUmVuZGVyIixbImZvcmJpZGRlbiIsInJlcXVpcmVkIl0pfX1jbGFzcyBFbWJlZCBleHRlbmRzIG4uT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIobywiZW1iZWQiKX19Y2xhc3MgRW5jcnlwdCBleHRlbmRzIG4uT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIobywiZW5jcnlwdCIpfX1jbGFzcyBFbmNyeXB0aW9uIGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywiZW5jcnlwdGlvbiIsITApO3RoaXMuZW5jcnlwdD1udWxsO3RoaXMuZW5jcnlwdGlvbkxldmVsPW51bGw7dGhpcy5wZXJtaXNzaW9ucz1udWxsfX1jbGFzcyBFbmNyeXB0aW9uTGV2ZWwgZXh0ZW5kcyBuLk9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJlbmNyeXB0aW9uTGV2ZWwiLFsiNDBiaXQiLCIxMjhiaXQiXSl9fWNsYXNzIEVuZm9yY2UgZXh0ZW5kcyBuLlN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJlbmZvcmNlIil9fWNsYXNzIEVxdWF0ZSBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sImVxdWF0ZSIpO3RoaXMuZm9yY2U9KDAsaS5nZXRJbnRlZ2VyKSh7ZGF0YTplLmZvcmNlLGRlZmF1bHRWYWx1ZToxLHZhbGlkYXRlOmU9PjA9PT1lfSk7dGhpcy5mcm9tPWUuZnJvbXx8IiI7dGhpcy50bz1lLnRvfHwiIn19Y2xhc3MgRXF1YXRlUmFuZ2UgZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJlcXVhdGVSYW5nZSIpO3RoaXMuZnJvbT1lLmZyb218fCIiO3RoaXMudG89ZS50b3x8IiI7dGhpcy5fdW5pY29kZVJhbmdlPWUudW5pY29kZVJhbmdlfHwiIn1nZXQgdW5pY29kZVJhbmdlKCl7Y29uc3QgZT1bXSx0PS9VXCsoWzAtOWEtZkEtRl0rKS8sYT10aGlzLl91bmljb2RlUmFuZ2U7Zm9yKGxldCByIG9mIGEuc3BsaXQoIiwiKS5tYXAoKGU9PmUudHJpbSgpKSkuZmlsdGVyKChlPT4hIWUpKSl7cj1yLnNwbGl0KCItIiwyKS5tYXAoKGU9Pntjb25zdCBhPWUubWF0Y2godCk7cmV0dXJuIGE/cGFyc2VJbnQoYVsxXSwxNik6MH0pKTsxPT09ci5sZW5ndGgmJnIucHVzaChyWzBdKTtlLnB1c2gocil9cmV0dXJuKDAscy5zaGFkb3cpKHRoaXMsInVuaWNvZGVSYW5nZSIsZSl9fWNsYXNzIEV4Y2x1ZGUgZXh0ZW5kcyBuLkNvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywiZXhjbHVkZSIpfVtuLiRmaW5hbGl6ZV0oKXt0aGlzW24uJGNvbnRlbnRdPXRoaXNbbi4kY29udGVudF0udHJpbSgpLnNwbGl0KC9ccysvKS5maWx0ZXIoKGU9PmUmJlsiY2FsY3VsYXRlIiwiY2xvc2UiLCJlbnRlciIsImV4aXQiLCJpbml0aWFsaXplIiwicmVhZHkiLCJ2YWxpZGF0ZSJdLmluY2x1ZGVzKGUpKSl9fWNsYXNzIEV4Y2x1ZGVOUyBleHRlbmRzIG4uU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sImV4Y2x1ZGVOUyIpfX1jbGFzcyBGbGlwTGFiZWwgZXh0ZW5kcyBuLk9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJmbGlwTGFiZWwiLFsidXNlUHJpbnRlclNldHRpbmciLCJvbiIsIm9mZiJdKX19Y2xhc3MgRm9udEluZm8gZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJmb250SW5mbyIsITApO3RoaXMuZW1iZWQ9bnVsbDt0aGlzLm1hcD1udWxsO3RoaXMuc3Vic2V0QmVsb3c9bnVsbDt0aGlzLmFsd2F5c0VtYmVkPW5ldyBuLlhGQU9iamVjdEFycmF5O3RoaXMuZGVmYXVsdFR5cGVmYWNlPW5ldyBuLlhGQU9iamVjdEFycmF5O3RoaXMubmV2ZXJFbWJlZD1uZXcgbi5YRkFPYmplY3RBcnJheX19Y2xhc3MgRm9ybUZpZWxkRmlsbGluZyBleHRlbmRzIG4uT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIobywiZm9ybUZpZWxkRmlsbGluZyIpfX1jbGFzcyBHcm91cFBhcmVudCBleHRlbmRzIG4uU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sImdyb3VwUGFyZW50Iil9fWNsYXNzIElmRW1wdHkgZXh0ZW5kcyBuLk9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJpZkVtcHR5IixbImRhdGFWYWx1ZSIsImRhdGFHcm91cCIsImlnbm9yZSIsInJlbW92ZSJdKX19Y2xhc3MgSW5jbHVkZVhEUENvbnRlbnQgZXh0ZW5kcyBuLlN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJpbmNsdWRlWERQQ29udGVudCIpfX1jbGFzcyBJbmNyZW1lbnRhbExvYWQgZXh0ZW5kcyBuLk9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJpbmNyZW1lbnRhbExvYWQiLFsibm9uZSIsImZvcndhcmRPbmx5Il0pfX1jbGFzcyBJbmNyZW1lbnRhbE1lcmdlIGV4dGVuZHMgbi5PcHRpb24wMXtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJpbmNyZW1lbnRhbE1lcmdlIil9fWNsYXNzIEludGVyYWN0aXZlIGV4dGVuZHMgbi5PcHRpb24wMXtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJpbnRlcmFjdGl2ZSIpfX1jbGFzcyBKb2cgZXh0ZW5kcyBuLk9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJqb2ciLFsidXNlUHJpbnRlclNldHRpbmciLCJub25lIiwicGFnZVNldCJdKX19Y2xhc3MgTGFiZWxQcmludGVyIGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywibGFiZWxQcmludGVyIiwhMCk7dGhpcy5uYW1lPSgwLGkuZ2V0U3RyaW5nT3B0aW9uKShlLm5hbWUsWyJ6cGwiLCJkcGwiLCJpcGwiLCJ0Y3BsIl0pO3RoaXMuYmF0Y2hPdXRwdXQ9bnVsbDt0aGlzLmZsaXBMYWJlbD1udWxsO3RoaXMuZm9udEluZm89bnVsbDt0aGlzLnhkYz1udWxsfX1jbGFzcyBMYXlvdXQgZXh0ZW5kcyBuLk9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJsYXlvdXQiLFsicGFnaW5hdGUiLCJwYW5lbCJdKX19Y2xhc3MgTGV2ZWwgZXh0ZW5kcyBuLkludGVnZXJPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywibGV2ZWwiLDAsKGU9PmU+MCkpfX1jbGFzcyBMaW5lYXJpemVkIGV4dGVuZHMgbi5PcHRpb24wMXtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJsaW5lYXJpemVkIil9fWNsYXNzIExvY2FsZSBleHRlbmRzIG4uU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sImxvY2FsZSIpfX1jbGFzcyBMb2NhbGVTZXQgZXh0ZW5kcyBuLlN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJsb2NhbGVTZXQiKX19Y2xhc3MgTG9nIGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywibG9nIiwhMCk7dGhpcy5tb2RlPW51bGw7dGhpcy50aHJlc2hvbGQ9bnVsbDt0aGlzLnRvPW51bGw7dGhpcy51cmk9bnVsbH19Y2xhc3MgTWFwRWxlbWVudCBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sIm1hcCIsITApO3RoaXMuZXF1YXRlPW5ldyBuLlhGQU9iamVjdEFycmF5O3RoaXMuZXF1YXRlUmFuZ2U9bmV3IG4uWEZBT2JqZWN0QXJyYXl9fWNsYXNzIE1lZGl1bUluZm8gZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJtZWRpdW1JbmZvIiwhMCk7dGhpcy5tYXA9bnVsbH19Y2xhc3MgTWVzc2FnZSBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sIm1lc3NhZ2UiLCEwKTt0aGlzLm1zZ0lkPW51bGw7dGhpcy5zZXZlcml0eT1udWxsfX1jbGFzcyBNZXNzYWdpbmcgZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJtZXNzYWdpbmciLCEwKTt0aGlzLm1lc3NhZ2U9bmV3IG4uWEZBT2JqZWN0QXJyYXl9fWNsYXNzIE1vZGUgZXh0ZW5kcyBuLk9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJtb2RlIixbImFwcGVuZCIsIm92ZXJ3cml0ZSJdKX19Y2xhc3MgTW9kaWZ5QW5ub3RzIGV4dGVuZHMgbi5PcHRpb24wMXtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJtb2RpZnlBbm5vdHMiKX19Y2xhc3MgTXNnSWQgZXh0ZW5kcyBuLkludGVnZXJPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywibXNnSWQiLDEsKGU9PmU+PTEpKX19Y2xhc3MgTmFtZUF0dHIgZXh0ZW5kcyBuLlN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJuYW1lQXR0ciIpfX1jbGFzcyBOZXZlckVtYmVkIGV4dGVuZHMgbi5Db250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sIm5ldmVyRW1iZWQiKX19Y2xhc3MgTnVtYmVyT2ZDb3BpZXMgZXh0ZW5kcyBuLkludGVnZXJPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywibnVtYmVyT2ZDb3BpZXMiLG51bGwsKGU9PmU+PTImJmU8PTUpKX19Y2xhc3MgT3BlbkFjdGlvbiBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sIm9wZW5BY3Rpb24iLCEwKTt0aGlzLmRlc3RpbmF0aW9uPW51bGx9fWNsYXNzIE91dHB1dCBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sIm91dHB1dCIsITApO3RoaXMudG89bnVsbDt0aGlzLnR5cGU9bnVsbDt0aGlzLnVyaT1udWxsfX1jbGFzcyBPdXRwdXRCaW4gZXh0ZW5kcyBuLlN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJvdXRwdXRCaW4iKX19Y2xhc3MgT3V0cHV0WFNMIGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywib3V0cHV0WFNMIiwhMCk7dGhpcy51cmk9bnVsbH19Y2xhc3MgT3ZlcnByaW50IGV4dGVuZHMgbi5PcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywib3ZlcnByaW50IixbIm5vbmUiLCJib3RoIiwiZHJhdyIsImZpZWxkIl0pfX1jbGFzcyBQYWNrZXRzIGV4dGVuZHMgbi5TdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywicGFja2V0cyIpfVtuLiRmaW5hbGl6ZV0oKXsiKiIhPT10aGlzW24uJGNvbnRlbnRdJiYodGhpc1tuLiRjb250ZW50XT10aGlzW24uJGNvbnRlbnRdLnRyaW0oKS5zcGxpdCgvXHMrLykuZmlsdGVyKChlPT5bImNvbmZpZyIsImRhdGFzZXRzIiwidGVtcGxhdGUiLCJ4ZmRmIiwieHNsdCJdLmluY2x1ZGVzKGUpKSkpfX1jbGFzcyBQYWdlT2Zmc2V0IGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywicGFnZU9mZnNldCIpO3RoaXMueD0oMCxpLmdldEludGVnZXIpKHtkYXRhOmUueCxkZWZhdWx0VmFsdWU6InVzZVhEQ1NldHRpbmciLHZhbGlkYXRlOmU9PiEwfSk7dGhpcy55PSgwLGkuZ2V0SW50ZWdlcikoe2RhdGE6ZS55LGRlZmF1bHRWYWx1ZToidXNlWERDU2V0dGluZyIsdmFsaWRhdGU6ZT0+ITB9KX19Y2xhc3MgUGFnZVJhbmdlIGV4dGVuZHMgbi5TdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywicGFnZVJhbmdlIil9W24uJGZpbmFsaXplXSgpe2NvbnN0IGU9dGhpc1tuLiRjb250ZW50XS50cmltKCkuc3BsaXQoL1xzKy8pLm1hcCgoZT0+cGFyc2VJbnQoZSwxMCkpKSx0PVtdO2ZvcihsZXQgYT0wLHI9ZS5sZW5ndGg7YTxyO2ErPTIpdC5wdXNoKGUuc2xpY2UoYSxhKzIpKTt0aGlzW24uJGNvbnRlbnRdPXR9fWNsYXNzIFBhZ2luYXRpb24gZXh0ZW5kcyBuLk9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJwYWdpbmF0aW9uIixbInNpbXBsZXgiLCJkdXBsZXhTaG9ydEVkZ2UiLCJkdXBsZXhMb25nRWRnZSJdKX19Y2xhc3MgUGFnaW5hdGlvbk92ZXJyaWRlIGV4dGVuZHMgbi5PcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywicGFnaW5hdGlvbk92ZXJyaWRlIixbIm5vbmUiLCJmb3JjZUR1cGxleCIsImZvcmNlRHVwbGV4TG9uZ0VkZ2UiLCJmb3JjZUR1cGxleFNob3J0RWRnZSIsImZvcmNlU2ltcGxleCJdKX19Y2xhc3MgUGFydCBleHRlbmRzIG4uSW50ZWdlck9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJwYXJ0IiwxLChlPT4hMSkpfX1jbGFzcyBQY2wgZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJwY2wiLCEwKTt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLmJhdGNoT3V0cHV0PW51bGw7dGhpcy5mb250SW5mbz1udWxsO3RoaXMuam9nPW51bGw7dGhpcy5tZWRpdW1JbmZvPW51bGw7dGhpcy5vdXRwdXRCaW49bnVsbDt0aGlzLnBhZ2VPZmZzZXQ9bnVsbDt0aGlzLnN0YXBsZT1udWxsO3RoaXMueGRjPW51bGx9fWNsYXNzIFBkZiBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sInBkZiIsITApO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMuYWRvYmVFeHRlbnNpb25MZXZlbD1udWxsO3RoaXMuYmF0Y2hPdXRwdXQ9bnVsbDt0aGlzLmNvbXByZXNzaW9uPW51bGw7dGhpcy5jcmVhdG9yPW51bGw7dGhpcy5lbmNyeXB0aW9uPW51bGw7dGhpcy5mb250SW5mbz1udWxsO3RoaXMuaW50ZXJhY3RpdmU9bnVsbDt0aGlzLmxpbmVhcml6ZWQ9bnVsbDt0aGlzLm9wZW5BY3Rpb249bnVsbDt0aGlzLnBkZmE9bnVsbDt0aGlzLnByb2R1Y2VyPW51bGw7dGhpcy5yZW5kZXJQb2xpY3k9bnVsbDt0aGlzLnNjcmlwdE1vZGVsPW51bGw7dGhpcy5zaWxlbnRQcmludD1udWxsO3RoaXMuc3VibWl0Rm9ybWF0PW51bGw7dGhpcy50YWdnZWQ9bnVsbDt0aGlzLnZlcnNpb249bnVsbDt0aGlzLnZpZXdlclByZWZlcmVuY2VzPW51bGw7dGhpcy54ZGM9bnVsbH19Y2xhc3MgUGRmYSBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sInBkZmEiLCEwKTt0aGlzLmFtZD1udWxsO3RoaXMuY29uZm9ybWFuY2U9bnVsbDt0aGlzLmluY2x1ZGVYRFBDb250ZW50PW51bGw7dGhpcy5wYXJ0PW51bGx9fWNsYXNzIFBlcm1pc3Npb25zIGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywicGVybWlzc2lvbnMiLCEwKTt0aGlzLmFjY2Vzc2libGVDb250ZW50PW51bGw7dGhpcy5jaGFuZ2U9bnVsbDt0aGlzLmNvbnRlbnRDb3B5PW51bGw7dGhpcy5kb2N1bWVudEFzc2VtYmx5PW51bGw7dGhpcy5mb3JtRmllbGRGaWxsaW5nPW51bGw7dGhpcy5tb2RpZnlBbm5vdHM9bnVsbDt0aGlzLnBsYWludGV4dE1ldGFkYXRhPW51bGw7dGhpcy5wcmludD1udWxsO3RoaXMucHJpbnRIaWdoUXVhbGl0eT1udWxsfX1jbGFzcyBQaWNrVHJheUJ5UERGU2l6ZSBleHRlbmRzIG4uT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIobywicGlja1RyYXlCeVBERlNpemUiKX19Y2xhc3MgUGljdHVyZSBleHRlbmRzIG4uU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sInBpY3R1cmUiKX19Y2xhc3MgUGxhaW50ZXh0TWV0YWRhdGEgZXh0ZW5kcyBuLk9wdGlvbjAxe2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sInBsYWludGV4dE1ldGFkYXRhIil9fWNsYXNzIFByZXNlbmNlIGV4dGVuZHMgbi5PcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywicHJlc2VuY2UiLFsicHJlc2VydmUiLCJkaXNzb2x2ZSIsImRpc3NvbHZlU3RydWN0dXJlIiwiaWdub3JlIiwicmVtb3ZlIl0pfX1jbGFzcyBQcmVzZW50IGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywicHJlc2VudCIsITApO3RoaXMuYmVoYXZpb3JPdmVycmlkZT1udWxsO3RoaXMuY2FjaGU9bnVsbDt0aGlzLmNvbW1vbj1udWxsO3RoaXMuY29waWVzPW51bGw7dGhpcy5kZXN0aW5hdGlvbj1udWxsO3RoaXMuaW5jcmVtZW50YWxNZXJnZT1udWxsO3RoaXMubGF5b3V0PW51bGw7dGhpcy5vdXRwdXQ9bnVsbDt0aGlzLm92ZXJwcmludD1udWxsO3RoaXMucGFnaW5hdGlvbj1udWxsO3RoaXMucGFnaW5hdGlvbk92ZXJyaWRlPW51bGw7dGhpcy5zY3JpcHQ9bnVsbDt0aGlzLnZhbGlkYXRlPW51bGw7dGhpcy54ZHA9bnVsbDt0aGlzLmRyaXZlcj1uZXcgbi5YRkFPYmplY3RBcnJheTt0aGlzLmxhYmVsUHJpbnRlcj1uZXcgbi5YRkFPYmplY3RBcnJheTt0aGlzLnBjbD1uZXcgbi5YRkFPYmplY3RBcnJheTt0aGlzLnBkZj1uZXcgbi5YRkFPYmplY3RBcnJheTt0aGlzLnBzPW5ldyBuLlhGQU9iamVjdEFycmF5O3RoaXMuc3VibWl0VXJsPW5ldyBuLlhGQU9iamVjdEFycmF5O3RoaXMud2ViQ2xpZW50PW5ldyBuLlhGQU9iamVjdEFycmF5O3RoaXMuenBsPW5ldyBuLlhGQU9iamVjdEFycmF5fX1jbGFzcyBQcmludCBleHRlbmRzIG4uT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIobywicHJpbnQiKX19Y2xhc3MgUHJpbnRIaWdoUXVhbGl0eSBleHRlbmRzIG4uT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIobywicHJpbnRIaWdoUXVhbGl0eSIpfX1jbGFzcyBQcmludFNjYWxpbmcgZXh0ZW5kcyBuLk9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJwcmludFNjYWxpbmciLFsiYXBwZGVmYXVsdCIsIm5vU2NhbGluZyJdKX19Y2xhc3MgUHJpbnRlck5hbWUgZXh0ZW5kcyBuLlN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJwcmludGVyTmFtZSIpfX1jbGFzcyBQcm9kdWNlciBleHRlbmRzIG4uU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sInByb2R1Y2VyIil9fWNsYXNzIFBzIGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywicHMiLCEwKTt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLmJhdGNoT3V0cHV0PW51bGw7dGhpcy5mb250SW5mbz1udWxsO3RoaXMuam9nPW51bGw7dGhpcy5tZWRpdW1JbmZvPW51bGw7dGhpcy5vdXRwdXRCaW49bnVsbDt0aGlzLnN0YXBsZT1udWxsO3RoaXMueGRjPW51bGx9fWNsYXNzIFJhbmdlIGV4dGVuZHMgbi5Db250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sInJhbmdlIil9W24uJGZpbmFsaXplXSgpe3RoaXNbbi4kY29udGVudF09dGhpc1tuLiRjb250ZW50XS50cmltKCkuc3BsaXQoL1xzKixccyovLDIpLm1hcCgoZT0+ZS5zcGxpdCgiLSIpLm1hcCgoZT0+cGFyc2VJbnQoZS50cmltKCksMTApKSkpKS5maWx0ZXIoKGU9PmUuZXZlcnkoKGU9PiFpc05hTihlKSkpKSkubWFwKChlPT57MT09PWUubGVuZ3RoJiZlLnB1c2goZVswXSk7cmV0dXJuIGV9KSl9fWNsYXNzIFJlY29yZCBleHRlbmRzIG4uQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJyZWNvcmQiKX1bbi4kZmluYWxpemVdKCl7dGhpc1tuLiRjb250ZW50XT10aGlzW24uJGNvbnRlbnRdLnRyaW0oKTtjb25zdCBlPXBhcnNlSW50KHRoaXNbbi4kY29udGVudF0sMTApOyFpc05hTihlKSYmZT49MCYmKHRoaXNbbi4kY29udGVudF09ZSl9fWNsYXNzIFJlbGV2YW50IGV4dGVuZHMgbi5Db250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sInJlbGV2YW50Iil9W24uJGZpbmFsaXplXSgpe3RoaXNbbi4kY29udGVudF09dGhpc1tuLiRjb250ZW50XS50cmltKCkuc3BsaXQoL1xzKy8pfX1jbGFzcyBSZW5hbWUgZXh0ZW5kcyBuLkNvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywicmVuYW1lIil9W24uJGZpbmFsaXplXSgpe3RoaXNbbi4kY29udGVudF09dGhpc1tuLiRjb250ZW50XS50cmltKCk7KHRoaXNbbi4kY29udGVudF0udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCJ4bWwiKXx8dGhpc1tuLiRjb250ZW50XS5tYXRjaChuZXcgUmVnRXhwKCJbXFxwe0x9X11bXFxwe0x9XFxkLl9cXHB7TX0tXSoiLCJ1IikpKSYmKDAscy53YXJuKSgiWEZBIC0gUmVuYW1lOiBpbnZhbGlkIFhGQSBuYW1lIil9fWNsYXNzIFJlbmRlclBvbGljeSBleHRlbmRzIG4uT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sInJlbmRlclBvbGljeSIsWyJzZXJ2ZXIiLCJjbGllbnQiXSl9fWNsYXNzIFJ1blNjcmlwdHMgZXh0ZW5kcyBuLk9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJydW5TY3JpcHRzIixbImJvdGgiLCJjbGllbnQiLCJub25lIiwic2VydmVyIl0pfX1jbGFzcyBTY3JpcHQgZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJzY3JpcHQiLCEwKTt0aGlzLmN1cnJlbnRQYWdlPW51bGw7dGhpcy5leGNsdWRlPW51bGw7dGhpcy5ydW5TY3JpcHRzPW51bGx9fWNsYXNzIFNjcmlwdE1vZGVsIGV4dGVuZHMgbi5PcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywic2NyaXB0TW9kZWwiLFsiWEZBIiwibm9uZSJdKX19Y2xhc3MgU2V2ZXJpdHkgZXh0ZW5kcyBuLk9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJzZXZlcml0eSIsWyJpZ25vcmUiLCJlcnJvciIsImluZm9ybWF0aW9uIiwidHJhY2UiLCJ3YXJuaW5nIl0pfX1jbGFzcyBTaWxlbnRQcmludCBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sInNpbGVudFByaW50IiwhMCk7dGhpcy5hZGRTaWxlbnRQcmludD1udWxsO3RoaXMucHJpbnRlck5hbWU9bnVsbH19Y2xhc3MgU3RhcGxlIGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywic3RhcGxlIik7dGhpcy5tb2RlPSgwLGkuZ2V0U3RyaW5nT3B0aW9uKShlLm1vZGUsWyJ1c2VQcmludGVyU2V0dGluZyIsIm9uIiwib2ZmIl0pfX1jbGFzcyBTdGFydE5vZGUgZXh0ZW5kcyBuLlN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJzdGFydE5vZGUiKX19Y2xhc3MgU3RhcnRQYWdlIGV4dGVuZHMgbi5JbnRlZ2VyT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sInN0YXJ0UGFnZSIsMCwoZT0+ITApKX19Y2xhc3MgU3VibWl0Rm9ybWF0IGV4dGVuZHMgbi5PcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywic3VibWl0Rm9ybWF0IixbImh0bWwiLCJkZWxlZ2F0ZSIsImZkZiIsInhtbCIsInBkZiJdKX19Y2xhc3MgU3VibWl0VXJsIGV4dGVuZHMgbi5TdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywic3VibWl0VXJsIil9fWNsYXNzIFN1YnNldEJlbG93IGV4dGVuZHMgbi5JbnRlZ2VyT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sInN1YnNldEJlbG93IiwxMDAsKGU9PmU+PTAmJmU8PTEwMCkpfX1jbGFzcyBTdXBwcmVzc0Jhbm5lciBleHRlbmRzIG4uT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIobywic3VwcHJlc3NCYW5uZXIiKX19Y2xhc3MgVGFnZ2VkIGV4dGVuZHMgbi5PcHRpb24wMXtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJ0YWdnZWQiKX19Y2xhc3MgVGVtcGxhdGUgZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJ0ZW1wbGF0ZSIsITApO3RoaXMuYmFzZT1udWxsO3RoaXMucmVsZXZhbnQ9bnVsbDt0aGlzLnN0YXJ0UGFnZT1udWxsO3RoaXMudXJpPW51bGw7dGhpcy54c2w9bnVsbH19Y2xhc3MgVGhyZXNob2xkIGV4dGVuZHMgbi5PcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywidGhyZXNob2xkIixbInRyYWNlIiwiZXJyb3IiLCJpbmZvcm1hdGlvbiIsIndhcm5pbmciXSl9fWNsYXNzIFRvIGV4dGVuZHMgbi5PcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywidG8iLFsibnVsbCIsIm1lbW9yeSIsInN0ZGVyciIsInN0ZG91dCIsInN5c3RlbSIsInVyaSJdKX19Y2xhc3MgVGVtcGxhdGVDYWNoZSBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sInRlbXBsYXRlQ2FjaGUiKTt0aGlzLm1heEVudHJpZXM9KDAsaS5nZXRJbnRlZ2VyKSh7ZGF0YTplLm1heEVudHJpZXMsZGVmYXVsdFZhbHVlOjUsdmFsaWRhdGU6ZT0+ZT49MH0pfX1jbGFzcyBUcmFjZSBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sInRyYWNlIiwhMCk7dGhpcy5hcmVhPW5ldyBuLlhGQU9iamVjdEFycmF5fX1jbGFzcyBUcmFuc2Zvcm0gZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJ0cmFuc2Zvcm0iLCEwKTt0aGlzLmdyb3VwUGFyZW50PW51bGw7dGhpcy5pZkVtcHR5PW51bGw7dGhpcy5uYW1lQXR0cj1udWxsO3RoaXMucGljdHVyZT1udWxsO3RoaXMucHJlc2VuY2U9bnVsbDt0aGlzLnJlbmFtZT1udWxsO3RoaXMud2hpdGVzcGFjZT1udWxsfX1jbGFzcyBUeXBlIGV4dGVuZHMgbi5PcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywidHlwZSIsWyJub25lIiwiYXNjaWk4NSIsImFzY2lpSGV4IiwiY2NpdHRmYXgiLCJmbGF0ZSIsImx6dyIsInJ1bkxlbmd0aCIsIm5hdGl2ZSIsInhkcCIsIm1lcmdlZFhEUCJdKX19Y2xhc3MgVXJpIGV4dGVuZHMgbi5TdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywidXJpIil9fWNsYXNzIFZhbGlkYXRlIGV4dGVuZHMgbi5PcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywidmFsaWRhdGUiLFsicHJlU3VibWl0IiwicHJlUHJpbnQiLCJwcmVFeGVjdXRlIiwicHJlU2F2ZSJdKX19Y2xhc3MgVmFsaWRhdGVBcHByb3ZhbFNpZ25hdHVyZXMgZXh0ZW5kcyBuLkNvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywidmFsaWRhdGVBcHByb3ZhbFNpZ25hdHVyZXMiKX1bbi4kZmluYWxpemVdKCl7dGhpc1tuLiRjb250ZW50XT10aGlzW24uJGNvbnRlbnRdLnRyaW0oKS5zcGxpdCgvXHMrLykuZmlsdGVyKChlPT5bImRvY1JlYWR5IiwicG9zdFNpZ24iXS5pbmNsdWRlcyhlKSkpfX1jbGFzcyBWYWxpZGF0aW9uTWVzc2FnaW5nIGV4dGVuZHMgbi5PcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywidmFsaWRhdGlvbk1lc3NhZ2luZyIsWyJhbGxNZXNzYWdlc0luZGl2aWR1YWxseSIsImFsbE1lc3NhZ2VzVG9nZXRoZXIiLCJmaXJzdE1lc3NhZ2VPbmx5Iiwibm9NZXNzYWdlcyJdKX19Y2xhc3MgVmVyc2lvbiBleHRlbmRzIG4uT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sInZlcnNpb24iLFsiMS43IiwiMS42IiwiMS41IiwiMS40IiwiMS4zIiwiMS4yIl0pfX1jbGFzcyBWZXJzaW9uQ29udHJvbCBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sIlZlcnNpb25Db250cm9sIik7dGhpcy5vdXRwdXRCZWxvdz0oMCxpLmdldFN0cmluZ09wdGlvbikoZS5vdXRwdXRCZWxvdyxbIndhcm4iLCJlcnJvciIsInVwZGF0ZSJdKTt0aGlzLnNvdXJjZUFib3ZlPSgwLGkuZ2V0U3RyaW5nT3B0aW9uKShlLnNvdXJjZUFib3ZlLFsid2FybiIsImVycm9yIl0pO3RoaXMuc291cmNlQmVsb3c9KDAsaS5nZXRTdHJpbmdPcHRpb24pKGUuc291cmNlQmVsb3csWyJ1cGRhdGUiLCJtYWludGFpbiJdKX19Y2xhc3MgVmlld2VyUHJlZmVyZW5jZXMgZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJ2aWV3ZXJQcmVmZXJlbmNlcyIsITApO3RoaXMuQURCRV9KU0NvbnNvbGU9bnVsbDt0aGlzLkFEQkVfSlNEZWJ1Z2dlcj1udWxsO3RoaXMuYWRkVmlld2VyUHJlZmVyZW5jZXM9bnVsbDt0aGlzLmR1cGxleE9wdGlvbj1udWxsO3RoaXMuZW5mb3JjZT1udWxsO3RoaXMubnVtYmVyT2ZDb3BpZXM9bnVsbDt0aGlzLnBhZ2VSYW5nZT1udWxsO3RoaXMucGlja1RyYXlCeVBERlNpemU9bnVsbDt0aGlzLnByaW50U2NhbGluZz1udWxsfX1jbGFzcyBXZWJDbGllbnQgZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJ3ZWJDbGllbnQiLCEwKTt0aGlzLm5hbWU9ZS5uYW1lP2UubmFtZS50cmltKCk6IiI7dGhpcy5mb250SW5mbz1udWxsO3RoaXMueGRjPW51bGx9fWNsYXNzIFdoaXRlc3BhY2UgZXh0ZW5kcyBuLk9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJ3aGl0ZXNwYWNlIixbInByZXNlcnZlIiwibHRyaW0iLCJub3JtYWxpemUiLCJydHJpbSIsInRyaW0iXSl9fWNsYXNzIFdpbmRvdyBleHRlbmRzIG4uQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJ3aW5kb3ciKX1bbi4kZmluYWxpemVdKCl7Y29uc3QgZT10aGlzW24uJGNvbnRlbnRdLnRyaW0oKS5zcGxpdCgvXHMqLFxzKi8sMikubWFwKChlPT5wYXJzZUludChlLDEwKSkpO2lmKGUuc29tZSgoZT0+aXNOYU4oZSkpKSl0aGlzW24uJGNvbnRlbnRdPVswLDBdO2Vsc2V7MT09PWUubGVuZ3RoJiZlLnB1c2goZVswXSk7dGhpc1tuLiRjb250ZW50XT1lfX19Y2xhc3MgWGRjIGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywieGRjIiwhMCk7dGhpcy51cmk9bmV3IG4uWEZBT2JqZWN0QXJyYXk7dGhpcy54c2w9bmV3IG4uWEZBT2JqZWN0QXJyYXl9fWNsYXNzIFhkcCBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKG8sInhkcCIsITApO3RoaXMucGFja2V0cz1udWxsfX1jbGFzcyBYc2wgZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihvLCJ4c2wiLCEwKTt0aGlzLmRlYnVnPW51bGw7dGhpcy51cmk9bnVsbH19Y2xhc3MgWnBsIGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIobywienBsIiwhMCk7dGhpcy5uYW1lPWUubmFtZT9lLm5hbWUudHJpbSgpOiIiO3RoaXMuYmF0Y2hPdXRwdXQ9bnVsbDt0aGlzLmZsaXBMYWJlbD1udWxsO3RoaXMuZm9udEluZm89bnVsbDt0aGlzLnhkYz1udWxsfX1jbGFzcyBDb25maWdOYW1lc3BhY2V7c3RhdGljW3IuJGJ1aWxkWEZBT2JqZWN0XShlLHQpe2lmKENvbmZpZ05hbWVzcGFjZS5oYXNPd25Qcm9wZXJ0eShlKSlyZXR1cm4gQ29uZmlnTmFtZXNwYWNlW2VdKHQpfXN0YXRpYyBhY3JvYmF0KGUpe3JldHVybiBuZXcgQWNyb2JhdChlKX1zdGF0aWMgYWNyb2JhdDcoZSl7cmV0dXJuIG5ldyBBY3JvYmF0NyhlKX1zdGF0aWMgQURCRV9KU0NvbnNvbGUoZSl7cmV0dXJuIG5ldyBBREJFX0pTQ29uc29sZShlKX1zdGF0aWMgQURCRV9KU0RlYnVnZ2VyKGUpe3JldHVybiBuZXcgQURCRV9KU0RlYnVnZ2VyKGUpfXN0YXRpYyBhZGRTaWxlbnRQcmludChlKXtyZXR1cm4gbmV3IEFkZFNpbGVudFByaW50KGUpfXN0YXRpYyBhZGRWaWV3ZXJQcmVmZXJlbmNlcyhlKXtyZXR1cm4gbmV3IEFkZFZpZXdlclByZWZlcmVuY2VzKGUpfXN0YXRpYyBhZGp1c3REYXRhKGUpe3JldHVybiBuZXcgQWRqdXN0RGF0YShlKX1zdGF0aWMgYWRvYmVFeHRlbnNpb25MZXZlbChlKXtyZXR1cm4gbmV3IEFkb2JlRXh0ZW5zaW9uTGV2ZWwoZSl9c3RhdGljIGFnZW50KGUpe3JldHVybiBuZXcgQWdlbnQoZSl9c3RhdGljIGFsd2F5c0VtYmVkKGUpe3JldHVybiBuZXcgQWx3YXlzRW1iZWQoZSl9c3RhdGljIGFtZChlKXtyZXR1cm4gbmV3IEFtZChlKX1zdGF0aWMgYXJlYShlKXtyZXR1cm4gbmV3IEFyZWEoZSl9c3RhdGljIGF0dHJpYnV0ZXMoZSl7cmV0dXJuIG5ldyBBdHRyaWJ1dGVzKGUpfXN0YXRpYyBhdXRvU2F2ZShlKXtyZXR1cm4gbmV3IEF1dG9TYXZlKGUpfXN0YXRpYyBiYXNlKGUpe3JldHVybiBuZXcgQmFzZShlKX1zdGF0aWMgYmF0Y2hPdXRwdXQoZSl7cmV0dXJuIG5ldyBCYXRjaE91dHB1dChlKX1zdGF0aWMgYmVoYXZpb3JPdmVycmlkZShlKXtyZXR1cm4gbmV3IEJlaGF2aW9yT3ZlcnJpZGUoZSl9c3RhdGljIGNhY2hlKGUpe3JldHVybiBuZXcgQ2FjaGUoZSl9c3RhdGljIGNoYW5nZShlKXtyZXR1cm4gbmV3IENoYW5nZShlKX1zdGF0aWMgY29tbW9uKGUpe3JldHVybiBuZXcgQ29tbW9uKGUpfXN0YXRpYyBjb21wcmVzcyhlKXtyZXR1cm4gbmV3IENvbXByZXNzKGUpfXN0YXRpYyBjb21wcmVzc0xvZ2ljYWxTdHJ1Y3R1cmUoZSl7cmV0dXJuIG5ldyBDb21wcmVzc0xvZ2ljYWxTdHJ1Y3R1cmUoZSl9c3RhdGljIGNvbXByZXNzT2JqZWN0U3RyZWFtKGUpe3JldHVybiBuZXcgQ29tcHJlc3NPYmplY3RTdHJlYW0oZSl9c3RhdGljIGNvbXByZXNzaW9uKGUpe3JldHVybiBuZXcgQ29tcHJlc3Npb24oZSl9c3RhdGljIGNvbmZpZyhlKXtyZXR1cm4gbmV3IENvbmZpZyhlKX1zdGF0aWMgY29uZm9ybWFuY2UoZSl7cmV0dXJuIG5ldyBDb25mb3JtYW5jZShlKX1zdGF0aWMgY29udGVudENvcHkoZSl7cmV0dXJuIG5ldyBDb250ZW50Q29weShlKX1zdGF0aWMgY29waWVzKGUpe3JldHVybiBuZXcgQ29waWVzKGUpfXN0YXRpYyBjcmVhdG9yKGUpe3JldHVybiBuZXcgQ3JlYXRvcihlKX1zdGF0aWMgY3VycmVudFBhZ2UoZSl7cmV0dXJuIG5ldyBDdXJyZW50UGFnZShlKX1zdGF0aWMgZGF0YShlKXtyZXR1cm4gbmV3IERhdGEoZSl9c3RhdGljIGRlYnVnKGUpe3JldHVybiBuZXcgRGVidWcoZSl9c3RhdGljIGRlZmF1bHRUeXBlZmFjZShlKXtyZXR1cm4gbmV3IERlZmF1bHRUeXBlZmFjZShlKX1zdGF0aWMgZGVzdGluYXRpb24oZSl7cmV0dXJuIG5ldyBEZXN0aW5hdGlvbihlKX1zdGF0aWMgZG9jdW1lbnRBc3NlbWJseShlKXtyZXR1cm4gbmV3IERvY3VtZW50QXNzZW1ibHkoZSl9c3RhdGljIGRyaXZlcihlKXtyZXR1cm4gbmV3IERyaXZlcihlKX1zdGF0aWMgZHVwbGV4T3B0aW9uKGUpe3JldHVybiBuZXcgRHVwbGV4T3B0aW9uKGUpfXN0YXRpYyBkeW5hbWljUmVuZGVyKGUpe3JldHVybiBuZXcgRHluYW1pY1JlbmRlcihlKX1zdGF0aWMgZW1iZWQoZSl7cmV0dXJuIG5ldyBFbWJlZChlKX1zdGF0aWMgZW5jcnlwdChlKXtyZXR1cm4gbmV3IEVuY3J5cHQoZSl9c3RhdGljIGVuY3J5cHRpb24oZSl7cmV0dXJuIG5ldyBFbmNyeXB0aW9uKGUpfXN0YXRpYyBlbmNyeXB0aW9uTGV2ZWwoZSl7cmV0dXJuIG5ldyBFbmNyeXB0aW9uTGV2ZWwoZSl9c3RhdGljIGVuZm9yY2UoZSl7cmV0dXJuIG5ldyBFbmZvcmNlKGUpfXN0YXRpYyBlcXVhdGUoZSl7cmV0dXJuIG5ldyBFcXVhdGUoZSl9c3RhdGljIGVxdWF0ZVJhbmdlKGUpe3JldHVybiBuZXcgRXF1YXRlUmFuZ2UoZSl9c3RhdGljIGV4Y2x1ZGUoZSl7cmV0dXJuIG5ldyBFeGNsdWRlKGUpfXN0YXRpYyBleGNsdWRlTlMoZSl7cmV0dXJuIG5ldyBFeGNsdWRlTlMoZSl9c3RhdGljIGZsaXBMYWJlbChlKXtyZXR1cm4gbmV3IEZsaXBMYWJlbChlKX1zdGF0aWMgZm9udEluZm8oZSl7cmV0dXJuIG5ldyBGb250SW5mbyhlKX1zdGF0aWMgZm9ybUZpZWxkRmlsbGluZyhlKXtyZXR1cm4gbmV3IEZvcm1GaWVsZEZpbGxpbmcoZSl9c3RhdGljIGdyb3VwUGFyZW50KGUpe3JldHVybiBuZXcgR3JvdXBQYXJlbnQoZSl9c3RhdGljIGlmRW1wdHkoZSl7cmV0dXJuIG5ldyBJZkVtcHR5KGUpfXN0YXRpYyBpbmNsdWRlWERQQ29udGVudChlKXtyZXR1cm4gbmV3IEluY2x1ZGVYRFBDb250ZW50KGUpfXN0YXRpYyBpbmNyZW1lbnRhbExvYWQoZSl7cmV0dXJuIG5ldyBJbmNyZW1lbnRhbExvYWQoZSl9c3RhdGljIGluY3JlbWVudGFsTWVyZ2UoZSl7cmV0dXJuIG5ldyBJbmNyZW1lbnRhbE1lcmdlKGUpfXN0YXRpYyBpbnRlcmFjdGl2ZShlKXtyZXR1cm4gbmV3IEludGVyYWN0aXZlKGUpfXN0YXRpYyBqb2coZSl7cmV0dXJuIG5ldyBKb2coZSl9c3RhdGljIGxhYmVsUHJpbnRlcihlKXtyZXR1cm4gbmV3IExhYmVsUHJpbnRlcihlKX1zdGF0aWMgbGF5b3V0KGUpe3JldHVybiBuZXcgTGF5b3V0KGUpfXN0YXRpYyBsZXZlbChlKXtyZXR1cm4gbmV3IExldmVsKGUpfXN0YXRpYyBsaW5lYXJpemVkKGUpe3JldHVybiBuZXcgTGluZWFyaXplZChlKX1zdGF0aWMgbG9jYWxlKGUpe3JldHVybiBuZXcgTG9jYWxlKGUpfXN0YXRpYyBsb2NhbGVTZXQoZSl7cmV0dXJuIG5ldyBMb2NhbGVTZXQoZSl9c3RhdGljIGxvZyhlKXtyZXR1cm4gbmV3IExvZyhlKX1zdGF0aWMgbWFwKGUpe3JldHVybiBuZXcgTWFwRWxlbWVudChlKX1zdGF0aWMgbWVkaXVtSW5mbyhlKXtyZXR1cm4gbmV3IE1lZGl1bUluZm8oZSl9c3RhdGljIG1lc3NhZ2UoZSl7cmV0dXJuIG5ldyBNZXNzYWdlKGUpfXN0YXRpYyBtZXNzYWdpbmcoZSl7cmV0dXJuIG5ldyBNZXNzYWdpbmcoZSl9c3RhdGljIG1vZGUoZSl7cmV0dXJuIG5ldyBNb2RlKGUpfXN0YXRpYyBtb2RpZnlBbm5vdHMoZSl7cmV0dXJuIG5ldyBNb2RpZnlBbm5vdHMoZSl9c3RhdGljIG1zZ0lkKGUpe3JldHVybiBuZXcgTXNnSWQoZSl9c3RhdGljIG5hbWVBdHRyKGUpe3JldHVybiBuZXcgTmFtZUF0dHIoZSl9c3RhdGljIG5ldmVyRW1iZWQoZSl7cmV0dXJuIG5ldyBOZXZlckVtYmVkKGUpfXN0YXRpYyBudW1iZXJPZkNvcGllcyhlKXtyZXR1cm4gbmV3IE51bWJlck9mQ29waWVzKGUpfXN0YXRpYyBvcGVuQWN0aW9uKGUpe3JldHVybiBuZXcgT3BlbkFjdGlvbihlKX1zdGF0aWMgb3V0cHV0KGUpe3JldHVybiBuZXcgT3V0cHV0KGUpfXN0YXRpYyBvdXRwdXRCaW4oZSl7cmV0dXJuIG5ldyBPdXRwdXRCaW4oZSl9c3RhdGljIG91dHB1dFhTTChlKXtyZXR1cm4gbmV3IE91dHB1dFhTTChlKX1zdGF0aWMgb3ZlcnByaW50KGUpe3JldHVybiBuZXcgT3ZlcnByaW50KGUpfXN0YXRpYyBwYWNrZXRzKGUpe3JldHVybiBuZXcgUGFja2V0cyhlKX1zdGF0aWMgcGFnZU9mZnNldChlKXtyZXR1cm4gbmV3IFBhZ2VPZmZzZXQoZSl9c3RhdGljIHBhZ2VSYW5nZShlKXtyZXR1cm4gbmV3IFBhZ2VSYW5nZShlKX1zdGF0aWMgcGFnaW5hdGlvbihlKXtyZXR1cm4gbmV3IFBhZ2luYXRpb24oZSl9c3RhdGljIHBhZ2luYXRpb25PdmVycmlkZShlKXtyZXR1cm4gbmV3IFBhZ2luYXRpb25PdmVycmlkZShlKX1zdGF0aWMgcGFydChlKXtyZXR1cm4gbmV3IFBhcnQoZSl9c3RhdGljIHBjbChlKXtyZXR1cm4gbmV3IFBjbChlKX1zdGF0aWMgcGRmKGUpe3JldHVybiBuZXcgUGRmKGUpfXN0YXRpYyBwZGZhKGUpe3JldHVybiBuZXcgUGRmYShlKX1zdGF0aWMgcGVybWlzc2lvbnMoZSl7cmV0dXJuIG5ldyBQZXJtaXNzaW9ucyhlKX1zdGF0aWMgcGlja1RyYXlCeVBERlNpemUoZSl7cmV0dXJuIG5ldyBQaWNrVHJheUJ5UERGU2l6ZShlKX1zdGF0aWMgcGljdHVyZShlKXtyZXR1cm4gbmV3IFBpY3R1cmUoZSl9c3RhdGljIHBsYWludGV4dE1ldGFkYXRhKGUpe3JldHVybiBuZXcgUGxhaW50ZXh0TWV0YWRhdGEoZSl9c3RhdGljIHByZXNlbmNlKGUpe3JldHVybiBuZXcgUHJlc2VuY2UoZSl9c3RhdGljIHByZXNlbnQoZSl7cmV0dXJuIG5ldyBQcmVzZW50KGUpfXN0YXRpYyBwcmludChlKXtyZXR1cm4gbmV3IFByaW50KGUpfXN0YXRpYyBwcmludEhpZ2hRdWFsaXR5KGUpe3JldHVybiBuZXcgUHJpbnRIaWdoUXVhbGl0eShlKX1zdGF0aWMgcHJpbnRTY2FsaW5nKGUpe3JldHVybiBuZXcgUHJpbnRTY2FsaW5nKGUpfXN0YXRpYyBwcmludGVyTmFtZShlKXtyZXR1cm4gbmV3IFByaW50ZXJOYW1lKGUpfXN0YXRpYyBwcm9kdWNlcihlKXtyZXR1cm4gbmV3IFByb2R1Y2VyKGUpfXN0YXRpYyBwcyhlKXtyZXR1cm4gbmV3IFBzKGUpfXN0YXRpYyByYW5nZShlKXtyZXR1cm4gbmV3IFJhbmdlKGUpfXN0YXRpYyByZWNvcmQoZSl7cmV0dXJuIG5ldyBSZWNvcmQoZSl9c3RhdGljIHJlbGV2YW50KGUpe3JldHVybiBuZXcgUmVsZXZhbnQoZSl9c3RhdGljIHJlbmFtZShlKXtyZXR1cm4gbmV3IFJlbmFtZShlKX1zdGF0aWMgcmVuZGVyUG9saWN5KGUpe3JldHVybiBuZXcgUmVuZGVyUG9saWN5KGUpfXN0YXRpYyBydW5TY3JpcHRzKGUpe3JldHVybiBuZXcgUnVuU2NyaXB0cyhlKX1zdGF0aWMgc2NyaXB0KGUpe3JldHVybiBuZXcgU2NyaXB0KGUpfXN0YXRpYyBzY3JpcHRNb2RlbChlKXtyZXR1cm4gbmV3IFNjcmlwdE1vZGVsKGUpfXN0YXRpYyBzZXZlcml0eShlKXtyZXR1cm4gbmV3IFNldmVyaXR5KGUpfXN0YXRpYyBzaWxlbnRQcmludChlKXtyZXR1cm4gbmV3IFNpbGVudFByaW50KGUpfXN0YXRpYyBzdGFwbGUoZSl7cmV0dXJuIG5ldyBTdGFwbGUoZSl9c3RhdGljIHN0YXJ0Tm9kZShlKXtyZXR1cm4gbmV3IFN0YXJ0Tm9kZShlKX1zdGF0aWMgc3RhcnRQYWdlKGUpe3JldHVybiBuZXcgU3RhcnRQYWdlKGUpfXN0YXRpYyBzdWJtaXRGb3JtYXQoZSl7cmV0dXJuIG5ldyBTdWJtaXRGb3JtYXQoZSl9c3RhdGljIHN1Ym1pdFVybChlKXtyZXR1cm4gbmV3IFN1Ym1pdFVybChlKX1zdGF0aWMgc3Vic2V0QmVsb3coZSl7cmV0dXJuIG5ldyBTdWJzZXRCZWxvdyhlKX1zdGF0aWMgc3VwcHJlc3NCYW5uZXIoZSl7cmV0dXJuIG5ldyBTdXBwcmVzc0Jhbm5lcihlKX1zdGF0aWMgdGFnZ2VkKGUpe3JldHVybiBuZXcgVGFnZ2VkKGUpfXN0YXRpYyB0ZW1wbGF0ZShlKXtyZXR1cm4gbmV3IFRlbXBsYXRlKGUpfXN0YXRpYyB0ZW1wbGF0ZUNhY2hlKGUpe3JldHVybiBuZXcgVGVtcGxhdGVDYWNoZShlKX1zdGF0aWMgdGhyZXNob2xkKGUpe3JldHVybiBuZXcgVGhyZXNob2xkKGUpfXN0YXRpYyB0byhlKXtyZXR1cm4gbmV3IFRvKGUpfXN0YXRpYyB0cmFjZShlKXtyZXR1cm4gbmV3IFRyYWNlKGUpfXN0YXRpYyB0cmFuc2Zvcm0oZSl7cmV0dXJuIG5ldyBUcmFuc2Zvcm0oZSl9c3RhdGljIHR5cGUoZSl7cmV0dXJuIG5ldyBUeXBlKGUpfXN0YXRpYyB1cmkoZSl7cmV0dXJuIG5ldyBVcmkoZSl9c3RhdGljIHZhbGlkYXRlKGUpe3JldHVybiBuZXcgVmFsaWRhdGUoZSl9c3RhdGljIHZhbGlkYXRlQXBwcm92YWxTaWduYXR1cmVzKGUpe3JldHVybiBuZXcgVmFsaWRhdGVBcHByb3ZhbFNpZ25hdHVyZXMoZSl9c3RhdGljIHZhbGlkYXRpb25NZXNzYWdpbmcoZSl7cmV0dXJuIG5ldyBWYWxpZGF0aW9uTWVzc2FnaW5nKGUpfXN0YXRpYyB2ZXJzaW9uKGUpe3JldHVybiBuZXcgVmVyc2lvbihlKX1zdGF0aWMgdmVyc2lvbkNvbnRyb2woZSl7cmV0dXJuIG5ldyBWZXJzaW9uQ29udHJvbChlKX1zdGF0aWMgdmlld2VyUHJlZmVyZW5jZXMoZSl7cmV0dXJuIG5ldyBWaWV3ZXJQcmVmZXJlbmNlcyhlKX1zdGF0aWMgd2ViQ2xpZW50KGUpe3JldHVybiBuZXcgV2ViQ2xpZW50KGUpfXN0YXRpYyB3aGl0ZXNwYWNlKGUpe3JldHVybiBuZXcgV2hpdGVzcGFjZShlKX1zdGF0aWMgd2luZG93KGUpe3JldHVybiBuZXcgV2luZG93KGUpfXN0YXRpYyB4ZGMoZSl7cmV0dXJuIG5ldyBYZGMoZSl9c3RhdGljIHhkcChlKXtyZXR1cm4gbmV3IFhkcChlKX1zdGF0aWMgeHNsKGUpe3JldHVybiBuZXcgWHNsKGUpfXN0YXRpYyB6cGwoZSl7cmV0dXJuIG5ldyBacGwoZSl9fXQuQ29uZmlnTmFtZXNwYWNlPUNvbmZpZ05hbWVzcGFjZX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LkNvbm5lY3Rpb25TZXROYW1lc3BhY2U9dm9pZCAwO3ZhciByPWEoNzkpLG49YSg3Nyk7Y29uc3QgaT1yLk5hbWVzcGFjZUlkcy5jb25uZWN0aW9uU2V0LmlkO2NsYXNzIENvbm5lY3Rpb25TZXQgZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihpLCJjb25uZWN0aW9uU2V0IiwhMCk7dGhpcy53c2RsQ29ubmVjdGlvbj1uZXcgbi5YRkFPYmplY3RBcnJheTt0aGlzLnhtbENvbm5lY3Rpb249bmV3IG4uWEZBT2JqZWN0QXJyYXk7dGhpcy54c2RDb25uZWN0aW9uPW5ldyBuLlhGQU9iamVjdEFycmF5fX1jbGFzcyBFZmZlY3RpdmVJbnB1dFBvbGljeSBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGksImVmZmVjdGl2ZUlucHV0UG9saWN5Iik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIEVmZmVjdGl2ZU91dHB1dFBvbGljeSBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGksImVmZmVjdGl2ZU91dHB1dFBvbGljeSIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBPcGVyYXRpb24gZXh0ZW5kcyBuLlN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihpLCJvcGVyYXRpb24iKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMuaW5wdXQ9ZS5pbnB1dHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy5vdXRwdXQ9ZS5vdXRwdXR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgUm9vdEVsZW1lbnQgZXh0ZW5kcyBuLlN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihpLCJyb290RWxlbWVudCIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBTb2FwQWN0aW9uIGV4dGVuZHMgbi5TdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoaSwic29hcEFjdGlvbiIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBTb2FwQWRkcmVzcyBleHRlbmRzIG4uU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGksInNvYXBBZGRyZXNzIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIFVyaSBleHRlbmRzIG4uU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGksInVyaSIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBXc2RsQWRkcmVzcyBleHRlbmRzIG4uU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGksIndzZGxBZGRyZXNzIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIFdzZGxDb25uZWN0aW9uIGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoaSwid3NkbENvbm5lY3Rpb24iLCEwKTt0aGlzLmRhdGFEZXNjcmlwdGlvbj1lLmRhdGFEZXNjcmlwdGlvbnx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy5lZmZlY3RpdmVJbnB1dFBvbGljeT1udWxsO3RoaXMuZWZmZWN0aXZlT3V0cHV0UG9saWN5PW51bGw7dGhpcy5vcGVyYXRpb249bnVsbDt0aGlzLnNvYXBBY3Rpb249bnVsbDt0aGlzLnNvYXBBZGRyZXNzPW51bGw7dGhpcy53c2RsQWRkcmVzcz1udWxsfX1jbGFzcyBYbWxDb25uZWN0aW9uIGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoaSwieG1sQ29ubmVjdGlvbiIsITApO3RoaXMuZGF0YURlc2NyaXB0aW9uPWUuZGF0YURlc2NyaXB0aW9ufHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVyaT1udWxsfX1jbGFzcyBYc2RDb25uZWN0aW9uIGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoaSwieHNkQ29ubmVjdGlvbiIsITApO3RoaXMuZGF0YURlc2NyaXB0aW9uPWUuZGF0YURlc2NyaXB0aW9ufHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnJvb3RFbGVtZW50PW51bGw7dGhpcy51cmk9bnVsbH19Y2xhc3MgQ29ubmVjdGlvblNldE5hbWVzcGFjZXtzdGF0aWNbci4kYnVpbGRYRkFPYmplY3RdKGUsdCl7aWYoQ29ubmVjdGlvblNldE5hbWVzcGFjZS5oYXNPd25Qcm9wZXJ0eShlKSlyZXR1cm4gQ29ubmVjdGlvblNldE5hbWVzcGFjZVtlXSh0KX1zdGF0aWMgY29ubmVjdGlvblNldChlKXtyZXR1cm4gbmV3IENvbm5lY3Rpb25TZXQoZSl9c3RhdGljIGVmZmVjdGl2ZUlucHV0UG9saWN5KGUpe3JldHVybiBuZXcgRWZmZWN0aXZlSW5wdXRQb2xpY3koZSl9c3RhdGljIGVmZmVjdGl2ZU91dHB1dFBvbGljeShlKXtyZXR1cm4gbmV3IEVmZmVjdGl2ZU91dHB1dFBvbGljeShlKX1zdGF0aWMgb3BlcmF0aW9uKGUpe3JldHVybiBuZXcgT3BlcmF0aW9uKGUpfXN0YXRpYyByb290RWxlbWVudChlKXtyZXR1cm4gbmV3IFJvb3RFbGVtZW50KGUpfXN0YXRpYyBzb2FwQWN0aW9uKGUpe3JldHVybiBuZXcgU29hcEFjdGlvbihlKX1zdGF0aWMgc29hcEFkZHJlc3MoZSl7cmV0dXJuIG5ldyBTb2FwQWRkcmVzcyhlKX1zdGF0aWMgdXJpKGUpe3JldHVybiBuZXcgVXJpKGUpfXN0YXRpYyB3c2RsQWRkcmVzcyhlKXtyZXR1cm4gbmV3IFdzZGxBZGRyZXNzKGUpfXN0YXRpYyB3c2RsQ29ubmVjdGlvbihlKXtyZXR1cm4gbmV3IFdzZGxDb25uZWN0aW9uKGUpfXN0YXRpYyB4bWxDb25uZWN0aW9uKGUpe3JldHVybiBuZXcgWG1sQ29ubmVjdGlvbihlKX1zdGF0aWMgeHNkQ29ubmVjdGlvbihlKXtyZXR1cm4gbmV3IFhzZENvbm5lY3Rpb24oZSl9fXQuQ29ubmVjdGlvblNldE5hbWVzcGFjZT1Db25uZWN0aW9uU2V0TmFtZXNwYWNlfSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuRGF0YXNldHNOYW1lc3BhY2U9dm9pZCAwO3ZhciByPWEoNzcpLG49YSg3OSk7Y29uc3QgaT1uLk5hbWVzcGFjZUlkcy5kYXRhc2V0cy5pZDtjbGFzcyBEYXRhIGV4dGVuZHMgci5YbWxPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoaSwiZGF0YSIsZSl9W3IuJGlzTnNBZ25vc3RpY10oKXtyZXR1cm4hMH19Y2xhc3MgRGF0YXNldHMgZXh0ZW5kcyByLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihpLCJkYXRhc2V0cyIsITApO3RoaXMuZGF0YT1udWxsO3RoaXMuU2lnbmF0dXJlPW51bGx9W3IuJG9uQ2hpbGRdKGUpe2NvbnN0IHQ9ZVtyLiRub2RlTmFtZV07KCJkYXRhIj09PXQmJmVbci4kbmFtZXNwYWNlSWRdPT09aXx8IlNpZ25hdHVyZSI9PT10JiZlW3IuJG5hbWVzcGFjZUlkXT09PW4uTmFtZXNwYWNlSWRzLnNpZ25hdHVyZS5pZCkmJih0aGlzW3RdPWUpO3RoaXNbci4kYXBwZW5kQ2hpbGRdKGUpfX1jbGFzcyBEYXRhc2V0c05hbWVzcGFjZXtzdGF0aWNbbi4kYnVpbGRYRkFPYmplY3RdKGUsdCl7aWYoRGF0YXNldHNOYW1lc3BhY2UuaGFzT3duUHJvcGVydHkoZSkpcmV0dXJuIERhdGFzZXRzTmFtZXNwYWNlW2VdKHQpfXN0YXRpYyBkYXRhc2V0cyhlKXtyZXR1cm4gbmV3IERhdGFzZXRzKGUpfXN0YXRpYyBkYXRhKGUpe3JldHVybiBuZXcgRGF0YShlKX19dC5EYXRhc2V0c05hbWVzcGFjZT1EYXRhc2V0c05hbWVzcGFjZX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LkxvY2FsZVNldE5hbWVzcGFjZT12b2lkIDA7dmFyIHI9YSg3OSksbj1hKDc3KSxpPWEoNzgpO2NvbnN0IHM9ci5OYW1lc3BhY2VJZHMubG9jYWxlU2V0LmlkO2NsYXNzIENhbGVuZGFyU3ltYm9scyBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHMsImNhbGVuZGFyU3ltYm9scyIsITApO3RoaXMubmFtZT0iZ3JlZ29yaWFuIjt0aGlzLmRheU5hbWVzPW5ldyBuLlhGQU9iamVjdEFycmF5KDIpO3RoaXMuZXJhTmFtZXM9bnVsbDt0aGlzLm1lcmlkaWVtTmFtZXM9bnVsbDt0aGlzLm1vbnRoTmFtZXM9bmV3IG4uWEZBT2JqZWN0QXJyYXkoMil9fWNsYXNzIEN1cnJlbmN5U3ltYm9sIGV4dGVuZHMgbi5TdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocywiY3VycmVuY3lTeW1ib2wiKTt0aGlzLm5hbWU9KDAsaS5nZXRTdHJpbmdPcHRpb24pKGUubmFtZSxbInN5bWJvbCIsImlzb25hbWUiLCJkZWNpbWFsIl0pfX1jbGFzcyBDdXJyZW5jeVN5bWJvbHMgZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihzLCJjdXJyZW5jeVN5bWJvbHMiLCEwKTt0aGlzLmN1cnJlbmN5U3ltYm9sPW5ldyBuLlhGQU9iamVjdEFycmF5KDMpfX1jbGFzcyBEYXRlUGF0dGVybiBleHRlbmRzIG4uU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHMsImRhdGVQYXR0ZXJuIik7dGhpcy5uYW1lPSgwLGkuZ2V0U3RyaW5nT3B0aW9uKShlLm5hbWUsWyJmdWxsIiwibG9uZyIsIm1lZCIsInNob3J0Il0pfX1jbGFzcyBEYXRlUGF0dGVybnMgZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihzLCJkYXRlUGF0dGVybnMiLCEwKTt0aGlzLmRhdGVQYXR0ZXJuPW5ldyBuLlhGQU9iamVjdEFycmF5KDQpfX1jbGFzcyBEYXRlVGltZVN5bWJvbHMgZXh0ZW5kcyBuLkNvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocywiZGF0ZVRpbWVTeW1ib2xzIil9fWNsYXNzIERheSBleHRlbmRzIG4uU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHMsImRheSIpfX1jbGFzcyBEYXlOYW1lcyBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHMsImRheU5hbWVzIiwhMCk7dGhpcy5hYmJyPSgwLGkuZ2V0SW50ZWdlcikoe2RhdGE6ZS5hYmJyLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy5kYXk9bmV3IG4uWEZBT2JqZWN0QXJyYXkoNyl9fWNsYXNzIEVyYSBleHRlbmRzIG4uU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHMsImVyYSIpfX1jbGFzcyBFcmFOYW1lcyBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHMsImVyYU5hbWVzIiwhMCk7dGhpcy5lcmE9bmV3IG4uWEZBT2JqZWN0QXJyYXkoMil9fWNsYXNzIExvY2FsZSBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHMsImxvY2FsZSIsITApO3RoaXMuZGVzYz1lLmRlc2N8fCIiO3RoaXMubmFtZT0iaXNvbmFtZSI7dGhpcy5jYWxlbmRhclN5bWJvbHM9bnVsbDt0aGlzLmN1cnJlbmN5U3ltYm9scz1udWxsO3RoaXMuZGF0ZVBhdHRlcm5zPW51bGw7dGhpcy5kYXRlVGltZVN5bWJvbHM9bnVsbDt0aGlzLm51bWJlclBhdHRlcm5zPW51bGw7dGhpcy5udW1iZXJTeW1ib2xzPW51bGw7dGhpcy50aW1lUGF0dGVybnM9bnVsbDt0aGlzLnR5cGVGYWNlcz1udWxsfX1jbGFzcyBMb2NhbGVTZXQgZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihzLCJsb2NhbGVTZXQiLCEwKTt0aGlzLmxvY2FsZT1uZXcgbi5YRkFPYmplY3RBcnJheX19Y2xhc3MgTWVyaWRpZW0gZXh0ZW5kcyBuLlN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihzLCJtZXJpZGllbSIpfX1jbGFzcyBNZXJpZGllbU5hbWVzIGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocywibWVyaWRpZW1OYW1lcyIsITApO3RoaXMubWVyaWRpZW09bmV3IG4uWEZBT2JqZWN0QXJyYXkoMil9fWNsYXNzIE1vbnRoIGV4dGVuZHMgbi5TdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocywibW9udGgiKX19Y2xhc3MgTW9udGhOYW1lcyBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHMsIm1vbnRoTmFtZXMiLCEwKTt0aGlzLmFiYnI9KDAsaS5nZXRJbnRlZ2VyKSh7ZGF0YTplLmFiYnIsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV9KTt0aGlzLm1vbnRoPW5ldyBuLlhGQU9iamVjdEFycmF5KDEyKX19Y2xhc3MgTnVtYmVyUGF0dGVybiBleHRlbmRzIG4uU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHMsIm51bWJlclBhdHRlcm4iKTt0aGlzLm5hbWU9KDAsaS5nZXRTdHJpbmdPcHRpb24pKGUubmFtZSxbImZ1bGwiLCJsb25nIiwibWVkIiwic2hvcnQiXSl9fWNsYXNzIE51bWJlclBhdHRlcm5zIGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocywibnVtYmVyUGF0dGVybnMiLCEwKTt0aGlzLm51bWJlclBhdHRlcm49bmV3IG4uWEZBT2JqZWN0QXJyYXkoNCl9fWNsYXNzIE51bWJlclN5bWJvbCBleHRlbmRzIG4uU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHMsIm51bWJlclN5bWJvbCIpO3RoaXMubmFtZT0oMCxpLmdldFN0cmluZ09wdGlvbikoZS5uYW1lLFsiZGVjaW1hbCIsImdyb3VwaW5nIiwicGVyY2VudCIsIm1pbnVzIiwiemVybyJdKX19Y2xhc3MgTnVtYmVyU3ltYm9scyBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHMsIm51bWJlclN5bWJvbHMiLCEwKTt0aGlzLm51bWJlclN5bWJvbD1uZXcgbi5YRkFPYmplY3RBcnJheSg1KX19Y2xhc3MgVGltZVBhdHRlcm4gZXh0ZW5kcyBuLlN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihzLCJ0aW1lUGF0dGVybiIpO3RoaXMubmFtZT0oMCxpLmdldFN0cmluZ09wdGlvbikoZS5uYW1lLFsiZnVsbCIsImxvbmciLCJtZWQiLCJzaG9ydCJdKX19Y2xhc3MgVGltZVBhdHRlcm5zIGV4dGVuZHMgbi5YRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocywidGltZVBhdHRlcm5zIiwhMCk7dGhpcy50aW1lUGF0dGVybj1uZXcgbi5YRkFPYmplY3RBcnJheSg0KX19Y2xhc3MgVHlwZUZhY2UgZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihzLCJ0eXBlRmFjZSIsITApO3RoaXMubmFtZT0iInxlLm5hbWV9fWNsYXNzIFR5cGVGYWNlcyBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHMsInR5cGVGYWNlcyIsITApO3RoaXMudHlwZUZhY2U9bmV3IG4uWEZBT2JqZWN0QXJyYXl9fWNsYXNzIExvY2FsZVNldE5hbWVzcGFjZXtzdGF0aWNbci4kYnVpbGRYRkFPYmplY3RdKGUsdCl7aWYoTG9jYWxlU2V0TmFtZXNwYWNlLmhhc093blByb3BlcnR5KGUpKXJldHVybiBMb2NhbGVTZXROYW1lc3BhY2VbZV0odCl9c3RhdGljIGNhbGVuZGFyU3ltYm9scyhlKXtyZXR1cm4gbmV3IENhbGVuZGFyU3ltYm9scyhlKX1zdGF0aWMgY3VycmVuY3lTeW1ib2woZSl7cmV0dXJuIG5ldyBDdXJyZW5jeVN5bWJvbChlKX1zdGF0aWMgY3VycmVuY3lTeW1ib2xzKGUpe3JldHVybiBuZXcgQ3VycmVuY3lTeW1ib2xzKGUpfXN0YXRpYyBkYXRlUGF0dGVybihlKXtyZXR1cm4gbmV3IERhdGVQYXR0ZXJuKGUpfXN0YXRpYyBkYXRlUGF0dGVybnMoZSl7cmV0dXJuIG5ldyBEYXRlUGF0dGVybnMoZSl9c3RhdGljIGRhdGVUaW1lU3ltYm9scyhlKXtyZXR1cm4gbmV3IERhdGVUaW1lU3ltYm9scyhlKX1zdGF0aWMgZGF5KGUpe3JldHVybiBuZXcgRGF5KGUpfXN0YXRpYyBkYXlOYW1lcyhlKXtyZXR1cm4gbmV3IERheU5hbWVzKGUpfXN0YXRpYyBlcmEoZSl7cmV0dXJuIG5ldyBFcmEoZSl9c3RhdGljIGVyYU5hbWVzKGUpe3JldHVybiBuZXcgRXJhTmFtZXMoZSl9c3RhdGljIGxvY2FsZShlKXtyZXR1cm4gbmV3IExvY2FsZShlKX1zdGF0aWMgbG9jYWxlU2V0KGUpe3JldHVybiBuZXcgTG9jYWxlU2V0KGUpfXN0YXRpYyBtZXJpZGllbShlKXtyZXR1cm4gbmV3IE1lcmlkaWVtKGUpfXN0YXRpYyBtZXJpZGllbU5hbWVzKGUpe3JldHVybiBuZXcgTWVyaWRpZW1OYW1lcyhlKX1zdGF0aWMgbW9udGgoZSl7cmV0dXJuIG5ldyBNb250aChlKX1zdGF0aWMgbW9udGhOYW1lcyhlKXtyZXR1cm4gbmV3IE1vbnRoTmFtZXMoZSl9c3RhdGljIG51bWJlclBhdHRlcm4oZSl7cmV0dXJuIG5ldyBOdW1iZXJQYXR0ZXJuKGUpfXN0YXRpYyBudW1iZXJQYXR0ZXJucyhlKXtyZXR1cm4gbmV3IE51bWJlclBhdHRlcm5zKGUpfXN0YXRpYyBudW1iZXJTeW1ib2woZSl7cmV0dXJuIG5ldyBOdW1iZXJTeW1ib2woZSl9c3RhdGljIG51bWJlclN5bWJvbHMoZSl7cmV0dXJuIG5ldyBOdW1iZXJTeW1ib2xzKGUpfXN0YXRpYyB0aW1lUGF0dGVybihlKXtyZXR1cm4gbmV3IFRpbWVQYXR0ZXJuKGUpfXN0YXRpYyB0aW1lUGF0dGVybnMoZSl7cmV0dXJuIG5ldyBUaW1lUGF0dGVybnMoZSl9c3RhdGljIHR5cGVGYWNlKGUpe3JldHVybiBuZXcgVHlwZUZhY2UoZSl9c3RhdGljIHR5cGVGYWNlcyhlKXtyZXR1cm4gbmV3IFR5cGVGYWNlcyhlKX19dC5Mb2NhbGVTZXROYW1lc3BhY2U9TG9jYWxlU2V0TmFtZXNwYWNlfSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuU2lnbmF0dXJlTmFtZXNwYWNlPXZvaWQgMDt2YXIgcj1hKDc5KSxuPWEoNzcpO2NvbnN0IGk9ci5OYW1lc3BhY2VJZHMuc2lnbmF0dXJlLmlkO2NsYXNzIFNpZ25hdHVyZSBleHRlbmRzIG4uWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGksInNpZ25hdHVyZSIsITApfX1jbGFzcyBTaWduYXR1cmVOYW1lc3BhY2V7c3RhdGljW3IuJGJ1aWxkWEZBT2JqZWN0XShlLHQpe2lmKFNpZ25hdHVyZU5hbWVzcGFjZS5oYXNPd25Qcm9wZXJ0eShlKSlyZXR1cm4gU2lnbmF0dXJlTmFtZXNwYWNlW2VdKHQpfXN0YXRpYyBzaWduYXR1cmUoZSl7cmV0dXJuIG5ldyBTaWduYXR1cmUoZSl9fXQuU2lnbmF0dXJlTmFtZXNwYWNlPVNpZ25hdHVyZU5hbWVzcGFjZX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LlN0eWxlc2hlZXROYW1lc3BhY2U9dm9pZCAwO3ZhciByPWEoNzkpLG49YSg3Nyk7Y29uc3QgaT1yLk5hbWVzcGFjZUlkcy5zdHlsZXNoZWV0LmlkO2NsYXNzIFN0eWxlc2hlZXQgZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihpLCJzdHlsZXNoZWV0IiwhMCl9fWNsYXNzIFN0eWxlc2hlZXROYW1lc3BhY2V7c3RhdGljW3IuJGJ1aWxkWEZBT2JqZWN0XShlLHQpe2lmKFN0eWxlc2hlZXROYW1lc3BhY2UuaGFzT3duUHJvcGVydHkoZSkpcmV0dXJuIFN0eWxlc2hlZXROYW1lc3BhY2VbZV0odCl9c3RhdGljIHN0eWxlc2hlZXQoZSl7cmV0dXJuIG5ldyBTdHlsZXNoZWV0KGUpfX10LlN0eWxlc2hlZXROYW1lc3BhY2U9U3R5bGVzaGVldE5hbWVzcGFjZX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LlhkcE5hbWVzcGFjZT12b2lkIDA7dmFyIHI9YSg3OSksbj1hKDc3KTtjb25zdCBpPXIuTmFtZXNwYWNlSWRzLnhkcC5pZDtjbGFzcyBYZHAgZXh0ZW5kcyBuLlhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihpLCJ4ZHAiLCEwKTt0aGlzLnV1aWQ9ZS51dWlkfHwiIjt0aGlzLnRpbWVTdGFtcD1lLnRpbWVTdGFtcHx8IiI7dGhpcy5jb25maWc9bnVsbDt0aGlzLmNvbm5lY3Rpb25TZXQ9bnVsbDt0aGlzLmRhdGFzZXRzPW51bGw7dGhpcy5sb2NhbGVTZXQ9bnVsbDt0aGlzLnN0eWxlc2hlZXQ9bmV3IG4uWEZBT2JqZWN0QXJyYXk7dGhpcy50ZW1wbGF0ZT1udWxsfVtuLiRvbkNoaWxkQ2hlY2tdKGUpe2NvbnN0IHQ9ci5OYW1lc3BhY2VJZHNbZVtuLiRub2RlTmFtZV1dO3JldHVybiB0JiZlW24uJG5hbWVzcGFjZUlkXT09PXQuaWR9fWNsYXNzIFhkcE5hbWVzcGFjZXtzdGF0aWNbci4kYnVpbGRYRkFPYmplY3RdKGUsdCl7aWYoWGRwTmFtZXNwYWNlLmhhc093blByb3BlcnR5KGUpKXJldHVybiBYZHBOYW1lc3BhY2VbZV0odCl9c3RhdGljIHhkcChlKXtyZXR1cm4gbmV3IFhkcChlKX19dC5YZHBOYW1lc3BhY2U9WGRwTmFtZXNwYWNlfSwoZSx0LGEpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3QuWGh0bWxOYW1lc3BhY2U9dm9pZCAwO3ZhciByPWEoNzcpLG49YSg3OSksaT1hKDg0KSxzPWEoNzgpO2NvbnN0IG89bi5OYW1lc3BhY2VJZHMueGh0bWwuaWQsYz1TeW1ib2woKSxsPW5ldyBTZXQoWyJjb2xvciIsImZvbnQiLCJmb250LWZhbWlseSIsImZvbnQtc2l6ZSIsImZvbnQtc3RyZXRjaCIsImZvbnQtc3R5bGUiLCJmb250LXdlaWdodCIsIm1hcmdpbiIsIm1hcmdpbi1ib3R0b20iLCJtYXJnaW4tbGVmdCIsIm1hcmdpbi1yaWdodCIsIm1hcmdpbi10b3AiLCJsZXR0ZXItc3BhY2luZyIsImxpbmUtaGVpZ2h0Iiwib3JwaGFucyIsInBhZ2UtYnJlYWstYWZ0ZXIiLCJwYWdlLWJyZWFrLWJlZm9yZSIsInBhZ2UtYnJlYWstaW5zaWRlIiwidGFiLWludGVydmFsIiwidGFiLXN0b3AiLCJ0ZXh0LWFsaWduIiwidGV4dC1kZWNvcmF0aW9uIiwidGV4dC1pbmRlbnQiLCJ2ZXJ0aWNhbC1hbGlnbiIsIndpZG93cyIsImtlcm5pbmctbW9kZSIsInhmYS1mb250LWhvcml6b250YWwtc2NhbGUiLCJ4ZmEtZm9udC12ZXJ0aWNhbC1zY2FsZSIsInhmYS1zcGFjZXJ1biIsInhmYS10YWItc3RvcHMiXSksaD1uZXcgTWFwKFtbInBhZ2UtYnJlYWstYWZ0ZXIiLCJicmVha0FmdGVyIl0sWyJwYWdlLWJyZWFrLWJlZm9yZSIsImJyZWFrQmVmb3JlIl0sWyJwYWdlLWJyZWFrLWluc2lkZSIsImJyZWFrSW5zaWRlIl0sWyJrZXJuaW5nLW1vZGUiLGU9PiJub25lIj09PWU/Im5vbmUiOiJub3JtYWwiXSxbInhmYS1mb250LWhvcml6b250YWwtc2NhbGUiLGU9PmBzY2FsZVgoJHtNYXRoLm1heCgwLE1hdGgubWluKHBhcnNlSW50KGUpLzEwMCkpLnRvRml4ZWQoMil9KWBdLFsieGZhLWZvbnQtdmVydGljYWwtc2NhbGUiLGU9PmBzY2FsZVkoJHtNYXRoLm1heCgwLE1hdGgubWluKHBhcnNlSW50KGUpLzEwMCkpLnRvRml4ZWQoMil9KWBdLFsieGZhLXNwYWNlcnVuIiwiIl0sWyJ4ZmEtdGFiLXN0b3BzIiwiIl0sWyJmb250LXNpemUiLChlLHQpPT57ZT10LmZvbnRTaXplPSgwLHMuZ2V0TWVhc3VyZW1lbnQpKGUpO3JldHVybigwLGkubWVhc3VyZVRvU3RyaW5nKSguOTkqZSl9XSxbImxldHRlci1zcGFjaW5nIixlPT4oMCxpLm1lYXN1cmVUb1N0cmluZykoKDAscy5nZXRNZWFzdXJlbWVudCkoZSkpXSxbImxpbmUtaGVpZ2h0IixlPT4oMCxpLm1lYXN1cmVUb1N0cmluZykoKDAscy5nZXRNZWFzdXJlbWVudCkoZSkpXSxbIm1hcmdpbiIsZT0+KDAsaS5tZWFzdXJlVG9TdHJpbmcpKCgwLHMuZ2V0TWVhc3VyZW1lbnQpKGUpKV0sWyJtYXJnaW4tYm90dG9tIixlPT4oMCxpLm1lYXN1cmVUb1N0cmluZykoKDAscy5nZXRNZWFzdXJlbWVudCkoZSkpXSxbIm1hcmdpbi1sZWZ0IixlPT4oMCxpLm1lYXN1cmVUb1N0cmluZykoKDAscy5nZXRNZWFzdXJlbWVudCkoZSkpXSxbIm1hcmdpbi1yaWdodCIsZT0+KDAsaS5tZWFzdXJlVG9TdHJpbmcpKCgwLHMuZ2V0TWVhc3VyZW1lbnQpKGUpKV0sWyJtYXJnaW4tdG9wIixlPT4oMCxpLm1lYXN1cmVUb1N0cmluZykoKDAscy5nZXRNZWFzdXJlbWVudCkoZSkpXSxbInRleHQtaW5kZW50IixlPT4oMCxpLm1lYXN1cmVUb1N0cmluZykoKDAscy5nZXRNZWFzdXJlbWVudCkoZSkpXSxbImZvbnQtZmFtaWx5IixlPT5lXSxbInZlcnRpY2FsLWFsaWduIixlPT4oMCxpLm1lYXN1cmVUb1N0cmluZykoKDAscy5nZXRNZWFzdXJlbWVudCkoZSkpXV0pLHU9L1xzKy9nLGQ9L1tcclxuXSsvZyxmPS9cclxuPy9nO2Z1bmN0aW9uIG1hcFN0eWxlKGUsdCxhKXtjb25zdCBuPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoIWUpcmV0dXJuIG47Y29uc3Qgbz1PYmplY3QuY3JlYXRlKG51bGwpO2Zvcihjb25zdFt0LGFdb2YgZS5zcGxpdCgiOyIpLm1hcCgoZT0+ZS5zcGxpdCgiOiIsMikpKSl7Y29uc3QgZT1oLmdldCh0KTtpZigiIj09PWUpY29udGludWU7bGV0IHI9YTtlJiYocj0ic3RyaW5nIj09dHlwZW9mIGU/ZTplKGEsbykpO3QuZW5kc1dpdGgoInNjYWxlIik/bi50cmFuc2Zvcm0/bi50cmFuc2Zvcm09YCR7blt0XX0gJHtyfWA6bi50cmFuc2Zvcm09cjpuW3QucmVwbGFjZUFsbCgvLShbYS16QS1aXSkvZywoKGUsdCk9PnQudG9VcHBlckNhc2UoKSkpXT1yfW4uZm9udEZhbWlseSYmKDAsaS5zZXRGb250RmFtaWx5KSh7dHlwZWZhY2U6bi5mb250RmFtaWx5LHdlaWdodDpuLmZvbnRXZWlnaHR8fCJub3JtYWwiLHBvc3R1cmU6bi5mb250U3R5bGV8fCJub3JtYWwiLHNpemU6by5mb250U2l6ZXx8MH0sdCx0W3IuJGdsb2JhbERhdGFdLmZvbnRGaW5kZXIsbik7aWYoYSYmbi52ZXJ0aWNhbEFsaWduJiYiMHB4IiE9PW4udmVydGljYWxBbGlnbiYmbi5mb250U2l6ZSl7Y29uc3QgZT0uNTgzLHQ9LjMzMyxhPSgwLHMuZ2V0TWVhc3VyZW1lbnQpKG4uZm9udFNpemUpO24uZm9udFNpemU9KDAsaS5tZWFzdXJlVG9TdHJpbmcpKGEqZSk7bi52ZXJ0aWNhbEFsaWduPSgwLGkubWVhc3VyZVRvU3RyaW5nKShNYXRoLnNpZ24oKDAscy5nZXRNZWFzdXJlbWVudCkobi52ZXJ0aWNhbEFsaWduKSkqYSp0KX1hJiZuLmZvbnRTaXplJiYobi5mb250U2l6ZT1gY2FsYygke24uZm9udFNpemV9ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgKTsoMCxpLmZpeFRleHRJbmRlbnQpKG4pO3JldHVybiBufWNvbnN0IGc9bmV3IFNldChbImJvZHkiLCJodG1sIl0pO2NsYXNzIFhodG1sT2JqZWN0IGV4dGVuZHMgci5YbWxPYmplY3R7Y29uc3RydWN0b3IoZSx0KXtzdXBlcihvLHQpO3RoaXNbY109ITE7dGhpcy5zdHlsZT1lLnN0eWxlfHwiIn1bci4kY2xlYW5dKGUpe3N1cGVyW3IuJGNsZWFuXShlKTt0aGlzLnN0eWxlPWZ1bmN0aW9uIGNoZWNrU3R5bGUoZSl7cmV0dXJuIGUuc3R5bGU/ZS5zdHlsZS50cmltKCkuc3BsaXQoL1xzKjtccyovKS5maWx0ZXIoKGU9PiEhZSkpLm1hcCgoZT0+ZS5zcGxpdCgvXHMqOlxzKi8sMikpKS5maWx0ZXIoKChbdCxhXSk9PnsiZm9udC1mYW1pbHkiPT09dCYmZVtyLiRnbG9iYWxEYXRhXS51c2VkVHlwZWZhY2VzLmFkZChhKTtyZXR1cm4gbC5oYXModCl9KSkubWFwKChlPT5lLmpvaW4oIjoiKSkpLmpvaW4oIjsiKToiIn0odGhpcyl9W3IuJGFjY2VwdFdoaXRlc3BhY2VdKCl7cmV0dXJuIWcuaGFzKHRoaXNbci4kbm9kZU5hbWVdKX1bci4kb25UZXh0XShlLHQ9ITEpe2lmKHQpdGhpc1tjXT0hMDtlbHNle2U9ZS5yZXBsYWNlKGQsIiIpO3RoaXMuc3R5bGUuaW5jbHVkZXMoInhmYS1zcGFjZXJ1bjp5ZXMiKXx8KGU9ZS5yZXBsYWNlKHUsIiAiKSl9ZSYmKHRoaXNbci4kY29udGVudF0rPWUpfVtyLiRwdXNoR2x5cGhzXShlLHQ9ITApe2NvbnN0IGE9T2JqZWN0LmNyZWF0ZShudWxsKSxuPXt0b3A6TmFOLGJvdHRvbTpOYU4sbGVmdDpOYU4scmlnaHQ6TmFOfTtsZXQgaT1udWxsO2Zvcihjb25zdFtlLHRdb2YgdGhpcy5zdHlsZS5zcGxpdCgiOyIpLm1hcCgoZT0+ZS5zcGxpdCgiOiIsMikpKSlzd2l0Y2goZSl7Y2FzZSJmb250LWZhbWlseSI6YS50eXBlZmFjZT0oMCxzLnN0cmlwUXVvdGVzKSh0KTticmVhaztjYXNlImZvbnQtc2l6ZSI6YS5zaXplPSgwLHMuZ2V0TWVhc3VyZW1lbnQpKHQpO2JyZWFrO2Nhc2UiZm9udC13ZWlnaHQiOmEud2VpZ2h0PXQ7YnJlYWs7Y2FzZSJmb250LXN0eWxlIjphLnBvc3R1cmU9dDticmVhaztjYXNlImxldHRlci1zcGFjaW5nIjphLmxldHRlclNwYWNpbmc9KDAscy5nZXRNZWFzdXJlbWVudCkodCk7YnJlYWs7Y2FzZSJtYXJnaW4iOmNvbnN0IGU9dC5zcGxpdCgvIFx0LykubWFwKChlPT4oMCxzLmdldE1lYXN1cmVtZW50KShlKSkpO3N3aXRjaChlLmxlbmd0aCl7Y2FzZSAxOm4udG9wPW4uYm90dG9tPW4ubGVmdD1uLnJpZ2h0PWVbMF07YnJlYWs7Y2FzZSAyOm4udG9wPW4uYm90dG9tPWVbMF07bi5sZWZ0PW4ucmlnaHQ9ZVsxXTticmVhaztjYXNlIDM6bi50b3A9ZVswXTtuLmJvdHRvbT1lWzJdO24ubGVmdD1uLnJpZ2h0PWVbMV07YnJlYWs7Y2FzZSA0Om4udG9wPWVbMF07bi5sZWZ0PWVbMV07bi5ib3R0b209ZVsyXTtuLnJpZ2h0PWVbM119YnJlYWs7Y2FzZSJtYXJnaW4tdG9wIjpuLnRvcD0oMCxzLmdldE1lYXN1cmVtZW50KSh0KTticmVhaztjYXNlIm1hcmdpbi1ib3R0b20iOm4uYm90dG9tPSgwLHMuZ2V0TWVhc3VyZW1lbnQpKHQpO2JyZWFrO2Nhc2UibWFyZ2luLWxlZnQiOm4ubGVmdD0oMCxzLmdldE1lYXN1cmVtZW50KSh0KTticmVhaztjYXNlIm1hcmdpbi1yaWdodCI6bi5yaWdodD0oMCxzLmdldE1lYXN1cmVtZW50KSh0KTticmVhaztjYXNlImxpbmUtaGVpZ2h0IjppPSgwLHMuZ2V0TWVhc3VyZW1lbnQpKHQpfWUucHVzaERhdGEoYSxuLGkpO2lmKHRoaXNbci4kY29udGVudF0pZS5hZGRTdHJpbmcodGhpc1tyLiRjb250ZW50XSk7ZWxzZSBmb3IoY29uc3QgdCBvZiB0aGlzW3IuJGdldENoaWxkcmVuXSgpKSIjdGV4dCIhPT10W3IuJG5vZGVOYW1lXT90W3IuJHB1c2hHbHlwaHNdKGUpOmUuYWRkU3RyaW5nKHRbci4kY29udGVudF0pO3QmJmUucG9wRm9udCgpfVtyLiR0b0hUTUxdKGUpe2NvbnN0IHQ9W107dGhpc1tyLiRleHRyYV09e2NoaWxkcmVuOnR9O3RoaXNbci4kY2hpbGRyZW5Ub0hUTUxdKHt9KTtpZigwPT09dC5sZW5ndGgmJiF0aGlzW3IuJGNvbnRlbnRdKXJldHVybiBzLkhUTUxSZXN1bHQuRU1QVFk7bGV0IGE7YT10aGlzW2NdP3RoaXNbci4kY29udGVudF0/dGhpc1tyLiRjb250ZW50XS5yZXBsYWNlKGYsIlxuIik6dm9pZCAwOnRoaXNbci4kY29udGVudF18fHZvaWQgMDtyZXR1cm4gcy5IVE1MUmVzdWx0LnN1Y2Nlc3Moe25hbWU6dGhpc1tyLiRub2RlTmFtZV0sYXR0cmlidXRlczp7aHJlZjp0aGlzLmhyZWYsc3R5bGU6bWFwU3R5bGUodGhpcy5zdHlsZSx0aGlzLHRoaXNbY10pfSxjaGlsZHJlbjp0LHZhbHVlOmF9KX19Y2xhc3MgQSBleHRlbmRzIFhodG1sT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsImEiKTt0aGlzLmhyZWY9KDAsaS5maXhVUkwpKGUuaHJlZil8fCIifX1jbGFzcyBCIGV4dGVuZHMgWGh0bWxPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwiYiIpfVtyLiRwdXNoR2x5cGhzXShlKXtlLnB1c2hGb250KHt3ZWlnaHQ6ImJvbGQifSk7c3VwZXJbci4kcHVzaEdseXBoc10oZSk7ZS5wb3BGb250KCl9fWNsYXNzIEJvZHkgZXh0ZW5kcyBYaHRtbE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlLCJib2R5Iil9W3IuJHRvSFRNTF0oZSl7Y29uc3QgdD1zdXBlcltyLiR0b0hUTUxdKGUpLHtodG1sOmF9PXQ7aWYoIWEpcmV0dXJuIHMuSFRNTFJlc3VsdC5FTVBUWTthLm5hbWU9ImRpdiI7YS5hdHRyaWJ1dGVzLmNsYXNzPVsieGZhUmljaCJdO3JldHVybiB0fX1jbGFzcyBCciBleHRlbmRzIFhodG1sT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsImJyIil9W3IuJHRleHRdKCl7cmV0dXJuIlxuIn1bci4kcHVzaEdseXBoc10oZSl7ZS5hZGRTdHJpbmcoIlxuIil9W3IuJHRvSFRNTF0oZSl7cmV0dXJuIHMuSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJiciJ9KX19Y2xhc3MgSHRtbCBleHRlbmRzIFhodG1sT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsImh0bWwiKX1bci4kdG9IVE1MXShlKXtjb25zdCB0PVtdO3RoaXNbci4kZXh0cmFdPXtjaGlsZHJlbjp0fTt0aGlzW3IuJGNoaWxkcmVuVG9IVE1MXSh7fSk7aWYoMD09PXQubGVuZ3RoKXJldHVybiBzLkhUTUxSZXN1bHQuc3VjY2Vzcyh7bmFtZToiZGl2IixhdHRyaWJ1dGVzOntjbGFzczpbInhmYVJpY2giXSxzdHlsZTp7fX0sdmFsdWU6dGhpc1tyLiRjb250ZW50XXx8IiJ9KTtpZigxPT09dC5sZW5ndGgpe2NvbnN0IGU9dFswXTtpZihlLmF0dHJpYnV0ZXMmJmUuYXR0cmlidXRlcy5jbGFzcy5pbmNsdWRlcygieGZhUmljaCIpKXJldHVybiBzLkhUTUxSZXN1bHQuc3VjY2VzcyhlKX1yZXR1cm4gcy5IVE1MUmVzdWx0LnN1Y2Nlc3Moe25hbWU6ImRpdiIsYXR0cmlidXRlczp7Y2xhc3M6WyJ4ZmFSaWNoIl0sc3R5bGU6e319LGNoaWxkcmVuOnR9KX19Y2xhc3MgSSBleHRlbmRzIFhodG1sT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsImkiKX1bci4kcHVzaEdseXBoc10oZSl7ZS5wdXNoRm9udCh7cG9zdHVyZToiaXRhbGljIn0pO3N1cGVyW3IuJHB1c2hHbHlwaHNdKGUpO2UucG9wRm9udCgpfX1jbGFzcyBMaSBleHRlbmRzIFhodG1sT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsImxpIil9fWNsYXNzIE9sIGV4dGVuZHMgWGh0bWxPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwib2wiKX19Y2xhc3MgUCBleHRlbmRzIFhodG1sT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsInAiKX1bci4kcHVzaEdseXBoc10oZSl7c3VwZXJbci4kcHVzaEdseXBoc10oZSwhMSk7ZS5hZGRTdHJpbmcoIlxuIik7ZS5hZGRQYXJhKCk7ZS5wb3BGb250KCl9W3IuJHRleHRdKCl7cmV0dXJuIHRoaXNbci4kZ2V0UGFyZW50XSgpW3IuJGdldENoaWxkcmVuXSgpLmF0KC0xKT09PXRoaXM/c3VwZXJbci4kdGV4dF0oKTpzdXBlcltyLiR0ZXh0XSgpKyJcbiJ9fWNsYXNzIFNwYW4gZXh0ZW5kcyBYaHRtbE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlLCJzcGFuIil9fWNsYXNzIFN1YiBleHRlbmRzIFhodG1sT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsInN1YiIpfX1jbGFzcyBTdXAgZXh0ZW5kcyBYaHRtbE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlLCJzdXAiKX19Y2xhc3MgVWwgZXh0ZW5kcyBYaHRtbE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlLCJ1bCIpfX1jbGFzcyBYaHRtbE5hbWVzcGFjZXtzdGF0aWNbbi4kYnVpbGRYRkFPYmplY3RdKGUsdCl7aWYoWGh0bWxOYW1lc3BhY2UuaGFzT3duUHJvcGVydHkoZSkpcmV0dXJuIFhodG1sTmFtZXNwYWNlW2VdKHQpfXN0YXRpYyBhKGUpe3JldHVybiBuZXcgQShlKX1zdGF0aWMgYihlKXtyZXR1cm4gbmV3IEIoZSl9c3RhdGljIGJvZHkoZSl7cmV0dXJuIG5ldyBCb2R5KGUpfXN0YXRpYyBicihlKXtyZXR1cm4gbmV3IEJyKGUpfXN0YXRpYyBodG1sKGUpe3JldHVybiBuZXcgSHRtbChlKX1zdGF0aWMgaShlKXtyZXR1cm4gbmV3IEkoZSl9c3RhdGljIGxpKGUpe3JldHVybiBuZXcgTGkoZSl9c3RhdGljIG9sKGUpe3JldHVybiBuZXcgT2woZSl9c3RhdGljIHAoZSl7cmV0dXJuIG5ldyBQKGUpfXN0YXRpYyBzcGFuKGUpe3JldHVybiBuZXcgU3BhbihlKX1zdGF0aWMgc3ViKGUpe3JldHVybiBuZXcgU3ViKGUpfXN0YXRpYyBzdXAoZSl7cmV0dXJuIG5ldyBTdXAoZSl9c3RhdGljIHVsKGUpe3JldHVybiBuZXcgVWwoZSl9fXQuWGh0bWxOYW1lc3BhY2U9WGh0bWxOYW1lc3BhY2V9LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5Vbmtub3duTmFtZXNwYWNlPXZvaWQgMDt2YXIgcj1hKDc5KSxuPWEoNzcpO2NsYXNzIFVua25vd25OYW1lc3BhY2V7Y29uc3RydWN0b3IoZSl7dGhpcy5uYW1lc3BhY2VJZD1lfVtyLiRidWlsZFhGQU9iamVjdF0oZSx0KXtyZXR1cm4gbmV3IG4uWG1sT2JqZWN0KHRoaXMubmFtZXNwYWNlSWQsZSx0KX19dC5Vbmtub3duTmFtZXNwYWNlPVVua25vd25OYW1lc3BhY2V9LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5EYXRhc2V0UmVhZGVyPXZvaWQgMDt2YXIgcj1hKDIpLG49YSg2KSxpPWEoNjYpO2Z1bmN0aW9uIGRlY29kZVN0cmluZyhlKXt0cnl7cmV0dXJuKDAsci5zdHJpbmdUb1VURjhTdHJpbmcpKGUpfWNhdGNoKHQpeygwLHIud2FybikoYFVURi04IGRlY29kaW5nIGZhaWxlZDogIiR7dH0iLmApO3JldHVybiBlfX1jbGFzcyBEYXRhc2V0WE1MUGFyc2VyIGV4dGVuZHMgaS5TaW1wbGVYTUxQYXJzZXJ7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7dGhpcy5ub2RlPW51bGx9b25FbmRFbGVtZW50KGUpe2NvbnN0IHQ9c3VwZXIub25FbmRFbGVtZW50KGUpO2lmKHQmJiJ4ZmE6ZGF0YXNldHMiPT09ZSl7dGhpcy5ub2RlPXQ7dGhyb3cgbmV3IEVycm9yKCJBYm9ydGluZyBEYXRhc2V0WE1MUGFyc2VyLiIpfX19dC5EYXRhc2V0UmVhZGVyPWNsYXNzIERhdGFzZXRSZWFkZXJ7Y29uc3RydWN0b3IoZSl7aWYoZS5kYXRhc2V0cyl0aGlzLm5vZGU9bmV3IGkuU2ltcGxlWE1MUGFyc2VyKHtoYXNBdHRyaWJ1dGVzOiEwfSkucGFyc2VGcm9tU3RyaW5nKGUuZGF0YXNldHMpLmRvY3VtZW50RWxlbWVudDtlbHNle2NvbnN0IHQ9bmV3IERhdGFzZXRYTUxQYXJzZXIoe2hhc0F0dHJpYnV0ZXM6ITB9KTt0cnl7dC5wYXJzZUZyb21TdHJpbmcoZVsieGRwOnhkcCJdKX1jYXRjaChlKXt9dGhpcy5ub2RlPXQubm9kZX19Z2V0VmFsdWUoZSl7aWYoIXRoaXMubm9kZXx8IWUpcmV0dXJuIiI7Y29uc3QgdD10aGlzLm5vZGUuc2VhcmNoTm9kZSgoMCxuLnBhcnNlWEZBUGF0aCkoZSksMCk7aWYoIXQpcmV0dXJuIiI7Y29uc3QgYT10LmZpcnN0Q2hpbGQ7cmV0dXJuIGEmJiJ2YWx1ZSI9PT1hLm5vZGVOYW1lP3QuY2hpbGRyZW4ubWFwKChlPT5kZWNvZGVTdHJpbmcoZS50ZXh0Q29udGVudCkpKTpkZWNvZGVTdHJpbmcodC50ZXh0Q29udGVudCl9fX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LlhSZWY9dm9pZCAwO3ZhciByPWEoMiksbj1hKDUpLGk9YSg2KSxzPWEoMTcpLG89YSg3KSxjPWEoNjcpO3QuWFJlZj1jbGFzcyBYUmVme2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5zdHJlYW09ZTt0aGlzLnBkZk1hbmFnZXI9dDt0aGlzLmVudHJpZXM9W107dGhpcy54cmVmc3Rtcz1PYmplY3QuY3JlYXRlKG51bGwpO3RoaXMuX2NhY2hlTWFwPW5ldyBNYXA7dGhpcy5fcGVuZGluZ1JlZnM9bmV3IG4uUmVmU2V0O3RoaXMuc3RhdHM9bmV3IGkuRG9jU3RhdHModC5tc2dIYW5kbGVyKTt0aGlzLl9uZXdSZWZOdW09bnVsbH1nZXROZXdSZWYoKXtudWxsPT09dGhpcy5fbmV3UmVmTnVtJiYodGhpcy5fbmV3UmVmTnVtPXRoaXMuZW50cmllcy5sZW5ndGh8fDEpO3JldHVybiBuLlJlZi5nZXQodGhpcy5fbmV3UmVmTnVtKyssMCl9cmVzZXROZXdSZWYoKXt0aGlzLl9uZXdSZWZOdW09bnVsbH1zZXRTdGFydFhSZWYoZSl7dGhpcy5zdGFydFhSZWZRdWV1ZT1bZV19cGFyc2UoZT0hMSl7bGV0IHQsYSxzO2lmKGUpeygwLHIud2FybikoIkluZGV4aW5nIGFsbCBQREYgb2JqZWN0cyIpO3Q9dGhpcy5pbmRleE9iamVjdHMoKX1lbHNlIHQ9dGhpcy5yZWFkWFJlZigpO3QuYXNzaWduWHJlZih0aGlzKTt0aGlzLnRyYWlsZXI9dDt0cnl7YT10LmdldCgiRW5jcnlwdCIpfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBpLk1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7KDAsci53YXJuKShgWFJlZi5wYXJzZSAtIEludmFsaWQgIkVuY3J5cHQiIHJlZmVyZW5jZTogIiR7ZX0iLmApfWlmKGEgaW5zdGFuY2VvZiBuLkRpY3Qpe2NvbnN0IGU9dC5nZXQoIklEIikscj1lJiZlLmxlbmd0aD9lWzBdOiIiO2Euc3VwcHJlc3NFbmNyeXB0aW9uPSEwO3RoaXMuZW5jcnlwdD1uZXcgYy5DaXBoZXJUcmFuc2Zvcm1GYWN0b3J5KGEscix0aGlzLnBkZk1hbmFnZXIucGFzc3dvcmQpfXRyeXtzPXQuZ2V0KCJSb290Iil9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIGkuTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZTsoMCxyLndhcm4pKGBYUmVmLnBhcnNlIC0gSW52YWxpZCAiUm9vdCIgcmVmZXJlbmNlOiAiJHtlfSIuYCl9aWYocyBpbnN0YW5jZW9mIG4uRGljdCl0cnl7aWYocy5nZXQoIlBhZ2VzIilpbnN0YW5jZW9mIG4uRGljdCl7dGhpcy5yb290PXM7cmV0dXJufX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgaS5NaXNzaW5nRGF0YUV4Y2VwdGlvbil0aHJvdyBlOygwLHIud2FybikoYFhSZWYucGFyc2UgLSBJbnZhbGlkICJQYWdlcyIgcmVmZXJlbmNlOiAiJHtlfSIuYCl9aWYoIWUpdGhyb3cgbmV3IGkuWFJlZlBhcnNlRXhjZXB0aW9uO3Rocm93IG5ldyByLkludmFsaWRQREZFeGNlcHRpb24oIkludmFsaWQgUm9vdCByZWZlcmVuY2UuIil9cHJvY2Vzc1hSZWZUYWJsZShlKXsidGFibGVTdGF0ZSJpbiB0aGlzfHwodGhpcy50YWJsZVN0YXRlPXtlbnRyeU51bTowLHN0cmVhbVBvczplLmxleGVyLnN0cmVhbS5wb3MscGFyc2VyQnVmMTplLmJ1ZjEscGFyc2VyQnVmMjplLmJ1ZjJ9KTtjb25zdCB0PXRoaXMucmVhZFhSZWZUYWJsZShlKTtpZighKDAsbi5pc0NtZCkodCwidHJhaWxlciIpKXRocm93IG5ldyByLkZvcm1hdEVycm9yKCJJbnZhbGlkIFhSZWYgdGFibGU6IGNvdWxkIG5vdCBmaW5kIHRyYWlsZXIgZGljdGlvbmFyeSIpO2xldCBhPWUuZ2V0T2JqKCk7YSBpbnN0YW5jZW9mIG4uRGljdHx8IWEuZGljdHx8KGE9YS5kaWN0KTtpZighKGEgaW5zdGFuY2VvZiBuLkRpY3QpKXRocm93IG5ldyByLkZvcm1hdEVycm9yKCJJbnZhbGlkIFhSZWYgdGFibGU6IGNvdWxkIG5vdCBwYXJzZSB0cmFpbGVyIGRpY3Rpb25hcnkiKTtkZWxldGUgdGhpcy50YWJsZVN0YXRlO3JldHVybiBhfXJlYWRYUmVmVGFibGUoZSl7Y29uc3QgdD1lLmxleGVyLnN0cmVhbSxhPXRoaXMudGFibGVTdGF0ZTt0LnBvcz1hLnN0cmVhbVBvcztlLmJ1ZjE9YS5wYXJzZXJCdWYxO2UuYnVmMj1hLnBhcnNlckJ1ZjI7bGV0IGk7Zm9yKDs7KXtpZighKCJmaXJzdEVudHJ5TnVtImluIGEpfHwhKCJlbnRyeUNvdW50ImluIGEpKXtpZigoMCxuLmlzQ21kKShpPWUuZ2V0T2JqKCksInRyYWlsZXIiKSlicmVhazthLmZpcnN0RW50cnlOdW09aTthLmVudHJ5Q291bnQ9ZS5nZXRPYmooKX1sZXQgcz1hLmZpcnN0RW50cnlOdW07Y29uc3Qgbz1hLmVudHJ5Q291bnQ7aWYoIU51bWJlci5pc0ludGVnZXIocyl8fCFOdW1iZXIuaXNJbnRlZ2VyKG8pKXRocm93IG5ldyByLkZvcm1hdEVycm9yKCJJbnZhbGlkIFhSZWYgdGFibGU6IHdyb25nIHR5cGVzIGluIHN1YnNlY3Rpb24gaGVhZGVyIik7Zm9yKGxldCBpPWEuZW50cnlOdW07aTxvO2krKyl7YS5zdHJlYW1Qb3M9dC5wb3M7YS5lbnRyeU51bT1pO2EucGFyc2VyQnVmMT1lLmJ1ZjE7YS5wYXJzZXJCdWYyPWUuYnVmMjtjb25zdCBjPXt9O2Mub2Zmc2V0PWUuZ2V0T2JqKCk7Yy5nZW49ZS5nZXRPYmooKTtjb25zdCBsPWUuZ2V0T2JqKCk7aWYobCBpbnN0YW5jZW9mIG4uQ21kKXN3aXRjaChsLmNtZCl7Y2FzZSJmIjpjLmZyZWU9ITA7YnJlYWs7Y2FzZSJuIjpjLnVuY29tcHJlc3NlZD0hMH1pZighTnVtYmVyLmlzSW50ZWdlcihjLm9mZnNldCl8fCFOdW1iZXIuaXNJbnRlZ2VyKGMuZ2VuKXx8IWMuZnJlZSYmIWMudW5jb21wcmVzc2VkKXRocm93IG5ldyByLkZvcm1hdEVycm9yKGBJbnZhbGlkIGVudHJ5IGluIFhSZWYgc3Vic2VjdGlvbjogJHtzfSwgJHtvfWApOzA9PT1pJiZjLmZyZWUmJjE9PT1zJiYocz0wKTt0aGlzLmVudHJpZXNbaStzXXx8KHRoaXMuZW50cmllc1tpK3NdPWMpfWEuZW50cnlOdW09MDthLnN0cmVhbVBvcz10LnBvczthLnBhcnNlckJ1ZjE9ZS5idWYxO2EucGFyc2VyQnVmMj1lLmJ1ZjI7ZGVsZXRlIGEuZmlyc3RFbnRyeU51bTtkZWxldGUgYS5lbnRyeUNvdW50fWlmKHRoaXMuZW50cmllc1swXSYmIXRoaXMuZW50cmllc1swXS5mcmVlKXRocm93IG5ldyByLkZvcm1hdEVycm9yKCJJbnZhbGlkIFhSZWYgdGFibGU6IHVuZXhwZWN0ZWQgZmlyc3Qgb2JqZWN0Iik7cmV0dXJuIGl9cHJvY2Vzc1hSZWZTdHJlYW0oZSl7aWYoISgic3RyZWFtU3RhdGUiaW4gdGhpcykpe2NvbnN0IHQ9ZS5kaWN0LGE9dC5nZXQoIlciKTtsZXQgcj10LmdldCgiSW5kZXgiKTtyfHwocj1bMCx0LmdldCgiU2l6ZSIpXSk7dGhpcy5zdHJlYW1TdGF0ZT17ZW50cnlSYW5nZXM6cixieXRlV2lkdGhzOmEsZW50cnlOdW06MCxzdHJlYW1Qb3M6ZS5wb3N9fXRoaXMucmVhZFhSZWZTdHJlYW0oZSk7ZGVsZXRlIHRoaXMuc3RyZWFtU3RhdGU7cmV0dXJuIGUuZGljdH1yZWFkWFJlZlN0cmVhbShlKXtjb25zdCB0PXRoaXMuc3RyZWFtU3RhdGU7ZS5wb3M9dC5zdHJlYW1Qb3M7Y29uc3RbYSxuLGldPXQuYnl0ZVdpZHRocyxzPXQuZW50cnlSYW5nZXM7Zm9yKDtzLmxlbmd0aD4wOyl7Y29uc3RbbyxjXT1zO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKG8pfHwhTnVtYmVyLmlzSW50ZWdlcihjKSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcihgSW52YWxpZCBYUmVmIHJhbmdlIGZpZWxkczogJHtvfSwgJHtjfWApO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGEpfHwhTnVtYmVyLmlzSW50ZWdlcihuKXx8IU51bWJlci5pc0ludGVnZXIoaSkpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoYEludmFsaWQgWFJlZiBlbnRyeSBmaWVsZHMgbGVuZ3RoOiAke299LCAke2N9YCk7Zm9yKGxldCBzPXQuZW50cnlOdW07czxjOysrcyl7dC5lbnRyeU51bT1zO3Quc3RyZWFtUG9zPWUucG9zO2xldCBjPTAsbD0wLGg9MDtmb3IobGV0IHQ9MDt0PGE7Kyt0KXtjb25zdCB0PWUuZ2V0Qnl0ZSgpO2lmKC0xPT09dCl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiSW52YWxpZCBYUmVmIGJ5dGVXaWR0aHMgJ3R5cGUnLiIpO2M9Yzw8OHx0fTA9PT1hJiYoYz0xKTtmb3IobGV0IHQ9MDt0PG47Kyt0KXtjb25zdCB0PWUuZ2V0Qnl0ZSgpO2lmKC0xPT09dCl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcigiSW52YWxpZCBYUmVmIGJ5dGVXaWR0aHMgJ29mZnNldCcuIik7bD1sPDw4fHR9Zm9yKGxldCB0PTA7dDxpOysrdCl7Y29uc3QgdD1lLmdldEJ5dGUoKTtpZigtMT09PXQpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoIkludmFsaWQgWFJlZiBieXRlV2lkdGhzICdnZW5lcmF0aW9uJy4iKTtoPWg8PDh8dH1jb25zdCB1PXt9O3Uub2Zmc2V0PWw7dS5nZW49aDtzd2l0Y2goYyl7Y2FzZSAwOnUuZnJlZT0hMDticmVhaztjYXNlIDE6dS51bmNvbXByZXNzZWQ9ITA7YnJlYWs7Y2FzZSAyOmJyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoYEludmFsaWQgWFJlZiBlbnRyeSB0eXBlOiAke2N9YCl9dGhpcy5lbnRyaWVzW28rc118fCh0aGlzLmVudHJpZXNbbytzXT11KX10LmVudHJ5TnVtPTA7dC5zdHJlYW1Qb3M9ZS5wb3M7cy5zcGxpY2UoMCwyKX19aW5kZXhPYmplY3RzKCl7ZnVuY3Rpb24gcmVhZFRva2VuKGUsdCl7bGV0IGE9IiIscj1lW3RdO2Zvcig7MTAhPT1yJiYxMyE9PXImJjYwIT09ciYmISgrK3Q+PWUubGVuZ3RoKTspe2ErPVN0cmluZy5mcm9tQ2hhckNvZGUocik7cj1lW3RdfXJldHVybiBhfWZ1bmN0aW9uIHNraXBVbnRpbChlLHQsYSl7Y29uc3Qgcj1hLmxlbmd0aCxuPWUubGVuZ3RoO2xldCBpPTA7Zm9yKDt0PG47KXtsZXQgbj0wO2Zvcig7bjxyJiZlW3Qrbl09PT1hW25dOykrK247aWYobj49cilicmVhazt0Kys7aSsrfXJldHVybiBpfWNvbnN0IGU9L14oXGQrKVxzKyhcZCspXHMrb2JqXGIvLHQ9L1xiZW5kb2JqW1xiXHNdJC8sYT0vXHMrKFxkK1xzK1xkK1xzK29ialtcYlxzPF0pJC8sbz1uZXcgVWludDhBcnJheShbMTE2LDExNCw5NywxMDUsMTA4LDEwMSwxMTRdKSxjPW5ldyBVaW50OEFycmF5KFsxMTUsMTE2LDk3LDExNCwxMTYsMTIwLDExNCwxMDEsMTAyXSksbD1uZXcgVWludDhBcnJheShbMTExLDk4LDEwNl0pLGg9bmV3IFVpbnQ4QXJyYXkoWzQ3LDg4LDgyLDEwMSwxMDJdKTt0aGlzLmVudHJpZXMubGVuZ3RoPTA7dGhpcy5fY2FjaGVNYXAuY2xlYXIoKTtjb25zdCB1PXRoaXMuc3RyZWFtO3UucG9zPTA7Y29uc3QgZD11LmdldEJ5dGVzKCksZj1kLmxlbmd0aDtsZXQgZz11LnN0YXJ0O2NvbnN0IHA9W10sbT1bXTtmb3IoO2c8Zjspe2xldCBuPWRbZ107aWYoOT09PW58fDEwPT09bnx8MTM9PT1ufHwzMj09PW4peysrZztjb250aW51ZX1pZigzNz09PW4pe2RveysrZztpZihnPj1mKWJyZWFrO249ZFtnXX13aGlsZSgxMCE9PW4mJjEzIT09bik7Y29udGludWV9Y29uc3QgYj1yZWFkVG9rZW4oZCxnKTtsZXQgeTtpZihiLnN0YXJ0c1dpdGgoInhyZWYiKSYmKDQ9PT1iLmxlbmd0aHx8L1xzLy50ZXN0KGJbNF0pKSl7Zys9c2tpcFVudGlsKGQsZyxvKTtwLnB1c2goZyk7Zys9c2tpcFVudGlsKGQsZyxjKX1lbHNlIGlmKHk9ZS5leGVjKGIpKXtjb25zdCBlPTB8eVsxXSxuPTB8eVsyXTtsZXQgbyxjPWcrYi5sZW5ndGgsZj0hMTtpZih0aGlzLmVudHJpZXNbZV0pe2lmKHRoaXMuZW50cmllc1tlXS5nZW49PT1uKXRyeXtuZXcgcy5QYXJzZXIoe2xleGVyOm5ldyBzLkxleGVyKHUubWFrZVN1YlN0cmVhbShjKSl9KS5nZXRPYmooKTtmPSEwfWNhdGNoKGUpe2UgaW5zdGFuY2VvZiBpLlBhcnNlckVPRkV4Y2VwdGlvbj8oMCxyLndhcm4pKGBpbmRleE9iamVjdHMgLS0gY2hlY2tpbmcgb2JqZWN0ICgke2J9KTogIiR7ZX0iLmApOmY9ITB9fWVsc2UgZj0hMDtmJiYodGhpcy5lbnRyaWVzW2VdPXtvZmZzZXQ6Zy11LnN0YXJ0LGdlbjpuLHVuY29tcHJlc3NlZDohMH0pO2Zvcig7YzxkLmxlbmd0aDspe2NvbnN0IGU9Yytza2lwVW50aWwoZCxjLGwpKzQ7bz1lLWc7Y29uc3Qgbj1NYXRoLm1heChlLTI1LGMpLGk9KDAsci5ieXRlc1RvU3RyaW5nKShkLnN1YmFycmF5KG4sZSkpO2lmKHQudGVzdChpKSlicmVhazt7Y29uc3QgZT1hLmV4ZWMoaSk7aWYoZSYmZVsxXSl7KDAsci53YXJuKSgnaW5kZXhPYmplY3RzOiBGb3VuZCBuZXcgIm9iaiIgaW5zaWRlIG9mIGFub3RoZXIgIm9iaiIsIGNhdXNlZCBieSBtaXNzaW5nICJlbmRvYmoiIC0tIHRyeWluZyB0byByZWNvdmVyLicpO28tPWVbMV0ubGVuZ3RoO2JyZWFrfX1jPWV9Y29uc3QgcD1kLnN1YmFycmF5KGcsZytvKSx3PXNraXBVbnRpbChwLDAsaCk7aWYodzxvJiZwW3crNV08NjQpe20ucHVzaChnLXUuc3RhcnQpO3RoaXMueHJlZnN0bXNbZy11LnN0YXJ0XT0xfWcrPW99ZWxzZSBpZihiLnN0YXJ0c1dpdGgoInRyYWlsZXIiKSYmKDc9PT1iLmxlbmd0aHx8L1xzLy50ZXN0KGJbN10pKSl7cC5wdXNoKGcpO2crPXNraXBVbnRpbChkLGcsYyl9ZWxzZSBnKz1iLmxlbmd0aCsxfWZvcihsZXQgZT0wLHQ9bS5sZW5ndGg7ZTx0OysrZSl7dGhpcy5zdGFydFhSZWZRdWV1ZS5wdXNoKG1bZV0pO3RoaXMucmVhZFhSZWYoITApfWxldCBiO2ZvcihsZXQgZT0wLHQ9cC5sZW5ndGg7ZTx0OysrZSl7dS5wb3M9cFtlXTtjb25zdCB0PW5ldyBzLlBhcnNlcih7bGV4ZXI6bmV3IHMuTGV4ZXIodSkseHJlZjp0aGlzLGFsbG93U3RyZWFtczohMCxyZWNvdmVyeU1vZGU6ITB9KSxhPXQuZ2V0T2JqKCk7aWYoISgwLG4uaXNDbWQpKGEsInRyYWlsZXIiKSljb250aW51ZTtjb25zdCByPXQuZ2V0T2JqKCk7aWYociBpbnN0YW5jZW9mIG4uRGljdCl7dHJ5e2NvbnN0IGU9ci5nZXQoIlJvb3QiKTtpZighKGUgaW5zdGFuY2VvZiBuLkRpY3QpKWNvbnRpbnVlO2NvbnN0IHQ9ZS5nZXQoIlBhZ2VzIik7aWYoISh0IGluc3RhbmNlb2Ygbi5EaWN0KSljb250aW51ZTtjb25zdCBhPXQuZ2V0KCJDb3VudCIpO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGEpKWNvbnRpbnVlfWNhdGNoKGUpe2NvbnRpbnVlfWlmKHIuaGFzKCJJRCIpKXJldHVybiByO2I9cn19aWYoYilyZXR1cm4gYjtpZih0aGlzLnRvcERpY3QpcmV0dXJuIHRoaXMudG9wRGljdDt0aHJvdyBuZXcgci5JbnZhbGlkUERGRXhjZXB0aW9uKCJJbnZhbGlkIFBERiBzdHJ1Y3R1cmUuIil9cmVhZFhSZWYoZT0hMSl7Y29uc3QgdD10aGlzLnN0cmVhbSxhPW5ldyBTZXQ7dHJ5e2Zvcig7dGhpcy5zdGFydFhSZWZRdWV1ZS5sZW5ndGg7KXtjb25zdCBlPXRoaXMuc3RhcnRYUmVmUXVldWVbMF07aWYoYS5oYXMoZSkpeygwLHIud2FybikoInJlYWRYUmVmIC0gc2tpcHBpbmcgWFJlZiB0YWJsZSBzaW5jZSBpdCB3YXMgYWxyZWFkeSBwYXJzZWQuIik7dGhpcy5zdGFydFhSZWZRdWV1ZS5zaGlmdCgpO2NvbnRpbnVlfWEuYWRkKGUpO3QucG9zPWUrdC5zdGFydDtjb25zdCBpPW5ldyBzLlBhcnNlcih7bGV4ZXI6bmV3IHMuTGV4ZXIodCkseHJlZjp0aGlzLGFsbG93U3RyZWFtczohMH0pO2xldCBjLGw9aS5nZXRPYmooKTtpZigoMCxuLmlzQ21kKShsLCJ4cmVmIikpe2M9dGhpcy5wcm9jZXNzWFJlZlRhYmxlKGkpO3RoaXMudG9wRGljdHx8KHRoaXMudG9wRGljdD1jKTtsPWMuZ2V0KCJYUmVmU3RtIik7aWYoTnVtYmVyLmlzSW50ZWdlcihsKSl7Y29uc3QgZT1sO2lmKCEoZSBpbiB0aGlzLnhyZWZzdG1zKSl7dGhpcy54cmVmc3Rtc1tlXT0xO3RoaXMuc3RhcnRYUmVmUXVldWUucHVzaChlKX19fWVsc2V7aWYoIU51bWJlci5pc0ludGVnZXIobCkpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoIkludmFsaWQgWFJlZiBzdHJlYW0gaGVhZGVyIik7aWYoIShOdW1iZXIuaXNJbnRlZ2VyKGkuZ2V0T2JqKCkpJiYoMCxuLmlzQ21kKShpLmdldE9iaigpLCJvYmoiKSYmKGw9aS5nZXRPYmooKSlpbnN0YW5jZW9mIG8uQmFzZVN0cmVhbSkpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoIkludmFsaWQgWFJlZiBzdHJlYW0iKTtjPXRoaXMucHJvY2Vzc1hSZWZTdHJlYW0obCk7dGhpcy50b3BEaWN0fHwodGhpcy50b3BEaWN0PWMpO2lmKCFjKXRocm93IG5ldyByLkZvcm1hdEVycm9yKCJGYWlsZWQgdG8gcmVhZCBYUmVmIHN0cmVhbSIpfWw9Yy5nZXQoIlByZXYiKTtOdW1iZXIuaXNJbnRlZ2VyKGwpP3RoaXMuc3RhcnRYUmVmUXVldWUucHVzaChsKTpsIGluc3RhbmNlb2Ygbi5SZWYmJnRoaXMuc3RhcnRYUmVmUXVldWUucHVzaChsLm51bSk7dGhpcy5zdGFydFhSZWZRdWV1ZS5zaGlmdCgpfXJldHVybiB0aGlzLnRvcERpY3R9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIGkuTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZTsoMCxyLmluZm8pKCIod2hpbGUgcmVhZGluZyBYUmVmKTogIitlKTt0aGlzLnN0YXJ0WFJlZlF1ZXVlLnNoaWZ0KCl9aWYoIWUpdGhyb3cgbmV3IGkuWFJlZlBhcnNlRXhjZXB0aW9ufWdldEVudHJ5KGUpe2NvbnN0IHQ9dGhpcy5lbnRyaWVzW2VdO3JldHVybiB0JiYhdC5mcmVlJiZ0Lm9mZnNldD90Om51bGx9ZmV0Y2hJZlJlZihlLHQ9ITEpe3JldHVybiBlIGluc3RhbmNlb2Ygbi5SZWY/dGhpcy5mZXRjaChlLHQpOmV9ZmV0Y2goZSx0PSExKXtpZighKGUgaW5zdGFuY2VvZiBuLlJlZikpdGhyb3cgbmV3IEVycm9yKCJyZWYgb2JqZWN0IGlzIG5vdCBhIHJlZmVyZW5jZSIpO2NvbnN0IGE9ZS5udW0saT10aGlzLl9jYWNoZU1hcC5nZXQoYSk7aWYodm9pZCAwIT09aSl7aSBpbnN0YW5jZW9mIG4uRGljdCYmIWkub2JqSWQmJihpLm9iaklkPWUudG9TdHJpbmcoKSk7cmV0dXJuIGl9bGV0IHM9dGhpcy5nZXRFbnRyeShhKTtpZihudWxsPT09cyl7dGhpcy5fY2FjaGVNYXAuc2V0KGEscyk7cmV0dXJuIHN9aWYodGhpcy5fcGVuZGluZ1JlZnMuaGFzKGUpKXt0aGlzLl9wZW5kaW5nUmVmcy5yZW1vdmUoZSk7KDAsci53YXJuKShgSWdub3JpbmcgY2lyY3VsYXIgcmVmZXJlbmNlOiAke2V9LmApO3JldHVybiBuLkNJUkNVTEFSX1JFRn10aGlzLl9wZW5kaW5nUmVmcy5wdXQoZSk7dHJ5e3M9cy51bmNvbXByZXNzZWQ/dGhpcy5mZXRjaFVuY29tcHJlc3NlZChlLHMsdCk6dGhpcy5mZXRjaENvbXByZXNzZWQoZSxzLHQpO3RoaXMuX3BlbmRpbmdSZWZzLnJlbW92ZShlKX1jYXRjaCh0KXt0aGlzLl9wZW5kaW5nUmVmcy5yZW1vdmUoZSk7dGhyb3cgdH1zIGluc3RhbmNlb2Ygbi5EaWN0P3Mub2JqSWQ9ZS50b1N0cmluZygpOnMgaW5zdGFuY2VvZiBvLkJhc2VTdHJlYW0mJihzLmRpY3Qub2JqSWQ9ZS50b1N0cmluZygpKTtyZXR1cm4gc31mZXRjaFVuY29tcHJlc3NlZChlLHQsYT0hMSl7Y29uc3Qgcj1lLmdlbjtsZXQgYz1lLm51bTtpZih0LmdlbiE9PXIpdGhyb3cgbmV3IGkuWFJlZkVudHJ5RXhjZXB0aW9uKGBJbmNvbnNpc3RlbnQgZ2VuZXJhdGlvbiBpbiBYUmVmOiAke2V9YCk7Y29uc3QgbD10aGlzLnN0cmVhbS5tYWtlU3ViU3RyZWFtKHQub2Zmc2V0K3RoaXMuc3RyZWFtLnN0YXJ0KSxoPW5ldyBzLlBhcnNlcih7bGV4ZXI6bmV3IHMuTGV4ZXIobCkseHJlZjp0aGlzLGFsbG93U3RyZWFtczohMH0pLHU9aC5nZXRPYmooKSxkPWguZ2V0T2JqKCksZj1oLmdldE9iaigpO2lmKHUhPT1jfHxkIT09cnx8IShmIGluc3RhbmNlb2Ygbi5DbWQpKXRocm93IG5ldyBpLlhSZWZFbnRyeUV4Y2VwdGlvbihgQmFkICh1bmNvbXByZXNzZWQpIFhSZWYgZW50cnk6ICR7ZX1gKTtpZigib2JqIiE9PWYuY21kKXtpZihmLmNtZC5zdGFydHNXaXRoKCJvYmoiKSl7Yz1wYXJzZUludChmLmNtZC5zdWJzdHJpbmcoMyksMTApO2lmKCFOdW1iZXIuaXNOYU4oYykpcmV0dXJuIGN9dGhyb3cgbmV3IGkuWFJlZkVudHJ5RXhjZXB0aW9uKGBCYWQgKHVuY29tcHJlc3NlZCkgWFJlZiBlbnRyeTogJHtlfWApfSh0PXRoaXMuZW5jcnlwdCYmIWE/aC5nZXRPYmoodGhpcy5lbmNyeXB0LmNyZWF0ZUNpcGhlclRyYW5zZm9ybShjLHIpKTpoLmdldE9iaigpKWluc3RhbmNlb2Ygby5CYXNlU3RyZWFtfHx0aGlzLl9jYWNoZU1hcC5zZXQoYyx0KTtyZXR1cm4gdH1mZXRjaENvbXByZXNzZWQoZSx0LGE9ITEpe2NvbnN0IGM9dC5vZmZzZXQsbD10aGlzLmZldGNoKG4uUmVmLmdldChjLDApKTtpZighKGwgaW5zdGFuY2VvZiBvLkJhc2VTdHJlYW0pKXRocm93IG5ldyByLkZvcm1hdEVycm9yKCJiYWQgT2JqU3RtIHN0cmVhbSIpO2NvbnN0IGg9bC5kaWN0LmdldCgiRmlyc3QiKSx1PWwuZGljdC5nZXQoIk4iKTtpZighTnVtYmVyLmlzSW50ZWdlcihoKXx8IU51bWJlci5pc0ludGVnZXIodSkpdGhyb3cgbmV3IHIuRm9ybWF0RXJyb3IoImludmFsaWQgZmlyc3QgYW5kIG4gcGFyYW1ldGVycyBmb3IgT2JqU3RtIHN0cmVhbSIpO2xldCBkPW5ldyBzLlBhcnNlcih7bGV4ZXI6bmV3IHMuTGV4ZXIobCkseHJlZjp0aGlzLGFsbG93U3RyZWFtczohMH0pO2NvbnN0IGY9bmV3IEFycmF5KHUpLGc9bmV3IEFycmF5KHUpO2ZvcihsZXQgZT0wO2U8dTsrK2Upe2NvbnN0IHQ9ZC5nZXRPYmooKTtpZighTnVtYmVyLmlzSW50ZWdlcih0KSl0aHJvdyBuZXcgci5Gb3JtYXRFcnJvcihgaW52YWxpZCBvYmplY3QgbnVtYmVyIGluIHRoZSBPYmpTdG0gc3RyZWFtOiAke3R9YCk7Y29uc3QgYT1kLmdldE9iaigpO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGEpKXRocm93IG5ldyByLkZvcm1hdEVycm9yKGBpbnZhbGlkIG9iamVjdCBvZmZzZXQgaW4gdGhlIE9ialN0bSBzdHJlYW06ICR7YX1gKTtmW2VdPXQ7Z1tlXT1hfWNvbnN0IHA9KGwuc3RhcnR8fDApK2gsbT1uZXcgQXJyYXkodSk7Zm9yKGxldCBlPTA7ZTx1OysrZSl7Y29uc3QgdD1lPHUtMT9nW2UrMV0tZ1tlXTp2b2lkIDA7aWYodDwwKXRocm93IG5ldyByLkZvcm1hdEVycm9yKCJJbnZhbGlkIG9mZnNldCBpbiB0aGUgT2JqU3RtIHN0cmVhbS4iKTtkPW5ldyBzLlBhcnNlcih7bGV4ZXI6bmV3IHMuTGV4ZXIobC5tYWtlU3ViU3RyZWFtKHArZ1tlXSx0LGwuZGljdCkpLHhyZWY6dGhpcyxhbGxvd1N0cmVhbXM6ITB9KTtjb25zdCBhPWQuZ2V0T2JqKCk7bVtlXT1hO2lmKGEgaW5zdGFuY2VvZiBvLkJhc2VTdHJlYW0pY29udGludWU7Y29uc3Qgbj1mW2VdLGk9dGhpcy5lbnRyaWVzW25dO2kmJmkub2Zmc2V0PT09YyYmaS5nZW49PT1lJiZ0aGlzLl9jYWNoZU1hcC5zZXQobixhKX1pZih2b2lkIDA9PT0odD1tW3QuZ2VuXSkpdGhyb3cgbmV3IGkuWFJlZkVudHJ5RXhjZXB0aW9uKGBCYWQgKGNvbXByZXNzZWQpIFhSZWYgZW50cnk6ICR7ZX1gKTtyZXR1cm4gdH1hc3luYyBmZXRjaElmUmVmQXN5bmMoZSx0KXtyZXR1cm4gZSBpbnN0YW5jZW9mIG4uUmVmP3RoaXMuZmV0Y2hBc3luYyhlLHQpOmV9YXN5bmMgZmV0Y2hBc3luYyhlLHQpe3RyeXtyZXR1cm4gdGhpcy5mZXRjaChlLHQpfWNhdGNoKGEpe2lmKCEoYSBpbnN0YW5jZW9mIGkuTWlzc2luZ0RhdGFFeGNlcHRpb24pKXRocm93IGE7YXdhaXQgdGhpcy5wZGZNYW5hZ2VyLnJlcXVlc3RSYW5nZShhLmJlZ2luLGEuZW5kKTtyZXR1cm4gdGhpcy5mZXRjaEFzeW5jKGUsdCl9fWdldENhdGFsb2dPYmooKXtyZXR1cm4gdGhpcy5yb290fX19LChlLHQsYSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7dC5NZXNzYWdlSGFuZGxlcj12b2lkIDA7dmFyIHI9YSgyKTtjb25zdCBuPTEsaT0yLHM9MSxvPTIsYz0zLGw9NCxoPTUsdT02LGQ9NyxmPTg7ZnVuY3Rpb24gd3JhcFJlYXNvbihlKXtlIGluc3RhbmNlb2YgRXJyb3J8fCJvYmplY3QiPT10eXBlb2YgZSYmbnVsbCE9PWV8fCgwLHIudW5yZWFjaGFibGUpKCd3cmFwUmVhc29uOiBFeHBlY3RlZCAicmVhc29uIiB0byBiZSBhIChwb3NzaWJseSBjbG9uZWQpIEVycm9yLicpO3N3aXRjaChlLm5hbWUpe2Nhc2UiQWJvcnRFeGNlcHRpb24iOnJldHVybiBuZXcgci5BYm9ydEV4Y2VwdGlvbihlLm1lc3NhZ2UpO2Nhc2UiTWlzc2luZ1BERkV4Y2VwdGlvbiI6cmV0dXJuIG5ldyByLk1pc3NpbmdQREZFeGNlcHRpb24oZS5tZXNzYWdlKTtjYXNlIlBhc3N3b3JkRXhjZXB0aW9uIjpyZXR1cm4gbmV3IHIuUGFzc3dvcmRFeGNlcHRpb24oZS5tZXNzYWdlLGUuY29kZSk7Y2FzZSJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24iOnJldHVybiBuZXcgci5VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24oZS5tZXNzYWdlLGUuc3RhdHVzKTtjYXNlIlVua25vd25FcnJvckV4Y2VwdGlvbiI6cmV0dXJuIG5ldyByLlVua25vd25FcnJvckV4Y2VwdGlvbihlLm1lc3NhZ2UsZS5kZXRhaWxzKTtkZWZhdWx0OnJldHVybiBuZXcgci5Vbmtub3duRXJyb3JFeGNlcHRpb24oZS5tZXNzYWdlLGUudG9TdHJpbmcoKSl9fXQuTWVzc2FnZUhhbmRsZXI9Y2xhc3MgTWVzc2FnZUhhbmRsZXJ7Y29uc3RydWN0b3IoZSx0LGEpe3RoaXMuc291cmNlTmFtZT1lO3RoaXMudGFyZ2V0TmFtZT10O3RoaXMuY29tT2JqPWE7dGhpcy5jYWxsYmFja0lkPTE7dGhpcy5zdHJlYW1JZD0xO3RoaXMuc3RyZWFtU2lua3M9T2JqZWN0LmNyZWF0ZShudWxsKTt0aGlzLnN0cmVhbUNvbnRyb2xsZXJzPU9iamVjdC5jcmVhdGUobnVsbCk7dGhpcy5jYWxsYmFja0NhcGFiaWxpdGllcz1PYmplY3QuY3JlYXRlKG51bGwpO3RoaXMuYWN0aW9uSGFuZGxlcj1PYmplY3QuY3JlYXRlKG51bGwpO3RoaXMuX29uQ29tT2JqT25NZXNzYWdlPWU9Pntjb25zdCB0PWUuZGF0YTtpZih0LnRhcmdldE5hbWUhPT10aGlzLnNvdXJjZU5hbWUpcmV0dXJuO2lmKHQuc3RyZWFtKXt0aGlzLl9wcm9jZXNzU3RyZWFtTWVzc2FnZSh0KTtyZXR1cm59aWYodC5jYWxsYmFjayl7Y29uc3QgZT10LmNhbGxiYWNrSWQsYT10aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2VdO2lmKCFhKXRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlc29sdmUgY2FsbGJhY2sgJHtlfWApO2RlbGV0ZSB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2VdO2lmKHQuY2FsbGJhY2s9PT1uKWEucmVzb2x2ZSh0LmRhdGEpO2Vsc2V7aWYodC5jYWxsYmFjayE9PWkpdGhyb3cgbmV3IEVycm9yKCJVbmV4cGVjdGVkIGNhbGxiYWNrIGNhc2UiKTthLnJlamVjdCh3cmFwUmVhc29uKHQucmVhc29uKSl9cmV0dXJufWNvbnN0IHI9dGhpcy5hY3Rpb25IYW5kbGVyW3QuYWN0aW9uXTtpZighcil0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYWN0aW9uIGZyb20gd29ya2VyOiAke3QuYWN0aW9ufWApO2lmKHQuY2FsbGJhY2tJZCl7Y29uc3QgZT10aGlzLnNvdXJjZU5hbWUscz10LnNvdXJjZU5hbWU7bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUpe2Uocih0LmRhdGEpKX0pKS50aGVuKChmdW5jdGlvbihyKXthLnBvc3RNZXNzYWdlKHtzb3VyY2VOYW1lOmUsdGFyZ2V0TmFtZTpzLGNhbGxiYWNrOm4sY2FsbGJhY2tJZDp0LmNhbGxiYWNrSWQsZGF0YTpyfSl9KSwoZnVuY3Rpb24ocil7YS5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTplLHRhcmdldE5hbWU6cyxjYWxsYmFjazppLGNhbGxiYWNrSWQ6dC5jYWxsYmFja0lkLHJlYXNvbjp3cmFwUmVhc29uKHIpfSl9KSl9ZWxzZSB0LnN0cmVhbUlkP3RoaXMuX2NyZWF0ZVN0cmVhbVNpbmsodCk6cih0LmRhdGEpfTthLmFkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLHRoaXMuX29uQ29tT2JqT25NZXNzYWdlKX1vbihlLHQpe2NvbnN0IGE9dGhpcy5hY3Rpb25IYW5kbGVyO2lmKGFbZV0pdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBhbHJlYWR5IGFuIGFjdGlvbk5hbWUgY2FsbGVkICIke2V9ImApO2FbZV09dH1zZW5kKGUsdCxhKXt0aGlzLmNvbU9iai5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTp0aGlzLnNvdXJjZU5hbWUsdGFyZ2V0TmFtZTp0aGlzLnRhcmdldE5hbWUsYWN0aW9uOmUsZGF0YTp0fSxhKX1zZW5kV2l0aFByb21pc2UoZSx0LGEpe2NvbnN0IG49dGhpcy5jYWxsYmFja0lkKyssaT0oMCxyLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO3RoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbbl09aTt0cnl7dGhpcy5jb21PYmoucG9zdE1lc3NhZ2Uoe3NvdXJjZU5hbWU6dGhpcy5zb3VyY2VOYW1lLHRhcmdldE5hbWU6dGhpcy50YXJnZXROYW1lLGFjdGlvbjplLGNhbGxiYWNrSWQ6bixkYXRhOnR9LGEpfWNhdGNoKGUpe2kucmVqZWN0KGUpfXJldHVybiBpLnByb21pc2V9c2VuZFdpdGhTdHJlYW0oZSx0LGEsbil7Y29uc3QgaT10aGlzLnN0cmVhbUlkKyssbz10aGlzLnNvdXJjZU5hbWUsYz10aGlzLnRhcmdldE5hbWUsbD10aGlzLmNvbU9iajtyZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtzdGFydDphPT57Y29uc3Qgcz0oMCxyLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO3RoaXMuc3RyZWFtQ29udHJvbGxlcnNbaV09e2NvbnRyb2xsZXI6YSxzdGFydENhbGw6cyxwdWxsQ2FsbDpudWxsLGNhbmNlbENhbGw6bnVsbCxpc0Nsb3NlZDohMX07bC5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTpvLHRhcmdldE5hbWU6YyxhY3Rpb246ZSxzdHJlYW1JZDppLGRhdGE6dCxkZXNpcmVkU2l6ZTphLmRlc2lyZWRTaXplfSxuKTtyZXR1cm4gcy5wcm9taXNlfSxwdWxsOmU9Pntjb25zdCB0PSgwLHIuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7dGhpcy5zdHJlYW1Db250cm9sbGVyc1tpXS5wdWxsQ2FsbD10O2wucG9zdE1lc3NhZ2Uoe3NvdXJjZU5hbWU6byx0YXJnZXROYW1lOmMsc3RyZWFtOnUsc3RyZWFtSWQ6aSxkZXNpcmVkU2l6ZTplLmRlc2lyZWRTaXplfSk7cmV0dXJuIHQucHJvbWlzZX0sY2FuY2VsOmU9PnsoMCxyLmFzc2VydCkoZSBpbnN0YW5jZW9mIEVycm9yLCJjYW5jZWwgbXVzdCBoYXZlIGEgdmFsaWQgcmVhc29uIik7Y29uc3QgdD0oMCxyLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO3RoaXMuc3RyZWFtQ29udHJvbGxlcnNbaV0uY2FuY2VsQ2FsbD10O3RoaXMuc3RyZWFtQ29udHJvbGxlcnNbaV0uaXNDbG9zZWQ9ITA7bC5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTpvLHRhcmdldE5hbWU6YyxzdHJlYW06cyxzdHJlYW1JZDppLHJlYXNvbjp3cmFwUmVhc29uKGUpfSk7cmV0dXJuIHQucHJvbWlzZX19LGEpfV9jcmVhdGVTdHJlYW1TaW5rKGUpe2NvbnN0IHQ9ZS5zdHJlYW1JZCxhPXRoaXMuc291cmNlTmFtZSxuPWUuc291cmNlTmFtZSxpPXRoaXMuY29tT2JqLHM9dGhpcyxvPXRoaXMuYWN0aW9uSGFuZGxlcltlLmFjdGlvbl0sdT17ZW5xdWV1ZShlLHM9MSxvKXtpZih0aGlzLmlzQ2FuY2VsbGVkKXJldHVybjtjb25zdCBjPXRoaXMuZGVzaXJlZFNpemU7dGhpcy5kZXNpcmVkU2l6ZS09cztpZihjPjAmJnRoaXMuZGVzaXJlZFNpemU8PTApe3RoaXMuc2lua0NhcGFiaWxpdHk9KDAsci5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTt0aGlzLnJlYWR5PXRoaXMuc2lua0NhcGFiaWxpdHkucHJvbWlzZX1pLnBvc3RNZXNzYWdlKHtzb3VyY2VOYW1lOmEsdGFyZ2V0TmFtZTpuLHN0cmVhbTpsLHN0cmVhbUlkOnQsY2h1bms6ZX0sbyl9LGNsb3NlKCl7aWYoIXRoaXMuaXNDYW5jZWxsZWQpe3RoaXMuaXNDYW5jZWxsZWQ9ITA7aS5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTphLHRhcmdldE5hbWU6bixzdHJlYW06YyxzdHJlYW1JZDp0fSk7ZGVsZXRlIHMuc3RyZWFtU2lua3NbdF19fSxlcnJvcihlKXsoMCxyLmFzc2VydCkoZSBpbnN0YW5jZW9mIEVycm9yLCJlcnJvciBtdXN0IGhhdmUgYSB2YWxpZCByZWFzb24iKTtpZighdGhpcy5pc0NhbmNlbGxlZCl7dGhpcy5pc0NhbmNlbGxlZD0hMDtpLnBvc3RNZXNzYWdlKHtzb3VyY2VOYW1lOmEsdGFyZ2V0TmFtZTpuLHN0cmVhbTpoLHN0cmVhbUlkOnQscmVhc29uOndyYXBSZWFzb24oZSl9KX19LHNpbmtDYXBhYmlsaXR5OigwLHIuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCksb25QdWxsOm51bGwsb25DYW5jZWw6bnVsbCxpc0NhbmNlbGxlZDohMSxkZXNpcmVkU2l6ZTplLmRlc2lyZWRTaXplLHJlYWR5Om51bGx9O3Uuc2lua0NhcGFiaWxpdHkucmVzb2x2ZSgpO3UucmVhZHk9dS5zaW5rQ2FwYWJpbGl0eS5wcm9taXNlO3RoaXMuc3RyZWFtU2lua3NbdF09dTtuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCl7dChvKGUuZGF0YSx1KSl9KSkudGhlbigoZnVuY3Rpb24oKXtpLnBvc3RNZXNzYWdlKHtzb3VyY2VOYW1lOmEsdGFyZ2V0TmFtZTpuLHN0cmVhbTpmLHN0cmVhbUlkOnQsc3VjY2VzczohMH0pfSksKGZ1bmN0aW9uKGUpe2kucG9zdE1lc3NhZ2Uoe3NvdXJjZU5hbWU6YSx0YXJnZXROYW1lOm4sc3RyZWFtOmYsc3RyZWFtSWQ6dCxyZWFzb246d3JhcFJlYXNvbihlKX0pfSkpfV9wcm9jZXNzU3RyZWFtTWVzc2FnZShlKXtjb25zdCB0PWUuc3RyZWFtSWQsYT10aGlzLnNvdXJjZU5hbWUsbj1lLnNvdXJjZU5hbWUsaT10aGlzLmNvbU9iaixnPXRoaXMuc3RyZWFtQ29udHJvbGxlcnNbdF0scD10aGlzLnN0cmVhbVNpbmtzW3RdO3N3aXRjaChlLnN0cmVhbSl7Y2FzZSBmOmUuc3VjY2Vzcz9nLnN0YXJ0Q2FsbC5yZXNvbHZlKCk6Zy5zdGFydENhbGwucmVqZWN0KHdyYXBSZWFzb24oZS5yZWFzb24pKTticmVhaztjYXNlIGQ6ZS5zdWNjZXNzP2cucHVsbENhbGwucmVzb2x2ZSgpOmcucHVsbENhbGwucmVqZWN0KHdyYXBSZWFzb24oZS5yZWFzb24pKTticmVhaztjYXNlIHU6aWYoIXApe2kucG9zdE1lc3NhZ2Uoe3NvdXJjZU5hbWU6YSx0YXJnZXROYW1lOm4sc3RyZWFtOmQsc3RyZWFtSWQ6dCxzdWNjZXNzOiEwfSk7YnJlYWt9cC5kZXNpcmVkU2l6ZTw9MCYmZS5kZXNpcmVkU2l6ZT4wJiZwLnNpbmtDYXBhYmlsaXR5LnJlc29sdmUoKTtwLmRlc2lyZWRTaXplPWUuZGVzaXJlZFNpemU7bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUpe2UocC5vblB1bGwmJnAub25QdWxsKCkpfSkpLnRoZW4oKGZ1bmN0aW9uKCl7aS5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTphLHRhcmdldE5hbWU6bixzdHJlYW06ZCxzdHJlYW1JZDp0LHN1Y2Nlc3M6ITB9KX0pLChmdW5jdGlvbihlKXtpLnBvc3RNZXNzYWdlKHtzb3VyY2VOYW1lOmEsdGFyZ2V0TmFtZTpuLHN0cmVhbTpkLHN0cmVhbUlkOnQscmVhc29uOndyYXBSZWFzb24oZSl9KX0pKTticmVhaztjYXNlIGw6KDAsci5hc3NlcnQpKGcsImVucXVldWUgc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXIiKTtpZihnLmlzQ2xvc2VkKWJyZWFrO2cuY29udHJvbGxlci5lbnF1ZXVlKGUuY2h1bmspO2JyZWFrO2Nhc2UgYzooMCxyLmFzc2VydCkoZywiY2xvc2Ugc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXIiKTtpZihnLmlzQ2xvc2VkKWJyZWFrO2cuaXNDbG9zZWQ9ITA7Zy5jb250cm9sbGVyLmNsb3NlKCk7dGhpcy5fZGVsZXRlU3RyZWFtQ29udHJvbGxlcihnLHQpO2JyZWFrO2Nhc2UgaDooMCxyLmFzc2VydCkoZywiZXJyb3Igc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXIiKTtnLmNvbnRyb2xsZXIuZXJyb3Iod3JhcFJlYXNvbihlLnJlYXNvbikpO3RoaXMuX2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoZyx0KTticmVhaztjYXNlIG86ZS5zdWNjZXNzP2cuY2FuY2VsQ2FsbC5yZXNvbHZlKCk6Zy5jYW5jZWxDYWxsLnJlamVjdCh3cmFwUmVhc29uKGUucmVhc29uKSk7dGhpcy5fZGVsZXRlU3RyZWFtQ29udHJvbGxlcihnLHQpO2JyZWFrO2Nhc2UgczppZighcClicmVhaztuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCl7dChwLm9uQ2FuY2VsJiZwLm9uQ2FuY2VsKHdyYXBSZWFzb24oZS5yZWFzb24pKSl9KSkudGhlbigoZnVuY3Rpb24oKXtpLnBvc3RNZXNzYWdlKHtzb3VyY2VOYW1lOmEsdGFyZ2V0TmFtZTpuLHN0cmVhbTpvLHN0cmVhbUlkOnQsc3VjY2VzczohMH0pfSksKGZ1bmN0aW9uKGUpe2kucG9zdE1lc3NhZ2Uoe3NvdXJjZU5hbWU6YSx0YXJnZXROYW1lOm4sc3RyZWFtOm8sc3RyZWFtSWQ6dCxyZWFzb246d3JhcFJlYXNvbihlKX0pfSkpO3Auc2lua0NhcGFiaWxpdHkucmVqZWN0KHdyYXBSZWFzb24oZS5yZWFzb24pKTtwLmlzQ2FuY2VsbGVkPSEwO2RlbGV0ZSB0aGlzLnN0cmVhbVNpbmtzW3RdO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJVbmV4cGVjdGVkIHN0cmVhbSBjYXNlIil9fWFzeW5jIF9kZWxldGVTdHJlYW1Db250cm9sbGVyKGUsdCl7YXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFtlLnN0YXJ0Q2FsbCYmZS5zdGFydENhbGwucHJvbWlzZSxlLnB1bGxDYWxsJiZlLnB1bGxDYWxsLnByb21pc2UsZS5jYW5jZWxDYWxsJiZlLmNhbmNlbENhbGwucHJvbWlzZV0pO2RlbGV0ZSB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3RdfWRlc3Ryb3koKXt0aGlzLmNvbU9iai5yZW1vdmVFdmVudExpc3RlbmVyKCJtZXNzYWdlIix0aGlzLl9vbkNvbU9iak9uTWVzc2FnZSl9fX0sKGUsdCxhKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt0LlBERldvcmtlclN0cmVhbT12b2lkIDA7dmFyIHI9YSgyKTt0LlBERldvcmtlclN0cmVhbT1jbGFzcyBQREZXb3JrZXJTdHJlYW17Y29uc3RydWN0b3IoZSl7dGhpcy5fbXNnSGFuZGxlcj1lO3RoaXMuX2NvbnRlbnRMZW5ndGg9bnVsbDt0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj1udWxsO3RoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnM9W119Z2V0RnVsbFJlYWRlcigpeygwLHIuYXNzZXJ0KSghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIlBERldvcmtlclN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLiIpO3RoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPW5ldyBQREZXb3JrZXJTdHJlYW1SZWFkZXIodGhpcy5fbXNnSGFuZGxlcik7cmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyfWdldFJhbmdlUmVhZGVyKGUsdCl7Y29uc3QgYT1uZXcgUERGV29ya2VyU3RyZWFtUmFuZ2VSZWFkZXIoZSx0LHRoaXMuX21zZ0hhbmRsZXIpO3RoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChhKTtyZXR1cm4gYX1jYW5jZWxBbGxSZXF1ZXN0cyhlKXt0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciYmdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIuY2FuY2VsKGUpO2Zvcihjb25zdCB0IG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpdC5jYW5jZWwoZSl9fTtjbGFzcyBQREZXb3JrZXJTdHJlYW1SZWFkZXJ7Y29uc3RydWN0b3IoZSl7dGhpcy5fbXNnSGFuZGxlcj1lO3RoaXMub25Qcm9ncmVzcz1udWxsO3RoaXMuX2NvbnRlbnRMZW5ndGg9bnVsbDt0aGlzLl9pc1JhbmdlU3VwcG9ydGVkPSExO3RoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkPSExO2NvbnN0IHQ9dGhpcy5fbXNnSGFuZGxlci5zZW5kV2l0aFN0cmVhbSgiR2V0UmVhZGVyIik7dGhpcy5fcmVhZGVyPXQuZ2V0UmVhZGVyKCk7dGhpcy5faGVhZGVyc1JlYWR5PXRoaXMuX21zZ0hhbmRsZXIuc2VuZFdpdGhQcm9taXNlKCJSZWFkZXJIZWFkZXJzUmVhZHkiKS50aGVuKChlPT57dGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ9ZS5pc1N0cmVhbWluZ1N1cHBvcnRlZDt0aGlzLl9pc1JhbmdlU3VwcG9ydGVkPWUuaXNSYW5nZVN1cHBvcnRlZDt0aGlzLl9jb250ZW50TGVuZ3RoPWUuY29udGVudExlbmd0aH0pKX1nZXQgaGVhZGVyc1JlYWR5KCl7cmV0dXJuIHRoaXMuX2hlYWRlcnNSZWFkeX1nZXQgY29udGVudExlbmd0aCgpe3JldHVybiB0aGlzLl9jb250ZW50TGVuZ3RofWdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpe3JldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZH1nZXQgaXNSYW5nZVN1cHBvcnRlZCgpe3JldHVybiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkfWFzeW5jIHJlYWQoKXtjb25zdHt2YWx1ZTplLGRvbmU6dH09YXdhaXQgdGhpcy5fcmVhZGVyLnJlYWQoKTtyZXR1cm4gdD97dmFsdWU6dm9pZCAwLGRvbmU6ITB9Ont2YWx1ZTplLmJ1ZmZlcixkb25lOiExfX1jYW5jZWwoZSl7dGhpcy5fcmVhZGVyLmNhbmNlbChlKX19Y2xhc3MgUERGV29ya2VyU3RyZWFtUmFuZ2VSZWFkZXJ7Y29uc3RydWN0b3IoZSx0LGEpe3RoaXMuX21zZ0hhbmRsZXI9YTt0aGlzLm9uUHJvZ3Jlc3M9bnVsbDtjb25zdCByPXRoaXMuX21zZ0hhbmRsZXIuc2VuZFdpdGhTdHJlYW0oIkdldFJhbmdlUmVhZGVyIix7YmVnaW46ZSxlbmQ6dH0pO3RoaXMuX3JlYWRlcj1yLmdldFJlYWRlcigpfWdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpe3JldHVybiExfWFzeW5jIHJlYWQoKXtjb25zdHt2YWx1ZTplLGRvbmU6dH09YXdhaXQgdGhpcy5fcmVhZGVyLnJlYWQoKTtyZXR1cm4gdD97dmFsdWU6dm9pZCAwLGRvbmU6ITB9Ont2YWx1ZTplLmJ1ZmZlcixkb25lOiExfX1jYW5jZWwoZSl7dGhpcy5fcmVhZGVyLmNhbmNlbChlKX19fV0sdD17fTtmdW5jdGlvbiBfX3dfcGRmanNfcmVxdWlyZV9fKGEpe3ZhciByPXRbYV07aWYodm9pZCAwIT09cilyZXR1cm4gci5leHBvcnRzO3ZhciBuPXRbYV09e2V4cG9ydHM6e319O2VbYV0obixuLmV4cG9ydHMsX193X3BkZmpzX3JlcXVpcmVfXyk7cmV0dXJuIG4uZXhwb3J0c31fX3dfcGRmanNfcmVxdWlyZV9fLmQ9KGUsdCk9Pntmb3IodmFyIGEgaW4gdClfX3dfcGRmanNfcmVxdWlyZV9fLm8odCxhKSYmIV9fd19wZGZqc19yZXF1aXJlX18ubyhlLGEpJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxhLHtlbnVtZXJhYmxlOiEwLGdldDp0W2FdfSl9O19fd19wZGZqc19yZXF1aXJlX18ubz0oZSx0KT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCk7X193X3BkZmpzX3JlcXVpcmVfXy5yPWU9PnsidW5kZWZpbmVkIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOiJNb2R1bGUifSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pfTt2YXIgYT17fTsoKCk9Pnt2YXIgZT1hO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiV29ya2VyTWVzc2FnZUhhbmRsZXIiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0Lldvcmtlck1lc3NhZ2VIYW5kbGVyfX0pO3ZhciB0PV9fd19wZGZqc19yZXF1aXJlX18oMSl9KSgpO3JldHVybiBhfSkoKSkpOw==", initializePdfjs = () => {
  pdfExports.GlobalWorkerOptions.workerSrc = workerSrc;
}, readAsPDF = async (L, c = "string") => {
  let i;
  if (c === "string" && typeof L == "string") {
    const W = atob(L), y = new Uint8Array(W.length);
    for (let h = 0; h < W.length; h++)
      y[h] = W.charCodeAt(h);
    i = y.buffer;
  } else if (L instanceof File)
    i = await L.arrayBuffer();
  else
    throw new Error("Invalid input type for readAsPDF");
  const { PDFDocument: t } = await import("pdf-lib");
  return await t.load(i);
}, downloadPDF = (L, c) => {
  download(L, c, "application/pdf");
}, getPDFDocument = async (L) => {
  const c = await L.save();
  return pdfExports.getDocument({ data: c }).promise;
};
function ggID() {
  let L = 0;
  return function() {
    return L++;
  };
}
async function save(L, c, i, t = !1) {
  const Z = await L.arrayBuffer(), W = await PDFDocument.load(Z);
  try {
    const p = W.getForm();
    p.getFields().forEach((X) => {
      p.removeField(X);
    });
  } catch (p) {
    console.warn("No AcroForm found or already removed:", p);
  }
  const y = W.getPages();
  for (let p = 0; p < y.length; p++) {
    const X = y[p], M = X.getHeight(), x = c[p] || [];
    for (const n of x)
      if (n.type === "drawing") {
        const {
          x: V,
          y: S,
          path: o,
          originWidth: R,
          originHeight: J,
          width: u,
          height: e
        } = n, m = u / R, d = e / J, b = Math.min(m, d), N = R * b, G = V + (u - N) / 2;
        X.drawSvgPath(o, {
          x: G,
          y: M - S,
          // align bottom of signature to Vue's top position
          scale: b,
          borderWidth: 5,
          borderColor: rgb(0, 0, 0),
          borderLineCap: LineCapStyle.Round
        });
      }
  }
  const h = await W.save();
  return t && downloadPDF(h, i), await W.saveAsBase64();
}
const _sfc_main = {
  name: "DrawSignPdf",
  components: {
    PDFPage,
    DrawingCanvas,
    DrawingSignature,
    DialogBox,
    MagnifyingGlassMinusIcon: render$1,
    MagnifyingGlassPlusIcon: render
  },
  props: {
    pdfData: String,
    signatureData: Array,
    isDownload: {
      type: Boolean,
      default: !1
    },
    finish: Function,
    translations: {
      type: Object,
      default: () => ({})
    },
    enableZoom: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["finish", "onPDFRendered"],
  setup(L, { emit: c }) {
    const i = ggID(), t = ref(null), Z = ref(""), W = ref([]), y = ref([]), h = ref([]), p = ref("Times-Roman"), X = ref(null), M = ref(-1), x = ref(!1), n = ref(!1), V = ref(""), S = ref({
      data: "",
      type: "application/pdf"
    }), o = ref(!1), R = ref("warning"), J = ref(1), u = 0.25, e = 0.5, m = 3, d = ref([]), b = computed(() => ({ ...{
      updateSign: "Update Signature",
      save: "Save",
      saving: "Saving",
      drawLabel: "Draw the signature here",
      drawDone: "Done",
      drawCancel: "Cancel",
      confirmBoxTitle: "Confirm Saving",
      confirmBoxDesc: "Are you sure you want to save the signed document?",
      confirmBoxClose: "Close",
      confirmBoxSaveChanges: "Save Changes",
      warningTitle: "Missing Signature",
      warningDesc: "The required signature is missing. Please sign to continue",
      warningClose: "Close",
      pdfLoading: "PDF will load here",
      additionalTextField: ""
    }, ...L.translations })), N = async () => {
      try {
        if (initializePdfjs(), !L.pdfData) return;
        M.value = 0, await r(L.pdfData, "string"), D(), document.addEventListener("keydown", al);
      } catch (Q) {
        console.error("onMounted error:", Q);
      }
    }, G = async (Q) => {
      const w = (Q.target.files || Q.dataTransfer && Q.dataTransfer.files)[0];
      if (!(!w || w.type !== "application/pdf")) {
        M.value = -1;
        try {
          await r(w, "arrayBuffer"), M.value = 0;
        } catch {
        }
      }
    }, r = async (Q, T) => {
      const w = await readAsPDF(Q, T), g = await getPDFDocument(w), K = [];
      for (let a = 1; a <= g.numPages; a++) {
        const Y = await g.getPage(a);
        K.push(markRaw(Y));
      }
      if (W.value = K, h.value = Array(g.numPages).fill([]), y.value = Array(g.numPages).fill({ scale: 1 }), d.value = Array(g.numPages).fill(!1), T === "string") {
        const a = atob(Q), Y = new Uint8Array(a.length);
        for (let C = 0; C < a.length; C++)
          Y[C] = a.charCodeAt(C);
        const z = new Blob([Y], { type: "application/pdf" });
        t.value = new File([z], "document.pdf", {
          type: "application/pdf"
        }), Z.value = "document.pdf";
      }
    }, j = async (Q) => {
      V.value = Q.signatureImageData, await f(Q.originWidth, Q.originHeight, Q.path), n.value = !1;
    }, D = () => {
      M.value >= 0 && (n.value = !0);
    }, f = (Q, T, w) => {
      var g;
      h.value = Array(h.value.length).fill([]), (g = L.signatureData) == null || g.forEach((K) => {
        const a = i(), Y = H(K.width), z = H(K.height), C = Y / Q, F = z / T, v = Math.min(C, F), $ = {
          id: a,
          path: w,
          type: "drawing",
          x: H(K.left),
          y: H(K.top),
          originWidth: Q,
          originHeight: T,
          width: Y,
          height: z,
          scale: v
        }, il = K.page - 1;
        h.value[il] && (h.value[il] = [
          ...h.value[il],
          $
        ]);
      });
    }, P = (Q) => {
      M.value = Q;
    }, B = (Q, T) => {
      h.value = h.value.map(
        (w, g) => g == M.value ? w.map(
          (K) => K.id === Q ? { ...K, ...T } : K
        ) : w
      );
    }, A = (Q, T) => {
      y.value[T] = Q;
    }, H = (Q) => Q * 72 / 2.54, O = async () => {
      if (!(!t.value || x.value || !W.value.length)) {
        x.value = !0;
        try {
          const Q = await save(
            t.value,
            h.value,
            Z.value,
            L.isDownload
          );
          S.value = { type: "application/pdf", data: Q }, c("finish", {
            signedDocument: S.value,
            signatureImage: V.value
          });
        } catch (Q) {
          console.error("Error saving PDF:", Q);
        } finally {
          x.value = !1;
        }
      }
    }, U = () => {
      R.value = V.value !== "" ? "confirm" : "warning", o.value = !0, document.body.classList.add("overflow-y-hidden");
    }, k = () => {
      o.value = !1, document.body.classList.remove("overflow-y-hidden");
    }, q = () => {
      O(), k();
    }, al = (Q) => {
      (Q.key === "Escape" || Q.key === "Esc") && k();
    }, Ml = (Q) => {
      J.value = Q === "in" ? Math.min(J.value + u, m) : Math.max(J.value - u, e);
    }, wl = (Q) => {
      d.value[Q] = !0, d.value.every(Boolean) && c("onPDFRendered");
    };
    return onMounted(N), onBeforeUnmount(() => {
      document.removeEventListener("keydown", al);
    }), {
      getTranslation: b,
      genID: i,
      pdfFile: t,
      pdfName: Z,
      pages: W,
      pagesScale: y,
      allObjects: h,
      currentFont: p,
      focusId: X,
      selectedPageIndex: M,
      saving: x,
      addingDrawing: n,
      isOpenConfirm: o,
      onUploadPDF: G,
      addPDF: r,
      onAddDrawing: D,
      addDrawing: f,
      selectPage: P,
      updateObject: B,
      onMeasure: A,
      savePDF: O,
      onFinishDrawing: j,
      openModal: U,
      closeModal: k,
      confirmSave: q,
      isConfirmOrWarning: R,
      zoomScale: J,
      zoomPDF: Ml,
      pageRenderStatus: d,
      renderFinished: wl
    };
  }
}, _hoisted_1 = {
  key: 0,
  id: "modelConfirm",
  class: "fixed inset-0 z-50 h-full w-full overflow-y-auto bg-gray-900 bg-opacity-60 px-4"
}, _hoisted_2 = { class: "flex min-h-screen flex-col items-center bg-gray-100 py-5" }, _hoisted_3 = {
  key: 0,
  class: "left-0 right-0 top-0 z-10 flex items-center justify-center flex-col gap-2 py-2 bg-gray-100 sticky w-full"
}, _hoisted_4 = {
  key: 0,
  class: "mt-2 flex gap-2"
}, _hoisted_5 = {
  key: 1,
  class: "sign-drawing-canvas fixed left-0 right-0 top-0 z-10 items-center justify-center border-b border-gray-300 bg-white shadow-lg",
  style: { height: "200px", "z-index": "60", width: "100%" },
  "data-cy": "sign-drawing-canvas"
}, _hoisted_6 = {
  key: 0,
  class: "bg-gray-100 border-b border-gray-300 shadow-lg p-2 flex justify-center gap-2"
}, _hoisted_7 = {
  key: 2,
  class: "w-full"
}, _hoisted_8 = ["onMousedown", "onTouchstart", "data-cy"], _hoisted_9 = {
  key: 3,
  class: "flex w-full flex-grow items-center justify-center"
}, _hoisted_10 = { class: "text-3xl font-bold text-gray-500" };
function _sfc_render(L, c, i, t, Z, W) {
  const y = resolveComponent("DialogBox"), h = resolveComponent("MagnifyingGlassMinusIcon"), p = resolveComponent("MagnifyingGlassPlusIcon"), X = resolveComponent("DrawingCanvas"), M = resolveComponent("PDFPage"), x = resolveComponent("DrawingSignature");
  return openBlock(), createElementBlock(Fragment, null, [
    t.isOpenConfirm ? (openBlock(), createElementBlock("div", _hoisted_1, [
      createVNode(y, {
        translations: t.getTranslation,
        type: t.isConfirmOrWarning,
        onCancel: t.closeModal,
        onFinish: t.confirmSave
      }, null, 8, ["translations", "type", "onCancel", "onFinish"])
    ])) : createCommentVNode("", !0),
    createElementVNode("div", null, [
      createElementVNode("main", _hoisted_2, [
        t.addingDrawing ? createCommentVNode("", !0) : (openBlock(), createElementBlock("div", _hoisted_3, [
          createElementVNode("button", {
            onClick: c[0] || (c[0] = (...n) => t.onAddDrawing && t.onAddDrawing(...n)),
            class: "btn-positive ml-3 mr-3 rounded bg-blue-500 px-3 py-1 font-bold text-white hover:bg-blue-700 md:mr-4 md:px-4",
            "data-cy": "update-sign"
          }, toDisplayString(t.getTranslation.updateSign), 1),
          createElementVNode("button", {
            onClick: c[1] || (c[1] = (...n) => t.openModal && t.openModal(...n)),
            class: normalizeClass(["btn-positive mr-3 rounded bg-blue-500 px-3 py-1 font-bold text-white hover:bg-blue-700 md:mr-4 md:px-4", {
              "cursor-not-allowed": t.pages.length === 0 || t.saving,
              "bg-blue-700": t.pages.length === 0 || t.saving
            }]),
            "data-cy": "save-sign"
          }, toDisplayString(t.saving ? t.getTranslation.saving : t.getTranslation.save), 3),
          i.enableZoom ? (openBlock(), createElementBlock("div", _hoisted_4, [
            createElementVNode("button", {
              onClick: c[2] || (c[2] = (n) => t.zoomPDF("out")),
              class: "w-6",
              "data-cy": "pdf-zoom-out"
            }, [
              createVNode(h)
            ]),
            createElementVNode("button", {
              onClick: c[3] || (c[3] = (n) => t.zoomPDF("in")),
              class: "w-6",
              "data-cy": "pdf-zoom-in"
            }, [
              createVNode(p)
            ])
          ])) : createCommentVNode("", !0)
        ])),
        t.addingDrawing ? (openBlock(), createElementBlock("div", _hoisted_5, [
          createVNode(X, {
            onFinish: t.onFinishDrawing,
            onCancel: c[4] || (c[4] = (n) => t.addingDrawing = !1),
            translations: t.getTranslation
          }, null, 8, ["onFinish", "translations"]),
          i.enableZoom ? (openBlock(), createElementBlock("div", _hoisted_6, [
            createElementVNode("button", {
              onClick: c[5] || (c[5] = (n) => t.zoomPDF("out")),
              class: "w-6",
              "data-cy": "pdf-zoom-out-toolbar"
            }, [
              createVNode(h)
            ]),
            createElementVNode("button", {
              onClick: c[6] || (c[6] = (n) => t.zoomPDF("in")),
              class: "w-6",
              "data-cy": "pdf-zoom-in-toolbar"
            }, [
              createVNode(p)
            ])
          ])) : createCommentVNode("", !0)
        ])) : createCommentVNode("", !0),
        t.pages.length ? (openBlock(), createElementBlock("div", _hoisted_7, [
          (openBlock(!0), createElementBlock(Fragment, null, renderList(t.pages, (n, V) => (openBlock(), createElementBlock("div", {
            key: V + t.zoomScale,
            class: "flex w-full flex-col items-center overflow-hidden p-5",
            onMousedown: (S) => t.selectPage(V),
            onTouchstart: (S) => t.selectPage(V),
            "data-cy": "page-" + V
          }, [
            createElementVNode("div", {
              class: normalizeClass(["relative shadow-lg", { "shadow-outline": V === t.selectedPageIndex }])
            }, [
              createVNode(M, {
                onMeasure: (S) => t.onMeasure(S, V),
                page: n,
                zoomScale: t.zoomScale,
                onFinishedRendering: () => t.renderFinished(V)
              }, null, 8, ["onMeasure", "page", "zoomScale", "onFinishedRendering"]),
              createElementVNode("div", {
                class: "absolute left-0 top-0 origin-top-left transform",
                style: normalizeStyle({
                  transform: `scale(${t.pagesScale[V].scale})`,
                  touchAction: "none"
                })
              }, [
                (openBlock(!0), createElementBlock(Fragment, null, renderList(t.allObjects[V], (S) => {
                  var o;
                  return openBlock(), createElementBlock("div", {
                    key: S.id
                  }, [
                    S.type === "drawing" ? (openBlock(), createBlock(x, {
                      key: 0,
                      onUpdate: (R) => t.updateObject(S.id, R),
                      path: S.path,
                      x: S.x,
                      y: S.y,
                      width: S.width,
                      height: S.height,
                      originWidth: S.originWidth,
                      originHeight: S.originHeight,
                      pageScale: (o = t.pagesScale[V]) == null ? void 0 : o.scale,
                      "data-cy": "sign-pos-" + S.id,
                      zoomScale: t.zoomScale
                    }, null, 8, ["onUpdate", "path", "x", "y", "width", "height", "originWidth", "originHeight", "pageScale", "data-cy", "zoomScale"])) : createCommentVNode("", !0)
                  ]);
                }), 128))
              ], 4)
            ], 2)
          ], 40, _hoisted_8))), 128))
        ])) : (openBlock(), createElementBlock("div", _hoisted_9, [
          createElementVNode("span", _hoisted_10, toDisplayString(t.getTranslation.pdfLoading), 1)
        ]))
      ])
    ])
  ], 64);
}
const DrawSignPdf = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-ab11e8e4"]]);
initializePdfjs();
const install = (L) => {
  L.component(DrawSignPdf.name || "DrawSignPdf", DrawSignPdf);
};
DrawSignPdf.install = install;
export {
  DrawSignPdf,
  DrawSignPdf as default
};
